---
title: "A Trick of the Tail"
tags: [allonge, noindex]
---

In [Recursion? We don't need no stinking recursion!](http://raganwald.com/2018/05/20/we-dont-need-no-stinking-recursion.html), we looked at seven different techniques for turning recursive functions into iterative functions. In this post, we're going to take a deeper look at technique #3, [convert recursion to iteration with tail calls](http://raganwald.com/2018/05/20/we-dont-need-no-stinking-recursion.html#3-convert-recursion-to-iteration-with-tail-calls).

Before we dive into it, here's a quick recap of what we explored in the previous post:

### recursion, see recursion

The shallow definition of a recursive algorithm is a function that directly or indirectly calls itself. For example, the [factorial](https://en.wikipedia.org/wiki/Factorial) of an integer:

> In mathematics, the factorial of a non-negative integer *n*, denoted by *n*!, is the product of all positive integers less than or equal to *n*. For example,
>
> 5! = 5 * 4 * 3 * 2 * 1 = 120.
>
> The value of 0! is 1, according to the convention for an empty product.

In JavaScript, we can write it as:

```javascript
function factorial (n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

Our `factorial` function clearly calls itself. And because of the way almost every implementation of Javascript we encounter is designed, every time it calls itself, it creates a frame on the program stack. The stack is a limited resource, and for a sufficiently large number, our function will exhaust the stack.

This is sometimes given as a reason to convert recursive calls to iteration. That is true in theory, but in practice it is unusual to have to worry about the stack being exhausted. For example, if we wanted to compute 5000!, rewriting our function to avoid exhausting the stack is the least of our worries. We'd also have to convert our function to work with some kind of Big Interger data type, as we are going to end up working with some huge integers, and JavaScript does not support arbitrarily large numbers "out of the box."

However, exploring the process of converting a recursive function to a function that is [tail recursive][tc] is interesting in its own right, and furthermore, exploring how to make a function that is tail recursive avoid exhausting the stack is even more interesting in its own right, so that's what we're going to do.

[tc]: https://en.wikipedia.org/wiki/Tail_call

### tail calls

> In computer science, a tail call is a subroutine call performed as the final action of a procedure. If a tail call might lead to the same subroutine being called again later in the call chain, the subroutine is said to be tail-recursive, which is a special case of recursion. Tail recursion (or tail-end recursion) is particularly useful, and often easy to handle in implementations.

The TL;DR is that if a function calls another function and then does nothing with the result except return it, it is said to be making a tail call. Here's a simplified version of a function from [JavaScript Allongé](https://leanpub.com/javascriptallongesix/):

```javascript
function whenNotNull(fn, ...args) {
  if (args.length === null) {
    return;
  }
  for (const arg of args) {
    if (arg == null) {
      return;
    }
  }
  return fn(...args);
}

factorial(5)
  //=> 120
factorial(null)
  //=> Maximum call stack size exceeded.

whenNotNull(factorial, 5)
  //=> 120
whenNotNull(factorial, null)
  //=> undefined
```

`whenNotNull` is a higher-order function closely related to the `maybe` decorator. We call it with the name of a function and one or more arguments. If none of teh arguments are null, it returns teh result of calling that function with the arguments. But of no arguments are supplied, or any of them are null, it simply returns without calling the function.

The key thing to observe is that when `whenNotNull` calls `fn`, it returns the result with no further calculations or computations. The statement `return fn(...args);` is a *tail call*. By way of contrast, the statement `return n * factorial(n - 1);` is not a tail call, because after invoking `factorial(n - 1)`, our factorial function proceeds to multiply the result by `n`.

A *tail recursive* function is simply a function that only makes calls in tail position, and that as a result of making a call in tail position, directly or indirectly calls itself.

### converting simple recursive functions to make tail calls

There are a large class of recursive functions that can be converted into tail recursive functions. Tom Moertel gives a procedure for performing this conversion in his [Tricks of the trade: Recursion to Iteration](http://blog.moertel.com/tags/recursion-to-iteration%20series.html) series:

0. Find a recursive call that’s not a tail call.
0. Identify what work is being done between that call and its return statement.
0. Extend the function with a secret feature to do that work, as controlled by a new accumulator argument with a default value that causes it to do nothing.
0. Use the secret feature to eliminate the old work.
0. You’ve now got a tail call!
0. Repeat until all recursive calls are tail calls.

---

## notes

