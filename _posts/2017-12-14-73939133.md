---
layout: default
tags: [allonge, noindex]
---

> In number theory, a **right-truncatable prime** is a prime number which, in a given base, contains no 0, and if the last ("right") digit is successively removed, then all resulting numbers are prime. 7393 is an example of a right-truncatable prime, since 7393, 739, 73, and 7 are all prime.

> --[Wikipedia](https://en.wikipedia.org/wiki/Truncatable_prime)

Truncatable primes have been thoroughly explored. But it is still interesting to explore them ourselves, for much the same reason that a beautiful mountain is still worth climbing, even if somebody else has already climbed it.

---

[![prime numbers < 250,000](/assets/images/prime-numbers.jpg)](https://www.flickr.com/photos/tim-brown/5128265698)

### the infinitude of primes

Now, we know that there are an infinite number of primes. The _reductio ad absurdum_ proof of this is easy to follow along:

> To prove that there are an infinite number of primes, we first assume the opposite--that there are a finite number of primes--and then show that this presumption leads to a contradiction.

> If there are a finite number of primes, there is some finite list of primes, call them p0, p1, p2, ..., pN, where "pN" is the largest prime. Now we know from other work in number theory that every number can be decomposed into a set of prime factors, even primes. The only thing special about primes in this respect is that their only prime factor is themselves.

> It follows then that every integer has one or more factors from the list p0, p1, p2, ..., pN and only this list. So now let us consider the number p0 times p1 times p2, ..., times pN. It is the product of all of the primes, and we will call it pN*. This is obviously not a prime. But what about the number pN* + 1?

> We also know from other work that if some number x is divisible by some prime p, the numbers x + y and x - y are not divisible by p unless y is divisible by p. The most trivial example is when y = 1, because 1 is not divisible by any prime. For example, the number 10 is divisible by 2 and 5, but the numbers 9 and 11 are not divisible by either 2 or 5.

> From this, we know that pN* + 1 is not divisible by any prime, be it p0, p1, p2, ..., or pN. But that contradicts our knowledge that all numbers have one or more prime factors! So, from this, we conclude that pN* + 1 must be divisible by some prime other than p0, p1, p2, ..., pN.

> This tells us that any finite list of primes is necessarily incomplete.

Ok, that is middle-school mathematics. What about _truncatable_ primes? Are there an infinite number of them?

---

[![Monks Cellarium](/assets/images/cellarium.jpg)](https://www.flickr.com/photos/fieldsofview/14786729799)

### are there an infinite number of truncatable primes?

One way to settle this question is with a clever bit of reasoning, like the proof that there are an infinite number of primes. But while that's the elegant way, it's not the only way.

Some mathematical problems can be solved by brute force. If you have an abbey full of mathematically minded monks, you can solve a brute force probblem in a couple of decades. It's a matter of figuring out how to enumerate all of the cases, divide up the work, and wait.

No abbey? No problem, today we have computers. How can we put a computer to work to brute-force the problem?

### the naïve brute force approach

The naïve thing to do is to lazily generate a list of primes, checking each one to see if it's a truncatable prime. This generates a lazy list of truncatable primes.

That seems like a terrible idea, because we just established that there are an infinite list of primes. Whether there are a finite number of truncatable primes or not, our algorithm will never terminate.

But we can combine brute force with a modicum of reasoning. If there are an infinite number of truncatable primes, our algorithm will never stop. But what if there are a finite number of truncatable primes?

What do we know about truncatable primes? One thing we can use is the deduction that any two consecutive truncatable primes must either have the same number of digits, or differ by at most one digit.

> Consider some right truncatable prime p, with d digits. The next largest truncatable prime might also have d digits, as might the next. Or it might have d + 1 digits, as might the next. But for any truncatable prime, the next largest truncatable prime cannot have d + 2 digits, because if you removed a digit, there would have to be some truncatable prime with d + 1 digits.

It follows then that if we are testing consecutive primes for "truncatability," and if we know the length of the largest truncatable prime that we've seen so far, any prime that has two more digits than the largest truncatable prime must necessarily not be truncatable, and we would know there would be no larger truncatable primes. Which would mean that there would be a finite number of left truncatable primes.

Of course, if our algorithm keeps finding trunctable primes that have the same length as the previous truncatable prime, or are at most one digit longer, we will only know that there are more of them than we have patience to test.

But maybe we should try it? There may be a reasonably tractable finite number of truncatable primes.

[![PDP-8](/assets/images/pdp-8.jpg)](https://www.flickr.com/photos/ajmexico/2682618330)

### computering truncatable primes

In job interviews, it seems they always ask you to implement something from scratch, whereas in real life you just google for TEH CODEZ. Let's do that: We want some code that lazily generates prime numbers in ascending order. Like this code from [The Hubris of Impatient Sieves of Eratosthenes](http://raganwald.com/2016/04/25/hubris-impatient-sieves-of-eratosthenes.html):

<script src="https://gist.github.com/raganwald/78b086166c0712b49e5160edca5ebadd.js"></script>

We'll need to iterate over all the primes, checking each one to see if it is truncatable. That would normally involve a lot of checking whether numbers are prime. But a lazy list of primes doesn't help with that. We could save them as we generate them, but that might take up a lot of space. If we presume that there are a lot fewer tractable primes than all primes, maybe we can get away with just storing tractable primes.

In fact, we don't need to save *every* truncatable prime, just those that are the same length or one digit smaller than whatever prime we're currently examining. If there aren't any that are the same length or one digit smaller, it means our current prime is at least two digits larger than the largest truncatable prime we've found, and we're done.

Here's a first cut at a brute-force check for right truncatable primes. Although we're generating the primes, what we're really doing is a brute-force search for a gap that would indicate that there can be no larger right truncatable primes:

```javascript
// Depends upon Primes() from https://gist.github.com/raganwald/78b086166c0712b49e5160edca5ebadd

const rightTruncatablePrimeStrings = [];

for (const primeInt of Primes()) {
  const prime = primeInt.toString();
  const isRightTruncatablePrime = isRightTruncatablePrimeString(prime);

  if (isRightTruncatablePrime === true) {
    rightTruncatablePrimeStrings.push(prime);
    console.log(prime);
  } else if (isRightTruncatablePrime === null) {
    console.log('There are no more right truncatable primes.');
    break;
  }
}

// returns:
//
//   true,  indicating that the string passed represents a right truncatable prime;
//
//   false, indicating that the string passed does not represent a right truncatable prime,
//          but more right truncatable primes may yet exist
//
//   null,  indicating the string passed does not represent a right truncatable prime,
//          and there are no larger right truncatable primes
function isRightTruncatablePrimeString(prime) {
  if (prime.length === 1) {
    return true;
  } else {
    const remainder = prime.substr(0, prime.length - 1);
    const remainderLength = remainder.length - 1;

    // remove our existing truncatable primes that are too short
    while (rightTruncatablePrimeStrings.length > 0 && rightTruncatablePrimeStrings[0].length < remainderLength) {
      rightTruncatablePrimeStrings.shift();
    }

    if (rightTruncatablePrimeStrings.length === 0) {
      return null;
    } else {
      return rightTruncatablePrimeStrings.includes(remainder);
    }
  }
}

//=>
  2
  3
  5
  7
  23

  ...

  23399339
  29399999
  37337999
  59393339
  73939133
  There are no more right truncatable primes.
```

Success! Of a kind...

---

[![Mechanical Adding Machine](/assets/images/adding-machine.jpg)](https://www.flickr.com/photos/65720474@N03/5988560780)

### evaluating our naïve brute force algorithm





