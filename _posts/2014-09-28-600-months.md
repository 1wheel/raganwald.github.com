---
layout: default
tags: spessore
---

The tweet says it all:

> "I have personally found that LISP is unbelievably productive if you're willing to invest in the 600-month learning curve."-[Paul Ford][1]

[1]: https://twitter.com/ftrain/status/516237176636715008

Now Mr. Ford is probably exaggerating by a factor of five: I'll go with Peter Norvig and say that Lisp is unbelievably productive if you're willing to invest in the 120 month (ten year!) learning curve. But exaggeration or no, doesn't this seem damning?

Aren't people productive in Rails or JavaScript in a few years, maybe even a few months? Don't people learn to write complete Rails or Node applications at "boot camps" in the space of weeks?

### define "productive"

Sure people learn to write complete Rails, Node, Ember, or whatever applications in weeks. If we define "productive" as "being able to make something useful," You can be productive in Ruby or JavaScript in weeks.

[Racket]: https://en.wikipedia.org/wiki/Racket_(programming_language)

But then again, you can learn to write complete [Racket], [Clojure], or [PureScript] programs in weeks as well.

[PureScript]: https://leanpub.com/purescript/
[CLojure]: http://clojure.org

Are we using the same definition of "productive" for Lisp as we are for JavaScript? Somehow, I think we're "grading on a curve." We can learn to be "unbelievably productive" In Lisp after a decade of study, but that "unbelievably productive" is a different kind of productive than "whip together a web app iusing Ember.js" productive, or "learn enough to get a paying job" productive.

In my anecdotal experience, many supposedly "advanced" languages (like Lisp, but also Haskell) suffer from the high expectations set for them by enthusiasts: We have heard about the phenomenal things you can do with them, so we naturally assume that phrases liek "productive" or "proficient" or "knows well" apply to doing these wonderful things.

Whereas the pedestrian and "pragmatic" languages like JavaScript or Python aren't held out as being these magnificent mental force multipliers, so we grade them against our lowered expectations.

### ten years

This makes me wonder: What happens if we invest ten years in learning Lisp? Wonderful things, we get a wizard's hat. If we invest ten years in PureScript I expect we'll be dreaming of [fizz buzz with semigroups and apply][2].

[2]: http://www.purescript.org/posts/FizzBuzz-With-Semigroups-And-Apply/

But what happens if we put ten years of study into JavaScript? Will we be as "incredibly productive" as we would be with ten years of Lisp? Or do we end up with two years of JavaScript productivity and five years of general-purpose broad principles we borrow from Java and Python?

Either way, we'll be better after ten years studying *something*. But perhaps all something's aren't really equal?

What language has the property that after ten years' study, you are the *most* incredibly productive? What language has the lurning curve that stays steep, longer?

I laugh at the joke about spending 600 months becoming incredibly productive in Lisp. But then I wonder: If I keep studying the things I'm studying today, will I be on my way to becoming incredibly productive? Or will I flatten out long before a decade passes?

Hmmm.