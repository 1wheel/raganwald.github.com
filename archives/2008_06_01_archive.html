<html> 
<head>
        
        <title>raganwald: 06/08</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
</head>

<body>

	<div id="leftcontent">
			<img src="http://raganwald.github.com/assets/raganwald_2008_350_150" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Monday, June 30, 2008</div>
			

			<div class="Post"><a name="3851212997327201496">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/my-mixed-feelings-about-ruby.html" title="permanent link">My Mixed Feelings about Ruby</a></span>
					<div style="clear:both;"></div><blockquote>There&#8217;s a lot of features of Ruby that I like, but there are some that just drive me nuts like blocks not taking blocks and the ampersand operator. Raganwald did a great job of explaining blocks, procs, and the ampersand in this blog post: <a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">Explanation of Ruby&#8217;s Unary operator</a>. I came away with the feeling, &#8220;Wow! It took that much explanation just to tell how to send blocks around?&#8221; If blocks were first-class citizens, Ruby would be more elegant. Raganwald would not be writing huge blog posts on block vs. proc because it would be unneeded.</blockquote>
<div>&mdash;Blaine Buxton, <a href="http://blog.blainebuxton.com/2008/06/too-complex.html">Too Complex?</a></div>
<br />
I feel for Blaine, I really do. When I first looked at Ruby, quite honestly I hated it. Not hated it in a Blubb-dacious &ldquo;It&rsquo;s not the same as my popular language&rdquo; way, but hated it in a &ldquo;The language is full of Accidental Complexity&rdquo; way.<br />
<br />
To my eyes, Ruby as a language looked a lot like an internal IT app that is built as an aggregation of features. There might be a wonderful, coherent design in the implementation that I can&rsquo;t see, but the interface I use seems like a bunch on one-off features that don&rsquo;t play well together.<br />
<br />
Ruby definitely isn&rsquo;t <a href="http://www.cincomsmalltalk.com/userblogs/avi/blogView?showComments=true&entry=3284695382">turtles all the way down</a>. And I have never stopped being troubled by this. I lamented the fact that <a title="The significance of the meta-circular interpreter" href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">Ruby isn&rsquo;t written in Ruby</a>. <a title="Why Rubinius Matters to Ruby's Future" href="http://raganwald.github.com/2007/12/why-rubinius-matters-to-rubys-future.html">Twice</a>. No, make that <a title=" Turtles all the way down, please" href="http://raganwald.github.com/2008/02/turtles-all-way-down-please.html">three times</a>.<br />
<br />
Deep breath. But.<br />
<br />
There&rsquo;s a part of my personality that craves purity and regularity in a system. Purity and regularity have practical benefits, to be sure, but at the same time there are practical benefits to being messy and having special cases optimizing for things people do frequently. This is why design is freakin&rsquo; hard. It&rsquo;s not as easy as following a bunch of rules that produce a system with the smallest possible intellectual surface area, otherwise we&rsquo;d have stopped with Scheme and its five axiomatic special forms.<br />
<br />
<br />
<center><object width="425" height="344">
<param name="movie" value="http://www.youtube.com/v/1kvdq8cRNBM&hl=en"></param>
<embed src="http://www.youtube.com/v/1kvdq8cRNBM&hl=en" type="application/x-shockwave-flash" width="425" height="344"></embed></object><br />
<br />
<em>A Rube Goldberg contraption does a simple thing (like making ramen) in an extremely complex way. It turns accidental complexity and irregularity into entertainment.</em></center><br />
Nor is it as easy as piling more features on regardless of how well they fit or whether people will actually use them. Otherwise Windows would have 97% of the market and OS X 3%. (<em>Oh wait</em>.)<br />
<br />
When it comes to design, sometimes you have to experience the result to judge it. You can decide whether a chair is attractive by looking at it, but you really need to sit in it a while to know whether you will feel comfortable using it. Even then, only long experience will tell you whether it is a keeper. Many things that are nice in the showroom are mediocre in day-to-day use.<br />
<br />
Design is all about problem solving. What problem do you think programming languages solve as a group? What problem does Lisp solve? Smalltalk? Ruby? For whom?<br />
<br />
Matz has said that Ruby is an attempt to solve the problem of making programmers happy. So maybe we aren&rsquo;t happy with some of the accidental complexity. But can we be happy overall? Can we find a way to program in harmony with Ruby rather than trying to <a href="http://en.wikipedia.org/wiki/Greenspun's_Tenth_Rule">Greenspun</a> it into Lisp?<br />
<br />
(I speak as a man working on rewriting code for Ruby: By far the hardest part of this is trying to provide the power of macros in a mechanism that works in harmony with the Ruby Way, rather than bolting Lisp onto Ruby&rsquo;s side.)<br />
<br />
Programming languages also solve the deep problem of helping programmers think about the parts of a program that matter and not clutter their minds up with the parts that don&rsquo;t matter. This is a very hard problem. Very, very hard. Make things too simple, have too few axioms and abstractions, and you end up with something where each element is extremely simple to understand, but any non-trivial program has too many elements with difficult-to-understand interactions and dependencies so as a whole programs are harder to understand.<br />
<br />
Does a regular language help us understand the parts of programs that matter more than an irregular language? That is not an easy question to answer. When I&rsquo;m struggling with some subtle difference between Proc.new and lambda, I want to shout YES, GODDAMIT, GIVE ME SOME CONSISTENCY.<br />
<br />
I&rsquo;m wary of trying to decide about languages based on infrequent edge cases. With a certain very popular language, I&rsquo;ve made up my mind that the design choices don&rsquo;t pay off, that the places where you work hard to express yourself aren&rsquo;t places where the easy, obvious thing is easy to write and obvious to read. But so far in Ruby, the things that trouble me do seem to have some inherent trade-off merit. I can see how making blocks a special case makes certain eay, simple things easy. So is it overall the best possible design? I don&rsquo;t know. is it a good design? So far it seems to be a reasonable design.<br />
<br />
At my core, I believe axiomatically that there is no one &ldquo;best&rdquo; language. That is not an excuse for saying that every language has merit. While I think that there can be more than one good language with different approaches and styles, I do not exclude the possibility that 90% of the programming languages in existence are stinkers through and through.<br />
<br />
Is Ruby better for me personally than Lisp or Smalltalk? I don&rsquo;t know the answer to that question either.<br />
<br />
I decided a while back that I would <a title="I'm not young enough to know everything" href="http://raganwald.github.com/2005/10/im-not-young-enough-to-know-everything.html">give Ruby an honest try</a>. And while I give myself the freedom to express my misgivings about some of the choices Matz has made, I also try to keep an open mind about them.<br />
<br />
It&rsquo;s really freakin&rsquo; (I know, I used this word already) hard for me to to do, but I&rsquo;m trying to find out if <a href="http://www.dreamsongs.com/WorseIsBetter.html">worse might be better</a>. And I don&rsquo;t mean, &ldquo;Ruby is worse than Lisp, but it&rsquo;s better for those n00bs over there.&rdquo; That&rsquo;s not embracing change. I mean I am trying to discover if worse might be better for me personally, and it is hard for me to open my mind to that possibility when I&rsquo;m already invested in &ldquo;better.&rdquo;<br />
<br />
At this moment in time I have extremely mixed feelings about Ruby. I sorely miss the elegance and purity of languages like Scheme and Smalltalk. But at the same time, I am trying to keep my mind open to some of the ways in which Ruby is a great programming language.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/my-mixed-feelings-about-ruby.html" title="permanent link">10:42 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, June 27, 2008</div>
			

			<div class="Post"><a name="2487354129772750654">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html" title="permanent link">The unary ampersand in Ruby</a></span>
					<div style="clear:both;"></div><p>A marshmallow toasting dragon slayer from Montréal <a href="http://lovehateubuntu.blogspot.com/2008/06/some-neat-things-in-ruby.html" title="Some Neat Things in Ruby">asked about the unary &amp;</a>.</p><p>I like this question, because when I saw it, I realized immediately that although I’ve figured out how to use it to accomplish certain things, writing an answer serves the excellent purpose of forcing myself to learn more.</p><p>Let’s start with what I do know, and what everyone can figure out from grepping source code: <em>It has something to do with converting things to and from blocks</em>. If you take nothing else away from this, remember that when you see a unary “&amp;” in Ruby, you are looking at making something into a block, or making a block into something.</p><p>Now, blocks in Ruby are not first-class entities. You cannot store them in variables. They are not objects. There is no Block.new expression. The only way to make a block in Ruby syntax is to write one as part of a method call, like this:</p><pre><code>
[1, 2, 3, 4, 5].map { |x| x * x  }
    =&gt; [1, 4, 9, 16, 25]</code></pre><p>As we said above, you <strong>cannot</strong> assign a block to a variable:</p><pre><code>
square_block = { |x| x * x  }
    =&gt; syntax error, unexpected '}', expecting $end</code></pre><p>What do we do with these blocks? Well, inside of a method, we can yield to a block. Yielding to a block is something very much like calling a function. The value of an expression yielding to a block is the value of the expression in the block, paramaterized by anything you pass in the yield expression.</p><p>Oh heck, an example is much better:</p><pre><code>
def take_a_guess(range) # expects a block testing a guess
    guess = range.begin + rand(range.end - range.begin)
    if yield(guess)
        "Yay, I guessed correctly"
    else
        "Boo hoo, my guess was wrong"
    end
end

take_a_guess(1..10) { |x| x == 6 }
    =&gt; "Boo hoo, my guess was wrong"
take_a_guess(1..10) { |x| x == 6 }
    =&gt; "Boo hoo, my guess was wrong"
take_a_guess(1..10) { |x| x == 6 }
    =&gt; "Yay, I guessed correctly"</code></pre><p>This method plays a guessing game with you: it takes a range (“guess a number from one to ten”) and a block for testing whether the guess was correct. It takes a guess and yield the guess to the block. It then exclaims its joy to the world if it guesses correctly.</p><p>Notice that there is nothing in the method signature saying it expects a block. There is no name for the block. You have to look for the yield keyword to figure out what is going on if the programmer doesn’t add a comment.</p><p><strong>converting blocks to procs</strong></p><p>So… Let’s talk conversions. If you want to do <em>anything</em> besides invoke a block with yield, you really want a Proc, not a block. For example:</p><pre><code>
class Guesser
    attr_reader :range, :tester
    def initialize(range, &amp;tester)
        @range, @tester = range, tester
    end
    def take_a_guess
        guess = range.begin + rand(range.end - range.begin)
        if tester.call(guess)
            "Yay, I guessed #{guess} correctly"
        else
            "Boo hoo, my guess of #{guess} was wrong"
        end
    end
end

foo = Guesser.new(1..10) { |n| n == 6 }
foo.take_a_guess
    =&gt; "Boo hoo, my guess of 2 was wrong"
foo.take_a_guess
    =&gt; "Boo hoo, my guess of 8 was wrong"
foo.take_a_guess
    =&gt; "Yay, I guessed 6 correctly"</code></pre><p>We want to store the tester block as an instance variable. So what we do is add a parameter at the very end with an ampersand, and what Ruby does is take the block and convert it to a Proc, which you can pass around as an object. And when you want to use it, you send it the #call method.</p><p>Now if you think about this for a second or two, you’ll realize that almost every Proc you ever create works this way: We pass a block to a method, and the method turns it into a proc by having a parameter with an &amp;. Let’s try writing another one:</p><pre><code>
def our_proc(&amp;proc)
    proc
end

double = our_proc { |n| n * 2}
double.call(7)
    =&gt; 14</code></pre><p>Not much to it, is there? When you want a Proc, you can create one by calling a method with a block and using &amp;parameter to convert the block to a Proc. There is no other way to convert a block to a proc because the only place blocks exist is in method invocations.</p><p><strong>converting procs to blocks</strong></p><p>Okay, we know how to make a Proc out of a block. What about going the other way? What if we want to make a block out of a Proc?</p><p>Let’s reopen our Guesser class:</p><pre><code>
class Guesser
    def three_guesses
        guesses = Array.new(3) { range.begin + rand(range.end - range.begin) }
        if guesses.any?(&amp;tester)
            "Yay, #{guesses.join(', ')} includes a correct guess"
        else
            "Boo hoo, my guesses of #{guesses.join(', ')} were wrong"
        end
    end
end

bar = Guesser.new(1..10) { |x| x == 3 }
bar.three_guesses
    =&gt; "Yay, 5, 9, 3 includes a correct guess"</code></pre><p>What just happened?</p><p>For starters, we made an array with three guesses in it. That line of code includes a block, but let’s ignore that as being irrelevant to this particular discussion. The next part is what we’re after:</p><p>We then want to call <a href="http://www.ruby-doc.org/core/classes/Enumerable.html#M001153" title="Module: Enumerable">Enumerable#any?</a> to ask the array if any of its members are the correct guess. Now #any? expects a block. But we don’t have a block, we have a Proc. So now we do the <em>reverse</em> of what we did when we wanted to convert a block to a Proc: instead of a method having an extra parameter with an ampersand, we pass a parameter to the method and apply the ampersand to the parameter we are passing.</p><p>So “&amp;tester” says to Ruby: “Take this object and pass it to a method as a block.” The #any? method gets a block, it has no idea we are doing any Proc to block conversion shenanigans. We can prove that:</p><pre><code>
def did_you_pass_me_a_block?
    if block_given?
        yield
    else
        "NO BLOCK"
    end
end

did_you_pass_me_a_block?
    =&gt; "NO BLOCK"
did_you_pass_me_a_block? { 'I passed you a block' }
    =&gt; "I passed you a block"
proc = Proc.new { 'I passed you a proc' }
did_you_pass_me_a_block?(&amp;proc)
    =&gt; "I passed you a proc"</code></pre><p>As you can see, our methods don’t really know whether they get a block or a proc passed as a block. They just yield and all is well. (And yes, you can convert a block to a proc and then the method can convert it right back into another proc.)</p><p><strong>to_proc shakur</strong></p><p>Which leads us to the final piece of the puzzle. How does Ruby convert whatever you pass with “&amp;” into a block? The answer is that if it is not already a Proc, it tries to convert the object to a Proc by calling the object’s #to_proc method, and from there it converts the Proc into a block.</p><p>So you can do fun stuff like convert strings into blocks <a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="String#to_proc">by defining a method that converts a string to a Proc</a>:</p><pre><code>
(1..5).map &amp;'*2'
    =&gt; [2, 4, 6, 8, 10]</code></pre><p>Note that this conversion only happens when you try to pass a string as a block to a method with “&amp;.” It is not correct to say that “&amp;” converts an object to a Proc, the #to_proc method does that. It is correct to say that when passing an object to a method, the “&amp;” unary operator tries to convert the object to a block, using the Object’s #to_proc method if need be.</p><p>We’ll close with an example, where we decide that a Guesser can be converted to a Proc:</p><pre><code>
class Guesser
    def to_proc
        Proc.new { |guess|
            "Yay, I guessed #{guess} correctly" if tester.call(guess)
        }
    end
end

foo = Guesser.new(1..10) { |n| n == 8 }
&amp;foo
    =&gt; syntax error, unexpected tAMPER
foo.to_proc
    =&gt; #&lt;Proc:0x0008cc08@-:26&gt;
(1..100).map(foo).compact.first
    =&gt; ArgumentError: wrong number of arguments (1 for 0)
(1..100).map(&amp;foo).compact.first
    =&gt; "Yay, I guessed 8 correctly"</code></pre><p>So that’s it: When you want to convert a block to a Proc, define an extra parameter for your method and preface it with an ampersand. When the method is called, the parameter will hold a proc.</p><p>When you want to convert any object to a block, pass it to a method expecting a block and preface it with an ampersand. Ruby will call the #to_proc method if need be, then convert the Proc into a block.</p><p><strong>because it’s friday</strong></p><p>I really hate writing anything too serious on a Friday. So if you’re eyes have glazed over and you’ve marked this to be read later, here’s a little diversion for you. I just picked up <a href="http://www.amazon.com/gp/product/8876990666?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=8876990666">The Magic Garden of George B. And Other Logic Puzzles</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=8876990666" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> by my favourite nonfiction author, Raymond Smullyan.</p><p>Right off the bat, the first paragraphs of the preface introduce a neat puzzle:</p><blockquote>Here is a remarkable problem: Imagine a garden of magic flowers that can change color from day to day. On any one day, a flower is either blue the entire day or red the entire day, but can change from one day to another. Given any flower A and any flower B, there is a flower C that is red on all and only those days on which A and B are both blue. Also, we are given that for any distinct flowers A and B, there is at least one day on which A and B are of different colors. Now suppose that the number of flowers is somewhere between 200 and 500. How many flowers are in the garden?Amazingly enough, the problem actually has a unique solution! Doesn’t this surprise you?</blockquote><p>Have fun!</p><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html" title="permanent link">4:07 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, June 24, 2008</div>
			

			<div class="Post"><a name="4217991168585523478">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/bit-of-history-and-interesting.html" title="permanent link">A bit of history and an interesting conjecture</a></span>
					<div style="clear:both;"></div><blockquote>We Smalltalkers used to think the advantages of our language were so significant that it would take over the world. We had a huge productivity advantage over C coders. Then C++ came along and gave C coders just enough to let them improve their productivity and their ability to write larger more complex systems. It still wasn&#8217;t as good as Smalltalk, but it was better than C, and much more accessible to most programmers than Smalltalk.<br /><br />C++ eventually sucked up all the oxygen and Smalltalk is now only a language for hobbyists and the occasional programming god. I think this is the most likely threat to the Rails surplus, that C# or Scala or something can do a good enough job that people can double their productivity with far less of a change in mindset or tools, and eventually no one will care about the ten times (or whatever) productivity of Rails.<br /><br />&#8220;Good enough is good enough.&#8221;</blockquote><div>&mdash;<a href="http://blog.hasmanythrough.com/2008/5/31/quick-railsconf-update">Josh Susser</a></div><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/bit-of-history-and-interesting.html" title="permanent link">10:05 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="861417926615539281">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/interview-questions-i-have-never-been.html" title="permanent link">Interview questions I have never been asked, Episode I</a></span>
					<div style="clear:both;"></div>Compare and contrast:<pre><code><br />some_array.any? { |n| n > 100 }</code></pre><br />And:<pre><code><br />!!some_array.detect { |n| n > 100 }</code></pre><br />Which do you think is easier to read?<br /><br />Are classes and modules easier to read and understand when they have lots and lots of specific methods like <a href="http://globalnerdy.com/2008/06/24/enumerating-enumerable-enumerableany/">#any?</a> or are they easier to read and understand with a small number of axiomatic methods that can be composed and combined like #fold and #unfold? When you design a module or class, do you write lots of convenience methods in advance? Or do you refactor code by writing convenience methods when you find yourself repeating the same code? <br /><div class="book"><hr/><em><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to functional programming techniques.</em><hr/></div><br />If you do refactor code to eliminate duplication, is there an amount of duplication that is too small to matter, like "!!"? Or is there an underlying principle of documenting intent that you wish to make explicit?<br /><br />Is:<pre><code><br />do_something() if some_array.detect { |n| n > 100 }</code></pre><br />Misleading because it doesn&rsquo;t actually <em>use</em> the element it detects? Or is it a reasonable idiom to test for an element&rsquo;s existence without using a specific method like #any or #nil?<br /><br />Are applications easier to read and understand when they make use of lots and lots of specific methods like #any or are they easier to read and understand when they compose and combine a smaller number of axiomatic methods so that you aren&rsquo;t constantly looking things up?<br /><br />Do you think applications should have large or small vocabularies?<br /><br /><em>This example can be easily translated to the language du jour, the underlying principle applies to programming in general</em><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/interview-questions-i-have-never-been.html" title="permanent link">10:45 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, June 22, 2008</div>
			

			<div class="Post"><a name="8802494876056821164">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/macros-hygiene-and-call-by-name-in-ruby.html" title="permanent link">Macros, Hygiene, and Call By Name in Ruby</a></span>
					<div style="clear:both;"></div><blockquote>Never send a macro to do a function&#8217;s job.</blockquote><br />Sound advice, however just because functions (or methods) are better than macros for the things they both can do, that doesn&#8217;t mean functions can do everything macros can do. Let&#8217;s look at <a href="http://andand.rubyforge.org/" title="Object#andand">andand</a> for a moment. When you write:<br /><pre><code><br />foo().andand.bar(blitz())</code></pre><br />Using the andand gem, Ruby treats this something like:<br /><pre><code><br />temp1 = foo()<br />temp2 = temp1.andand<br />temp3 = blitz()<br />temp2.bar(temp3)</code></pre><br />As it happens, if you call nil.andand.bar(blitz()), it will return nil. But it will still evaluate blitz() before returning nil. What <em>I</em> would expect from something named andand is that if foo() is nil, Ruby will never evaluate blitz(). Something like:<br /><pre><code><br />temp1 = foo()<br />if temp1.nil?<br />    nil<br />else<br />    temp2 = blitz()<br />    temp1.bar(temp2)<br />end</code></pre><br />What we want is that when we pass blitz() to andand, it is not evaluated <em>unless the andand function uses it</em>. The trouble is, you cannot write an andand method in Ruby that delivers these semantics.<br /><br />Let&#8217;s hand wave over the difference between methods and functions for a moment and just look at calling functions. We&#8217;ll consider writing &#8220;our_and,&#8221; a function that emulates the short-circuit evaluation behaviour of Ruby&#8217;s &#8220;&amp;&amp;&#8221; and &#8220;and&#8221; operators. Ruby (and most other languages in use these days) uses <a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" title="Evaluation strategy - Wikipedia, the free encyclopedia">call-by-value</a> when it passes parameters to functions. In other words, when you write:<br /><pre><code><br />our_and(foo(), blitz())</code></pre><br />Ruby turns that into something that looks like this:<br /><pre><code><br />var temp1 = foo()<br />var temp2 = blitz()<br />our_and(temp1, temp2)</code></pre><br />It doesn&#8217;t matter if the function our_and uses blitz() internally or not, it is evaluated <em>before</em> our_and is called and its value is passed to our_and. Whereas our &#8220;if&#8221; statement in the previous example does not evaluate &#8220;blitz()&#8221; unless &#8220;foo().andand&#8221; is not nil.<br /><br />Well, well, well. The inescapable conclusion is that there are some sequences of expressions in Ruby that cannot be represented as functions or methods. That&#8217;s right, <em>functions and methods can&#8217;t do everything that Ruby code can do</em>.<br /><br />Macros and code rewriting can do an awful lot. The implementation of andand in the <a href="http://rewrite.rubyforge.org/" title="rewrite">rewrite</a> gem <em>does</em> rewrite code. When you write:<br /><pre><code><br />with(andand) do<br />    # ...<br />    foo().andand.bar(blitz())<br />    # ...<br />end</code></pre><br />Rewrite rewrites your code in place to look something like:<br /><pre><code><br /># ...<br />lambda do |__121414053598468__|<br />    if __121414053598468__.nil?<br />        nil<br />    else<br />        __121414053598468__.bar(blitz())<br />    end<br />end.call(foo)<br />#...</code></pre><br />And for that reason when you write foo().andand.bar(blitz()) using the rewrite gem instead of the andand gem, blitz() is not evaluated if foo() is nil. Big difference!! So it looks like one way to get around call-by-value is to rewrite your Ruby code. Excellent. Or is it?<br /><br /><strong>What&#8217;s wrong with rewrite</strong><br /><br />Right now, the rewrite gem supports writing sexp processors. These are objects that encapsulate a way of transforming sexps. For example, here is the code that transforms expressions like &#8220;foo().andand.bar(blitz()):&#8221;<br /><pre><code><br />  def process_call(exp)<br />    exp.shift<br />    receiver_sexp = exp.first<br />    if matches_andand_invocation(receiver_sexp)<br />      exp.shift<br />      mono_parameter = Rewrite.gensym()<br />      s(:call, <br />        s(:iter, <br />          s(:fcall, :lambda), <br />          s(:dasgn_curr, mono_parameter), <br />          s(:if, <br />            s(:call, s(:dvar, mono_parameter), :nil?), <br />            s(:nil), <br />            begin<br />              s(:call, <br />                s(:dvar, mono_parameter), <br />                *(exp.map { |inner| process_inner_expr inner })<br />              )<br />            ensure<br />              exp.clear<br />            end<br />          )<br />        ), <br />        :call, <br />        s(:array, <br />          process_inner_expr(receiver_sexp[1])<br />        )<br />      )<br />    else<br />      begin<br />        s(:call,<br />          *(exp.map { |inner| process_inner_expr inner })<br />        )<br />      ensure<br />        exp.clear<br />      end<br />    end<br />  end</code></pre><br />And that&#8217;s just a third of andand: There is another method that handles expressions like &#8220;foo().andand { |x| x.bar(blitz()) }&#8221; and a third that handles &#8220;foo().andand(&amp;bar_proc).&#8221; Brutal.<br /><br />Now, rewriting code has many other uses. One on my wish list is a rewriter that transforms expressions like: &#8220;foo.select { |x| &#8230; }.map { |y| &#8230; }.inject { |z| &#8230; }&#8221; into one big inject as an optimization. So I&#8217;m not ready to throw rewrite in the trash can just yet. But there&#8217;s no way I want to be writing all that out by hand every time I want to implement a function but work around call-by-value semantics.<br /><br /><strong>What about macros?</strong><br /><br />Why can&#8217;t I write:<br /><pre><code><br />def_macro our_and(x,y)<br />    ((temp = x) ? (y) : (temp))<br />end</code></pre><br />&#8230;And have it automatically expand my code such that when I write:<br /><pre><code><br /># ...<br />foo = our_and(bar(), blitz())<br /># ...</code></pre><br />The macro expander rewrites it as:<br /><pre><code><br /># ...<br />foo = ((temp = bar() ? blitz() : temp)<br /># ...</code></pre><br />Wouldn&#8217;t that work? Maybe. Then again, maybe not.<br /><br />The problem given above&#8212;working around call-by-value&#8212;is just one small problem. A macro implementation would solve that problem, but there&#8217;s an awful lot of overhead required to make the implementation work, and whatever you do ends up being an incredibly leaky abstraction.<br /><br />Take our example above. What happens if we have our own variable named temp? Does it get clobbered by expanding our_and? Or do we rename temp? Or do some automagic jigger-pokery with scopes?<br /><br />Getting macros right is very tricky. I don&#8217;t personally plan to try my hand at implementing macros until I&#8217;m an expert on the subject of <a href="http://www.bookshelf.jp/texi/onlisp/onlisp_10.html" title="Onlisp:  Variable Capture">variable capture</a> and can hold forth on the design trade-offs inherent in different schemes for implementing <a href="http://en.wikipedia.org/wiki/Hygienic_macro" title="Hygienic macro - Wikipedia, the free encyclopedia">hygienic macros</a>. But that&#8217;s just me.<br /><br />Perhaps there are other ways to solve it without diving into a full-blown macro facility?<br /><br /><strong>Lambdas and blocks</strong><br /><br />Indeed there are other ways. Ruby already has one-and-a-half of them: blocks and lambdas. Using blocks and lambdas, you can control evaluation precisely. The andand gem actually does support short-circuit semantics using a block. When you write:<br /><pre><code><br />nil.andand { |x| x.foo(blitz()) }</code></pre><br />It does <em>not</em> evaluate blitz(). This alternate way of using andand supports the semantics we want by explicitly placing the code that should not be eagerly evaluated in a block. Given patience and a taste for squiggly braces, you can create non-standard evaluation without resorting to macros.<br /><br />We said at the beginning that the reason we cannot use functions and methods to represent everything we can write in code is because Ruby uses call-by-value to pass parameters to functions. One way to work around that is this: instead of passing the value of each expression to a function, we can pass the expression itself, wrapped up in its own lambda.<br /><br />Then, when the function needs the value, it can call the lambda. This technique has a name: it is called <a href="http://en.wikipedia.org/wiki/Thunk#Thunk_as_delayed_computation" title="Thunk as delayed computation">thunking</a>.<br /><br />We could implement our_and as follows:<br /><pre><code><br />our_and = lambda { |x,y|<br />    if temp = x.call<br />        y.call<br />    else<br />        temp<br />    end<br />end</code></pre><br />Then when we call it, we could wrap our parameters in lambdas:<br /><pre><code><br />our_and.call(<br />    lambda { a() },<br />    lambda { b() }<br />)</code></pre><br />Verify for yourself that this produces the behaviour we want, without the worry of our local variables messing things up for the calling code. Let&#8217;s go further: we can implement functions with a variable number of arguments using an enumeration of thunks. For example, we could write:<br /><pre><code><br />def try_these(*clauses)<br />    clauses.each { |clause| return clause.call rescue nil }<br />    nil<br />end</code></pre><br />And call our function like this:<br /><pre><code><br />try_these(<br />    lambda { http_util.fetch(url, :login_as =&gt; :anonymous) },<br />    lambda { http_util.fetch(url, :login_as =&gt; ['user', 'password']) },<br />    lambda { default_value() }<br />)</code></pre><br />We have just implemented the <a href="http://www.prototypejs.org/api/utility/try-these" title="Prototype JavaScript framework:  Utility Methods.Try.these">Try.these</a> function from the Prototype Javascript library.<br /><br />This technique gets us almost all of what we want for this common case of wanting to work around call-by-value semantics. As you can surmise from the fact that it has a name, it is not some newfangled shiny toy idea, it goes back to ALGOL 60, where it was known as <a href="http://foldoc.org/?call-by-name" title="call-by-name from FOLDOC">call-by-name</a>. (PHP has something called &#8220;Call By Name,&#8221; but it has a lot more in common with C++ references than it does with ALGOL parameter passing.)<br /><br />The application of call-by-name as a substitute for full-blown macros isn&#8217;t novel either. Joel Klein pointed out that <a href="http://jfkbits.blogspot.com/2008/05/call-by-need-lambda-poor-mans-macro.html" title="Call by Need Lambda a Poor Man's Macro?">Call by need is a poor man&#8217;s macro</a>. Another suggestion along similar lines is to <a href="http://arclanguage.org/item?id=7216" title="Arc Forum | Rethinking macros">rethink macros in Arc</a>.<br /><br /><strong>thunks: ugly name, ugly code</strong><br /><br />Our thunking approach solves a lot of our problems, but the implementation severely protrudes into the interface! We could argue that since our call-by-name functions have different behaviour than ordinary functions or methods, they ought to have different syntax.<br /><br />That&#8217;s a reasonable point of view, and that&#8217;s exactly how languages like Smalltalk work: everything that involves delaying evaluation in some way uses blocks, even the if statements, which are methods that take blocks as arguments. So in Smalltalk, everything is consistent.<br /><br />Ruby, OTOH, is not consistent. Operators like &#8220;&amp;&#8221; and &#8220;|&#8221; are actually methods with call-by-value semantics, while operators like &#8220;&amp;&amp;&#8221; and &#8220;||&#8221; are special forms with call-by-value semantics. Likewise if you only need to delay one expression you can use a block, but if you need to delay two or more, you need at least one lambda. So another reasonable point of view is that we should follow Ruby&#8217;s philosophy of making the common case easy to use and not become reductionists trying to build everything out of five axiomatic forms.<br /><br />So we have one approach&#8212;rewriting&#8212;that is crazy-hard to write but produces nicely readable code. And we have another approach&#8212;thunking&#8212;that is easy to write but produces unsightly boilerplate.<br /><br />Maybe what we want is a rewriter, but we want an easier way to write rewriters for this simple case?<br /><br /><strong>Called by name</strong><br /><br />Here&#8217;s how we could define and use a call-by-name function called &#8220;our_and&#8221;:<br /><pre><code><br />with (<br />    called_by_name(:our_and) { |x,y|<br />        if temp = x<br />            y<br />        else<br />            temp<br />        end<br />    }<br />) do<br />    # ...<br />    foo = our_and(bar(), blitz()) # method-like syntactic sugar<br />    # ...<br />end</code></pre><br />What we just did is manufacture a rewriter without any sexps. Instead of getting rid of sexps, we&#8217;re treating them like assembler and using a declarative language to write the assembler for us. Our rewriter dutifully rewrites our code to look something like:<br /><pre><code><br />our_and = lambda { |x,y|<br />    if temp = x.call<br />        y.call<br />    else<br />        temp<br />    end<br />end<br /># ...<br />foo = our_and.call(<br />    lambda { bar() },<br />    lambda { blitz() }<br />)<br /># ...</code></pre><br />We can define a rewriter for functions with splatted parameters too:<br /><pre><code><br />with(<br />    called_by_name(:try_these) { |*clauses|<br />        clauses.each { |clause| return clause rescue nil }<br />        nil<br />    }<br />) do<br />    # ...<br />    try_these(<br />        http_util.fetch(url, :login_as =&gt; :anonymous),<br />        http_util.fetch(url, :login_as =&gt; ['user', 'password']),<br />        default_value()<br />    )<br />    # ...<br />end</code></pre><br />Becomes something like:<br /><pre><code><br />try_these = lambda { |*clauses|<br />    clauses.each { |clause| return clause.call rescue nil }<br />    nil<br />}<br /># ...<br />try_these.call(<br />    lambda { http_util.fetch(url, :login_as =&gt; :anonymous) },<br />    lambda { http_util.fetch(url, :login_as =&gt; ['user', 'password']) },<br />    lambda { default_value() }<br />)<br /># ...</code></pre><br /><br /><blockquote>It goes, boys!</blockquote><div>&#8212;Lynn Hill after becoming the first person of either sex to climb The Nose of El Capitan, all free.</div><br />As of now, the <a href="http://rewrite.rubyforge.org">rewrite</a> gem supports called_by_name. You can write your own functions with call-by-name semantics using called_by_name just as you see here. As is standard with the rewrite gem, only the code in the do&#8230; end block is affected by your change.<br /><br /><strong>call-by-name, in summary</strong><br /><br />To summarize, with the rewrite gem you can write functions that have call-by-name semantics without wrestling sexps into submission or encumbering your code with a lot of superfluous lambdas and calls:<br /><pre><code><br />with(<br />    called_by_name(:try_these) { |*clauses|<br />        clauses.each { |clause| return clause rescue nil }<br />        nil<br />    },<br />    called_by_name(:our_and) { |x,y|<br />        if temp = x<br />            y<br />        else<br />            temp<br />        end<br />    }<br />) do<br />    # ...<br />    try_these(<br />        http_util.fetch(url, :login_as =&gt; :anonymous),<br />        http_util.fetch(url, :login_as =&gt; ['user', 'password']),<br />        default_value()<br />    )<br />    # ...<br />    foo = our_and(bar(), blitz())<br />    # ...<br />end</code></pre><br />This is a win when you don&rsquo;t want your code encumbered with more lambdas than business logic. It may be a matter of taste, but part of what I like about Ruby having a special case for blocks is that they act as a huge hint that an expression is temporary: a block after #map suggests we are only using that expression in one place. Whereas when I see &ldquo;Proc.new&rdquo; or &ldquo;lambda,&rdquo; I expect that the expression will be passed around and used elsewhere.<br /><br />Functions with call-by-name semantics communicate the same thing as blocks: the expressions are to be consumed by the function. When I see a lambda being passed to a function, I automatically expect it to be saved and possibly used elsewhere. For that reason, I prefer call-by-name semantics when an expression is not meant to be persisted beyond the function invocation.<br /><br />Now, called_by_name is not a replacement for macros. There are lots of things macros can do that called_by_name cannot do (not to mention that there are lots of things code rewriting can do that macros cannot do). But just as Ruby&#8217;s blocks are a deliberate attempt to make a common case for anonymous functions easy to write, called_by_name makes a common case for macros easy to write and safe from variable capture problems.<br /><br />Of course, called_by_name does so with lots of anonymous functions, and that is a much more expensive implementation than using a hygienic macro to rewrite code inline. But it feels like a move in an interesting direction: if it is a win to sometimes meta-program Ruby&#8217;s syntax with DSLs, it ought to also be a win to sometimes meta-program Ruby&#8217;s semantics with call-by-name functions.<br /><br /><strong>afterword</strong><br /><br />So&hellip; Is this merely a way to replicate things that are already built into Ruby but do them fifty times slower?<br /><br />I don&rsquo;t know how to answer that question. When I heard Matz talk about Ruby at <a href="http://raganwald.github.com/2007/01/where-were-you-on-saturday-november-9.html" title="Where were you on Saturday, November 9, 2002?">LL1</a>, I didn&rsquo;t catch the part of his speech where he described how to use metaprogramming to build a really neat web development framework. When you first see a new tool, you naturally start by applying it to problems you already know how to solve with your existing tools in the same way you have always solved such problems.<br /><br />Only later, after this tool becomes perfectly natural to you, do you start to think of entirely new ways to use the tool. I&rsquo;m not there yet, but my experience tells me that it&rsquo;s always a win to have more freedom, to have fewer things you can&rsquo;s do with a language.<br /><br />If just one person&mdash;maybe it&rsquo;s me, maybe it&rsquo;s somebody else&mdash;leans forward one day and sees a new way of solving a problem with call-by-name semantics, I&rsquo;ll consider working on this feature time well spent.<br /><br />It probably won&rsquo;t be something trivial like replicating short-circuit boolean operators. But it will be interesting, and I&rsquo;m looking forward to finding out what it is.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/macros-hygiene-and-call-by-name-in-ruby.html" title="permanent link">9:25 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="6433618312064877824">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/little-something-about-dumbing-code.html" title="permanent link">A little something about dumbing code down to the lowest common denominator</a></span>
					<div style="clear:both;"></div><blockquote>When the productive have to ask permission from the unproductive in order to produce, then you may know your culture is doomed.</blockquote><div>&mdash;Ayn Rand, via <a href="http://matt.blogs.it/entries/00002867.html">Matt Mower</a></div><br /><hr/><br /><em>update:</em> <a href="http://chalain.livejournal.com/74633.html">Chalain nails it</a>, especially when he writes &ldquo;&hellip; she's right about those two little words: ask permission. And not about dumbing down code.&rdquo; Although the examples he gives are nothing like the examples that crossed my mind.<br /><br />I have been happiest when I have worked with people much, much smarter than I am, people who forced me to raise my game. I recall that when I worked on JProbe Threadalyzer, the three key people on my team were Steve Rosenberg, Christian Jaekl, and John MacMillan. Steve was my manager, and he forced me to raise my game as a team lead. Christian was our domain expert, he had written his Masters Thesis on analyzing the behaviour of concurrent software, and he forced me to immerse myself deeply in concurrency just to understand what he was designing. And John was a C++ Wizard. I recall him being extremely patient with me a I got up to speed writing production C++ code.<br /><br />All three were patient with my shortcomings, but our culture was to help me be more productive, to help me understand their ideas. Not to hold them back so that I could stay in my comfort zone.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/little-something-about-dumbing-code.html" title="permanent link">7:42 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, June 17, 2008</div>
			

			<div class="Post"><a name="6708145457801438905">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/not-going-dark.html" title="permanent link">Not going dark</a></span>
					<div style="clear:both;"></div>Rubyforge is now hosting an &ldquo;initial pre-release of a preview of an alpha of an undocumented proof-of-concept&rdquo; of the <a href="http://rewrite.rubyforge.org/">rewrite</a> gem. More on this presently, but the important (and really the only thing of interest) about rewrite is that when you use rewrite to write:<br /><br /><em>Person.find_by_last_name("Braithwaite").andand.first_name</em><br /><br />...You are not opening the Object, Person or Nil classes to add an andand method, nor are you creating a weird temporary BlankSlate object. Rewrite does its thing by rewriting Ruby code: it performs <em>syntactic</em> metaprogramming, much as Lisp macros rewrite Lisp code.<br /><br /><strong>what problem does rewrite solve?</strong><br /><br />Recall that when you use the &ldquo;standard&rdquo; implementation of things like <a href="http://andand.rubyforge.org">andand</a> or <a href="http://ozmm.org/posts/try.html">try</a>, you are openly modifying core classes like Object.<br /><br />Therefore, you are reaching out and touching every line of code in your project. You probably aren&rsquo;t breaking everything, but even if the chance of introducing a bug by adopting something like &ldquo;try&rdquo; is infinitesimal for each source code file in your project, the chance grows greater and greater as your application grows.<br /><br />The problem is that you are introducing a change on Object, and everything depends on Object. This is very different than introducing a change in your code. In that case, only the other bits of code that directly depend on your code are at risk.<br /><br />Also, imagine if you introduce try and are careful not to break anything. Now somebody else wakes up one day and decides they need a method that works like Prototype&rsquo;s <a href="http://www.prototypejs.org/api/utility/try-these">Try.these</a>. They call it &ldquo;try.&rdquo; They just broke your code, dude! Not only are you making everything dependant upon your version of try, but your code is dependent upon everyone else not breaking try as well. It&rsquo;s a train-wreck waiting to happen.<br /><br />Rewrite restricts things like andand or try to your code and your code alone. Sure, if you introduce a bug in your code, you may break things that directly depend on your code. But if you introduce &ldquo;try&rdquo; using rewrite instead of modifying Object, you will not reach out across your project and break something entirely unrelated that happens to have defined its own version of try in a completely different way.<br /><br /><strong>how does it work?</strong><br /><br />Rewrite takes your code, converts it to an sexp with Parse Tree, then rewrites the sexp using one or more rewriters you specify. Finally, it converts the sexp back to Ruby with Ruby2Ruby and evals it. It does this when the code is first read, not every time it is invoked, so we mitigate the &ldquo;do not use andand in a tight loop&rdquo; problem.<br /><br />For example, rewrite converts this:<pre><code><br />emails.find_by_email(email).try(:destroy)</code></pre>Into:<pre><code><br />lambda { |receiver, method|<br />   receiver.send(method) if receiver.respond_to? method<br /> }.call(emails.find_by_email(email), :destroy)</code></pre>And this:<pre><code><br /> numbers.andand.inject(base_sum()) { |total, number| total + number }</code></pre>Into:<pre><code><br /> lambda { |__1234567890__|<br />   if __1234567890__.nil?<br />     nil<br />   else<br />     __1234567890__.inject(base_sum()) { |total, number| total + number }<br />   end<br /> }.call(numbers)</code></pre>Note that with the examples, the names &ldquo;andand&rdquo; and &ldquo;try&rdquo; completely go away. If someone else defines a try method elsewhere, it will not affect your code because your code never executes a method called try.<br /><br /><strong>the most important open problem to solve in this area</strong><br /><br />At the moment that is a huge PITA when creating new rewriters. I don&rsquo;t think that <a href="http://ola-bini.blogspot.com/2008/06/applications-and-libraries.html" title="Applications and Libraries">it's OK that a language makes it harder for a library creator than for an application developer</a>, so I am working on making it easy to write things like andand or try.<br /><br /><strong>puzzles for language weenies</strong><br /><br />Note that the andand example above uses gemsym for its parameter while the try example does not. <a title="Macros, Hygiene, and Call By Name in Ruby" href="http://raganwald.github.com/2008/06/macros-hygiene-and-call-by-name-in-ruby.html">Why</a>? What could break if it used a name like &ldquo;receiver?&rdquo; If you can figure out the salient difference between these two example rewrites, you can probably explain why rewriting try produces exactly the same semantics as the original open classes implementation, but rewriting andand produces a subtle change in semantics.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/not-going-dark.html" title="permanent link">11:30 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, June 14, 2008</div>
			

			<div class="Post"><a name="8842105618136377860">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/todays-public-key-is-modulus-46-e-5.html" title="permanent link">Today's public key is { :n => 46, :e => 5 }</a></span>
					<div style="clear:both;"></div><pre><code><br />def rsa_encrypt(message, public_key)<br />  n = public_key[:n]<br />  e = public_key[:e]<br />  n_arr = message.downcase.scan(/[a-z]| /).map { |character|<br />    "abcdefghijklmnopqrstuvwxyz ".index(character)<br />  }<br />  n_arr.map { |m|<br />    (m ** e).modulo n<br />  }<br />end<br /><br />def rsa_decrypt(ciphertext, private_key)<br />  n = private_key[:n]<br />  d = private_key[:d]<br />  n_arr = ciphertext.map { |c| <br />    (c ** d).modulo n<br />  }<br />  n_arr.map { |n| "abcdefghijklmnopqrstuvwxyz "[n,1] }.join('')<br />end</code></pre><br />And the secret message is: [11, 38, 13, 0, 24, 36, 16, 26, 36, 18, 24, 36, 1, 16, 21, 11, 17, 13, 0, 24]<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/todays-public-key-is-modulus-46-e-5.html" title="permanent link">7:15 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, June 09, 2008</div>
			

			<div class="Post"><a name="8015758512711595388">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/bitchiness-also-sucks.html" title="permanent link">Bitchiness also sucks</a></span>
					<div style="clear:both;"></div><blockquote>&#8220;This framework I never use in a programming language I also never use is designed in a way that I don&#8217;t like, so I&#8217;m going to raise a ruckus even though I&#8217;m never going to use it and there are other frameworks that meet my design standards better&#8221; just seems like a dumb thing to write a bitchy blog post about.</blockquote><div>&mdash;Chuck Hoffman, <a href="http://nothinghappens.net/?p=324">activerecord sucks, but it doesn't matter</a></div><br />Chuck, thank you for saying what needs to be said. Bitchy blog posts purport to describe shortcomings, but are they anything more than thinly veiled chest thumping from an author who feels he is the smartest person in the room?<br /><br />p.s. Question: Are bitchy blog posts about bitchy blog posts (like this one!) still bitchy blog posts?<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/bitchiness-also-sucks.html" title="permanent link">7:06 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, June 05, 2008</div>
			

			<div class="Post"><a name="4848135369923511619">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/06/skirting-edge-of-topicality-five-days.html" title="permanent link">Skirting the edge of topicality: Five days left to register for RubyFringe</a></span>
					<div style="clear:both;"></div>Pete Forde wrote to say that there are only 5 days left to <a href="http://rubyfringe.eventbrite.com/">register</a> for <a href="http://rubyfringe.com/">RubyFringe</a>, and currently fewer than 20 tickets left.<br /><br />Co&iuml;ncidentally, I have submitted my title and abstract:<br /><br /><strong>Ruby.rewrite(Ruby)</strong><br /><br /><em>An introduction to writing Ruby that reads, writes, and rewrites Ruby. In an extremely short period of time we will extend the Ruby language to include new conditional expressions, add new forms of evaluation such as call-by-name and call-by-need, and if time permits we&#8217;ll define new recursive combinators.<br /><br />In other words we&#8217;ll practice the truest form of constructive criticism: Instead of complaining about missing language features, we&#8217;ll implement them.</em><br /><br />Luckily for you, the <a href="http://rubyfringe.com/speakers">other speakers</a> are people with actual talent and a knack for entertaining people. What are you waiting for? <a href="http://rubyfringe.eventbrite.com/">Register!</a><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/06/skirting-edge-of-topicality-five-days.html" title="permanent link">12:59 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://reginald.braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://raganwald.github.com/uploaded_images/coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://raganwald.github.com/uploaded_images/coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>