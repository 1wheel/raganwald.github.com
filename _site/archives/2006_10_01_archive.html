<html> 
<head>
        
        <title>raganwald: 10/06</title>

	<link rel="stylesheet" type="text/css" href="/assets/css/weblog.old.css" />
	<link rel="stylesheet" type="text/css" href="/assets/css/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
</head>

<body>

	<div id="leftcontent">
			<img src="http://i.minus.com/ioSY4FTZKVCwz.png"
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Monday, October 30, 2006</div>
			

			<div class="Post"><a name="116223422144967513">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/ruby-io-and-ocaml-programming-pattern.html" title="permanent link">A Ruby, Io, and Ocaml Programming Pattern</a></span>
					<div style="clear:both;"></div><blockquote>Every 5 minutes you spend writing code in a new language is more useful than 5 hours reading blog posts about how great the language is.</blockquote><div style="text-align: right;"><a href="http://www.minds.may.ie/%7Edez/serendipity/index.php?/archives/102-Programming-Theorems.html">Programming Theorems</a><br /><br /><div style="text-align: left;">Seriously.<br /><br />If I hand you a plastic disc, are we going to spend all day debating whether Ultimate is more fun than Soccer? Do you want to investigate the physics of rotating aerofoils and how gyroscopic precession affects the flight path when the disc is released from your hand at 190 degrees?<br /><br />Or should we just go out and throw the <a href="http://www.ultimatehandbook.com/uh/training_hammer.html">Hammer</a> already?<br /><br />Reading is important. But reading (and blogging!) is no substitute for doing. And on that note, I shall return to writing unit tests...<br /></div></div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/ruby-io-and-ocaml-programming-pattern.html" title="permanent link">1:38 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, October 20, 2006</div>
			

			<div class="Post"><a name="116136483351520278">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/is-your-ide-tilting-at-dynamic.html" title="permanent link">Is your IDE tilting at the dynamic language windmill?</a></span>
					<div style="clear:both;"></div>Quite a few programmers love having powerful IDEs. These IDEs perform certain simple refactorings somewhat automatically, they can take a compiled language and make it seem a little more like an interpreted language, they can find certain types of errors as you type…<br /><br />In short, they do a lot of drudge work on the programmer’s behalf. What’s not to like about this? <strong>Nothing</strong>. These are useful tools. I have been working with Eclipse lately when editing Java, although I really don’t care one way or another. I like what it does but I’m fundamentally indifferent to its existence.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://raganwald.github.com/assets/images/old//ferris_wheel-772595.jpg"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://raganwald.github.com/assets/images/old//ferris_wheel-769229.jpg" alt="" border="0" /></a>Of course, there are <a href="http://www.zwitserloot.com/">more than a few people</a> who espouse the idea that the most powerful features of these IDEs are only possible with statically typed languages. And that this productivity is so important that it—ummm—<em>eclipses</em> all other considerations such as which language allows you to express a program with the least redundancy.<br /><br />How interesting.<br /><h4 id="do_all_powerful_ides_require_static_typing">Do all powerful IDEs require static typing?</h4>The idea that IDEs make you more productive is nothing particularly specific to statically typed languages. Have you ever heard of an editor called <a href="http://www.gnu.org/software/emacs/">Emacs</a>? Did you know that some of the hairiest, most dynamic, self-modifying code ever written was once part of Emacs? And that the author of that dynamic, self-modifying code, some fellow named <a href="http://en.wikipedia.org/wiki/James_Gosling">Jim</a>, went on to develop a popular statically typed language?<br /><br />Anyways, lots of people use Emacs for Lisp (don’t you love the symmetry? you need to use Lisp for Emacs). They <a href="http://www.windley.com/archives/2006/10/when_you_pick_your_tools_pick_those_that_can_build_tools.shtml">invest a lot of time making themselves more productive</a>.<br /><br />So here’s what I see from my chair: There’s this group of star-bellied sneetches who say “the important thing about being a productive programmer is having a tool that makes you productive.” And there’s this group of sneetches who say <em>the same dammned thing</em>. The only difference between them is that the star-bellied sneetches say that the productivity of the tool is all about the special things the tool can do when the programs are written in statically typed languages. The plain sneetches love the tool that they can customize so heavily it feels like a personal extension of their mind.<br /><br />Hmmm.<br /><h4 id="who_deserves_a_title_bout">Who deserves a title bout?</h4>The thing that strikes me as obvious is that <em>I’m the wrong person to argue with a star-bellied sneetch</em>. I use a fairly nice text editor, <a href="http://macromates.com/">TextMate</a>, but it doesn’t do 1% of what Emacs does and while it does a lot more than I ever figured out how to make Eclipse do, it also doesn’t even try to do a lot of the star-bellied stuff like move methods around.<br /><br />The right thing to do is to get two people who both agree that productivity from IDEs is important to debate how to do it. That way there’s one, clear point of debate: <em>does an IDE + static typing beat a programmable editor by an order of magnitude</em>?<br /><br />Debating with me is going to be entertaining but inconclusive, because we’ll be mixing several arguments up: are IDEs important, and if they are, what’s the best way to make an IDE powerful, and if that is the best way, is it so good that it outweighs other considerations for choosing a programming language? If you stop by my house, that’s a conversation that is going to put a serious dent in my collection of single malts.<br /><h4 id="the_third_perspective">The third perspective</h4>I’m not a sneetch in this matter. I spend far, far more time thinking about code than I do editing code. Therefore, I invest more energy looking for ways to improve the way I think about code than I do looking for ways to improve the way I edit code.<br /><br />Kinda something not entirely unlike what happens when you sit down to improve the performance of a program. First you profile. Then you choose what to optimize. I’ve profiled myself, and what I need is more help deciding what to do than I do doing it.<br /><br />I am also holding on to a somewhat axiomatic (and irrepressibly optimistic) belief that some languages have orders of magnitude higher <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html">signal-to-noise</a> ratio than others. This is important for understanding why I am reluctant to pick a language because my IDE likes it.<br /><br />For starters, one needs to understand the goal of all this refactoring: it’s to have better code. Better languages also achieve this goal. let’s look at a simple example and work backwards from that to the importance of languages.<br /><h4 id="delegation_and_dynamic_programming">Delegation and dynamic programming</h4>Delegation in Ruby is easy because you have <code>send</code> and you have <code>method_missing</code>, so even if you don’t feel like using the built-in <code>SimpleDelegator</code> or <code>Forwardable</code>, you can forward messages whenever and however you like.<br /><br />Whereas in Java, you need to define an <code>Interface</code>, then make sure that <code>person_doing_the_actual_work</code> implements the interface, then you can use a <code>DynamicProxy</code> to implement delegation. Note that you can’t delegate to a built-in class unless it implements an interface, so you can delegate to <code>ArrayList</code> (because it implements the <code>List</code> interface), but you can’t delegate to <code>String</code>.<br /><br />(Well, you can <span style="font-style: italic;">forward</span> calls to classes that don't implement interfaces, but you can't make the delegator look like a delegatee. So what you really have is a kind of private inheritence. You cannot, for example, decorate a <code>StringBuffer</code> so that you can set a flag for whether it has been encoded for display in HTML or not, and decorate the append method so that you can throw an exception when an unencoded <code>String</code> is appended to an encoded <code>StringBuffer</code>).<br /><br />Why can’t you just generate the delegation using the IDE’s handy-dandy feature?<br /><br />The problem is that code generation produces a static change. It’s a one-time thing, like one of those push-button programming wizards from <a href="http://finance.yahoo.com/q/bc?t=1y&s=MSFT&amp;amp;amp;amp;amp;amp;amp;l=on&z=m&amp;q=l&c=AAPL">MSFT</a>. If you change interfaces, perhaps you are refactoring something else, your delegation breaks. So you have to write something relatively dynamic.<br /><br />In Ruby, it looks things up at run time. I’ll settle for something that can reflect at compile time. But either way, you can’t just do it once. You have to have dynamic code handle the forwarding.<br /><br />(There are exactly similar problems in all sorts of code. If you write some serialization code by hand or with an IDE, you have a problem when you expand an object. The old code doesn’t know how to serialize the new members. You have to make sure your serialization code reflects on the object so it can keep up with all changes.)<br /><br />I find that IDEs are nice, but even the most sophisticated IDEs are… static. They make one-time changes to code. I’m far more interested in languages that let me write code that writes code, in languages that let me write code that doesn't <span style="font-style: italic;">need</span> a lot of rewriting and fixing across the board when I make a change. (This is just my perspective. I’m still learning a lot about the intersection between theory and practice in programming languages.)<br /><br />But this is why you’re tilting at windmills when you ask me why I don’t eschew Ruby for Java just so I can “rename class.”<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/is-your-ide-tilting-at-dynamic.html" title="permanent link">1:18 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 19, 2006</div>
			

			<div class="Post"><a name="116100787388296516">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/would-you-like-side-of-referential.html" title="permanent link">Would you like a side of referential transparency with your order of static typing?</a></span>
					<div style="clear:both;"></div><acronym title="recapitulate: to repeat in concise form">Recapitulating</acronym> some of the arguments <a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?">for and against static typing</a> has been very refreshing. And thanks to everyone who took the time to share their point of view.<br /><br />Leaving aside the argument that static typing helps your IDE help you, the really big idea behind modern static typing is that because certain properties of variables are invariant, it is tractable to perform a lot of analysis on a program looking for contradictions. For example, we say that <code>foo</code> is an <code>Integer</code>, and then a little later on we call <code>foo.append </code>. Since <code>Integers</code> don’t implement a method for appending, we know that there is an error in the program without having to run the program.<br /><blockquote>Thoſe who would give up E<span style="font-variant: small-caps; text-transform: lowercase;">ssential</span> L<span style="font-variant: small-caps; text-transform: lowercase;">iberty</span> to purchaſe a little T<span style="font-variant: small-caps; text-transform: lowercase;">emporary</span> S<span style="font-variant: small-caps; text-transform: lowercase;">afety</span>, deſerve neither L<span style="font-variant: small-caps; text-transform: lowercase;">iberty</span> nor S<span style="font-variant: small-caps; text-transform: lowercase;">afety</span>.</blockquote><div style="text-align: right;"><a href="http://en.wikiquote.org/wiki/Benjamin_Franklin">Benjamin Franklin</a><br /></div><br />And do you know what? Although I accept that this is true, and even useful, I haven’t personally been swayed by it (I’m just going to give my experience here, not a prescription or advice to others). The problem, as I see it, is that the statically typed languages I’ve used for production work have had such primitive typing systems that I couldn’t use them to <a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html">solve really important problems</a>.<br /><br />Errors where I mistakingly try to call <code>append</code> on a <code>String</code> when I should be calling it on a <code>StringBuffer</code> just don’t make up for all the extra verbiage and the onerous restrictions on meta-programming imposed by popular languages.<br /><br /><div style="text-align: center;"><a href="http://flickr.com/photos/87547772@N00/264113001/" title="Cognitive Hazard"><img src="http://static.flickr.com/109/264113001_f1ed3fb11e.jpg?v=0" alt="Cognitive Hazard" border="0" height="240" width="233" /></a><br /></div><br />But I had a sudden “Oho, you’re busted!” moment a few days ago. Didn’t I write a nice post explaining why <a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html">mutable local variables are bad</a>? The gist of my argument was… wait for it… <em>mutable things make it hard to move stuff around, because you don’t have those nice invariants to reason about</em>. Hmmm. Could there be a strong parallel between getting rid of mutable variables and static typing?<br /><h4 id="static_typing_and_functional_programming">Static typing and stateless programming</h4>Yes, of course there is. It’s about minimizing the state changes. Static typing is about having just one state for each variable’s type. Programming with immutable variables is about having just one value for each variable. I advocate the latter. Why haven’t I embraced the former?<br /><br />Well… I could argue that dynamic meta-programming is worth more to me than the benefits of static typing. They really are worth a lot more than the benefits of the simplistic typing systems you find in popular languages. But are they worth more than the powerful systems in languages like Haskell or ML? Maybe not.<br /><br />And how dynamic is my meta-programming? I love the fact that I can use constructs like <code>acts_as_versioned</code> in Ruby, but there are languages that allow static meta-programming (like Scheme’s macros) that would go as far for much of what I do. Much farther than the restrictive straight-jacket of popular languages, anyways.<br /><h4 id="paradigm_smells">Paradigm smells</h4>This brings me to <a href="http://obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf">writing DSLs in Ruby</a>. One of the reasons DSLs are incredibly useful is that they are <em>declarative</em>: The what is cleanly separated from the how. Lots of successful DSLs are “business rules”, they aren’t statements to be executed, they’re constraints on the behaviour of a system. Just like static types are constraints.<br /><br />Does this sounds familiar? I’m confessing that one of the reasons I like Ruby is that it’s easy to write things that are static, that don’t change state. But Ruby is all about having flexible things that change at runtime. This is what you might call a <em>paradigm smell</em>, the paradigm of the language—types change on the fly—is at odds with the kind of programs I try to write in Ruby.<br /><br /><span style="font-style: italic;">Isn’t that interesting</span>?<br /><br /><span style="font-size:85%;">p.s. Okay, all of you static typing fans who are rolling up your sleeves to write an “I told you so” comment: before you hit “publish,” ...<br /><br />Are you curious about what would happen if you turned the static typing knob up to eleven? If you took the Red Pill? Could you use a really powerfully typed language to <a href="http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem">detect XSS vulnerabilities in the compiler</a>? Could you switch from an impertitive, loop programming style to a functional style and get rid of mutable variables? Could you express your domain logic declaratively in a DSL instead of in procedures and methods? If a little compile-time analysis is good, how much better could a <span style="font-weight: bold;">lot</span> of compile-time analysis be?<br /></span><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/would-you-like-side-of-referential.html" title="permanent link">5:21 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="116129090476912164">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/good-taste-for-software-design.html" title="permanent link">Good taste for software design</a></span>
					<div style="clear:both;"></div>This just landed in my in box:<br /><blockquote>I am looking for a talented .NET developer/architect to drive a <br />challenging and ambitious project. <br /><br />Strong hands-on .NET, good taste for software design, agile mindset, <br />and exposure to Test Driven Development are the must.<br /><br />The project is long term, therefore permanent is preferred, yet <br />contract is negotiable for a right candidate. <br /><br />Please spread the word; if someone is interested, contact Dmitri at <br />Opalis.com for details.</blockquote><br />"Good <i>taste</i> for software design." I love how our industry is shaping up: proud development leaders like Dmitri are not afraid to seek the "quality without a name."<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/good-taste-for-software-design.html" title="permanent link">4:44 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, October 16, 2006</div>
			

			<div class="Post"><a name="116105348803572321">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/irony.html" title="permanent link">Irony</a></span>
					<div style="clear:both;"></div><blockquote>Programs must be written for people to read, and only incidentally for machines to execute.</blockquote><div style="text-align: right;">Abelson &amp; Sussman, <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&linkCode=ur2&camp=1789&creative=9325">Structure and Interpretation of Computer Programs</a><br /></div><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&linkCode=ur2&camp=1789&creative=9325"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://raganwald.github.com/assets/images/old//sicp-786043.jpg" alt="" border="0" /></a>From time to time people quote this as a justification for staying <em>away</em> from high-level languages like Lisp, Scheme, <a href="http://www.planetpython.org/">Python</a>, and <a href="http://poignantguide.net/ruby/" title="Why's (Poignant) Guide to Ruby">Ruby</a>, and not only sticking to popular languages but also staying within the lowest-common denominator when choosing idioms within those popular languages.<br /><br />Isn’t it interesting that the quote is from a book explaining concepts such as recursion and metalinguistic abstraction? In Scheme?<br /><br />The <a href="http://mitpress.mit.edu/sicp/">full text</a> is on line. If you have yet to read it, I recommend you give it a try.<br /><br /><i>update: if you enjoyed reading <acronym title="Structure and Interpretation of Computer Programs">SICP</acronym>, you may find my list of <a href="http://raganwald.github.com/2006/11/first-seven-books-i-would-buy-if-my_17.html">the first seven books I would buy if my shelves were bare</a> interesting.</i><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/irony.html" title="permanent link">10:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, October 15, 2006</div>
			

			<div class="Post"><a name="116096381333418437">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/in-praise-of-informed-choices.html" title="permanent link">In praise of informed choices</a></span>
					<div style="clear:both;"></div><h4 id="first_a_word_from_our_sponsor">First, a word from our sponsor</h4>You know, this whole “<a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a>” thing has too many negative connotations. It has become, like “Star-Bellied Sneetch,” a way of labeling people.<br /><br />“<em>You use <a href="http://en.wikipedia.org/wiki/J_programming_language">J</a>, therefore you’re a Blub Programmer</em>.”<br /><br />“<em>There’s no such thing as Blub, therefore I can’t be a Blub Programmer</em>.”<br /><br />For the remainder of this post, we are going to discuss things in terms of <em>informed and uninformed choices</em>. This is a functional description and it focuses on a one-time behaviour. If you like the old terms, you know where to find grep.<br /><br />One argument <em>against</em> the idea that there is one overarching continuum of language or tool “power” is that tools <em>specialize</em>. The most appropriate tool for building CRUD database-backed web applications may not be the most appropriate tool for building interactive games.<br /><h4 id="success_through_specialization">Success through specialization</h4>Within a particular specialization, there is still a continuum of power. There may be a programmer who insists that Visual Basic backed ASP pages provide all the power she will ever need for CRUD web applications, and there is no need to Ruby, ASP.NET, or any of the other advances on the technology she likes. This sounds remarkably like she is making an uninformed choice, doesn’t it?<br /><br />The specialization argument is invoked quite often. When I hear it from <a href="http://undefined.com/ia/2006/10/14/blub-blub-blub/" title="Blub, blub, blub">someone who has taken the time to become comfortable with several different approaches to solving a problem</a>, I give it some credence.<br /><br />But how often do we hear someone say, “Oh, language X. Yeah, I hear that’s kind of specialized for Artificial Intelligence. And Y is probably terrific if you need to do some startup thing where you need to make a lot of changes as you go. I haven’t tried it, because I don’t do Y-like stuff. But for <em>my</em> purposes Z is the way to go. Each language has its specialization, and Z is best for what I’m doing.”<br /><br />Are those the words of someone who really understands X or Y and why anyone would need those weird features X and Y programmers boast of? Or what parts of languages X and Y would or wouldn’t apply to the problem at hand? Or is this just a way of sounding <a href="http://raganwald.github.com/2006/03/fair-and-balanced-look-at-static-vs.html">Fair and Balanced</a>?<br /><br />Just because tools <em>may</em> provide specialized benefits depending on the problem at hand, that doesn’t mean that the particular tool a programmer chooses is the best possible or best available. In other words, <em>uninformed choice can be local to a problem domain</em>.<br /><h4 id="in_a_fight_between_a_bear_and_an_alligator8230">In a fight between a bear and an alligator</h4>My second conjecture about specialized tool hypothesis is that most tools evolve over time away from specialization and towards generalization. Java, the language often mentioned in the same breath as uninformed choice, began its life as a specialized language for embedded programming. Toasters, set-top boxes, that kind of thing. Other languages have seen the same trend towards trying to solve all problems for all people.<br /><br />The older a language or tool is, the more likely it is a general-purpose tool. The converse tends to be true: the younger a language or tool is, the more likely it is to be specialized. The latter seem to be true even if the designers and sponsors intend it to be a general-purpose tool, because younger tools have smaller ecosystems.<br /><br />Take a language with a relatively small ecosystem: it may have been designed as a general-purpose tool, but if the the most popular stable, widely used libraries and frameworks support <a href="http://www.rubyonrails.com/" title="Ruby on Rails">building Ajax-ified CRUD applications</a>, it is a specialized tool as compared to a language that seems to support building everything up to an including <a href="http://java.sys-con.com/read/193146.htm">interplanetary navigation</a>.<br /><br />So It seems that some languages boast flexibility, others specialization. It seems unrealistic to expect that the specialized language can beat the generalized language. Unless you are comparing the languages on the basis of the specialized language’s “home turf.” In a fight between a bear and an alligator, <em>terrain determines the outcome</em>.<br /><br />Now someone argues, “Hey, you wouldn’t try to fight a fire with a Maserati or drive the Autobahn on a Segway.” The specialization argument. Ok. But is that really the comparison? All too often, I hear that argument, but what I see in the toolbox is a mini-van, the king of popularity, the vehicle that does several different things equally poorly.<br /><br />Honestly. Are programmers clinging to Haskell, Erlang, and Postscript because their needs are specialized and within their niche these languages are the best possible choice? Or are they vocally defending a language that does an awful lot of things in awkward ways against languages that solve their exact problem in an elegant way?<br /><h4 id="remember_java_is_not_an_uninformed_choice_and_neither_is_c">Java is not an uninformed choice, and neither is Visual Basic<br /></h4>Languages and tools are not uninformed. It’s the breadth of experience applied to making a choice that counts. Making a popular, comfortable, established, unfashionable, safe choice does not make you uninformed. An uninformed choice is made in ignorance of the benefits of making other choices.<br /><br />If you think that your next CRUD application would need anywhere from one half the code to one tenth the code if you used a specialized meta-programming tool like Ruby on Rails, but you’re sticking with ASP because that’s what the client asked for, you’re making an informed choice.<br /><br />If you write a new application and make heavy use of functional programming constructs for the first time, good for you. If you choose to leave an existing application more or less as-is and you don’t refactor every method to remove <a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html" title="Why are local variables bad?">mutable local variables</a>, good for you again. You’re making an informed choice.<br /><br />Some uninformed choices are conservative choices, but so are are some informed choices. You can’t tell the difference merely by examining the language or tool chosen.<br /><h4 id="conservative_or_just_uninformed">Conservative? Or just Uninformed?</h4>I have a little litmus test for identifying an informed choice that just happens to be conservative. I don’t claim it’s infallible, and I have done absolutely no research to back it up. But in the interest of keeping the amusement value up, here is my proposal:<br /><br /><span style="font-style: italic;">When you see a program written in a conservative, “safe” language, and you want to know whether the programmer is a made a fully informed choice, examine the source code looking for evidence that the programmer has been exposed to other programming paradigms.</span><br /><br />Uninformed programmers invariably stick to whatever has been promoted as the sole, orthodox way to write programs for their language. If they need to work around a language limitation, they will do so using well known conventions such as widely disseminated “design patterns.” They can invariable name a dozen or more such patterns, but can never name a single language that handles these problems in a different way.<br /><br />The informed but conservative programmer has learnt something from other tools, other languages. The principles find their way into her work. A conservative programmer might have extremely pragmatic reasons for doing some work in Javascript. But she uses the <a href="http://prototype.conio.net/">Prototype Library</a> to implement higher-order functional programming. Or she might need to build something really big and hairy in C++. But she’ll implement Lisp’s map and reduce as a library so that <a href="http://en.wikipedia.org/wiki/MapReduce" title="MapReduce">C++ programs can vectorize on a grid with thousands of computers</a>.<br /><br />The uninformed programmer may have heard of these things, but not only will they eschew other tools and languages, the eschew the ideas behind them as well.<br /><br />Although <a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule">the act of implementing a more powerful language on top of a more conservative language</a> is sometimes frustrating and often derided by purists, it is a sign that the programmer has thought deeply about the best way to solve a particular problem, and is not afraid to port what they like from one environment to another.<br /><br />What do you think? Do informed but conservative programmers incorporate features and paradigms from other tools and languages into their work?<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/java.html">java</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/in-praise-of-informed-choices.html" title="permanent link">9:52 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 12, 2006</div>
			

			<div class="Post"><a name="116068720976582522">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="permanent link">Are we Blub programmers?</a></span>
					<div style="clear:both;"></div>From time to time I open my email and find someone asking a question:<br /><br /><blockquote>What the hell is Blub? I take from context that it may be a pejorative generalist term for programming languages that encourage writing pablum instead of programs. Or maybe it really is a new language out there that has a huge following I'm unaware of. </blockquote><div style="text-align: right;"><a href="http://chalain.livejournal.com/">Chalain</a>, the "<span style="font-style: italic;">if you're not having fun, you're doing</span><span style="font-style: italic;"> it wrong</span>" guy<br /></div><br /><a style="margin: 0pt 0pt 10px 10px; float: right;" href="http://www.flickr.com/photos/raganwald/15824364/" title="Preparing to climb Lollipop Kids"><img src="http://static.flickr.com/10/15824364_16defaae5e_m.jpg" alt="Preparing to climb Lollipop Kids" border="0" height="240" width="180" /></a>Actually, Blub is a hypothetical programming language Paul Graham invented when describing something very interesting: the <span style="font-style: italic;">Blub Paradox</span>:<br /><br /><blockquote>Blub falls right in the middle of the abstractness continuum... As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages... Blub is good enough for him, because he thinks in Blub.</blockquote><div style="text-align: right;">Paul Graham, <a href="http://www.paulgraham.com/avg.html">Beating the Averages</a><br /></div><br />The interesting things about this paradox is that almost <span style="font-style: italic;">any</span> language could be Blub. The pre-requisites for a language being Blub are (a) there is at least one language less powerful than Blub, (b) there is at least one language <span style="font-style: italic;">more</span> powerful than Blub, and (c) that there be at least one programmer using Blub who accepts (a) but refutes (b) because he or she cannot see how the more powerful language is more powerful. She does not think in the <a href="http://www.braithwaite-lee.com/weblog/2006/01/finding-signal-to-noise-ratio-in-never.html">idioms</a> that the more powerful language affords.<br /><br /><div style="margin: 0pt 10px 10px 0pt; width: 240px; float: left; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325"><img style="cursor: pointer;" src="http://raganwald.github.com/assets/images/old//little_mler-705423.jpg" alt="" border="0" height="180" width="180" /></a><em><br /><br />The Little MLer introduces ML (and Ocaml) through a series of entertaining and straightforward exercises leading up to the construction of the Y Combinator.<br /><br />ML and OCaml introduce powerful strong typing and type inference. Both are great languages to learn: you will stretch your understanding of defining types and writing correct programs.<br /></em></div>When <span style="font-style: italic;">I</span> use the term, I am thinking of the language and also the programmers around it. Could Java be Blub? Sometimes, possibly often, but only when I'm thinking about Java programmers who dismiss Ruby's features as unnecessary. <a href="http://t-a-w.blogspot.com/2006/08/programming-in-blub.html">Could Ruby be Blub</a>? Sometimes, but only when I'm thinking about Ruby programmers who dismiss macros as unimportant.<br /><br /><a href="http://raganwald.github.com/2006/12/lisp-is-not-last-word.html">Could Lisp be Blub?</a> I suspect that Erlang and Haskell programmers might say that it is, provided we can find a Lisp programmer who feels that all progress in programming languages stopped when Common Lisp was standardized.<br /><br />At the same time, Java is not Blub when I am thinking of programmers <a href="http://raganwald.github.com/2006/10/in-praise-of-informed-choices.html">who are perfectly aware of its shortcomings and deliberately Greenspun around them for pragmatic reasons</a>. The same goes for any other language: it is sometimes Blub, and sometimes not Blub.<br /><br />So... I use the term "Blub" to refer to a programming language in the context of intransigent programmers who feel that their chosen tool is the best tool possible.<br /><br /><blockquote>Programming consists of overcoming two things: accidental difficulties, things which are difficult because you happen to be using inadequate programming tools, and things which are <em>actually difficult</em>, which no programming tool or language is going to solve. </blockquote><div style="text-align: right;"><a href="http://www.joelonsoftware.com/items/2006/10/12.html">Joel Spolsky reviewing Beyond Java<br /></a></div><br />This provokes a very obvious question: <span style="font-style: italic;">How do we know which things are accidentally difficult and which are actually difficult</span>? Is it only because we haven't discovered the right tool yet?<br /><br />It's easy to find a Java programmer who believes that all of the Design Patterns in the GoF's book are necessary. She believes that the difficulties of applying those patterns are actual difficulties of programming systems. It is only when she learns a different language that she realizes how the patterns were strongly driven by limitations in Java's object model.<br /><br />At that point she has an epiphany and understands that what she thought were actual difficulties were merely accidental difficulties. And the line between "accidental" and "actual" moves for her.<br /><br />No matter how much each us us thinks we know right now, are we nevertheless like this Java programmer, unable to see the difference between accidental and actual differences because we simply haven't discovered a more powerful tool?<br /><br />Are we Blub programmers?<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">update</span>: <a href="http://raganwald.github.com/2006/10/in-praise-of-informed-choices.html">In praise of informed choices</a> and </span><a href="http://raganwald.github.com/2006/12/lisp-is-not-last-word.html">Lisp is not the last word</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="permanent link">4:40 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, October 10, 2006</div>
			

			<div class="Post"><a name="116053947679775540">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/what-colour-is-your-parachute.html" title="permanent link">What colour is your parachute?</a></span>
					<div style="clear:both;"></div>You know the old saying:<br /><blockquote>A mind is like a parachute: it works better when it's open.</blockquote>So: what's with the black-and-white sounding statements I make about subjects like <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html">people</a> ("no methodology can save a project staffed with under-performers") or local variables ("bad") or even <a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html">static typing</a> ("useful, but it doesn't prevent errors that endanger my projects")?<br /><br /><span style="font-weight: bold;">My World</span><br /><br />I write about my experience, what has worked for me and what I think will continue to work for me. I'm not presenting a unified theory of everything. I know for a fact that <a href="http://www.joelonsoftware.com/articles/FiveWorlds.html">my world is different from your world</a>.<br /><br />Case in point: everything I write is from the perspective of small teams of skilled practitioners. Yes, I know that there are people who try to build big pieces of software with one hundred and eighty programmers. I'm not one of them. Furthermore, I have absolutely no interest in trying to find techniques or tools that "scale" to hundreds of programmers.<br /><br />I assume you have a modicum of intelligence and an open mind. I assume you will temper my blacks and whites, you will think them over, and you will figure out whether or how they apply to you.<br /><br />I did some programming in Scheme a long time ago. Then I learned Java. One day I was responsible for writing approximately four hundred classes in a Struts application. I wrote a code generator that wrote the classes for me. The code generator actually worked off of an Excel spreadsheet that some business analyst used for writing business rules.<br /><br />Java and Scheme are different worlds. But if you squint a little, and tilt your head just so, you might see some common ground.<br /><br /><span style="font-weight: bold;">Bippety Bop, Bang!</span><br /><br />When I write something and say "this is a guideline, use it in these situations but eschew it in these other situations, and temper it with this technique," everyone reads it, nods, and forgets about it.  No impact. No passion.<br /><br />When I say "<span style="font-style: italic;">this is bad, and that is good</span>," I get fan mail. I get hate mail. I get flowers at work. I get dog poop in a burning paper bag on my door step. (Well, not enough fan mail, no flowers, and hardly any hate mail. I'm not that good at writing.) But I get one more thing that I can't ignore: <span style="font-style: italic;">the posts incite debate</span>. People argue for and against. With themselves. With me. With each other.<br /><blockquote>Because "considered harmful" essays are, by their nature, so incendiary, they are counter-productive both in terms of encouraging open and intelligent debate, and in gathering support for the view they promote. In other words, "considered harmful" essays cause more harm than they do good...</blockquote><div style="text-align: right;"><a href="http://meyerweb.com/eric/comment/chech.html">"Considered Harmful" Essays Considered Harmful</a><br /></div><br />And to me, that's the point. If you are motivated enough to say, "<span style="font-style: italic;">Reg, your idea is no damned good because of A, B, and C,</span>" I think we're making some progress. We're talking. We're thinking for ourselves. We don't have some corporation with a billion dollar marketing budget telling us how to program and what's important in our lives.<br /><br />Do you really think there are <a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html">no mutable local variables in my code</a>? Come on. But... don't you think I sincerely try to use alternatives whenever I can do so without crippling the code? Yes, I use alternatives in most cases.<br /><br /><span style="font-weight: bold;">University Politics</span><br /><br />Sometimes the debates over these things get heated. This is a problem. I think it happens because people have difficulty <a href="http://raganwald.github.com/2006/08/difference-between-values-and.html">understanding and articulating their own values</a>. So I say something about <a href="http://raganwald.github.com/2006/08/dynamic-is-opposite-of-static-not-of.html">static and dynamic typing,</a> and I get people saying I'm <span style="font-style: italic;">stupid</span> or a <span style="font-style: italic;">poor poor programmer</span> (both possibly true).<br /><br />What's going on? I think that people have some personal investment in these things. We're a little tribal. We think that because we have <a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html">stars on our bellies</a>, we're better than those without stars. Then someone says "stars are no dammed good."<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://raganwald.github.com/assets/images/old//sneetches-714990.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://raganwald.github.com/assets/images/old//sneetches-706538.jpg" alt="" border="0" /></a><br />What happens? We get hot and bothered, because we think that person was really saying "you and your entire value system are no dammed good." But we can't say that, because we're pretending this is about productivity, and methodology, and scaling to two hundred programmers.<br /><br />That's a shame, because getting in touch with what's really important to us and shaping our lives around it is so incredibly important. I really wish more people could be like this fellow a few desks away from me who programs in .NET because that's where he thinks the money is.<br /><br /><span style="font-weight: bold;">Flames</span><br /><br />I had a manager once. He was my boss's boss. When someone presented him with an idea, he would ask for proof it would work. If you wanted to try anything new, he demanded that it be risk-free. You could spend months getting the kind of data he demanded to prove that you couldn't fail.<br /><br />Now, I don't think he was a malicious man. I doubt he even knew that he was the organization's number one idea shooter-downer.  Too bad.<br /><br />Anyways, a lot of people do this. If they see something new, they seize upon its flaws at once. They point out the missing bits. "<span style="font-style: italic;">It's just superstition, there's no proof that Ruby is more productive or that smaller programs are less buggy, or that static typing eliminates critical bugs, or, ...</span>"<br /><br />Well maybe so, but do you really think the people complaining about Cargo Cult Programming are rigorous scientists when they look at their own practices? No, they have a blind spot. The finicky rejection of ideas only applies to <span style="font-style: italic;">other</span> ideas, <span style="font-style: italic;">new</span> ideas.<br /><br />And especially ideas that question some of the ideas that they already have.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/passion.html">passion</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/what-colour-is-your-parachute.html" title="permanent link">11:27 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, October 08, 2006</div>
			

			<div class="Post"><a name="116033648506034653">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?</a></span>
					<div style="clear:both;"></div><a href="http://en.wikipedia.org/wiki/ML_programming_language">ML</a> is a programming language featuring <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: you don’t have to encumber your code with type declarations, the compiler can figure them out for you. So… are type inference languages like ML for Sneetches <a href="http://steve-yegge.blogspot.com/2006/10/egomania-itself.html">with or without stars</a>? Or another kind of Sneetch entirely?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/Sneetches-Other-Stories-Classic-Seuss/dp/0394800893/s?ref=raganwald001-20"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/assets/images/old//sneetches-711589.jpg" border="0" alt="" /></a><blockquote style="font-style: italic;">Now, the Star-Belly Sneetches had bellies with stars.<br />The Plain-Belly Sneetches had none upon thars.<br />Those stars weren’t so big. They were really so small<br />You might think such a thing wouldn’t matter at all.</blockquote><span style="font-style: italic;font-size:85%;" >Update</span><span style="font-size:85%;">: More than a few people have <a href="http://empathybox.com/archives/7">written</a> that Steve Yegge's association of static typing with neatness and dynamic typing with slovenliness runs opposite to their impressions of the kinds of people who strongly prefer one or the other. I used Steve's terms in the original post, partly because I thought people would get the same joke I thought Steve was making. It looks like they don't, nobody wrote to say "LOL." I have changed the terms to something that represents what I think of the cultural divide between programmers who like Java and programmers who like Ruby.</span><br /><br />Let’s review. Sneetches with stars like to use a colour-coded label maker to label the drawers, boxes, and files in their office. Once glance at everything and you know what it holds. Sneetches with stars add extra labels even when you don’t need them. For example, if a box is labeled ‘tax receipts’, each piece of paper inside has a post-it note saying tax receipt’, even if it’s obviously a tax receipt and lives inside the tax receipts box.<h4 id="what_is_stariness">What is Stariness?</h4>Sneetches with stars like these languages we say are <em>statically typed</em>. What do we mean by the word static? We mean <em>it can be resolved at compile time</em>. Other words for this idea are <em>invariant</em> or <em>constant</em>. Sneetches with stars like languages where the type of each entity can be resolved at compile time.<br /><blockquote>Some people are always critical of vague statements. I tend rather to be critical of precise statements; they are the only ones which can correctly be labelled "wrong."</blockquote><div style="text-align: right;">Raymond Smullyan<br /></div><br />Let’s dive into this a little deeper. (My apologies to my readers who were actually paying attention to the stuff in first year computer science that isn’t a requirement for <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">getting a job at BigCo</a>.) What does it mean when we say “something can be resolved at compile time”? That expression is laden with implementation details like assuming we’re using a compiler. But it’s a convenient short-hand for saying <em>something about the program that is true every time you run the program</em>.<br /><br />Consider the <code>final</code> declaration in Java. If you write:<br /><pre><code>final String snafu = "situation normal...";<br /></code></pre>We know that the variable <code>snafu</code> always holds a reference to the constant string <code>"situation normal..."</code>. No matter what data you feed to your program and how you mangle it, <code>snafu</code> will always be <code>"situation normal..."</code>. Do you agree? (Joe Campbell, put your hand down. Yes, there is a back door way you can change the contents of a <code>String</code> in Java.)<br /><br />Java can take advantage of this to perform <em>constant propagation</em>. Everywhere you write <code>snafu</code>, Java can substitute <code>"situation normal..."</code> and throw away the variable lookup. To get away from arguing about back doors in the <code>String</code> class, let’s consider one of the primitive types, a <code>boolean</code>. If you write:<br /><pre><code>final boolean foo = true;<br />    // code without assignments to foo<br />    if (foo) {<br />        // do something<br />    }<br />    else {<br />        // do something else<br />    }<br /></code></pre>Wouldn’t you agree that the compiler can get rid of the variable lookup and the <code>if</code> statement? The path through the code is always through the <code>// do something</code> path every time you run the program.<br /><br />Now back to the word <em>stariness</em>. We really mean <em>the amount of stuff about the program that can be resolved at compile time</em>, or if you prefer, <em>the amount of stuff that is true every time you run the program</em>.<br /><br />In the example above, the compiler can figure out which branch the program will follow at compile time, because that variable is true every time you run the program.<br /><br />Stuff that is always true is useful. For most programs, we have an idea in our head about “correctness.” What we mean when we talk about a program being correct is that it produces desirable results every time you run the program.<br /><blockquote>A formalist is one who cannot understand a theory unless it is meaningless.</blockquote>Stariness is thus similar to correctness. And that’s why a lot of people, the Sneetches with stars, are obsessed with it. Being able to “prove” something about their program (“the method call <code>foo.bar(5)</code> never throws a <code>MethodNotImplemented</code> exception”) feels a lot like being able to prove that their program is correct.<br /><br />It feels a lot like it, but it isn’t the same thing. The reason it isn’t the same thing is that while its true that a program throwing <code>MethodNotImplemented</code> exceptions is probably not correct, it’s not true that a program that doesn’t throw such exceptions <em>is</em> correct. It just feels, somehow, more likely to be correct because we’ve thrown out one of the infinite ways it can be incorrect.<br /><br />Now that we’ve dispatched that logically, let’s be clear about something: just because stariness does not enforce correctness, it doesn’t mean that stariness isn’t <strong>useful</strong>. Stariness is useful. Period, no debate.<h4 id="back_to_inferences">Back to inferences</h4>Type inference is also for Sneetches with stars.  A language with type inference resolves the type of each entity at compile time by inspecting the program and figuring the types out through inspection. It’s a lot like the way a compiler can look at the Java code above and figure out that you always <code>// do something</code> and you never <code>// do something else</code>. The code looks sorta like you could go either way, but the compiler knows better.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald-store-20&linkCode=ur2&camp=1789&creative=9325"><img style="float:left; margin:0 10px 10px 0;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/assets/images/old//little_mler-705423.jpg" border="0" alt="" /></a>Languages with type inference look like variables can have any type, but the compiler knows better. Remember the labels that the verbose declaration Sneetches with stars love? Type inference languages still have labels, but the labels are hidden inside of the files and boxes where you can’t see them.<br /><br />Remember when manufacturers used to put their labels <em>inside</em> clothes instead of right across the front? Same thing. The rules for what goes where are strictly enforced, it’s just that if you can figure out what goes where with a bit of common sense, you don’t need a label or a post-it note.<br /><br />Compare these two snippets of Java:<br /><pre><code>final String[] words = { "foo", "bar", "blitz" };<br />final int word_length = words.length;<br />final String[] anagrams = new String[word_length];<br /></code></pre>…and…<br /><pre><code>final words = { "foo", "bar", "blitz" };<br />final word_length = words.length;<br />final anagrams = new String[word_length];<br /></code></pre>Hey, if a variable is final, we can figure out its type in Java through simple inspection. Making that work in the compiler is something an intern ought to be able to do over a Summer work term!<br /><br /><span style="font-size:85%;">(Frank Atanassow pointed out that techniques exist for inferring the types of nearly all Java variables through inspection of programs. But this simple case is enough for our purposes.)</span><br /><br />So if we take a valid Java program and simply erased type declarations whenever we could logically deduce the type of the variables (using our simple scheme), but left them in whenever we were not sure of the final type of the variables, we would have exactly the same program. Nothing about it has changed except it has fewer symbols. It’s just as starry, it is just as static, it is no more or less correct than it was before we erased some symbols.<br /><br />And you over there itching to say something about IDE refactorings and auto-completions: None of those go away either. You can rename things and move things and press command-tab to get an object’s methods whenever you like. So… would you agree that type inference of this sort doesn’t change a starry program into a starless program? This isn’t about stariness versus starlessness, it’s about the obsessive-compulsive desire to label everything.<br /><br />The bottom line: <em>type inference does not change a statically typed language into a dynamically typed language</em>. It’s still starry.<h4 id="so_why_can8217t_the_Sneetches without stars_use_type_inference">So why can’t the Sneetches without stars use type inference?</h4>Think of types as being like values and objects like variables. A statically typed language is one where there are no type re-assignments. Some languages enforce this. But if you write a program in a static way, you can still reason about it. This is why lots of people think that we can “neaten up” languages like Ruby by adding type inference to the compiler: they're thinking about programs that are neat to begin with, but we happen to have written them in a language for Sneetches without stars.<br /><br />And whenever someone talks about a refactoring IDE or an auto-completing IDE for a dynamic language, they’re talking about performing some type inference on Ruby programs that are written in a static way. So… what’s the holdup? We said we could add type inference to Java in a Summer. Where’s the intern to add it to Ruby?<br /><blockquote>Programmed. In me somewhere, he thought, there is a matrix fitted in place, a grid screen that cuts me off from certain thoughts, certain actions. And forces me into others. I am not free. I never was, but now I know that; that makes it different.</blockquote><div style="text-align: right;">Philip K. Dick, "The Electric Ant"<br /></div><br />The problem is that the set of all programs that are "starry" is a subset of the set of all programs that parse correctly. So either not all starless programs are neat, or not all portions of a starless program are neat, or both.<br /><br />Let’s compare back to our Java snippet. Remember:<br /><pre><code>final boolean foo = true;<br />// code without assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>The compiler could infer that we always follow the first branch because it knows that final variables are not reassigned. They’re <em>immutable</em>. What happens if we erase the <code>final</code> keyword as well:<br /><pre><code>boolean foo = true;<br />// code that might have assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>Now the job is much harder. We have to examine all the code in between the declaration and the use of foo. If there are any assignments involving things we can't know until runtime, we can't know the value of foo until runtime.<br /><br />For a very large class of programs, we cannot infer the contents of a variable with less runtime complexity than running the program for every possible input. This is why compilers have limitations on the optimizations they can perform, and humans still need to do some thinking about writing fast programs.<br /><br />This exact same thing happens with types. In statically typed languages, types are never re-assigned. Whether explicitly declared or inferred, they're immutable. But in languages like Ruby where methods can be added and removed dynamically, where messages can be forwarded dynamically, where we can even send messages dynamically, the types of objects are fully mutable.<br /><br />In starless languges, there is no <code>final</code> keyword on the types of objects. We can no longer infer the type of a variable in any but the simplest, degenerate cases.<br /><br />The type inference problem in dynamically typed languages is exactly the same as the inferring the possible contents of a variable problem. The inferring the contents of a variable problem is doable for a restricted set of programs. And the way we tell the compiler that a variable is a member of this restricted set is with the <code>final</code> keyword.<br /><br />Likewise, the way we tell a compiler that the type of a variable is also restricted is that we use a language where the type of every variable is final. It’s the same thing: we don’t reassign final variables and we don’t change types on the fly.<br /><br />Starlessness is not about writing programs without labels. Starlessness is when you write dynamic programs. Dynamic doesn’t mean ‘unlabeled’. As I showed above, if the <code>final</code> keyword is there, the label is mostly optional. But if you don’t have <code>final</code>, you’re writing dynamic programs.<br /><br />Truly starless programs have dynamic types: <em>types that change at run time</em>. they are not always one thing or another. For example, what if you write an Object-Relational Mapper (“ORM”) that reflects on the database structure at run time. That is, you can change columns in a database table and you get new getters and setter methods in your program. <em>Without recompiling</em>.<br /><br />In a fully static language (with or without type inference), you can’t do that. Think of Java’s JDBC: you have to fool around with methods that get values and pass a column name as a parameter. Or maybe you create a hash. And C# is getting this capability, but of you look closely you still have to define the “type” of a query through the LINQ syntax.<h4 id="are_neat_freaks_ever_starless">Are Sneetches with stars ever starless?</h4>A dynamically typed language lets us define an object holding a database row with methods for each column. But we can’t know at compile time whether our program will throw a <code>MethodNotImplemented</code> exception because we don’t know whether someone will monkey with the database structure. That sounds bad.<br /><br />But what happens if you write the same thing in a neat program? Aha! a <code>SQLException</code>! it seems that there are dynamic things that must be dynamic no matter what you do.<br /><br />This is a specific case of Greenspunning. There are some facilities of dynamic languages that you are going to need. If you don’t have them built into your static language, you will build them yourself or use a framework that has already built them for you. Other examples I have seen in Java programs include:<br /><br />Spring and Hibernate;<br />Any use of <code>Class.forName(...)</code>;<br />Any use of dynamic proxies;<br /><br />In essence, you’re being a Sneetch without a star but twisting your starry language to permit starlessness. And for those portions of the program that are no longer nice, starry bundles that can be examined at compile time for invariant behaviour, you are indeed in dynamic territory and have to live with the risks.<br /><br />In my experience, all non-trivial starry programs contain this kind of starlessness. To my admittedly inexperienced eyes, starlessness is the hallmark of expert programming in starry languages ("expert" does not necessarily mean "more desirable," especially in the minds of those who believe that programs should be written and maintained by mediocre developers).<h4 id="eating_cake">Eating cake</h4>So… can we say that since you can write starless programs in neat languages, you can have the useful benefits of stariness when you need it and the flexibility of starlessness when you need that too? Isn’t that better?<br /><br />Yes, you <em>can</em> say that. And you may be right, for you. The <a href="http://boo.codehaus.org/Language+Guide">Boo</a> people believe that: their language has a <code>duck</code> keyword for when you feel like a Sneetch without a star. Be aware that at this moment in history, languages designed for Sneetches without stars seem to have much better features for writing starless programs than languages for Sneetches with stars. So my observation is this:<br /><br /><em>If you dislike the verbosity of starry languages like Java but like the feeling of safety, try a type inference language. Don’t go to a starless language if you don’t intend to actually write dynamically typed programs.</em><br /><br />My experience is that if you are frustrated by the amount of work you have to do to express the algorithms in your head, you should look at a language that removes your frustration. If you're using Java and don't like the verbosity, find a language that celebrates brevity while preserving static typing. But if you're using Java and find yourself pushing more and more logic out of java because its type system is too static or too inflexible, you should consider a language with a different approach to typing.<br /><blockquote>Computer languages differ not so much in what they make possible, but in what they make easy. </blockquote><div style="text-align: right;">Larry Wall<br /></div><h4 id="why_would_the_Sneetches without stars_use_starless_languages">Why would the Sneetches without stars use starless languages?</h4><em>Writing starless programs on top of neat languages is exactly the same thing as writing automatic memory management routines on top of a manually managed programming language or writing functional programs on top of a noun-centric object-oriented language.</em><br /><br />You can take that statement as an argument in favour of specialized languages for Sneetches without stars or as an argument against them. My guess is that the above statement is true and a Rorschach Inkblot: You will interpret it as confirmation of your existing prejudices.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">3:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, October 04, 2006</div>
			

			<div class="Post"><a name="116001645840262686">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html" title="permanent link">Why are local variables bad?</a></span>
					<div style="clear:both;"></div>Steve Yegge wrote a terrific post about <a href="http://www.refactoring.com/">refactoring</a>, "<a href="http://www.oreillynet.com/ruby/blog/2006/03/transformation.html">Transformation</a>," in March of 2006. My two cent review is that the most valuable part is his discussion of how the <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a> community has become so enamored of push-button refactoring at the line of code level that they have lost sight of what refactoring is supposed to accomplish at the design level.<br /><br />Many Blub programmers won't even <span style="font-style: italic;">try</span> a language that doesn't have so-called refactoring support in their IDE. Given <a href="http://beust.com/weblog/archives/000414.html">the choice between dynamic metaprogramming and refactoring</a>, they choose refactoring without even knowing exactly what <a href="http://raganwald.github.com/2006/08/dynamic-is-opposite-of-static-not-of.html">dynamic metaprogramming</a> is.<br /><br />And they are blissfully unaware that the 'refactorings' in their editors are just a few of the <a href="http://www.refactoring.com/catalog/index.html">refactorings suggested</a> in Martin Fowler's seminal book on the topic. Furthermore, there is more than one way to accomplish the goal of well-designed software, and some languages, (especially folding languages), provide much more powerful tools for clean software design than micro-refactoring.<br /><br />All that leads me to a question posed on <a href="http://programming.reddit.com">programming.reddit.com</a>:<br /><br /><span style="font-style: italic;">Why are local variables considered bad?</span><br /><br />I'll simplify things. <span style="font-style: italic;">Mutable</span> local variables are bad. And here's why:<br /><br />Mutable local variables mean that within a method execution you have changes of state. That makes it very difficult to change anything without breaking things.<br /><span class="g"><blockquote>Those are my principles, and if you don't like them... well, I have others.</blockquote></span><div style="text-align: right;"><span class="g">Groucho Marx</span><br /><span class="g"></span></div><br />For Eclipse fans, consider what happens if you take a random chunk in the middle of a method with mutable local variables and try to use the automatic refactoring to make a new private method.<br /><br />If you have lots of immutable local variables, they have to be passed to your new method as parameters. That's not so bad. But if you have mutable local variables, you have to do some back flips and sit ups to ensure that any changes to those variables are propagated to the rest of your method.<br /><br />This is a tip-off that the mutable local variables have introduced a lot of complexity to the structure of the method. Unless they make it dramatically shorter than a variable-free version of the same method, they should be removed.<br /><br />(Update): What kind of complexity are we talking about? We are talking about lots and lots of dependencies between the lines of code in the method. Those dependencies are what make the code brittle: if you try to move something or change it, you break some other code that is depending on its side effects. The extra dependencies have introduced <span style="font-style: italic;">coupling</span>, which is a code smell.<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0201485672?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201485672" title="Refactoring: Improving the Design of Existing Code"><img style="" src="http://raganwald.github.com/assets/images/old//refactoring-720867.jpg" alt="Refactoring: Improving the Design of Existing Code" border="0" /></a><em><br /><br />The book that touched off a revolution in software design. Incredibly, most programmers think that refactoring is just about the dozen or so menu items in their IDE. This book discusses over a hundred refactorings, organized into themes. It goes beyond mere transformations to explain what makes good code and how to recover from bad decisions.</em></div>The extra coupling manifests itself in many ways, not just in the difficulty of moving code around. You also have problems changing lines of code. This manifests itself in regressions: every time you fix a problem or add some functionality, do you find yourself having to fix a bunch of bugs created by your change?<br /><br />Let's be clear: we don't say mutable local variables are bad because it's hard to refactor methods with mutable local variables. We say mutable local variables are bad because they intrduce complex dependencies and coupling between the lines of code in a method.<br /><br /><span style="font-style: italic;">Immutable</span> local variables, such as the local variables you use to cache certain results, are  <span style="font-style: italic;">not</span> bad. (I should say, "in my opinion," but this is my blog. Note the words "my" and "blog," establishing that we're talking about <span style="font-style: italic;">me</span> and <span style="font-style: italic;">opinions,</span> not everyone and especially not widely accepted irrefutable facts).<br /><br />As a matter of fact, I can <span style="font-style: italic;">prove</span> that they are not bad. Okay, "proof" is an ambitious word given that there is no widely accepted <a href="http://scienceblogs.com/goodmath/2006/06/extreme_math_1_1_2.php">proof that 1+1=2</a>. I'll demonstrate. Here's some code with an immutable local variable:<br /><pre><code><br />my_var = SomeModelClass.find :all<br />if my_var.empty?<br />  :empty<br />else<br />  my_var<br />end<br /></code></pre><br />Let's transform that code into:<br /><pre><code><br />(lambda do |my_var|<br />  if my_var.empty?<br />     :empty<br />  else<br />     my_var<br />  end).call(SomeModelClass.find :all)<br /></code></pre><br />We've transformed the immutable local variable into a parameter for a lambda (or closure, or anonymous proc object, whichever name you prefer). Parameters are not harmful. And since this transformation can be automatically performed for <span style="font-style: italic;">any</span> immutable local variable, I claim that immutable local variables are also not harmful.<br /><br />Cool discovery, hunh? I should be famous. Oh wait, someone on the phone from the 1970s. The Lisp people want their <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">macro</span> back. And they're right. People having been using <span style="font-weight: bold;">let</span> for more than thirty years to write concise code without the side effects and state changes associated with mutable local variables. Consider instead:<br /><pre><code><br />(let ((my_var (find SomeModelClass 'all)))<br />     (if<br />        (empty? my_var)<br />        'empty<br />        my_var))<br /></code></pre><br />That's simpler structurally than using one of Ruby's procs. So what do we conclude?<br /><br />First, refactoring is cool, but it's a tool, not an objective. The important thing is the objective,  well-designed software. Second, read the book. Really read it, cover to cover.<br /><br /><span style="font-size:85%;">Update: This is exactly why languages with more powerful abstractions are more important than adding push-button variable renaming to less powerful languages. Where's the button that refactors a method with lots of mutable variables into one with no mutable variables? No button? Okay, until you invent one, don't you want a language that makes it easy to write methods and functions without mutable local variables? (Attention Java programmers: <span style="font-style: italic;">Yes you do</span>, and I have proof. Do you like the new <span style="font-weight: bold;">for</span> syntactic sugar in Java 1.5? Its biggest benefit is that it makes loops that used to have a mutable variable look just like an iterator block with an immutable parameter in Ruby or Smalltalk. Think about it.)</span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html" title="permanent link">10:13 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, October 01, 2006</div>
			

			<div class="Post"><a name="115975754405971453">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/three-questions-and-three-answers.html" title="permanent link">Three questions and three answers about Wasabi and Rotten Fish</a></span>
					<div style="clear:both;"></div><span style="font-size:100%;"><span style="font-style: italic;">I have read some questions about my post <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html">Wasabi cannot cure rotten fish</a>. Here are the questions and my replies:</span><br /><a href="http://metadeveloper.blogspot.com/2006/09/people-process.html"><br /></a><span style="font-weight: bold;"> Reg, </span><a href="http://metadeveloper.blogspot.com/2006/09/people-process.html"><span style="font-weight: bold;">are you really saying "a good team will succeed despite methodological strategy"</span></a><span style="font-weight: bold;">?</span><br /><br />No. I'm saying that a "good" methodology cannot save a bad team. That does not mean that a good team can survive a bad methodology. There are <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">four critical parts</a> of a successful software project, and in my experience you cannot succeed if any of them are missing. People are the first of those, management the last. Methodology is a part of management in my view. In some situations, strong management can impose an informal rather than a formal methodology. But it would be stretching a point to claim that such situations lacked process or had a bad process.<br /><br /><span style="font-weight: bold;">Reg, when you say "the quality of the result is almost entirely driven by the quality of the programmer", </span><a style="font-weight: bold;" href="http://blog.labnotes.org/2006/10/01/rounded-corners-34/">are you also saying "the quality of the tool employed is irrelevant to the quality of the result"</a><span style="font-weight: bold;">?</span><br /><br />No, although I might have chosen better words for this idea. </span><span style="font-size:100%;">What I'm saying is that the difference in results between good and bad programmers using the same tool is much, much larger than the difference in results for programmers of equal abilities using good and bad tools. The good tools are wasted on bad programmers, who find ways to write Visual Basic in any language. The bad tools are the source of frustration for good programmers, who waste time and energy "<a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule">greenspunning</a>" the bad tools into passable tools.<br /><br />So I am <span style="font-style: italic;">not</span> saying that (good programmer, bad tool) == (good programmer, good tool). I <span style="font-style: italic;">am</span> saying that:<br /><br /></span><span style="font-size:100%;">(good programmer, any tool) - </span><span style="font-size:100%;">(bad programmer, same tool) ><br /></span><span style="font-size:100%;">(any programmer, good tool) - </span><span style="font-size:100%;">(same programmer, bad tool)<br /></span> <span style="font-size:100%;"><br />So it is to your advantage to combine good programmers with the best tools available to them. It is always possible to cause a project to fail by selecting bad tools. There is still a difference in result between a good programmer with a good tools and a good programmer with a bad tool. Just because it is a much smaller difference than the difference between good and bad programmers doesn't change the fact that there is a difference.<br /><br />As Paul Graham and Assaf have pointed out, tool selection strongly drives your ability to attract and retain good programmers. So while in theory you may be able to combine good programmers with bad tools, in practice you may have programmers who are experts in buzzword obfuscation and UML refactoring, but they are not competent in actual programming.<br /><br />Some "bad" tools have such fatal flaws that it is unrealistic to expect even talented teams to overcome the weaknesses in the tool. In that case my expectation is that a good programmer will fail just like a bad programmer, but the good programmer will alert you to the tool's weaknesses much earlier than a bad programmer, perhaps in the exit interview. Good luck with any project where your best people quit because of poor tools, management, or working conditions.<br /><br />Finally, in some situations management does not restrict themselves to only prescribing a poor tool but compounds the error by proscribing effective use of the poor tool. In plain English, they don't just force their "A" programmers to use a "C" programming language, but they tell them to write software that they think a "C" would be comfortable maintaining.<br /><br />(Aside: The usual intent is to "make the code easy to read and maintain." But the measure of "easy to read and maintain" is wrongly "would </span><span style="font-size:100%;">an inexperienced</span><span style="font-size:100%;"> programmer write the code this way</span>." This is <span style="font-style: italic;">not</span> the same thing as "<span style="font-style: italic;">would an inexperienced but motivated programmer be able to study this code, learn from this code, understand this code, and then maintain this code</span>.")<br /><br />There is a much larger difference between good programmers using good tools and good programmers forced to use bad tools and bad programming practices. There is some debate as to whether my assertion holds for this "worst case scenario" (such organizations often go for broke, treating the <a href="http://www.joelonsoftware.com/articles/fog0000000043.html">Joel Test</a> as a golf score and do things like demand that their programmers wear ties or refrain from using the Internet).<br /><br />It may be that the formula becomes:<br /><br /><span style="font-size:100%;">(good programmer, good tool) - </span><span style="font-size:100%;">(bad programmer, good tool) ><br /></span><span style="font-size:100%;">(good programmer, good tool) - </span><span style="font-size:100%;">(good programmer, bad tool+bad practices)</span><span style="font-size:100%;"> ><br /></span><span style="font-size:100%;">(bad programmer, good tool) - </span><span style="font-size:100%;">(bad programmer, bad tool+bad practices)<br /><br /><span style="font-weight: bold;">Reg, I don't get the connection to the <a href="http://www.joelonsoftware.com/items/2006/09/01b.html">Wasabi</a> DSL!?<br /><br /></span>The title was actually snarfed from Guy Kawasaki, who wrote this aphorism approximately twenty years ago. It may be traditional Japanese wisdom. Then again, it may not.<br /><br /><span style="font-weight: bold;">Reg, not everyone can hire the top 1%, 5%, 10%, or even 50% of all developers. So <a href="http://blog.qualityaspect.com/2006/10/02/hiring-great-developers/">isn't your simplistic "hire great developers" suggestion broken</a>?<br /><br /></span>(</span><span style="font-size:100%;">Make that <span style="font-style: italic;">four</span> questions and answers)<br /><br />You know, this kind of question reminds me why I'm prejudiced in favour of working for CEOs that have a background in competitive fields like sales or competitive team sports like Soccer.<br /><br />In sales, nobody abandons the idea of hiring good salespeople because "not everyone can hire the top salespeople." Imagine being appointed coach of an <a href="http://www.upa.org">Ultimate</a> team. Do you abandon the idea of recruiting the most gifted athletes you can find because every team ought to be able to do the same thing and therefore you will have to settle for average players?<br /><br />No, obviously not. There can only be one top company. There can only be one championship team. To win in a competitive arena, you have to have better people, and better strategy, and you have to out-execute your competitors.  Your goal is to be the one company, to be the one team.<br /><br />Of course your strategy won't work for everyone, it won't work if everybody tries it.  By definition, in a competitive (or "zero-sum") game there is <span style="font-style: italic;">no</span> strategy that can help every player win.<br /><br /></span><span style="font-size:100%;">That's ok,</span><span style="font-size:100%;"> you are not interested in World Peace, in every company providing nice working conditions and good management for programmers. You are ruthlessly attempting to beat those companies into oblivion. You want them closed, bankrupt. If they have any talented programmers you want to hire those programmers away from them and put them to work building your dream while their former employers mumble platitudes about "methodologies that produce great results from mediocre people".<br /><br />Consultants can wander around selling utopian visions of methodologies that work for every company and every programmer, no matter how inexperienced or incapable.  Language and tool vendors can spend billions convincing everyone that their silver bullet eliminates all of the bugs that cause projects to fail. IDE mavens can tout the code generation and auto-completion  bells and whistles that will give every programmer, no matter how mundanely talented, the productivity of a wizard.<br /><br />These people have a vested interest in maintaining the illusion that software development is a positive sum game where everyone can win, where every project can succeed, where every product will make money.<br /><br />But if you are working in a start up where you have to compete for talent, compete for funding, and compete for business success,  you do not care whether your strategy can work for 100% of the projects in the world. You care whether it works for just one project, yours.<br /><br />If you are working on an internal project where you compete with the prospect of your work being outsourced, where you compete for funding with other projects, where you compete for executive mind share, you do not care </span><span style="font-size:100%;">whether your strategy can work for 100% of the projects in the world. You care whether it works for just one project, yours.<br /><br />Honestly, <a href="/http://raganwald.github.com/2006/08/words-to-blog-by-off-topic.html">what matters to <span style="font-style: italic;">me</span> is how I manage my own projects</a>.<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">post scriptum</span>: Not everyone wants to be the top salesperson, some people play competitive sports for the camaraderie, not to win, and some people go to work for the purpose of collecting nothing more than a pay cheque. If this describes you, you may find a kindred spirit in the "Angry Aussie": <a href="http://angryaussie.wordpress.com/2006/09/29/in-praise-of-an-average-career/">In praise of an average career</a>.</span></span><span style="font-size:100%;"><br /></span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/three-questions-and-three-answers.html" title="permanent link">10:25 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/assets/media/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/assets/media/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/assets/media/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/assets/media/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/assets/media/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://raganwald.github.com/assets/images/old//coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://raganwald.github.com/assets/images/old//coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>