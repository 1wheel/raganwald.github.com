<html> 
<head>
        
        <title><script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>raganwald</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
<link rel="me" href="http://www.blogger.com/profile/13132345822387028437" />
</head>

<body>

	<div id="leftcontent">
			<img src="http://minus.com/loSY4FTZKVCwz"
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Monday, January 28, 2008</div>
			

			<div class="Post"><a name="6677507519763024841">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/01/rubyredditcom.html" title="permanent link">ruby.reddit.com</a></span>
					<div style="clear:both;"></div>Reddit is now experimenting with user-generated reddits, and one of the new ones is <a href="http://ruby.reddit.com">reddit for ruby hackers</a>. For the three people who have never heard of reddit, this is a link aggregation site where you can vote on ruby articles, something like Digg and Dzone.<br /><br /><a href="http://ruby.reddit.com"><img hsize="500" vszie="415" src="http://raganwald.github.com/uploaded_images/ruby.reddit.com.png" border="0"/></a><br /><br />The Ruby reddit is important, and if you patronize link aggregators like this, I encourage you to please post good Ruby links, vote for the links you like, and perhaps even participate in the comments.<br /><br />There is already a programming subreddit, but the Ruby reddit is appears to be an entirely distinct &ldquo;space.&rdquo; Posts can be in programming.reddit com and in ruby.reddit.com, and there are separate posts and comments. What this means is that Ruby programmers can vote for links and exchange comments without getting into tiresome flame-wars with people who do not care for Ruby.<br /><br />Of course, you are still free to defend Ruby against Smug Haskell Weenies over in programming.reddit.com. It isn&rsquo;t an all-or-nothing choice. I look forward to seeing you there!<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/01/rubyredditcom.html" title="permanent link">12:39 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, January 24, 2008</div>
			

			<div class="Post"><a name="1086915798486609063">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/01/objectandand-objectme-in-ruby.html" title="permanent link">Object#andand & Object#me in Ruby</a></span>
					<div style="clear:both;"></div>At <a href="http://www.mcommons.com/jobs.html" title="Mobile Commons - Jobs">Mobile Commons</a>, we have to write a lot of code under time constraints. We also work on a fairly distributed basis, which means that writing readable code is not a luxury, it&#8217;s a necessity. We can&#8217;t afford to be clever for clever&#8217;s sake, but if a new idiom helps make our code easier for our colleagues to grasp in a hurry, we embrace it. Here&#8217;re some idioms we&#8217;ve recently created:<br /><br /><strong>Object#andand</strong><br /><br />Ruby programmers are familiar with the two <em>guarded assignment</em> operators <code>&amp;&amp;=</code> and <code>||=</code>. The typical use for them is when you have a variable that might be nil. For example:<br /><pre><code><br />@first_name &amp;&amp;= @first_name.trim<br />@phone ||= '612-777-9311'</code></pre><br />You are trimming the first name provided it isn&#8217;t nil, and you are assigning &#8216;612-777-9311&#8217; to the phone if it <em>is</em> nil (or false, but that isn&#8217;t important right now). The other day we were discussing the guards and we agreed that we wished there was a <em>guarded method invocation</em> operator. Here&#8217;s an example of when you would use it:<br /><pre><code><br />@phone = Location.find(:first, ...elided... )&amp;&amp;.phone</code></pre><br />Meaning, search the location table for the first record matching some criteria, and if you find a location, get its phone. If you don&#8217;t, get nil. (Groovy provides this exact functionality, although Groovy uses <code>?.</code> instead of <code>&amp;&amp;.</code>) However, <code>&amp;&amp;.</code> won&#8217;t work because <code>&amp;&amp;.</code> is not a real Ruby operator. So what do we write instead?<br /><blockquote>A feature is &ldquo;powerful&rdquo; when at least one of the following holds:<br /><ol><li> It can be used to implement something trivial in an pointlessly complicated way.</li><li>It can cause a lot of damage.</li></ol>Seriously, it seems like 85% percents of the contexts where something is called &ldquo;powerful,&rdquo; it really means &ldquo;useless and dangerous.&rdquo;</blockquote><div>&mdash;Yossi Kreinin, <a href="http://www.yosefk.com/blog/?p=16">Fun at the Turing Tar Pit</a></div><br />How about:<br /><pre><code><br />@phone = (loc = Location.find(:first, ...elided... )) &amp;&amp; loc.phone</code></pre><br />Note that we need a local variable to make it work without extending the Object class. Note further that although we only need the local variable for one line of code, it is in method scope and we must be careful that we don&#8217;t clobber an existing <code>loc</code> variable. And when reading this code, we now have to look and see whether <code>loc</code> is used again to understand what this line does.<br /><br />This is a scoping problem. if you are going to use variables, you want to restrict their scope as much as possible. It feels like half of what we do when programming is manage side effects like overwriting a variable you are using elsewhere, and the more you can restrict those side effects, the easier programming becomes. Java supports block scoping natively, and languages like Scheme solve this by providing a block scope macro, <code>let</code>. And you can roll your own in languages like <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html" title="Block-Structured Javascript">Javascript</a> that provide anonymous functions. But this seems to get <a href="http://raganwald.github.com/2008/01/no-detail-too-small.html" title="No Detail Too Small">the natural left-to-right order</a> wrong:<br /><pre><code><br />@phone = lambda { |loc| loc &amp;&amp; loc.phone }.call(Location.find(:first, ...elided... ))</code></pre><br />Well, we are tinkerers and toolsmiths. So let&#8217;s roll our own. We can&#8217;t use <code>&amp;&amp;.</code> without rewriting the Ruby parser, and that seems drastic. So let&#8217;s use &#8220;andand&#8221; in the hope that our non-English-speaking colleagues will forgive us. We want to write:<br /><pre><code><br />@phone = Location.find(:first, ...elided... ).andand.phone</code></pre><br />And get the same effect as <code>@phone = -&gt;(loc){ loc &amp;&amp; loc.phone }.call(Location.find(:first, ...elided... ))</code>. This would be bloody trivial if we have a macro facility, but &#8220;If wishes were horses then beggars would ride.&#8221; Instead, we need to write a method that does some conditional evaluation for us. If the receiver (in this case the result of <code>Location.find(:first, ...elided... )</code>) is truthy, like an ActiveRecord model, we want <code>andand</code> to return it so we can use it. But if it is falsy, we want <code>andand</code> to somehow return something that takes any message you send it and returns itself without doing anything. In other words, we want a mock object of sorts. So that&#8217;s what we&#8217;ll do:<br /><pre><code><br />class Object<br />    def andand (p = nil)<br />      self or MockReturningMe.new(self)<br />    end<br />end<br /><br />class MockReturningMe<br />  instance_methods.reject { |m| m =~ /^__/ }.each { |m| undef_method m }<br />  def initialize(me)<br />    @me = me<br />  end<br />  def method_missing(*args)<br />    @me<br />  end<br />end</code></pre><br /><em><font size="-1">Actually, there is more to it than this, for example the MockReturningMe class is enclosed in a module to minimize namespace pollution. Consult the source and RSpec (links below) for the latest particulars</font></em>.<br /><br />Note that because you accept any method using Ruby&rsquo;s method invocation syntax, you can accept methods with parameters and/or blocks:<br /><pre><code><br />list_of_lists.detect { ...elided... }.andand.inject(42) { ...elided ... }</code></pre><br />Some of the other solutions to this problem that use <code>send</code> change Ruby&rsquo;s syntax. This solution emphasizes syntactic regularity: the goal was to make an &ldquo;&&.&rdquo; operation that worked like &&=. &&= looks just like normal assignment, you can use any expression on the RHS, only the semantics are different. The andand method also works just like a normal method invocation, only the semantics are modified.<br /><br /><strong>Enhanced Object#tap</strong><br /><br />(Formerly called Object#me)<br /><br />Ruby 1.9 includes <a href="http://blog.moertel.com/articles/2007/02/07/ruby-1-9-gets-handy-new-method-object-tap">Object#tap</a>:<br /><pre><code><br />Location.find(:first, ...elided... ) do |location|<br />    puts location.inspect<br />end<br />   =&gt; location</code></pre><br />Ruby On Rails includes a similar feature, the <em>returning</em> idiom:<br /><pre><code><br />returning(Location.find(:first, ...elided... )) do |location|<br />    ...elided...<br />end<br />   =&gt; location</code></pre><br />Both return the location, not whatever happens inside the block. This is very useful, especially when chaining methods in a pipeline. Sometimes you want to do something for side effects, but continue on with the chain. For example:<br /><pre><code><br />returning([1, 2, 3, 4, 5]) do |arr|<br />    arr.pop<br />end.map { |n| n * 2 }<br />    =&gt; [2, 4, 6, 8]</code></pre><br />There are going to be times that using a method instead of a function makes the code more consistent. So let&#8217;s imagine what that would look like:<br /><pre><code><br />Location.find(:first, ...elided... ).tap do |location|<br />    ...elided...<br />end&hellip;</code></pre><br />This is much nicer when you are &ldquo;injecting&rdquo; some extra code into the middle of an expression, such as when adding some poor-man&rsquo;s-debugging puts statements.<br /><br />Would we ever want to go beyond a block and write <code>Location.find(:first, ...elided... ).tap.some_method</code> instead of <code>Location.find(:first, ...elided... ).tap do ...elided... end</code>? Of course we would! Quite often, we want to send several methods to the same receiver. In Smalltalk, the semicolon does this explicitly. In Ruby, we have to be very careful to make sure our methods return <em>self</em> to enable chaining. For example:<br /><pre><code><br />[1, 2, 3] &lt;&lt; 4 &lt;&lt; 5<br />    =&gt; [1, 2, 3, 4, 5]</code></pre><br />But if a method doesn&#8217;t return the receiver, chaining doesn&#8217;t work. That&#8217;s why we had to use &#8220;returning&#8221; in the array example above:<br /><pre><code><br />[1, 2, 3, 4, 5].pop.map { |n| n * 2 }<br />    =&gt; NoMethodError: undefined method `map' for 5:Fixnum</code></pre><br />That&#8217;s because <code>[1, 2, 3, 4, 5].pop =&gt; 5</code>, not <code>[1, 2, 3, 4]</code>. So instead, we write:<br /><pre><code><br />[1, 2, 3, 4, 5].tap.pop.map { |n| n * 2 }<br />    =&gt; [2, 4, 6, 8]     # or we write...<br />[1, 2, 3, 4, 5].tap { |arr| arr.pop }.map { |n| n * 2 }<br />    =&gt; [2, 4, 6, 8]     # both work</code></pre><br />When you examine the source, you&#8217;ll see that <em>tap</em> looks a lot like <em>andand</em>. No surprise, we are doing similar things with slightly different semantics.<br /><br />This implementation of Object#tap has two advantages over the implementation in Ruby 1.9: first, it works in Ruby 1.8. Second, it adds the ability to call another method (like <code>pop</code>) and not have to include a block.<br /><br /><strong>Summary: andand &amp; enhanced tap</strong><br /><br /><em>andand</em> and <em>tap</em> both provide the same two benefits: First, they either eliminate (in the case of a method call) or limit in scope (in the case of a block) a local variable. Second, they let you maintain a natural left-to-right order when writing pipelined expressions. They are simple and obvious enough that I feel any unfamiliarity for the reader will be more than outweighed by the cleaner, easier-to-digest code that results from their liberal use.<br /><br />My suggestion is that these two benefits make it worth your while to add these methods to the Object class and use them regularly in your code.<br /><br /><strong>Installation</strong><br /><br /><code>sudo gem install andand</code>. For the source and more information, <a href="http://andand.rubyforge.org">http://andand.rubyforge.org</a>.<br /><br /><hr/><font size="-1">Similar solutions:<br /><ol><li><a href="http://facets.rubyforge.org/quick/rdoc/core/classes/Kernel.html#M000357">Kernel#ergo</a> in <a href="http://facets.rubyforge.org/">Ruby Facets</a></li><li><a href="http://rhnh.net/2007/10/2/object-send_with_default">send_with_default</a></li><li><a href="http://weavejester.com/node/10">maybe</a></li><li><a href="http://hobocentral.net/blog/2007/08/25/quiz/">_?</a></li><li><a href="http://recursive.ca/hutch/2007/11/22/a-little-unnecessary-smalltalk-envy/">if_not_nil</a> (via <a href="http://blog.teksol.info/2007/11/23/a-little-smalltalk-in-ruby-if_nil-and-if_not_nil">François Beausoleil</a>)</li><li>Groovy&rsquo;s <a href="http://groovy.codehaus.org/Operators#Operators-ElvisOperator(%3F%3A\)">Safe Navigation Operators</a> via <a href="http://jfkbits.blogspot.com/2008/02/call-by-name-yo-elvis.html">Call by Name: "Yo Elvis"</a></li><li><a href="http://ozmm.org/posts/try.html">try()</a> and <a href="http://ruby.tie-rack.org/53/a-better-try-chaining-methods-and-nil/">A better try</a></li></ol></font><br /><hr/><br /><em>postscript: Inline Rescues</em><br /><br />I have now seen two people asking about using an inline rescue instead of andand:<br /><pre><code><br />Location.find( &hellip;elided&hellip; ).phone rescue nil</code></pre><br />Also, one of the alternate solutions seems to use this technique. Obviously, it works for many of the cases you want to try, and you don&rsquo;t need to add a new method to Object. However, it is&mdash;to paraphrase <a href="http://chalain.livejournal.com/39332.html">Chalain</a>&mdash;&ldquo;Sneaking up on the Interpreter.&rdquo;<br /><br />It achieves what we want almost by accident, namely that it rescues <code>NoMethodError</code>, which by co&iuml;ncidence gives us the result we want. However, it does not communicate our intent. It says that we want to transmute all exceptions into a value of <code>nil</code>. When someone glances at the code, will they think of <code>NoMethodError</code>? Or will they assume that we are trying to handle exceptions that the <code>.phone</code> method might throw?<br />  <br />And what if <code>.phone</code> actually throws something serious? In Rails, what happens if a migration is screwed up and there is no phone column? I think we actually want a <code>NoMethodError</code> in that case. The rescue clause will accidentally swallow the exceptions we are trying to catch.<br /><br />I think if you are absolutely certain that you do not care about other exceptions and also if your team uses this idiom extensively so that it does not miscommunicate its intent, you can live a long and happy life using it. However, I would be hesitant to recommend it as a general-purpose solution. <em>andand</em> and some of the other solutions obviously require the code reader to learn a new method name, but after that they offer the exact functionality we need and clearly communicate their intent.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/01/objectandand-objectme-in-ruby.html" title="permanent link">9:09 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, January 22, 2008</div>
			

			<div class="Post"><a name="96976113199711671">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/01/ruby-is-soooooo-2002.html" title="permanent link">Ruby is soooooo 2002</a></span>
					<div style="clear:both;"></div>I first heard about Ruby when Matz spoke at LL2 in <a title="Where were you on Saturday, November 9, 2002?" href="http://raganwald.github.com/2007/01/where-were-you-on-saturday-november-9.html">November, 2002</a>. I experimented with it on and off over the next few years, and I liked it. I also experimented with C#, Groovy, and a few others, but Ruby reminded me of Smalltalk, a language I used in the 80s and loved, so I stuck with it even though I seemed to be one of three people using Ruby without using Rails.<br /><br />Lately, the internet echo chamber is souring on Ruby and moving from embracing it to hating it. I suspect that although people are quoting all sorts of technical reasons for their dislike, it comes down to cultural forces. Shrug.<br /><br />I am reminded of the time I showed up in high school one September on a skateboard. To give you an idea of where skateboards were in those days, my model had clay wheels designed for wood-rink roller-skates, not the polyurethane we have today. Any ways, everyone laughed at me. The next Summer, everyone had one, and they were laughing at the fact that I didn't ride the latest model, even though I was a more accomplished free-styler and slalom rider. Then, the fad passed, and I was the iconoclast again, still riding my board while everyone embraced mopeds.<br /><br />Guess what? There is no villain in the story. I was happy riding with my friends. The people who jumped on and off fads were happy, and they were learning important life skills about participating in human culture. And the fad was a big win: Early boards really weren&rsquo;t very good, and the popularity brought money and manufacturing scale to skateboarding that improved the technology.<br /><br />Paul Graham has said that the real world is nothing like high school. I&rsquo;m not so sure.<br /><br /><hr/><br /><em>I often use Ruby for code examples. What do you think: Should I continue using Ruby, or should I use another language for examples? If I continue using Ruby, should I try to show idiomatic Ruby or should I try to focus on general ideas that can be applied elsewhere?</em><br /><br /><form method=post action="http://poll.pollcode.com/Zp91"><table border=0 width=150 bgcolor="FFCC00" cellspacing=0 cellpadding=2><tr><td colspan=2><font face="Verdana" size=-1 color="000000"><b>Code examples should be:</b></font></td></tr><tr><td width=5><input type=radio name=answer value="1"></td><td><font face="Verdana" size=-1 color="000000">Ruby-specific</font></td></tr><tr><td width=5><input type=radio name=answer value="2"></td><td><font face="Verdana" size=-1 color="000000">Anything but Ruby</font></td></tr><tr><td width=5><input type=radio name=answer value="3"></td><td><font face="Verdana" size=-1 color="000000">Ruby, but general</font></td></tr><tr><td width=5><input type=radio name=answer value="4"></td><td><font face="Verdana" size=-1 color="000000">A mix of specific and general ideas</font></td></tr><tr><td colspan=2><center><input type=submit value="Vote">&nbsp;&nbsp;<input type=submit name=view value="View"></center></td></tr><tr><td bgcolor="white" colspan=2 align=right><font face="Verdana" size=-2 color="black">pollcode.com <a href=http://pollcode.com/><font color="navy">free polls</font></a></font></td></tr></table></form><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/01/ruby-is-soooooo-2002.html" title="permanent link">11:12 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, December 28, 2007</div>
			

			<div class="Post"><a name="5473500335651384097">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/why-rubinius-matters-to-rubys-future.html" title="permanent link">Why Rubinius Matters to Ruby's Future</a></span>
					<div style="clear:both;"></div>I am a long-time fan of <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="The significance of the meta-circular interpreter">self-hosted languages</a>. In that post I listed the reasons I thought that a language should be mostly or entirely written in itself. Here&rsquo;s another reason writing a language in itself is important: If a language&#8217;s core libraries and frameworks are written in that language, it is possible for every programmer to improve on them.<br /><br />Ruby&#8217;s core libraries are written in C. Here&#8217;s the source for Ruby&#8217;s collect method:<pre><code><br />/*<br /> *  call-seq:<br /> *     array.collect {|item| block }  -> an<em>array<br /> *     array.map     {|item| block }  -> an</em>array<br /> * <br><br /> *  Invokes <i>block</i> once for each element of <i>self</i>. Creates a <br /> *  new array containing the values returned by the block.<br /> *  See also <code>Enumerable#collect</code>.<br /> * <br><br /> *     a = [ &#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221; ]<br /> *     a.collect {|x| x + &#8220;!&#8221; }   #=> [&#8220;a!&#8221;, &#8220;b!&#8221;, &#8220;c!&#8221;, &#8220;d!&#8221;]<br /> *     a                          #=> [&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;]<br /> */<br />static VALUE<br />rb_ary_collect(ary)<br />    VALUE ary;<br />{<br />    long i;<br />    VALUE collect;<br /><br />    if (!rb_block_given_p()) {<br />    return rb_ary_new4(RARRAY(ary)-&gt;len, RARRAY(ary)-&gt;ptr);<br />    }<br /><br />    collect = rb_ary_new2(RARRAY(ary)-&gt;len);<br />    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {<br />    rb_ary_push(collect, rb_yield(RARRAY(ary)-&gt;ptr[i]));<br />    }<br />    return collect;<br />}<br /></code></pre><br />Perhaps you like working with Haskell-style fold and <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="Really useful anamorphisms in Ruby">unfold</a> rather than the Smalltalk-style collect, select, and detect. No problem, you can hack your own in Ruby, like this:<pre><code><br />class Object<br />  def unfold options = {}, &amp;incrementor<br />    return [] unless options[:while].nil? || options[:while].to_proc.call(self)<br />    transformed = options[:map] &amp;&amp; options[:map].to_proc[self] || self<br />    return [transformed] if options[:to] &amp;&amp; options[:to].to_proc.call(self)<br />    incrementor.call(self).unfold(options, &amp;incrementor).unshift(transformed)<br />  end<br />end</code></pre><br />One hitch: your fold and unfold are hundreds of times slower than Ruby&#8217;s built-in-C methods and classes. It reminds me of Newton programming. Apple gave us a really cool language&#8212;NewtonScript&#8212;for writing applications. Except, the built-in applications were written in C, and the C compiler was only for Apple engineers.<br /><br />The good news about Ruby is that you can write your own classes in C if you want to. But that is a significant barrier to entry for many programmers, shrinking the available pool of programmers who will enhance the language.<br /><br />Having core libraries in C is a great choice for implementing a language that is to be used for other things like building web applications. But it is not a great choice for a language that is to be used to build other languages. And &#8220;building other languages&#8221; is <em>exactly</em> what Bottom-Up Programming or Meta-Linguistic Abstractions are all about. In other words, writing the core libraries in C is not a great choice for a language where programmers write their own abstractions. <br /><br />Now for many things, the speed penalty of writing your own abstractions in Ruby is negligible. But not everything. So there is always going to be this class of things&#8212;and I think collection manipulation is one of those things&#8212;where you need to be able to write stuff that is as good as what comes out-of-the-box.<br /><br />If new stuff is an order of magnitude slower, you might be able to use it for non-critical things, but your chances of persuading anyone else to use it are very low. Which means that the language <em>as a whole</em> progresses slowly because real progress can only happen in areas where performance doesn&#8217;t matter. Like database-bound web applications.<br /><br />Having an implementation where the built-in stuff is on the same footing as your stuff opens up the doors for actual progress. It forces the language itself to be Good Enough, and it makes it possible for every Ruby programmer to improve the language.<br /><br /><strong>what we can learn from java, whoops smalltalk</strong><br /><br />Java has this incredibly powerful and popular IDE, Eclipse. It is so powerful that many people feel it is impossible to write production Java code without it. Why is it so powerful?<br /><br />One of the major reasons it is both powerful and popular is the availability of plug ins. It seems to support the language, UML diagrams, source code control, and everything up to (I&rsquo;m pretty sure) time tracking for client billing. Naturally, the plug ins are written in Java, just like the almost all of the built-in functionality.<br /><br />Clara Creative can write her own plug in and it won&rsquo;t be a second-class citizen. And since it is a tool for Java programmers, Clara Creative already knows how to write plug ins, she doesn&rsquo;t need to drop into another language.<br /><br />Wow, that is neat. And it does help explain why Eclipse has so many plug ins, and why they are popular: there is no low-level language barrier, and they all on an equal footing with each other.<br /><br />This shouldn&rsquo;t surprise you. <a href="http://en.wikipedia.org/wiki/IBM_VisualAge">Eclipse evolved from IBM VisualAge Micro</a>, which was written by Smalltalk programmers in Smalltalk. And of course, Smalltalk is a language where almost everything is written in Smalltalk itself. Smalltalk programmers expect to be able to extend the language and environment without penalty.<br /><br />In the end, the choice of whether to implement core features in C or Ruby will always be difficult. The temptation to optimize for speed will always be strong, especially when the language is fighting for mind share. But extensibility and variety is also a win, and Ruby fights with its libraries and features as much as with its performance.<br /><br />Perhaps we won&#8217;t all be using fold and unfold instead of collect, select, and detect. But if we aren&#8217;t, it ought to be because we prefer the originals, not because the replacements are crippled in comparison, or because the kind of person who likes inventing new tools prefers to write them in Ruby instead of in C.<br /><hr/><br />I&#8217;m looking forward to hearing more from the <a href="http://blog.fallingsnow.net/category/rubinius/" title="rubinius &laquo; evan.musing &lt;&lt; current">Rubinius</a> team. I really think they hold the key to the future. Thanks, Ezra, for your comment.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/why-rubinius-matters-to-rubys-future.html" title="permanent link">5:05 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, December 15, 2007</div>
			

			<div class="Post"><a name="9059803522407815872">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/grinch-who-stole-ruby-jobs.html" title="permanent link">The Grinch Who Stole the Ruby Jobs</a></span>
					<div style="clear:both;"></div>A reader was kind enough to point out that making statements about jobs being advertised could be misconstrued as a statement about the policies of the companies doing the hiring.<br /><br />I do not speak for any hiring company, and I&rsquo;m sure that hiring companies do not particularly want me articulating their policies for them.<br /><br />Therefore, my policy hereforward is that when I wish to describe a job, I will provide links to open positions or name companies hiring. If I quote something, it is partially or fully information provided by the company and it will be indicated as such in quote marks.<br /><br />I know, what a bother. Sheesh. But there you have it, that seems to be the way the world works. Roll with it and let&rsquo;s move on.<br /><br /><hr/><br /><blockquote><a href="http://www.mdlogix.com/">mdlogix</a>, a rapidly growing medical research software company is seeking Ruby on Rails developers for our downtown Toronto office.<br /><br />We're looking for passionate developers who love Rails and want to make the world a better place by supporting clinical research! <br /><br />For more information, visit <a href="http://www.mdlogix.com/aboutUs/jobSoftwareEngineerToronto.html">http://www.mdlogix.com/aboutUs/jobSoftwareEngineerToronto.html</a> or speak to us at the next <a href="http://unspace.ca/innovation/pubnite/">Rails pub night</a>!</blockquote><br /><br /><a href="http://www.hewitt.com/">Hewitt Associates</a> is looking for a &ldquo;P/A with Ruby on Rails experience,&rdquo; possibly in Toronto (No link: they use an HR application for job listings that supports nice searches but mightily resists bookmarking).<br /><br /><blockquote>GigPark is a Toronto-based web startup that's growing fast             <br />Built with Ruby on Rails and hosted on EC2<br />We develop iteratively and release weekly<br />We care about quality - our code is well-designed and tested<br />We work hard, but smart. We believe less code is better and simple UI design is key             We're not religious about technology. We believe in using the right tool for the job<br /><br /><a href="http://www.gigpark.com/page/jobs">http://www.gigpark.com/page/jobs</a></blockquote><br /><br /><a href="http://www.mcommons.com/about/jobs">Mobile Commons is looking for &ldquo;junior and senior hackers&rdquo;</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/grinch-who-stole-ruby-jobs.html" title="permanent link">2:41 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, December 10, 2007</div>
			

			<div class="Post"><a name="5727070802408468811">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/utility-belt.html" title="permanent link">Utility Belt</a></span>
					<div style="clear:both;"></div><a href="http://utilitybelt.rubyforge.org/" title="Utility Belt: Usage">Utility Belt</a> is a grab-bag of tricks, tools, techniques, trifles, and toys for IRB, including convenience methods, language patches, and useful extensions. It also includes a couple command-line widgets. Its primary inspirations were an awesome gem called <a href="http://www.gemtacular.com/gems/wirble">Wirble</a> and a blog post by Amy Hoy called &#8220;<a href="http://slash7.com/articles/2006/12/21/secrets-of-the-rails-console-ninjas">Secrets Of The Rails Console Ninjas</a>&#8221;.<br /><br />INSTALL<br /><br /><pre><code>sudo gem install utility_belt</code></pre><br />FEATURES<br /><ul><li>Interactively edit IRB code in your preferred text editor</li><br /><li>Read from and write to OS X clipboard</li><br /><li>Post your code to Pastie with one command (OS X only)</li><br /><li>Kick-ass Unix-style history buffer</li><br /><li>Write command history to file or vi</li><br /><li>Grep classes and methods for strings</li><br /><li>Verbosity controls for regular IRB and Rails console</li><br /><li>Finder shortcuts for Rails console</li><br /><li>Upload shortcut for Amazon S3</li><br /><li>Command-line Amazon S3 upload script</li><br /><li>Command-line Google shortcut (OS X only)</li><br /><li>Auto-indentation</li><br /><li><code>_</code> special variable (like Unix shell var !!)</li><br /><li>Extremely basic themes for Wirble syntax coloring</li><br /><li>Pascal/JavaScript-style &#8220;with&#8221; statement</li><br /><li><a href="http://raganwald.github.com/2007/10/stringtoproc.html">String#to_proc</a></li><br /><li>Grammatically-correct <code>is_an?</code> method - no more &#8220;<code>is_a? Array</code>&#8221; statements</li><br /><li>One-character exit command</li></ul><br /><hr><br /><br />Who can resist publicizing a grab-bag gem that just happens to contain some code you <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">snarfed from someone else</a>? Not me! It&#8217;s like one of those vanity books of poetry: your poem is included provided you buy twenty copies for your friends and family&#8230;<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/utility-belt.html" title="permanent link">7:51 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, November 27, 2007</div>
			

			<div class="Post"><a name="6774641316023962038">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/fun-with-symboltoproc.html" title="permanent link">Fun with Symbol#to_proc</a></span>
					<div style="clear:both;"></div><blockquote>If you want a golden rule that will fit everything, this is it: Have nothing in your houses that you do not know to be useful or believe to be beautiful.</blockquote><div>&mdash;<a href="http://en.wikipedia.org/wiki/William_morris">William Morris</a></div><br />Most people love Symbol#to_proc sugar in Ruby:<pre><code><br />%w[dsf fgdg fg].map(&amp;:capitalize)<br />    → ["Dsf", "Fgdg", "Fg"]</code></pre>And Googling around, all of the examples I could find were for unary methods like this. But what about <em>binary</em> methods like :merge? If Symbol#to_proc supported binary methods, you could do things like:<pre><code><br />(1..5).inject &amp;:+<br />    → 15</code></pre>Or:<pre><code><br />[{ :foo =&gt; 1 }, { :bar =&gt; 2 }, { :blitz =&gt; 3 }].inject &amp;:merge<br />    → {:foo=&gt;1, :bar=&gt;2, :blitz=&gt;3}</code></pre>That would be brilliant.<sup><font size="-2">1</font></sup> And the implementation can&#8217;t be that hard in a language like Ruby, can it? Let&#8217;s have a look at the source code (I don&#8217;t have the Ruby 1.9 source, but I do have Symbol.rb from the Rails Core Extensions):<pre><code><br />class Symbol<br />  # Turns the symbol into a simple proc, which is especially useful for enumerations. Examples:<br />  #<br />  #   # The same as people.collect { |p| p.name }<br />  #   people.collect(&amp;:name)<br />  #<br />  #   # The same as people.select { |p| p.manager? }.collect { |p| p.salary }<br />  #   people.select(&amp;:manager?).collect(&amp;:salary)<br />  def to_proc<br />    Proc.new { |*args| args.shift.__send__(self, *args) }<br />  end<br />end</code></pre>Would you look at that, Symbol#to_proc already handles methods with arguments. And indeed, the examples above work right out of the box in Rails. I expect them to work in Ruby 1.9 as well.<br /><br />You still can&#8217;t do some of <a href="http://raganwald.github.com/2007/10/stringtoproc.html">String#to_proc&#8217;s</a> other point-free tricks like <code>collection.map(&amp;'*2')</code>, but quite frankly this is a really nice feature that deserves more publicity. So&#8230; don&#8217;t forget that Symbol#to_proc handles your unary <em>and</em> binary methods.<br /><br />Cheers!<br /><br /><ol><li>I know what you&rsquo;re thinking, but try to remember that the other meaning of the word &ldquo;brilliant&rdquo; is <em>shiny and sparkling.</em></li></ol><br /><br />p.s. You&#8217;re wondering where I get the time to think up stuff like this? Actually, <a href="http://mcommons.com/about/jobs" title="We're Hiring at Mobile Commons!">I&#8217;m lucky enough use stuff like this for a living</a>. I needed to fold a collection of hashes together, and my first thought was that I&#8217;d like to write .inject(&amp;:merge) to do it. This is the principle of least astonishment in action&#8230;<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/fun-with-symboltoproc.html" title="permanent link">8:52 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, November 24, 2007</div>
			

			<div class="Post"><a name="8766303462631423169">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/weather-being-fine-i-managed-to-get-few.html" title="permanent link">How I've been spending my time off work lately</a></span>
					<div style="clear:both;"></div>The weather being fine, and in the flagrant <a title="Why I Program In Ruby (And Maybe Why You Shouldn't)" href="http://gilesbowkett.blogspot.com/2007/11/why-i-program-in-ruby-and-maybe-why-you.html">pursuit of happiness</a>, I&#8217;ve managed to get <a href="http://en.wikipedia.org/wiki/Perl#Perl_golf" title="Perl Golf">a few holes in</a> this week (using Ruby of course). Here&#8217;s my scorecard:<br /><pre><code><br /> palindrome =  (+(+[] | +[-:_] | ((-'[0]' &gt;&gt; -:ends) &amp; (-'[1..-2]' &gt;&gt; -:p) <br />               &amp; (-'[-1]' &gt;&gt; -:ends) &amp; -:_)) &gt;&gt; (-:'{}' &gt;&gt; -:p)).call<br />(palindrome =~ []).should_not be_nil<br />(palindrome =~ [:fish]).should_not be_nil<br />(palindrome =~ [:fish, :dog]).should be_nil<br />(palindrome =~ [:fish, :dog, :fish]).should_not be_nil<br />(palindrome =~ [:fish, :fish, :fish, :fish]).should_not be_nil<br />(palindrome =~ [:fish, :fish, :fish, :fish, :fish]).should_not be_nil<br />(palindrome =~ [:fish, :dog, :dog, :fish]).should_not be_nil<br />(palindrome =~ [:fish, :dog, :cat, :dog, :fish]).should_not be_nil<br />(palindrome =~ [:fish, :dog, :cat, :fish]).should be_nil</code></pre><br />Perhaps Guido has a point, indentation matters:<br /><pre><code><br />palindrome = (<br />    +(                            # we'll start by creating a pattern<br />        +[]    |                  # match the empty list, or:<br />        +[-:_] |                  # match a list containing anything<br />                                  # (-:_ matches any one entity), or:<br />        (                         # alternative three:<br />            (-'[0]' &gt;&gt; -:ends)  &amp; # extract the first element and<br />                                  # bind it to 'ends'<br />            (-'[1..-2]' &gt;&gt; -:p) &amp; # and everything from the second to the<br />                                  # second-last will be matched against a<br />                                  # pattern :p<br />            (-'[-1]' &gt;&gt; -:ends) &amp; # and the last element must match whatever<br />                                  # was bound to 'ends' above.<br />                                  # it's equally effective to include<br />                                  # -'_[0].eql?(_[1])', same thing.<br />            -:_                   # if all that matches, match the entire array<br />                                  # so that the result is the entire array, not<br />                                  # whatever part of the array we were just<br />                                  # matching<br />        )                         # therein ends the pattern<br />    ) &gt;&gt; (-:'{}' &gt;&gt; -:p)          # pass the pattern to a closure-maker (-:'{}')<br />                                  # and then bind it to 'p' so that the pattern<br />                                  # is now recursive: this pattern matches an<br />                                  # empty list, a list with one element, or<br />                                  # a list with the first and last elements eql?<br />                                  # to each other and whatever is in-between them<br />                                  # matching the palindrome pattern bound to 'p'.<br />).call</code></pre><br />Hmmm. Still doesn&rsquo;t make any sense. I guess home-brew programs are like babies: they appear to be delightful and impart a sense of wonder in the mysteries of the universe to their creators, but are noisy and obstreperous to everyone else.<br /><pre><code><br />f = (<br />    +(<br />      (-'==0' &gt;&gt; -'0') | <br />      (-'==1' &gt;&gt; -'1') |<br />      (-'n&gt;1' &gt;&gt; -'n * f[n-1]') ) &gt;&gt; (-:'{}' &gt;&gt; -:f)).call<br />f[0].should == 0<br />f[1].should == 1<br />f[2].should == 2<br />f[3].should == 6<br />f[4].should == 24<br />f[5].should == 120</code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/weather-being-fine-i-managed-to-get-few.html" title="permanent link">3:42 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, November 09, 2007</div>
			

			<div class="Post"><a name="2961100763442932381">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="permanent link">Really useful anamorphisms in Ruby</a></span>
					<div style="clear:both;"></div><a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="Really simple anamorphisms in Ruby">Really simple anamorphisms in Ruby</a> introduced a very simple <a href="http://weblog.raganwald.com/source/unfold.rb.html" title="unfold.rb">unfold</a>. Its chief characteristics were that it generated an Array from a value of some sort, and it did so by applying an incrementor block to its seed recursively until it generated nil. For example:<pre><code><br />10.class.unfold(&amp;:superclass)<br />    =&gt; [Fixnum, Integer, Numeric, Object]<br /></code></pre>A very simple modification allows us to separate the two blocks with a :while or :to pseudo-keyword, and to add a :map keyword for transforming the state into the desired result. Thus, this really simple unfold:<pre><code><br />1.unfold(<a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="String#to_proc">&amp;'_+1 unless _==10'</a>).map(&amp;'**2')<br />    =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br /></code></pre>Can also be expressed as:<pre><code><br />1.unfold(:to =&gt; '==10', :map =&gt; '**2', &amp;'_+1')<br />    =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br /></code></pre>The latter form is helpful once unfolds become larger and more complex than these simple one-liners.<br /><br />(There is another style of writing :unfold, using method chaining and lazy evaluation to eliminate lambda keywords, but we will save that for another time: it is a great examination of syntax but does not change :unfold&rsquo;s fundamental behaviour.)<br /><br /><strong>Let&#8217;s turn it up a notch</strong><br /><br />These trivial examples are not particularly compelling. Unfold is touted as the complement to :inject. So you would expect :unfold to be as useful as :inject. And :inject is very, very useful&mdash;you &#8220;reduce&#8221; lists of things to values all the time.<br /><br />But how often do you need to turn a value into a list? How often do you need to turn &#8216;10&#8217; into &#8216;[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&#8217;? And if you do, what&#8217;s wrong with using <code>(1..10).map(&amp;'**2')</code>?<br /><br />Remember that :unfold can be applied to objects with a lot more information to them. The thing that had me stuck when I first saw :unfold was thinking of it as the opposite of :inject. Or at least, the opposite of how I used :inject. I tended to use :inject in a way that reduced information. For example:<pre><code><br />[7, 6, 10, 3, 9, 4, 8, 5, 2, 1].inject(&amp;'+')<br /></code></pre>This gives us the sum of the numbers from one to ten, as it happens. It also gives us a value that is considerably simpler than the list we used to generate the number. Information is lost when we use :inject to &#8220;reduce&#8221; a list to a very simple value. So my first reaction to :unfold was to think of ways to use :unfold on very simple values, like numerics.<br /><br />But :unfold doesn&#8217;t have to work with simple values. It can work with arbitraily complex data structures. Consider:<pre><code><br />def zip(*lists)<br />  lists.unfold(<br />      :while =&gt; '.first', <br />      :map =&gt; '.map(&amp;".first")',<br />      &amp;'_.reject(&amp;".length &lt; 2").map(&amp;"[1..-1]")')<br />end<br /></code></pre>Zip is a function that takes two (or more, but let&#8217;s just say two for now) lists, and produces a list of pairs of items. So:<pre><code><br />zip([:a, :b, :c], [1, 2, 3])<br />    =&gt; [[:a, 1], [:b, 2], [:c, 3]]<br /></code></pre>How does :unfold do it? First, of course, it makes a single list of lists. It then performs an unfold on this single data structure. The incrementor successively reduces each sublist by removing the first items. So the output of the successive incrementor operations is:<pre><code><br />[<br />    [[:a, :b, :c], [1, 2, 3]],<br />    [[b, :c],      [2, 3]]<br />    [[:c],         [3]]<br />]<br /></code></pre>The :map then extracts the first items from each sublist and presents them as a list:<pre><code><br />[<br />    [:a,           1], <br />    [:b,           2], <br />    [:c,           3]<br />]<br /></code></pre>Neat. But why do we care about zip? Well, if you&#8217;ll notice, we already have a bunch of really useful things we can do with lists, like :map, :select, :reject, :detect, and so on. What would you do if you had two lists and needed to do something with each pair in the list, like&#8230; A list of first names and surnames that need to be catenated together?<pre><code><br />zip(first_names, surnames).map(&amp;'"#{_[0]} #{_[1]}"')<br /></code></pre>Zip is useful when we have a bunch of parallel lists and there&#8217;s something we want to do with each tuple from the lists.<br /><br /><strong>Generalized iteration</strong><br /><br />We recognize this &#8220;pattern,&#8221; it&#8217;s one of the most powerful in programming. Zip was one algorithm, a way of iterating over several lists simultaneously. The other algorithm was <code>"#{_[0]} #{_[1]}"</code>, a recipe for what to do with the successive tuples of values.<br /><br /><div class="book"><hr/><em><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to functional programming techniques just like these.</em><hr/></div>The powerful idea was to separate the mechanics of turning a data structure into a linear series of values&#8212;iterating&#8212;from what we want to actually do with each value. (In OO-style programming, we would define a method for lists of lists that returns an iterator over the tuples of values. Same thing, proving that how you do it is not as important as understanding <em>why</em> you do it.)<br /><br />Unfold has other uses, but this one alone is worth the trouble to understand the pattern even if you aren&rsquo;t rushing to implement this exact unfold method: Converting a single data structure to a list is one way to implement iteration: for any data structure, you can use unfold to define a linear iteration. You can then use :each or :map or :inject just as our parents before us would have used DO or FOR loops.<br /><br />Consider this (inelegant, but I&#8217;m writing this rather late at night) unfold:<pre><code><br />[[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10].unfold(<br />  :while =&gt; '.first',<br />  :map =&gt; lambda { |first|<br />    first = first.first while first.kind_of?(Array)<br />    first<br />  }<br />) { |state|<br />  state = state.first + state[1..-1] while state.first.kind_of?(Array)<br />  state[1..-1]<br />}<br />    =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br /></code></pre>This is the same idea, only we convert a tree into a list representing a depth-first search of a simple tree. You may recognize it as Array&#8217;s :flatten method. Once again, it&#8217;s really a way of iterating over the elements of a tree. So one way to think of this :unfold is that it is an iterator over a tree&#8217;s leaves:<pre><code><br />def flatten(arr)<br />  arr.unfold(<br />    :while =&gt; '.first',<br />    :map =&gt; lambda { |first|<br />      first = first.first while first.kind_of?(Array)<br />      first<br />    }<br />  ) { |state|<br />    state = state.first + state[1..-1] while state.first.kind_of?(Array)<br />    state[1..-1]<br />  }<br />end<br /></code></pre><strong>But I already know how to write Zip and Flatten methods, honest I do.</strong><br /><br />Zip and Flatten <em>are</em> relatively common, that&rsquo;s why :flatten and :zip can both be found in Ruby&rsquo;s standard Array class. And if there&rsquo;s a data structure that needs regular unfolding, you ought to weigh the advantages and disadvantages of writing an :unfold for it or using more humdrum ways of writing an iterator.<br /><br /><div class="book"><hr/><em>  <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/uploaded_images/haskell_school_of_expression.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089">The Haskell School of Expression</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is a terrific and relatively jargon-free introduction to the language that popularized fold, unfold, and all of the other functional programming idioms. As Eric Kidd says, it will make your head explode. Recommended!</em><hr/></div>However, what do you do when you only need to unfold something once? For example, perhaps you have code that obtains some data in JSON format, and having used a library to parse the JSON into a one-off list or hash, you want to iterate through it.<br /><br />With unfold, you can write your one-time, specific iterator right in place. This is no different than using blocks and lambdas in Ruby for one-off functions that really don&rsquo;t need the cermony and weight of being implemented as methods.<br /><br />When you want to iterate through something, and you want to separate the mechanism for iterating through the data from what you do with the data, :unfold should be in your tool box.<br /><br /><strong>Unfold and the bio-sciences. Not really.</strong><br /><br />I like to think of :unfold like unfolding a protein molecule. When you stare at a data structure, it&#8217;s dense, opaque. But you supply an unfold algorithm, and what looked like a messy ball of twine unravels into a long filament made up of simple elements. You can then operate on the simple elements, without getting what you want to do en-snarled in how you iterate over the data structure.<br /><br />So there you have it. Unfold can be really useful if we see it as a standardized way to write iterators for data structures.<br /><br /><hr/><em>Update: <a href="http://citeseer.ist.psu.edu/283921.html">The under-appreciated unfold</a>.</em><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="permanent link">10:46 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, November 07, 2007</div>
			

			<div class="Post"><a name="5076659457761846917">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="permanent link">Really simple anamorphisms in Ruby</a></span>
					<div style="clear:both;"></div><a href="http://tunes.org/wiki/Morphism" title="Morphisms">Anamorphisms</a> are functions that map from some object to a more complex structure containing the type of the object. They are the dual&#8212;a fancy word for complement&#8212;of Catamorphisms, functions that map from some complex structure down to a simpler object.<br /><br />In simpler terms, a Catamorphism is a function like <strong>inject</strong>: In Ruby, Inject takes a collection and produces something simpler. It is also called <strong>fold</strong> or <strong>reduce</strong> in other languages. Inject can do something like produce the sum of a list:<br /><pre><code><br />(1..5).inject <a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="String#to_proc">&amp;'+'</a> =&gt; 15</code></pre><br /><strong>Unfold</strong> does the reverse: it takes a single value and turns it into a collection. Now, a proper unfold can be configured with a seed value, a transformation, a stopping predicate, maybe a distinction between states and output values, and even the type of structure you want to create. A proper unfold would even work with <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="Haskell, Ruby and Infinity">lazy lists</a> if it didn&#8217;t have a stopping condition.<br /><br />But sometimes you want something really simple. The state and the output value could be the same thing, eliminating a transformation from state to output. The stopping predicate could simple, it could stop when it reaches <strong>nil</strong>. And it could always return Arrays. So you could use such a simple unfold whenever you have a seed value and some sort of function (expressed as a block) that returns nil when it has no more values.<br /><br />For example:<br /><pre><code><br />10.unfold { |n| n-1 unless n == 1 }.inspect =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]<br />10.class.unfold(<a href="http://pragdave.pragprog.com/pragdave/2005/11/symbolto_proc.html" title="Symbol#to_proc">&amp;:superclass</a>).inspect =&gt; [Fixnum, Integer, Numeric, Object]</code></pre><br />Hey, what happens if you combine really simple anamorphisms with really simple catamorphisms?<br /><pre><code><br />5.unfold(&amp;'_-1 unless _==1').inject(&amp;'*') =&gt; 120</code></pre><br />Here is the code <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a>. (If <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html" title="Not all functions should be object methods">overloading core classes with too much responsibility</a> is not to your taste, it is trivial to express unfold as a function taking a seed and a block as arguments).<br /><br />Now that I&#8217;ve whet your appetite, here&#8217;re <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html">Really useful anamorphisms in Ruby</a>. And for another implementation, <a href="http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/1052c289b22c60a5" title="multiple blocks (unfold)">everything you ever wanted to know about implementing a true unfold in Ruby</a>.<br /><br />Enjoy!<br /><br />(Code courtesy of <a href="http://www.mcommons.com/about/jobs">Mobile Commons</a>. Thanks!)<br /><br /><br/><em>Here&rsquo;s an interesting email from Hugh Sasse:</em><br /><br /><blockquote>I was reading <a href="http://www.amazon.com/gp/product/0735619670?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0735619670">Code Complete 2</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0735619670" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> last night and Steve McConnell says that he wouldn&#8217;t hire a programmer who wrote a recursive factorial function. [I&#8217;m not sure that would be such a crime in languages like <a href="http://www.lua.org/" title="The Programming Language Lua">Lua</a> with proper tail recursion, but still. (I&#8217;m probably wrong, now I&#8217;ve written that! &#8220;Open mouth, insert foot, echo internationally&#8221; as they used to say on Fidonet :-))] I thought &#8220;that seems a bit harsh&#8221;, especially since in real life they&#8217;d get one from a library most of the time, anyway.<br /><br />So, as I have often run out of stack on Ruby, I&#8217;ve tried to rewrite <a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="Really simple anamorphisms in Ruby">unfold</a> as an iterative function. It seems to be working. The script as modified blows up at 5000 on my system with the recursive version, but the iterative version succeeds at 5000.<br /><br />Thanks for this blog entry. There&#8217;s something REALLY nice about this idea, which I can&#8217;t put my finger on. Might be something to do with loops terminating when they should, and The Pragmatic Programmers&#8217; article about &#8220;cook until done&#8221;<br /><br /><a href="http://www.pragprog.com/articles/cook-until-done" title="Cook Until Done">http://www.pragprog.com/articles/cook-until-done</a><br /><br />Unfold feels like a &#8220;do until finished&#8221; loop.<br /></blockquote><pre><code><br />class Object<br />  # As above, but iterative, rather than recursive.<br />  def unfold2 &block<br />    result = [self]<br />    x = block.call(self)<br />    while not x.nil?<br />      result.push x<br />      x = block.call(x)<br />    end<br />    return result<br />  end<br />end<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="permanent link">5:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, October 27, 2007</div>
			

			<div class="Post"><a name="6254612993372428372">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="permanent link">String#to_proc</a></span>
					<div style="clear:both;"></div><i>Breaking news! The irb enhancement gem <a href="http://raganwald.github.com/2007/12/utility-belt.html">Utility Belt</a> includes String#to_proc</i><br /><br />String#to_proc is an addition to Ruby&rsquo;s core String class to enable <a href="http://rickyclarkson.blogspot.com/2007/09/point-free-programming-in-java-7-beyond.html">point-free</a> <a href="http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)">hylomorphisms</a>&hellip;<br /><br />I&rsquo;ll start again. String#to_proc adds a method to Ruby&rsquo;s core String class to make lots of mapping and reducing operations more compact and <em>easier to read</em> by removing boilerplate and focusing on what is to be done. In many cases, the existing black syntax is just fine. But in a few cases, String#to_proc can make an expression <em>even simpler</em>.<br /><br />String#to_proc is a port of the String Lambdas from Oliver Steele&#8217;s <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">Functional Javascript</a> library. I have modified the syntax to reflect how String#to_proc works in Ruby.<br /><br />We&rsquo;ll start with the examples from String Lambdas so you can see what is actually going on. Then we&rsquo;ll look at how to use the <code>&</code> coercion to make working with arrays really simple.<br /><br /><code>to_proc</code> creates a function from a string that contains a single expression. This function can then be applied to an argument list, either immediately:<br /><pre><code><br />'x+1'.to_proc[2];<br />     → 3<br />'x+2*y'.to_proc[2, 3];<br />     → 8<br /></code></pre>or (more usefully) later:<br /><pre><code><br />square = 'x*x'.to_proc;<br />square(3);<br />     → 9<br />square(4);<br />     → 16<br /></code></pre><strong>Explicit parameters</strong><br /><br />If the string contains a <code>-&gt;</code>, this separates the parameters from the body.<br /><pre><code><br />'x y -&gt; x+2*y'.to_proc[2, 3];<br />     → 8<br />'y x -&gt; x+2*y'.to_proc[2, 3];<br />     → 7<br /></code></pre>Otherwise, if the string contains a <code>_</code>, it&#8217;s a unary function and <code>_</code> is name of the parameter:<br /><pre><code><br />'_+1'.to_proc[2];<br />     → 3<br />'_*_'.to_proc[3];<br />     → 9<br /></code></pre><strong>Implicit parameters</strong><br /><br />If the string doesn&#8217;t specify explicit parameters, they are implicit.<br /><br />If the string starts with an operator or relation besides <code>-</code>, or ends with an operator or relation, then its implicit arguments are placed at the beginning and/or end:<br /><pre><code><br />'*2'.to_proc[2];<br />     → 4<br />'/2'.to_proc[4];<br />     → 2<br />'2/'.to_proc[4];<br />     → 0.5<br />'/'.to_proc[2, 4];<br />     → 0.5<br /></code></pre>&#8217;.&#8217; counts as a right operator:<br /><pre><code><br />'.abs'.to_proc[-1];<br /> → 1<br /></code></pre>Otherwise, the variables in the string, in order of occurrence, are its parameters.<br /><pre><code><br />'x+1'.to_proc[2];<br />     → 3<br />'x*x'.to_proc[3];<br />     → 9<br />'x + 2*y'.to_proc[1, 2];<br />     → 5<br />'y + 2*x'.to_proc[1, 2];<br />     → 5<br /></code></pre><strong>Chaining</strong><br /><br />Chain <code>-&gt;</code> to create curried functions.<br /><pre><code><br />'x y -&gt; x+y'.to_proc[2, 3];<br />     → 5<br />'x -&gt; y -&gt; x+y'.to_proc[2][3];<br />     → 5<br />plus_two = 'x -&gt; y -&gt; x+y'.to_proc[2];<br />plus_two[3]<br />     → 5<br /></code></pre><strong>Using String#to_proc in Idiomatic Ruby</strong><br /><br />Ruby on Rails popularized <code>Symbol#to_proc</code>, so much so that <a href="http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l168" title="Changes in Ruby 1.9">it will be part of Ruby 1.9</a>.<br /><br />If you like:<br /><pre><code><br />%w[dsf fgdg fg].map(&amp;:capitalize)<br />    → ["Dsf", "Fgdg", "Fg"]<br /></code></pre>then <code>%w[dsf fgdg fg].map(&amp;'.capitalize')</code> isn&#8217;t much of an improvement.<br /><br />But what about doubling every value in a list:<br /><pre><code><br />(1..5).map &amp;'*2'<br />    → [2, 4, 6, 8, 10]<br /></code></pre>Or folding a list:<br /><pre><code><br />(1..5).inject &amp;'+'<br />    → 15<br /></code></pre>Or having fun with factorial:<br /><pre><code><br />factorial = "(1.._).inject &amp;'*'".to_proc<br />factorial[5]<br />    → 120<br /></code></pre>String#to_proc, in combination with <code>&amp;</code> coercing a value into a proc, lets you write compact maps, injections, selections, detections (and many others!) when you only need a simple expression.<br /><br />Caveats: String#to_proc uses <code>eval</code>. Cue the chorus of people&#8212;pounding away on quad 3Ghz systems&#8212;complaining about the performance. You&#8217;re an adult. Decide for yourself whether this is an issue. After <a href="http://www.yourdictionary.com/wotd/wotd.pl?word=manky">mankying</a> things about to deduce the parameters, String#to_proc evaluates its expression in a different binding than where you wrote the String. This matters if you include free variables. My thinking is that it ceases to be a simple, easy-to-understand hack and becomes a cyrptic nightmare once you get too fancy.<br /><br /><blockquote>You know that Voight-Kampff test of yours&#8230; did you ever take that test yourself?</blockquote><div style="text-align: right;">&#8212;Rachael, Blade Runner</div><br /><br />I have been using <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">Functional Javascript</a> for quite some time now, and I use the String Lambdas a lot. However, Ruby and Javascript are very different languages. Once you get out of the browser&#8217;s DOM, Javascript is a lot cleaner and more elegant than Ruby. For example, you don&#8217;t need to memorize the difference between a block, a lambda, and a proc. Javascript just has functions.<br /><br />However, Javascript is more verbose: Whereas in Ruby you can write <code>[1, 2, 3].map { |x| x*2 }</code>, if Javascript had a <code>map</code> method for arrays, you would still have to write <code>[1, 2, 3].map(function (x) { return x*2; })</code>. So it&#8217;s a big win to make Javascript less verbose: code is easier to read at a glance when you don&#8217;t have to wade through jillions of function keywords.<br /><br />Nevertheless, I still find myself itching for the String Lambdas when I&#8217;m writing Ruby code. It may be a matter of questionable taste, but for certain extremely simple expressions, I vastly prefer the point-free style. <code>(-3..3).map &amp;:abs</code> is shorter than <code>(-3..3).map { |x| x.abs }</code>.<br /><br />It is also cleaner to me. <code>abs</code> is a <em>message</em>, especially in a language like Ruby that supports the sending arbitrary messages named by symbols. Writing <code>(-3..3).map &amp;:abs</code> looks very much like sending the <code>abs</code> message to everything in the list. I don&#8217;t need an <code>x</code> in there to tell me that.<br /><br />Thus, I obviously like <code>(-3..3).map &amp;'.abs'</code>. But I like <code>(1..5).map &amp;'*2'</code> for the same reason. It isn&#8217;t just shorter, it hides a temporary variable that really doesn&#8217;t mean Jack to me when I&#8217;m reading the code. And quite honestly, <code>(1..10).inject { |acc, mem| acc + mem }</code> raises more questions than it answers about what <code>inject</code> does and how it does it. <code>(1..10).inject &amp;'+'</code> gets right down to business for me. I&#8217;d prefer that it be called &#8220;fold,&#8221; but the raw, naked <code>+</code> seems to describe what I want <em>done</em> instead of how I want the computer to do it.<br /><br />Symbol#to_proc also supports named parameters, either through implication (<code>&amp;'x+y'</code>) or with the arrow (<code>'x y -&gt; x*y'</code>). I haven&#8217;t thought of a case where that would be a win over using a Ruby block: <code>{ |x, y| x*y }</code>.<br /><br />I&#8217;m divided about the underscore notation. It seems like a good compromise for expressions where there is a single parameter and it doesn&#8217;t fall on the left or the right side of an expression. Standardizing on an unusual variable name is, I think, a win. Underscore often means a &#8220;hole&#8221; in an expression or a computation, so it feels like a good fit. I would honestly much rather see something like: <code>&amp;'(1/_)+1'</code> than <code>&amp;'(1/x)+1'</code>. The underscore jumps out in an obvious way, and it wouldn&#8217;t be magically clearer to write <code>{ |x| (1/x)+1 }</code>.<br /><br />That being said, I haven&#8217;t actually written an underscore expression yet in actual code, so far I&#8217;m getting by using the point-free expressions to simplify things and using Ruby blocks for everything else.<br /><br /><strong>RSpec</strong><pre><code><br />describe "String to Proc" do<br /><br />  before(:all) do<br />    @one2five = 1..5<br />  end<br /><br />  it "should handle simple arrow notation" do<br />    @one2five.map(&amp;'x -&gt; x + 1').should eql(@one2five.map { |x| x + 1 })<br />    @one2five.map(&amp;'x -&gt; x*x').should eql(@one2five.map { |x| x*x })<br />    @one2five.inject(&amp;'x y -&gt; x*y').should eql(@one2five.inject { |x,y| x*y })<br />    'x y -&gt; x**y'.to_proc()[2,3].should eql(lambda { |x,y| x**y }[2,3])<br />    'y x -&gt; x**y'.to_proc()[2,3].should eql(lambda { |y,x| x**y }[2,3])<br />  end<br /><br />  it "should handle chained arrows" do<br />    'x -&gt; y -&gt; x**y'.to_proc()[2][3].should eql(lambda { |x| lambda { |y| x**y } }[2][3])<br />    'x -&gt; y z -&gt; y**(z-x)'.to_proc()[1][2,3].should eql(lambda { |x| lambda { |y,z| y**(z-x) } }[1][2,3])<br />  end<br /><br />  it "should handle the default parameter" do<br />    @one2five.map(&amp;'2**_/2').should eql(@one2five.map { |x| 2**x/2 })<br />    @one2five.select(&amp;'_%2==0').should eql(@one2five.select { |x| x%2==0 })<br />  end<br /><br />  it "should handle point-free notation" do<br />    @one2five.inject(&amp;'*').should eql(@one2five.inject { |mem, var| mem * var })<br />    @one2five.select(&amp;'&gt;2').should eql(@one2five.select { |x| x&gt;2 })<br />    @one2five.select(&amp;'2&lt;').should eql(@one2five.select { |x| 2&lt;x })<br />    @one2five.map(&amp;'2*').should eql(@one2five.map { |x| 2*x })<br />    (-3..3).map(&amp;'.abs').should eql((-3..3).map { |x| x.abs })<br />  end<br /><br />  it "should handle implied parameters as best it can" do<br />    @one2five.inject(&amp;'x*y').should eql(@one2five.inject(&amp;'*'))<br />    'x**y'.to_proc()[2,3].should eql(8)<br />    'y**x'.to_proc()[2,3].should eql(8)<br />  end<br /><br />end</code></pre>Go ahead, download the <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">source code</a> for yourself.<br /><hr/><em>Update: <a href="http://raganwald.github.com/2007/11/fun-with-symboltoproc.html">Reg smacks himself in the head!</a></em><br /><br />I had a look at the source code for <code>Symbol#to_proc</code>:<pre><code><br />class Symbol<br />  # Turns the symbol into a simple proc, which is especially useful for enumerations. Examples:<br />  #<br />  #   # The same as people.collect { |p| p.name }<br />  #   people.collect(&:name)<br />  #<br />  #   # The same as people.select { |p| p.manager? }.collect { |p| p.salary }<br />  #   people.select(&:manager?).collect(&:salary)<br />  def to_proc<br />    Proc.new { |*args| args.shift.__send__(self, *args) }<br />  end<br />end<br /></code></pre>Look at that: Although the examples are all of unary messages like <code>.name</code>, the lambdas created handle methods with arguments. And since almost everything in Ruby is a method, including operators like <code>+</code>&hellip; You can use Symbol#to_proc to do some of the point-free stuff I like:<pre><code><br />[1, 2, 3, 4, 5].inject(&:+)<br />     → 15<br />[{ :foo => 1 }, { :bar => 2 }, { :blitz => 3 }].inject &:merge<br />     → {:foo=>1, :bar=>2, :blitz=>3}<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="permanent link">11:22 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, October 26, 2007</div>
			

			<div class="Post"><a name="3596521528719407366">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/10/sneak-preview.html" title="permanent link">map(&"(1.._).inject(&'*')")</a></span>
					<div style="clear:both;"></div>Some working Ruby code:<pre><code><br /> (1..3).map(&amp;'*2') =&gt; [2, 4, 6]<br /> (1..3).map(&amp;'[-1, _, 0]') =&gt; [[-1, 1, 0], [-1, 2, 0], [-1, 3, 0]]<br /> (1..3).map(&amp;'x -&gt; y -&gt; x * y').map(&amp;'[2]') =&gt; [2, 4, 6]<br /> (1..5).select(&amp;'&gt;2') =&gt; [3, 4, 5]<br /> (1..3).map(&amp;'x -&gt; y -&gt; x * y').map(&amp;'.call(2)') =&gt; [2, 4, 6]<br /> [5].map(&"(1.._).inject(&'*')") => [120]</code></pre><br /><br />See <a href="http://raganwald.github.com/2007/10/stringtoproc.html">String#_to_proc</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/10/sneak-preview.html" title="permanent link">10:53 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, September 27, 2007</div>
			

			<div class="Post"><a name="8378328582722123438">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/09/java-is-right-answer-to-wrong-question.html" title="permanent link">Java is the right answer to the wrong question, Ruby is the wrong answer to the right question</a></span>
					<div style="clear:both;"></div><blockquote>Large code bases are the problem, not the language they&rsquo;re written in. Find a way to break/decompose big code bases into little ones.<br /></blockquote><div style="text-align: right;"><a href="http://dehora.net/journal/">Bill de h&Oacute;ra</a>, calming a <a href="http://beust.com/weblog/archives/000462.html">heated debate</a></div><br /><br />Can we please stop calling each other silly names over the languages we choose and move on to calling each other silly names over our choices for writing literate programs, eliminating redundancy, decoupling modules from each other, and so forth?<br /><br />The very next time you find yourself being drawn into a debate about Java vs. Ruby, try saying something obscure, such as, <em>Java is the right answer to the wrong question, Ruby is the wrong answer to the right question</em> and see if you can redirect the energy towards exploring new ground instead of stagnating in the same old tired place.<br /><br /><blockquote>Do not follow in the foot steps of the Sages. Seek what they sought.</blockquote><br />When we argue Java vs. Ruby, or testing vs. type checking, we are arguing about foot steps. Take the debate to the next level. What is it we are trying to accomplish with those features? What are we seeking?<br /><br />My favourite example of this is the subject of automatic <a href="http://www.amazon.com/gp/product/0201485672?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201485672" title="Refactoring: Improving the Design of Existing Code">refactoring</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0201485672" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. My current text editor doesn&rsquo;t perform automatic refactoring (ducks). Are you about to blast a flaming comment or perhaps an entire blog post explaining what a dunderhead I am for not using an IDE that can move a method with a single dialog box?<br /><br />Stop for a moment. <em>Why</em> do we move methods? <a href="http://steve.yegge.googlepages.com/transformation" title="Transformation, by Steve Yegge">What are we trying to accomplish?</a> What is it about our code after we have refactored that makes the code better? Now you have a really juicy comment to make, a deep and insightful point of view to bring to a discussion. Let&rsquo;s talk about that quality of good code first, and then we can talk about how to get there later, if ever.<br /><br />So the next time you read that &ldquo;Strong, static typing is superior because it enables the IDE to provide automatic refactoring support,&rdquo; take a deep breath. Don&rsquo;t nod and agree. Don&rsquo;t shake your head and disagree. Ask a polite question: <em>What are we trying to accomplish with automatic refactoring?</em> And when told that &ldquo;Unit tests are superior to compiler type checking for catching bugs,&rdquo; don&rsquo;t settle for &ldquo;catching bugs&rdquo; as axiomatic. Ask what quality <em>really</em> means for code.<br /><br />Nothing is going to save us from <a href="http://www.youtube.com/watch?v=OYecfV3ubP8" title="Apple's 1984 Macintosh commercial on Youtube">talking ourselves to death</a>. But at least we can debate at a higher level of abstraction.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/09/java-is-right-answer-to-wrong-question.html" title="permanent link">7:02 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, September 16, 2007</div>
			

			<div class="Post"><a name="5490141566327061228">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/09/breaking-news-write-ruby-function-win.html" title="permanent link">Breaking News: Write a Ruby function. Win a $100 Bounty!</a></span>
					<div style="clear:both;"></div><em>I just spotted this on the <a href="http://groups.google.com/group/torror?hl=en">Toronto Ruby on Rails</a> mailing list:</em><br /><br /><hr><br />/me thinks it&#8217;s too quiet here. Time for a Sunday afternoon ruby<br />challenge!<br /><br />$100 for the best implementation, good until 6pm tonight (September 16, 2007).<br /><br />THE PROBLEM<br /><br />Marcel&#8217;s Amazon S3 gem presents files stored in a bucket as an object<br />which exposes a key attribute that conceptually map to the idea of a<br />file in a filesystem. You can fake a folder hierarchy by uploading 0<br />byte files with a key ending in a / (eg. folder1/ )<br /><br /><div class="book"><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to dynamic programming techniques just like these.<br><br></div>Your mission is to convert the objects array of an S3 bucket to a<br />Hash, so that we can present a tree view to the user. It should<br />support an arbitrary depth, and make good use of Ruby best practices.<br /><br />THE TEST DATA<br /><br />Let&#8217;s assume you have a bunch of items in a bucket, and if you iterate<br />through the item keys, you&#8217;ll get this list:<br /><pre><code><br />folder1/<br />folder2/<br />folder2/folder4/<br />folder2/folder5/<br />folder2/folder5/temp6.txt<br />folder2/temp3.txt<br />folder2/temp4.txt<br />folder2/temp5.txt<br />folder3/<br />folder3/temp7.txt<br />temp1.txt<br />temp2.txt<br /></code></pre><br />This covers all cases; a hierarchy of files in folders, including<br />files in the root and empty folders.<br /><br />THE SOLUTION<br /><pre><code><br />results = {<br /> "temp1.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;,<br /> "temp2.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;,<br /> "folder1" =&gt; {},<br /> "folder2" =&gt; {<br />   "temp3.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;,<br />   "temp4.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;,<br />   "temp5.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;,<br />   "folder4" =&gt; {},<br />   "folder5" =&gt; {<br />     "temp6.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;<br />   },<br /> },<br /> "folder3" =&gt; {<br />   "temp7.txt" =&gt; #&lt;AWS::S3::S3Object:0x31ab7bc&gt;<br /> }<br />}<br /></code></pre><br />In other words, for each item in the hash, the name is the key without<br />any preceding path, and the value is the AWS::S3::S3Object that the<br />key points to. (I just pasted the same object in the example.)<br /><br />And&#8230; go!<br /><br />Pete Forde, <a href="http://unspace.ca/" title="Unspace">unspace.ca</a><br /><br /><hr><br /><em>Do you want to win the $100? Pete told me that your solution is eligible to win provided you post it to the TorROR <a href="mailto:torror@googlegroups.com">mailing list</a> by 6PM, September 16th, 2007 (EST). For more details, see the <a href="http://groups.google.com/group/torror?hl=en">TorROR Google Group</a>.</em><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/09/breaking-news-write-ruby-function-win.html" title="permanent link">2:07 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, April 13, 2007</div>
			

			<div class="Post"><a name="8074916481331990114">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/04/from-abstraction-to-zipf.html" title="permanent link">From Abstraction to Zipf</a></span>
					<div style="clear:both;"></div><em>Alpha&#8230;</em><br /><br /><a href="http://damienkatz.net/" title="Damien Katz">Damien Katz</a> raised an interesting question the other day: he wondered whether elements of computer programs followed a <a href="http://en.wikipedia.org/wiki/Zipf's_law" title="Zipf's law - Wikipedia, the free encyclopedia">Zipf distribution</a>. In other words, he wondered whether the most frequently used item occurred a lot more than the next most frequent, which occurs a lot more than the third most frequent, and so forth.<br /><br />That&#8217;s an interesting question. Is it true? And if it is, what does that tell us about composing programs?<br /><br />Looking at computer programs, some things seem to follow Zipf&#8217;s law and others don&#8217;t. In C++ programs, loop indices called <code>i</code> probably are an order of magnitude more common than those called <code>j</code>. Unless you use <a href="http://www.joelonsoftware.com/articles/Wrong.html" title="Making Wrong Code Look Wrong - Joel on Software">Apps Hungarian</a>, of course. But are <code>for</code> loops that much more common than <code>if</code> statements? That might vary from place to place within a single program, but overall they might be roughly equal in frequency.<br /><br />If we step up a level and look at idioms, my gut tells me that there is a strong Zipf distribution. Although each program will differ, some programs might make heavy use of lists, others of maps. Some might do a lot with closures, others with objects. These are fairly generic, of course.<br /><br />If we have a look at the more domain-specific items in a program, we really see a Zipf distribution. Some things pop up again and again and again in a program, others are rare.<br /><br /><strong>Why Abstract?</strong><sup>1</sup><br /><br />The most important tool we have for composing programs is <em>abstraction</em>. When we create an abstraction for something, we get one and a half wins (a <a href="http://en.wiktionary.org/wiki/sesqui-" title="sesqui- - Wiktionary">sesqui</a>-win).<br /><br /><div class="book"><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to implement advanced ideas like metaprogramming.<br /><br /></div>The full win is that we get to take a common element and place its responsibility in once place. For example, if your language gives you a <code>map</code> function or method, there is one place for the code that applies a function to each element of a collection and produces a collection of the results. Unlike a &#8220;pattern,&#8221; you don&#8217;t have to re-implement map every time you use it, you just use it. The centralization of responsibility in a single place is very powerful way to <a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html" title="Why Why Functional Programming Matters Matters">separate concerns</a>.<br /><br />The half win is that we don&#8217;t need to understand its implementation, we only need to understand its interface. I honestly don&#8217;t know whether Ruby&#8217;s built-in <code>map</code> method applies itself to a collection one at a time from the start to the end or in some other order. I suspect it&#8217;s from start to end for ordered collections, but I don&#8217;t know and I don&#8217;t have to know.<br /><br />This is only half a win, because for anything too complicated to explain on a PowerPoint slide where you are promising the newest silver bullet, abstractions have a nasty habit of leaking. <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html" title="The Law of Leaky Abstractions - Joel on Software">Leaky abstractions</a> force you to understand the implementation to use them.<br /><br />There are some drawbacks to abstractions. As noted, sometimes the abstraction leaks. In that case, you often have to look up what an abstraction does. If there was no abstraction and the implementation was right there in the middle of your code, you wouldn&#8217;t have to look it up. So when you see:<br /><br /><pre><code>class BlogPost &lt;&lt; ActiveRecord::Base<br />    has_many :comments<br />    # ...<br />end<br /></code></pre><br />You obviously to need to know that <code>has_many</code> creates methods like <code>comments</code>, <code>comment_ids=</code> and <code>comments&lt;&lt;</code> automagically for you. In fact, that is kind of the point of <code>has_many</code>. But if you are doing anything non-trivial, you also need to know whether <code>has_many</code> actually <em>defined</em> <code>comments</code>, <code>comment_ids=</code> and <code>comments&lt;&lt;</code> or whether it has merely modified <code>BlogPost</code> to <em>handle</em> those messages. In that sense, the abstraction leaks.<br /><br />You get much the same thing if you build a Java class hierarchy that is umpteen levels deep festooned with abstract base classes, factories, and dependency injection. In one sense you get a really tight abstraction. In another sense, you have a big leak: you need to know its internals to get any real work done.<br /><br />Another drawback to abstractions fall out of their strength. If you haven&#8217;t seen a particular abstraction before, you don&#8217;t know what it does and how it works. Contrary to popular hype, self-documenting names are not enough. If you are a Rails user, raise your hand if you can tell me what all of the various options for <code>has_many</code> are and what they do. You have to learn each abstraction&#8217;s interface, just as you had to learn what a <code>for</code> loop does for you.<br /><br />The win (not having to know how it works) is also a loss (not knowing what it does).<br /><br /><strong>An abstraction is an abstraction is an abstraction</strong><br /><br />I think most people agree that named subroutines (or functions, or procedures) are an excellent abstraction. First-class functions and anonymous functions seem to be an acquired taste (just one taste, and your programs will quickly acquire them). Objects&#8212;in the strong sense of polymorphic programs&#8212;are well-regarded abstractions.<br /><br /><blockquote>Macros, DSLs, and other means of writing your own mini-language provoke the wildest claims of productivity and equally baseless fears of unreadable, fragile, &#8220;magic&#8221; code built out of gossamer dreams.</blockquote><br /><br />What these all have in common is that these functional abstractions live happily within the syntax provided by the host programming language. They abstract function without abstracting syntax. For the most part, non-syntactic abstraction is uncontroversial.<br /><br />There seems to be debate over syntactic abstraction. Macros, DSLs, and other means of writing your own mini-language provoke the wildest claims of productivity and equally baseless fears of unreadable, fragile, &#8220;magic&#8221; code built out of gossamer dreams. The basic &#8220;problem&#8221; with syntactic abstractions like <code>has_many</code> in Rails or <code>let</code> in Scheme is that syntactic abstractions force you to learn their interface.<br /><br />They are right in your face, especially if they are very brief. Consider:<br /><br /><pre><code>BlogPost.find_or_create_by_name('From Abstraction to Zipf').comments &lt;&lt; Comment.new('bleh!', 'anonymous')<br /></code></pre><br />Don&#8217;t bother searching for the <code>find_or_create_by_name</code> method or the <code>comments&lt;&lt;</code> method in the code base.<br /><br />All the same, syntactic abstractions are <em>just like</em> functional abstractions. You get some wins, and you pay some costs in understanding and potential &#8220;leakiness.&#8221;<br /><br /><strong>Zipf to the rescue</strong><br /><br />So should we zealously abstract everything we can? Or should we conservatively avoid &#8220;magic&#8221; like syntactic abstractions?<br /><br />Every abstraction has a fixed learning cost. That cost is amortized over all of the instances we&#8217;ll encounter. So you need to learn how <code>has_many</code> works just once, and then you benefit every time you read it or write it. This is why abstractions built into a programming language are big wins: you amortize their cost over every program written in the language. Isn&#8217;t that why Java and C# look so much like C++ which looks so much like C? They were offering abstractions that have been paid up for years.<br /><br /><blockquote>Zipf&#8217;s law tells us that each application only needs a very few new kinds of abstractions to get most of the benefits. There are only a few low-hanging fruits, but each is plump and juicy.</blockquote><br /><br />An abstraction built into a framework like <code>Rinda</code> or <code>MapReduce</code> is amortized over fewer programs. A domain-specific abstraction for a single organization is amortized over a very few programs, and an abstraction built into one program is only amortized over instances in the one code base. Unsurprisingly, opportunities for abstraction follow the Zipf distribution.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262610744"><img border="0" src="http://raganwald.github.com/uploaded_images/art_of_mop.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262610744" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262610744">The Art of the Metaobject Protocol</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262610744" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is one of the most important books ever written on the subject of building abstractions with objects. If the idea that there is more than one way to structure objects and classes seems surprising, then learning about the Meta-Object protocol will teach you what your language has kept secret.<br /><br /></div>Of course, that distribution is self-similar: the abstractions <em>within a program</em> follow the same distribution as the abstractions <em>within an organization</em>. So even if you aren&#8217;t inventing a new programming language, Zipf can help.<br /><br />Quite simply, it pays to aggressively abstract the few things that are encountered the most frequently. In a CRUD web application, schema relationships like <code>belongs_to</code> are incredibly frequent. There&#8217;s a big win from creating a syntactic abstraction, even if the learning curve looks daunting to newcomers. Creating a domain-specific language for database schema changes is also a big win.<br /><br />Note that we aren&#8217;t saying that <code>has_one</code>, <code>belongs_to</code>, and <code>has_many</code> appear more than 50% of the time. They may be quite infrequent. The point is that they are far more frequent than something else you could abstract, and the other thing will take just as much time to learn to read but will pay off far less often.<br /><br />But should you create a DSL for <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html">list comprehensions</a> in your CRUD application or just use the language&#8217;s built-in collections? I would say, you would need an application that uses an awful lot of lists before a syntactic abstraction for lists is a win.<br /><br />It might be, but the nice thing is, it probably won&#8217;t be close: Zipf&#8217;s law tells us that each application only needs a very few new kinds of abstractions to get most of the benefits. There are only a few low-hanging fruits, but each is plump and juicy.<br /><br /><em>&#8230;Omega</em><br /><br />I think it is a win to use aggressive abstraction techniques like metaprogramming, but only if you restrain yourself to abstracting the very few things that appear most frequently in your code base. The things that are used less frequently should be abstracted using less aggressive techniques.<br /><br />The resulting program may not be magically 50% shorter than an unabstracted program, because the &#8220;long tail&#8221; of idioms and patterns are simply not worth abstracting away even though we have the tools for doing so.<br /><br />You can probably tell whether a program has the proper level of abstraction just by checking its distribution.<br /><br />If you find a big abstraction framework for one thing while frequently used idioms are expressed using patterns instead of abstractions, you are probably looking at an improperly abstracted program. You have to wade through verbiage to read everything, and the one time you don't need to abstract the code away, you have to chase definitions through indirection.<br /><br />And in a well-written program, I would expect that the things that occur most frequently are expressed at the highest and most powerful levels of abstraction, while things that happen infrequently are expressed in a more direct and explicit way. Such a program would be easy to read throughout.<br /><br /><hr /><br /><ol><li><a href="http://www.amazon.com/gp/product/B000NK48VO?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000NK48VO">Why Abstract?</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=B000NK48VO" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is a delightful and wonderfully brief book that explains the appeal of abstract art in a simple and direct way. It&#8217;s one of the treasures on my bookshelf and I urge you to find a copy through a used book seller.</li><br /><li>Suprised? There is no footnote two. But if there was, it would be to mention that Paul Graham&rsquo;s incredible book <a href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0130305529">On LISP: Advanced Techniques for Common LISP</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0130305529" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is <a href="http://www.bookshelf.jp/texi/onlisp/onlisp.html">freely available online</a>. This is a <em>must read</em> for anyone interested in composing syntactic abstractions in any language.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/04/from-abstraction-to-zipf.html" title="permanent link">12:52 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, March 16, 2007</div>
			

			<div class="Post"><a name="6177546136968725833">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html" title="permanent link">An Approach to Composing Domain-Specific Languages in Ruby</a></span>
					<div style="clear:both;"></div><em>Whoa! This looks like a long post with a lot of code snippets. Am I going to have to do a lot of hard thinking, or can I just relax and enjoy a good rambling essay?</em><br /><br />This is a bit long, probably (like all my posts) 200% longer than necessary. If you just want to see a neat DSL that implements Haskell and Python&rsquo;s List Comprehensions written in Ruby, just <a href="#lcir">scroll to the bottom</a>.<br /><br /><em>If I do bother to read it all, will I learn some neat hacks?</em><br /><br />Yes, but you could learn them just as well by reading the <a href="#dslsource">source code</a> directly.<br /><br /><em>So the benefit of reading the whole thing is...?</em><br /><br />The List Comprehensions DSL is the <strong>what</strong>. The source code is the <strong>how</strong>. But the essay is the <strong>why</strong>.<br /><br />Reading the whole thing will take you through some of the pitfalls of writing DSLs and explain why I chose my particular workarounds.<br /><br />Furthermore, <a href="http://raganwald.github.com/2007/02/why-ruby-is-not-acceptable.html">there are a lot of corners in Ruby where you can easily assume that things work one way, but really they don&rsquo;t</a>. If you actually try the snippets on your computer, you&rsquo;ll have a much better chance of remembering where the pitfalls are. That&rsquo;s why I tried to give a working example for every point, rather than just explaining things in words.<br /><br />Of course, if you have no interest in writing your own Domain Specific Languages in Ruby just yet... this isn&rsquo;t meant as a <em>popular</em> essay, rather it&rsquo;s meant as an experience report for fellow <em>practitioners</em>. And honestly, there&rsquo;s a world market for maybe five tools for writing DSLs in Ruby.<br /><br />But since you&rsquo;re here, the essay starts below!<br /><br /><hr/><br /><strong>An Approach to Composing Domain-Specific Languages in Ruby</strong><br /><br />Ruby is often touted as a good language for writing Domain-Specific Languages (&#8220;DSLs&#8221;). There are a few arguments in favour of writing a DSL as part of an application.<br /><br />The first argument that comes to mind is that if the application&#8217;s domain experts have a specific natural language or jargon of their own, writing a DSL makes it easy for programmers and domain experts to collaborate. While it is rare to find substantial applications entirely written by non-programmers at this time in <em>any</em> language, it is quite feasible for non-programmers to write or validate portions of an application representing its &#8220;business rules&#8221; or domain logic, while programmers maintain its infrastructure.<br /><br /><pre><code>    include StarbucksDSL<br />    order = latte venti, half_caf, non_fat, no_foam, no_whip<br />    print order.prepare<br /></code></pre><p style="text-align: right;">&#8212;<a href="http://obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf">Building Domain Specific Languages in Ruby</a></p><br />Another argument in favour of a DSL is that even when non-programmers are not involved directly in coding an application, the programmers themselves often have a jargon of their own to describe entities, algorithms and data structures in the application. Having portions of the application written in a language closely resembling the programmer&#8217;s own jargon makes it easy for them to read each other&#8217;s work and understand its intent.<br /><br />Successful examples of DSLs embedded within existing languages and frameworks include <a href="http://www.rubyonrails.org/">Ruby on Rails</a>&#8217; ActiveRecord, where statements such as:<br /><br /><pre><code>    has_and_belongs_to_many :Bar<br />    validates_presence_of :blitz<br />    some_bars = Bar.find_by_tavern_license(license_number)<br /></code></pre><br />Are self-documenting to anyone familiar with relational models.<br /><br />The final argument I&#8217;ll repeat here is that a DSL is a very effective way to separate the <em>what</em> from the <em>how</em> of an algorithm. <a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Separation of concerns is a desirable property of good programs</a>, and DSLs provide this separation very clearly. In the ActiveRecord examples above, the exact mechanisms of relating tables, validating records, and performing searches is &#8220;abstracted away&#8221; from the code where the programmer declares how she would like the results used.<br /><br /><strong>Freedom is Slavery</strong><br /><br />DSLs can be hacked together quickly in Ruby (whether they can be made sufficiently robust for your production needs may require considerably more care). Hacking a DSL together with little effort is a benefit, especially when prototyping: sometimes the best way to design a DSL is to try to use it, so you can discover what you need to express.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0672328844"><img border="0" src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to dynamic programming techniques just like these.<br /><br /></div>Some developers have raised the concern that extensive use of &#8220;magic&#8221; features leads to code that cannot be understood or maintained.<sup>1</sup> My own feeling is that DSLs lead to code that is easier to understand, not more difficult to understand. This leaves an argument about maintenance. Some techniques for meta-programming, such as extending core classes like Array, have what you might call &#8220;non-local effects.&#8221;<br /><br />For example, two different pieces of code might try to extend the same core class, interfering with each other. Each works in isolation and passes all of its unit tests. But when plugged into a larger application that uses them together, they break.<br /><br /><blockquote><br />  Lispers are among the best grads of the Sweep-It-Under-Someone-Else&#8217;s-Carpet School of Simulated Simplicity.<br /></blockquote><br /><p style="text-align: right;">&#8212;Larry Wall</p><br />Another problem occurs with extending the <code>Kernel</code> class or creating &#8220;top level&#8221; methods to be used as verbs in a DSL. You end up with name space crowding: you must be very careful that you do not redefine en existing method.<br /><br />To fix this problem, the code that implements the DSL needs to be contained so that it does not interfere with other code. We can still implement verbs as methods, but we must implement those methods in separate objects, classes, or modules.<br /><br /><strong>Zen in the Art of Program Maintenance</strong><br /><br />An established technique for implementing methods in objects is to define the methods and then execute a block of code using <code>instance_eval</code> so that it has access to the object&#8217;s methods.<br /><br /><blockquote><br />  I&#8217;m trying to get the Zen of building DSLs using Ruby. After reading a dozen or so pieces referenced by my favourite search engine, I have a feeling I&#8217;m still not quite getting it.<br /></blockquote><br /><p style="text-align: right;">&#8212;<a href="http://pluralsight.com/blogs/dbox/archive/2006/05/07/22985.aspx">Don Box</a></p><br />You know, code expresses an idea better than words express an idea&#8230; when the idea is about coding. Please try this example in irb. Don&#8217;t just skim the text and nod: there&#8217;s a powerful learning mechanism at work when you physically do things as you&#8217;re learning, even if it&#8217;s just copying, pasting, comparing the result in one window to the text in another, and so on:<br /><br /><pre><code>def bjarne<br />    'Barney'<br />end<br /><br />dsl = Object.new<br />def dsl.phred<br />    'Fred'<br />end<br /><br />plus = ' plus '<br /><br />print dsl.instance_eval {<br />    phred + plus + bjarne<br />}<br />##### "Fred plus Barney"<br /></code></pre><br />What does this show? Well, we have created a way to use a method defined in our <code>dsl</code> object, a local variable <code>plus</code>, and a top-level method <code>bjarne</code>. We can imagine scaling this up to defining a rich DSL in our DSL object and being able to mix verbs from the DSL with instance variables and other methods as we please.<br /><br />Touching back on the subject of containment, we have defined <code>bjarne</code> in <code>Kernel</code>. Now <code>bjarne</code> is essentially global. If we already defined <code>bjarne</code> somewhere else, we just clobbered it. And if we later run a piece of code that defines <code>bjarne</code>, we&#8217;ll clobber our own version. <code>phred</code> is different. It&#8217;s defined inside of an object, and it doesn&#8217;t conflict with any other <code>phred</code> we define elsewhere.<br /><br />Great! So&#8230; Can we cite a few examples of this technique in action (such as <a href="http://weblog.jamisbuck.org/2006/4/20/writing-domain-specific-languages">Jamis&#8217; post</a> where he calls <code>phred</code> and <code>bjarne</code> examples of <em>Sandboxing</em> and <em>Top-level methods</em>) and end the post here?<br /><br />No. The code above looks fine. But there is a hidden problem with this sandboxing technique:<br /><br /><pre><code>MyDsl = Object.new<br /><br />def MyDsl.phred<br />    'Fred'<br />end<br /><br />class ClientCode<br /><br />    def bjarne<br />        'Barney'<br />    end<br /><br />    def friends<br />        plus = ' plus '<br />        MyDsl.instance_eval { phred + plus + bjarne }<br />    end<br /><br />end<br /><br />ClientCode.new.friends<br />##### -:15:in `friends': undefined local variable or method `bjarne' for # (NameError) from -:15:in `friends' from -:20<br /></code></pre><br /><a href="http://worsethanfailure.com">WTF</a>?! This looks just like our top-level example, but we&#8217;ve placed our code inside of a <code>ClientCode</code> method. And <code>bjarne</code> is a method in ClientCode: this way we can continue to separate concerns, keeping <code>phred</code> inside our DSL and <code>bjarne</code> inside of the class where we are using the DSL. But it doesn&#8217;t work.<br /><br /><strong>Why <code>instance_eval</code> breaks (in tedious detail)</strong><br /><br />As you know, everything in Ruby is either a variable or a method (how it figures out the difference is a major irritation). When you invoke a method, you are actually sending a <em>message</em> to a <em>receiver</em>.<sup>2</sup> Sometimes you name the receiver (<code>some_object.a_method</code>), and there is no ambiguity.<br /><br />But when you just name the method (like <code>bjarne</code>), Ruby tries to find the method for itself. It does so by looking to see whether it is an instance method, in which case it behaves like <code>self.bjarne</code>. If not, it looks to see whether <code>bjarne</code> is top-level, in which case it calls that method in the <code>Kernel</code>. See for yourself:<br /><br /><pre><code>def foo<br />  'top level foo'<br />end<br /><br />def bar<br />  'top level bar'<br />end<br /><br />class Test<br />  def bar<br />    'instance method bar'<br />  end<br />  def test<br />    p foo<br />    p bar<br />  end<br />end<br /><br />Test.new.test<br />##### "top level foo" "instance method bar"<br /></code></pre><br />See? It looks for instance methods and then for top-level methods if it can&#8217;t find anything. (Again, we are hand-waving over the pesky problem with instance variables in the case where we don&#8217;t use <code>()</code>). What&#8217;s the problem? Well, I actually mis-described what happens. Here it is again, with more precision:<br /><br />It looks for methods defined in the object <code>self</code>, and then for top-level methods if it can&#8217;t find anything. Of course, <code>self</code> is the current object. Unless it isn&#8217;t: That&#8217;s what <code>instance_eval</code> does: it evaluates a block but it changes <code>self</code> to point to its receiver instead of the object where the code is executing. Everything else stays the same. One more example to show the mechanism:<br /><br /><pre><code>def foo<br />  'top level foo'<br />end<br /><br />def bar<br />  'top level bar'<br />end<br /><br />class Test<br />  def bar<br />    'instance method bar'<br />  end<br />  def blitz<br />    'current object blitz'<br />  end<br />  def test<br />    p foo<br />    p bar<br />    o = Object.new<br />    def o.blitz<br />        'redefined self blitz'<br />    end<br />    p o.instance_eval { blitz }<br />    p o.instance_eval { 'bar within o gives: ' + bar }<br />  end<br />end<br /><br />Test.new.test<br />##### "top level foo" "instance method bar" "redefined self blitz" "bar within o gives: top level bar"<br /></code></pre><br />Now we see: when we use <code>instance_eval</code>, we route around our current object and all of our methods are ignored within the block. Ruby really only has two levels of scope: whatever belongs to self and whatever belongs to Kernel.<br /><br />This state of affairs is unsatisfactory: we would like to introduce a DSL in such a way that we retain access to all of our methods without kludges (like storing the current object in an instance variable).<br /><br /><strong>Nesting Scopes</strong><br /><br /><div class="book"><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://raganwald.github.com/uploaded_images/seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is devoted to the myriad uses of first class functions. This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will be able to compose programs from functions in powerful new ways.<br><br></div>You can think of the current <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29">scope</a> as being nested inside of the top-level scope. <code>instance_eval</code> doesn&#8217;t change the scope for things like local variables, it just points <code>self</code> elsewhere.<br /><br />What we want is a new scope for our DSL nested inside of the current scope. So when we search for a method, we should check the DSL. If we don&#8217;t find it there, check the current object&#8217;s scope. If we don&#8217;t find it there, check the top-level.<br /><br /><blockquote><br />  Those who do not learn from the History of Lisp are doomed to repeat it.<br /></blockquote><br />Oops. <a href="http://www-formal.stanford.edu/jmc/">John McCarthy</a> called from 1960. He wants Lisp&#8217;s <em>dynamic scoping</em> back. Yes, our new feature is almost fifty years old. This is why either a through grounding in CS theory or a hobbyist&#8217;s interest in the history of programming are important for programming: much of what we want to do has already been done before, and sometimes in unexpected contexts. Who would have thought that a technique for helping programmers collaborate with Bond Traders has roots in Lisp 1.5?<br /><br /><a href="http://weblog.raganwald.com/source/dsl_and_let.html">Here&#8217;s an implementation of a nested scope construct</a> that does exactly what we want. You declare a new class that extends <code>DomainSpecificLanguage</code>, and then you can use methods from your DSL, from your current object, and from the top-level (if you so choose). For example:<br /><br /><pre><code>require 'dsl'<br /><br />class MyDSL &lt; DomainSpecificLanguage<br /><br />  def bjarne<br />    'Barney'<br />  end<br /><br />end<br /><br />class TheGreat<br /><br />  def phred<br />    'Fredrick'<br />  end<br /><br />  def test<br />    plus = ' plus '<br />    MyDSL.eval { p phred + plus + bjarne }<br />  end<br /><br />end<br /><br />TheGreat.new.test<br />##### "Fredrick plus Barney"<br /></code></pre><br />This does <em>exactly</em> what we want with methods.<br /><br />There's also a single extension to <code>kernel</code>, the method <code>with</code>. <code>with</code> replaces the <code>eval</code> method so you can also say:<br /><pre><code><br />    with MyDSL do<br />      p phred + plus + bjarne<br />    end<br /></code></pre><br /><br />The <code>eval</code> method creates a new instance of your DSL class, so you can track state within an evaluation. For example:<br /><br /><pre><code>class Censor &lt; DomainSpecificLanguage<br />  attr_reader :ok_on_tv<br /><br />  def initialize (given_binding)<br />    super(given_binding)<br />    @ok_on_tv = true<br />  end<br /><br />  def say something<br />    something.split.each do |word|<br />      @ok_on_tv = false if ['feces', 'urine', 'love', 'pudendum', 'fellator', 'oedipus', 'mammaries'].include?(word)<br />    end<br />  end<br /><br />end<br /><br />class GeorgeCarlin<br />  def test<br />    Censor.eval {<br />      say "People much wiser than I have said, I'd rather have my son watch a film with two people making love than two people trying to kill one other."<br />      say "And I of course agree. I wish I know who said it first, and I agree with that."<br />      ok_on_tv<br />    }<br />  end<br />end<br /><br />p GeorgeCarlin.new.test<br />##### "false"<br /></code></pre><br /><strong>let</strong><br /><br />The first obvious drawback of this approach is that the blocks we pass to <code>eval</code> cannot take parameters. For this reason, rumour has it that a method called <code>instance_exec</code> will be added to Ruby in 1.9. (There are some <a href="http://termos.vemod.net/object-instance_exec">implementations</a> available that work in Ruby 1.8 if you would like to experiment.)<br /><br />The second is that you don&#8217;t get anything like nested local variables, a &#8216;la Pascal, Scheme, or any other language with block structure. Block structure is very powerful: You can use a variable within a particular scope and nowhere else. Here&#8217;s a trivial example:<br /><br /><pre><code>with Let do<br />  let :x =&gt; 0, :y =&gt; 1 do<br />    assert_equal(1, x + y)<br />    let :x =&gt; 2 do<br />      assert_equal(3, x + y) <br />    end<br />    assert_equal(0, x)<br />  end <br />end<br /></code></pre><br />We're using the <code>with</code> syntax. In the <code>Let</code> DSL, there&rsquo;s a new method called <code>let</code>. <code>let</code> creates a new DSL within <code>Let</code>. You can see that re-declaring <code>x</code> does not clobber the value in the outer scope. That is because when <code>let</code> wrote a new DSL, it added <code>x</code> and <code>y</code> as methods.<br /><br />So really, that block of code says &ldquo;Write a new DSL where <code>x</code> and <code>y</code> are methods returning zero and one. Execute some code in that new DSL. That code will create <i>another</i> DSL where <code>x</code> is a method returning two.&rdquo;<br /><br />Because <code>let</code> defines methods and not local variables, bad things happen when you try to override real local variables. It&#8217;s best to use <code>Let</code> for some things and local variables for others, but not mix the two.<br /><br />Like what, you ask?<br /><br /><strong><a name="lcir">List Comprehensions in Ruby</a></strong><br /><br />A <a href="http://en.wikipedia.org/wiki/List_comprehension">List Comprehension</a> is syntactic sugar that lets you build collections using set-like notation. For example, <code>S = [ x | x&lt;-[0..], x^2&gt;3 ]</code> is a list comprehension in Haskell.<br /><br />Here is a <a href="http://weblog.raganwald.com/source/comprehensions.html">List Comprehensions DSL in Ruby</a>. Let&#8217;s say we&#8217;re building up a multiplication table. We want tuples of the form <code>[x, y, x * y]</code> given <code>x</code> is in the range <code>1..12</code> and <code>y</code> is in the range <code>1..12</code>. Let&#8217;s write that:<br /><pre><code><br />require 'comprehension'<br /><br />class MultiplicationTable<br />  def twelve_by_twelve<br />    with Comprehension::DSL do<br />      list { [x, y, x * y] }.given(:x =&gt; 1..12, :y =&gt; 1..12)<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve<br />##### [[1, 1, 1], [1, 2, 2], [2, 1, 2], [1, 3, 3], [2, 2, 4] ...<br /></code></pre><br />(In everyday use, you don&rsquo;t need a class and a method for each comprehension: the important bit is <code>list {</code> <code>[x, y, x * y]</code> <code>}.given(:x =&gt; 1..12,</code> <code>:y =&gt; 1..12)</code>. I just wrote it this way so you could see that comprehensions work fine inside of methods. You can also use more than one comprehension inside of a single <code>with Comprehension::DSL do...</code> <code>end</code> block: see the unit tests for examples.)<br /><br />The expression in the block doesn&#8217;t have to be a tuple:<br /><pre><code><br />class MultiplicationTable<br />  def twelve_by_twelve<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(:x =&gt; 1..12, :y =&gt; 1..12)<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve<br />##### ["1 times 1 is 1", "1 times 2 is 2", "2 times 1 is 2", "1 times 3 is 3", "2 times 2 is 4", ...<br /></code></pre><br />And you can stick a &#8220;where&#8221; block on the end:<br /><pre><code><br />class MultiplicationTable<br />  def twelve_by_twelve_odds<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(:x =&gt; 1..12, :y =&gt; 1..12) { (x % 2 == 1) &amp;&amp; (y % 2 == 1) }<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve_odds<br />##### ... 3 times 5 is 15", "5 times 3 is 15", "7 times 1 is 7", "1 times 9 is 9", ...<br /></code></pre><br /><br />Would you like to nest them? Your expression is the interpreter&rsquo;s command:<br /><pre><code><br />class MultiplicationTable<br />  def odds_times_evens<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(<br />          :x => list { x }.given(:x => 1..12) { x % 2 == 0 } , <br />          :y => list { x }.given(:x => 1..12) { x % 2 == 1 } )<br />    end<br />  end<br />end<br />p MultiplicationTable.new.odds_times_evens<br />##### ... "2 times 11 is 22", "4 times 9 is 36", "6 times 7 is 42", ...<br /></code></pre><br /><strong>List Comprehensions and Let</strong><br /><br />What is the relationship to <code>Let</code>? Well, <code>Let</code> builds the scopes needed for evaluating the where clause and the block defining the elements of the list. Yes, we&#8217;ve built a DSL on top of a DSL on top of a DSL. Does this seem like weird trickery? I don&#8217;t know why. Do you have <em>any idea</em> how many levels of abstraction are responsible for you reading this essay right now?<br /><br />This is what we humans do: we build tools on top of tools. Your browser runs on an OS, possibly in a VM, perhaps in a hypervisor, on top of a BIOS, and on and on. This is the normal state of affairs, not an exception.<br /><br /><strong>Closing Remarks</strong><br /><br />It is possible to build DSLs in Ruby to facilitate cross-functional teamwork and separation of concerns. Care must be taken to avoid polluting the top-level name space, but it is possible to work within sandboxes and still have access to the current object&#8217;s context.<br /><br />Oh yes, and programming is fun as always<br /><br /><strong><a name="dslsource">Source Code</a></strong><br /><br /><em>Update: The copy of <code>dsl.rb</code> has been updated to the latest version. I had committed a rather typical manual synchronization error: I copied the latest file to the wrong directory when I first posted this. Thanks, Justin!</em><br /><br /><ul><li><a href="http://weblog.raganwald.com/source/dsl_and_let.html">DomainSpecificLanguage and Let</a></li><br /><li><a href="http://weblog.raganwald.com/source/comprehensions.html">Comprehension</a></li></ul><br /><br /><strong>How to try it for yourself</strong>: Open <a href="http://weblog.raganwald.com/source/dsl_and_let.html">DomainSpecificLanguage and Let</a>. Save the text only (not the HTML) as <code>dsl.rb</code>. Open <a href="http://weblog.raganwald.com/source/comprehensions.html"><code>Comprehension</code></a></li>. Save the text only as anything you like, as long as it is in the same directory as <code>dsl.rb</code>: I use <code>comprehension.rb</code>. Run <code>comprehension.rb</code>.<br /><hr /><ol><li>I generally call &#8220;<a href="http://en.wikipedia.org/wiki/Bullshit%21">Bullshit</a>!&#8221; on any line of reasoning that sets up a straw man argument just to knock it down. So read on with skepticism!</li><br /><li>Alan Kay has said that he regrets popularizing the notion of &#8220;Object-Oriented&#8221; programming, and that he should have called it &#8220;Message-Oriented&#8221; programming.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html" title="permanent link">12:19 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, March 15, 2007</div>
			

			<div class="Post"><a name="5076801165540557858">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/03/coming-soon.html" title="permanent link">Coming soon...</a></span>
					<div style="clear:both;"></div><pre class="textmate-source sunburst"><span class="source source_ruby"><br /><span class="meta meta_require meta_require_ruby"><span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">require</span> <span class="string string_quoted string_quoted_double string_quoted_double_ruby"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_ruby">"</span>test/unit<span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_ruby">"</span></span></span><br /><br /><span class="meta meta_class meta_class_ruby"><span class="keyword keyword_control keyword_control_class keyword_control_class_ruby">class</span> <span class="entity entity_name entity_name_type entity_name_type_class entity_name_type_class_ruby">TestComprehension<span class="entity entity_other entity_other_inherited-class entity_other_inherited-class_ruby"> <span class="punctuation punctuation_separator punctuation_separator_inheritance punctuation_separator_inheritance_ruby">&lt;</span> Test::Unit::TestCase</span></span></span><br />  <br />  <span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">test_simple_cases</span></span><br />    with <span class="support support_class support_class_ruby">Comprehension</span>::<span class="variable variable_other variable_other_constant variable_other_constant_ruby">DSL</span> <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do<br /></span>      assert_equal(<br />          [<span class="constant constant_numeric constant_numeric_ruby">1</span>, <span class="constant constant_numeric constant_numeric_ruby">2</span>, <span class="constant constant_numeric constant_numeric_ruby">3</span>],<br />          list {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>x + <span class="constant constant_numeric constant_numeric_ruby">1</span> }.given(<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; <span class="constant constant_numeric constant_numeric_ruby">0</span>..<span class="constant constant_numeric constant_numeric_ruby">2</span>) )<br />      assert_equal(<br />          [[<span class="constant constant_numeric constant_numeric_ruby">0</span>, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>a</span>], [<span class="constant constant_numeric constant_numeric_ruby">0</span>, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>b</span>], [<span class="constant constant_numeric constant_numeric_ruby">1</span>, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>a</span>], [<span class="constant constant_numeric constant_numeric_ruby">1</span>, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>b</span>]],<br />          list {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>[x, y] }.given(<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; [<span class="constant constant_numeric constant_numeric_ruby">0</span>, <span class="constant constant_numeric constant_numeric_ruby">1</span>], <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; [<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>a</span>, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>b</span>]) )<br />      assert_equal(<br />          [<span class="constant constant_numeric constant_numeric_ruby">2</span>, <span class="constant constant_numeric constant_numeric_ruby">4</span>, <span class="constant constant_numeric constant_numeric_ruby">6</span>, <span class="constant constant_numeric constant_numeric_ruby">8</span>, <span class="constant constant_numeric constant_numeric_ruby">10</span>],<br />          list {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>x }.given(<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; <span class="constant constant_numeric constant_numeric_ruby">1</span>..<span class="constant constant_numeric constant_numeric_ruby">10</span>) {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>x % <span class="constant constant_numeric constant_numeric_ruby">2</span> == <span class="constant constant_numeric constant_numeric_ruby">0</span> } )<br />    <span class="keyword keyword_control keyword_control_ruby">end</span><br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br />  <br />  <span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">plus_seven</span></span> num<br />    num + <span class="constant constant_numeric constant_numeric_ruby">7</span><br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br />  <br />  <span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">times_maker</span></span> num<br />    lambda {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>x * num }<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br />  <br />  <span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">test_closure_cases</span></span><br />    two = <span class="constant constant_numeric constant_numeric_ruby">2</span><br />    triple = times_maker(<span class="constant constant_numeric constant_numeric_ruby">3</span>)<br />    with <span class="support support_class support_class_ruby">Comprehension</span>::<span class="variable variable_other variable_other_constant variable_other_constant_ruby">DSL</span> <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do<br /></span>      assert_equal(<br />          [<span class="constant constant_numeric constant_numeric_ruby">2</span>, <span class="constant constant_numeric constant_numeric_ruby">4</span>, <span class="constant constant_numeric constant_numeric_ruby">6</span>],<br />          list {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>x * two }.given(<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; <span class="constant constant_numeric constant_numeric_ruby">1</span>..<span class="constant constant_numeric constant_numeric_ruby">3</span>) )<br />      assert_equal(<br />          [<span class="constant constant_numeric constant_numeric_ruby">3</span>, <span class="constant constant_numeric constant_numeric_ruby">6</span>, <span class="constant constant_numeric constant_numeric_ruby">9</span>],<br />          list(&amp;triple).given(<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; <span class="constant constant_numeric constant_numeric_ruby">1</span>..<span class="constant constant_numeric constant_numeric_ruby">3</span>) )<br />      assert_equal(<br />          [<span class="constant constant_numeric constant_numeric_ruby">8</span>, <span class="constant constant_numeric constant_numeric_ruby">9</span>, <span class="constant constant_numeric constant_numeric_ruby">10</span>],<br />          list {<span class="meta meta_syntax meta_syntax_ruby meta_syntax_ruby_start-block"> </span>plus_seven(x) }.given(<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; <span class="constant constant_numeric constant_numeric_ruby">1</span>..<span class="constant constant_numeric constant_numeric_ruby">3</span>) )<br />    <span class="keyword keyword_control keyword_control_ruby">end</span><br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br />  <br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /></span></pre><br />March 16, 2007: <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html">An Approach to Composing Domain-Specific Languages in Ruby</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/03/coming-soon.html" title="permanent link">12:45 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, March 11, 2007</div>
			

			<div class="Post"><a name="1990194990621630996">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html" title="permanent link">Why Why Functional Programming Matters Matters</a></span>
					<div style="clear:both;"></div>I recently re-read the amazing paper <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a> (&#8220;WhyFP&#8221;). Although I thought that I understood WhyFP when I first read it a few years ago, when I had another look last weekend I suddenly understood that I had missed an important message.<sup>1</sup><br /><br />Now obviously (can you guess from the title?) the paper is about the importance of one particular style of programming, functional programming. And when I first read the paper, I took it at face value: I thought, &#8220;Here are some reasons why functional programming languages matter.&#8221;<br /><br />On re-reading it, I see that the paper contains insights that apply to programming in general. I don&#8217;t know why this surprises me. The fact is, programming language design revolves around program design. A language&#8217;s design reflects the opinions of its creators about the proper design of programs.<br /><br />In a very real sense, the design of a programming language is a strong expression of the opinions of the designer about good programs. When I first read WhyFP, I thought the author was expressing an opinion about the design of good programming languages. Whereas on the second reading, I realized he was expressing an opinion about the design of good programs.<br /><br /><strong>Can we add though subtraction?</strong><br /><br /><blockquote>It is a logical impossibility to make a language more powerful by omitting features, no matter how bad they may be.</blockquote><br />Is this obvious? So how do we explain that one reason Java is considered &#8220;better than C++&#8221; is because it omits manual memory management? And one reason many people consider Java &#8220;better than Ruby&#8221; is because you cannot open base classes like <code>String</code> in Java? So no, it is not obvious. Why not?<br /><br />The key is the word <em>better</em>. It&#8217;s not the same as the phrase <em>more powerful</em>.<sup>2</sup> The removal or deliberate omission of these features is an expression about the idea that programs which do not use these features are better than programs which do. Any feature (or removal of a feature) which makes the programs written in the language better makes the language better. Thus, it <em>is</em> possible to make a language &#8220;better&#8221; by removing features that are considered harmful,<sup>3</sup> if by doing so it makes programs in the language better programs.<br /><br />In the opinion of the designers of Java, programs that do not use <code>malloc</code> and <code>free</code> are safer than those that do. And the opinion of the designers of Java is that programs that do not modify base classes like <code>String</code> are safer than those that do. The Java language design emphasizes a certain kind of safety, and to a Java language designer, safer programs are better programs.<br /><br />&#8220;More powerful&#8221; is a design goal just like &#8220;safer.&#8221; But yet, what does it mean? We understand what a safer language is. It&#8217;s a language where programs written in the language are safer. But what is a &#8220;more powerful&#8221; language? That programs written in the language are more powerful? What does that mean? Fewer symbols (the &#8220;golf&#8221; metric)?<br /><br />WhyFP asserts that you cannot make a language more powerful through the removal of features. To paraphrase an argument from the paper, <em>if removing harmful features was useful by itself, C and C++ programmers would simply have stopped using</em> <code>malloc</code> <em>and</em> <code>free</code> <em>twenty years ago</em>. Improving on C/C++ was not just a matter of removing <code>malloc</code> and <code>free</code>, it was also a matter of adding automatic garbage collection.<br /><br /><blockquote>This space, wherein the essay ought to argue that Java compensates for its closed base classes by providing a more powerful substitute feature, left intentionally blank.</blockquote><br />At the same time, there is room for arguing that some languages are improved by the removal of harmful features. To understand why they may be improved but not more powerful, we need a more objective definition of what it means for a language to be &#8220;more powerful.&#8221; Specifically, what quality does a more powerful programming language permit or encourage in programs?<br /><br />When we understand what makes a program &#8220;better&#8221; in the mind of a language designer, we can understand the choices behind the language.<br /><br /><strong>Factoring</strong><br /><br />Factoring a program is the act of dividing it into units that are composed to produce the working software.<sup>4</sup> Factoring happens as part of the design. (<em>Re</em>-factoring is the act of rearranging an existing program to be factored in a different way). If you want to compare this to factoring in number theory, a well designed program has lots of factors, like the number <code>3,628,800</code> (<code>10!</code>). A <a href="http://www.laputan.org/mud/">Big Ball of Mud</a> is like the number <code>3,628,811</code>, a prime.<br /><br />Composition is the construction of programs from smaller programs. So factoring is to composition as division is to multiplication.<br /><br />Factoring programs isn&#8217;t really like factoring simple divisors. The most important reason is that programs can be factored in orthogonal ways. When you break a program into subprograms (using methods, subroutines, functions, what-have-you), that&#8217;s one axis of factoring. When you break an a modular program up into modules, that&#8217;s another, orthogonal axis of factoring.<br /><br />Programs that are well-factored are more desirable than programs that are poorly factored.<br /><br /><blockquote>In computer science, <strong>separation of concerns</strong> (SoC) is the process of breaking a program into distinct features that overlap in functionality as little as possible. A concern is any piece of interest or focus in a program.<br />  <br />  SoC is a long standing idea that simply means a large problem is easier to manage if it can be broken down into pieces; particularly so if the solutions to the sub-problems can be combined to form a solution to the large problem.<br />  <br />  The term separation of concerns was probably coined by Edsger W. Dijkstra in his paper <a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">On the role of scientific thought</a>.</blockquote><br />&#8212;Excerpts from the Wikipedia entry on <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns</a><br /><br />Programs that separate their concerns are well-factored. There&#8217;s a principle of software development, <a href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=211189&amp;creative=374929&amp;creativeASIN=0201379430" title="Object Design: Roles, Responsibilities, and Collaborations">responsibility-driven design</a>. Each component should have one clear responsibility, and it should have everything it needs to carry out its responsibility.<br /><br />This is the separation of concerns again. Each component of a program having one clearly defined responsibility means each concern is addressed in one clearly defined place.<br /><br /><blockquote>Let’s ask a question about Monopoly (and Enterprise software). Where do the rules live? In a noun-oriented design, the rules are smooshed and smeared across the design, because every single object is responsible for knowing everything about everything that it can ‘do’. All the verbs are glued to the nouns as methods.</blockquote><div>&#8212;<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a></div><br /><br />In a game design where you have important information about a rule smeared all over the object hierarchy, you have very poor separation of concerns. It looks at first like there&#8217;s a clear factoring &#8220;Baltic Avenue has a method called <code>isUpgradableToHotel</code>,&#8221; but when you look more closely you realize that every object representing a property is burdened with knowing almost all of the rules of the game.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256100X"><img border="0" src="http://raganwald.github.com/uploaded_images/seasoned_schemer.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256100X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256100X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is devoted to the myriad uses of first class functions. This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will be able to compose programs from functions in powerful new ways.<br><br></div>The concerns are not clearly separated: there&#8217;s no one place to look and understand the behaviour of the game.<br /><br />Programs that separate their concerns are better programs than those that do not. And languages that facilitate this kind of program design are better than those that hamper it.<br /><br /><strong>Power through features that separate concerns</strong><br /><br />One thing that makes a programming language &#8220;more powerful&#8221; in my opinion is the provision of more ways to factor programs. Or if you prefer, <em>more axes of composition</em>. The more different ways you can compose programs out of subprograms, the more powerful a language is. <br /><br />Do you remember <a href="http://en.wikipedia.org/wiki/Structured_programming">Structured Programming</a>? The gist is, you remove <code>goto</code> and you replace it with well-defined control flow mechanisms: some form of subroutine call and return, some form of selection mechanism like Algol-descendant <code>if</code>, and some form of repetition like Common Lisp&#8217;s <code>loop</code> macro.<br /><br />Dijkstra&#8217;s view on structured programming was that it promoted the separation of concerns. The factoring of programs into blocks with well-defined control flow made it easy to understand blocks and rearrange programs in different ways. Programs with indiscriminate jumps did not factor well (if at all): they were difficult to understand and often could not be rearranged at all.<br /><br />Structured <a href="http://dmoz.org/Computers/Programming/Languages/Assembly/68k/">68k ASM</a> programming is straightforward in theory. You just need a lot of boilerplate, design patterns, and the discipline to stick to your convictions. But of course, lots of 68k ASM programming in practice is only partially structured. Statistically speaking, 68k ASM is not a structured programming language even though structured programming is possible in 68k ASM.<br /><br />Structured Pascal programming is straightforward both in theory and in practice. Pascal facilitates separation of concerns through structured programming. So we say that Pascal &#8220;is more powerful than 68k ASM&#8221; to mean that in practice, programs written in Pascal are more structured than programs written in 68k ASM because Pascal provides facilities for separating concerns that are missing in 68k ASM.<br /><br /><strong>For example: working with lists</strong><br /><br />Consider this snippet of iterative code:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_java"><span class="storage storage_type storage_type_java">int</span> numberOfOldTimers = <span class="constant constant_numeric constant_numeric_java">0</span>;<br /><span class="meta meta_definition meta_definition_constructor meta_definition_constructor_java"><span class="entity entity_name entity_name_function entity_name_function_constructor entity_name_function_constructor_java">for</span> <span class="meta meta_definition meta_definition_param-list meta_definition_param-list_java">(<span class="storage storage_type storage_type_java">Employee</span> emp: employeeList</span>) </span>{<br /><span class="meta meta_definition meta_definition_constructor meta_definition_constructor_java">    <span class="entity entity_name entity_name_function entity_name_function_constructor entity_name_function_constructor_java">for</span> <span class="meta meta_definition meta_definition_param-list meta_definition_param-list_java">(<span class="storage storage_type storage_type_java">Department</span> dept: departmentsInCompany</span>) </span>{<br />        <span class="keyword keyword_control keyword_control_java">if</span> (emp.getDepartmentId() <span class="keyword keyword_operator keyword_operator_comparison keyword_operator_comparison_java">==</span> dept.getId() <span class="keyword keyword_operator keyword_operator_logical keyword_operator_logical_java">&amp;&amp;</span> emp.getYearsOfService() <span class="keyword keyword_operator keyword_operator_comparison keyword_operator_comparison_java">&gt;</span> dept.getAge()) {<br />            <span class="keyword keyword_operator keyword_operator_increment-decrement keyword_operator_increment-decrement_java">++</span>numberOfOldTimers;<br />        }<br />    }<br />}<br /></span><br /></pre><br />This is an improvement on older practices.<sup>5, 6</sup> For one thing, the <code>for</code> loops hide the implementation details of iterating over <code>employeeList</code> and <code>departmentsInCompany</code>. Is this better because you have less to type? Yes. Is it better because you eliminate the fence-post errors associated with loop variables? Of course.<br /><br />But most interestingly, you have the beginnings of a <em>separation of concerns</em>: how to iterate over a single list is separate from what you do in the iteration.<br /><br /><blockquote>Try calling a colleague on the telephone and explaining what we want as succinctly as possible. Do you say &#8220;We want a loop inside a loop and inside of that an if, and&#8230;&#8221;? Or do you say &#8220;We want to count the number of employees that have been with the company longer than their departments have existed.&#8221;</blockquote><br />One problem with the <code>for</code> loop is that it can only handle one loop at a time. We have to nest loops to work with two lists at once. This is patently wrong: there&#8217;s nothing inherently nested about what we&#8217;re trying to do. We can demonstrate this easily: try calling a colleague on the telephone and explaining what we want as succinctly as possible. Do you say &#8220;We want a loop inside a loop and inside of that an if, and&#8230;&#8221;?<br /><br />No, we say, &#8220;We want to count the number of employees that have been with the company longer than their departments have existed.&#8221; There&#8217;s no discussion of nesting.<br /><br />In this case, a limitation of our tool has caused our concerns to intermingle again. The concern of &#8220;How to find the employees that have been with the company longer than their departments have existed&#8221; is intertwined with the concern of &#8220;count them.&#8221; Let&#8217;s try a different notation that separates the details of <em>how to find</em> from the detail of <em>counting what we&#8217;ve found</em>:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_ruby">old_timers = (employees * departments).select <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|emp, dept|<br />  emp.department_id == dept.id &amp;&amp; emp.years_of_service &gt; dept.age<br /><span class="keyword keyword_control keyword_control_ruby">end</span><br />number_of_old_timers = old_timers.size<br /></span><br /></pre><br />Now we have separated the concern of finding from counting. And we have hidden the nesting by using the <code>*</code> operator to create a Cartesian product of the two lists. Now let&#8217;s look at what we used to filter the combined list, <code>select</code>. The difference is more than just semantics, or counting characters, or the alleged pleasure of fooling around with closures.<br /><br /><div class="book"><br>  <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/uploaded_images/haskell_school_of_expression.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br>I’m not a Haskell user (yet), but <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> has received rave reviews and comes with solid recommendations. It’s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you’re feeling generous!<br><br></div><code>*</code> and <code>select</code> facilitates separating the concerns of how to filter things (like iterate over them applying a test) from the concern of what we want to filter. So languages that make this easy are more powerful than languages that do not. In the sense that they facilitate additional axes of factoring.<br /><br /><strong>The Telephone Test</strong><br /><br />Let&#8217;s look back a few paragraphs. We have an example of the &#8220;Telephone Test:&#8221; when code very closely resembles how you would explain your solution over the telephone, we often say it is &#8220;very high level.&#8221; The usual case is that such code expresses a lot more <em>what</em> and a lot less <em>how</em>. The concern of what has been very clearly separated from the concern of how: you can&#8217;t even <em>see</em> the how if you don&#8217;t go looking for it.<br /><br />In general, we think this is a good thing. But it isn&#8217;t free: somewhere else there is a mass of code that supports your brevity. When that extra mass of code is built into the programming language, or is baked into the standard libraries, it is nearly free and obviously a Very Good Thing. A language that doesn&#8217;t just separate the concern of how but does the work for you is very close to &#8220;something for nothing&#8221; in programming.<br /><br />But sometimes you have to write the <em>how</em> as well as the <em>what</em>. It isn&#8217;t always handed to you. In that case, it is still valuable, because the resulting program still separates concerns. It still factors into separate components. The components can be changed.<br /><br />I recently separated the concern of describing &#8220;how to generate sample curves for some data mining&#8221; from the concern of &#8220;managing memory when generating the curves.&#8221; I did so by writing my own lazy evaluation code (Both the <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">story</a> and the <a href="http://weblog.raganwald.com/source/lazy_lists.html">code</a> are on line). Here&#8217;s the key &#8220;what&#8221; code that generates an infinite list of parameters for sample bezi&eacute;r curves:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_ruby"><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">magnitudes</span></span><br />  <span class="support support_class support_class_ruby">LazyList</span>.binary_search(<span class="constant constant_numeric constant_numeric_ruby">0.0</span>, <span class="constant constant_numeric constant_numeric_ruby">1.0</span>)<br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">control_points</span></span><br />  <span class="support support_class support_class_ruby">LazyList</span>.cartesian_product(magnitudes, magnitudes) <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|x, y|<br />    <span class="support support_class support_class_ruby">Dictionary</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>( <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; x, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; y )<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">order_one_flows</span></span> args = {}<br />  height, width = (args[<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>height</span>] || <span class="constant constant_numeric constant_numeric_ruby">100.0</span>), (args[<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>width</span>] || <span class="constant constant_numeric constant_numeric_ruby">100.0</span>)<br />  <span class="support support_class support_class_ruby">LazyList</span>.cartesian_product(<br />      magnitudes, control_points, control_points, magnitudes<br />  ) <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|initial_y, p1, p2, final_y|<br />    <span class="support support_class support_class_ruby">FlowParams</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>(<br />      height, width, initial_y * height,<br />      <span class="support support_class support_class_ruby">CubicBezierParams</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>(<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; width,          <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; final_y * height,<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x1</span> =&gt; p1.x * width,  <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y1</span> =&gt; p1.y * height,<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x2</span> =&gt; p2.x * width,  <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y2</span> =&gt; p2.y * height<br />      )<br />    )<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /></span><br /></pre><br />That&#8217;s it. Just as I might tell you on the phone: &#8220;Magnitudes&#8221; is a list of numbers between zero and one created by repeatedly dividing the intervals in half, like a binary search. &#8220;Control Points&#8221; is a list of the Cartesian product of magnitudes with itself, with one magnitude assigned to <code>x</code> and the other to <code>y</code>. And so forth.<br /><br />I will not say that the sum of this code and the code that actually implements infinite lists is shorter than imperative code that would intermingle loops and control structures, <a href="http://www.amazon.com/gp/product/B000002J27?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000002J27" title="A Trick of the Tail by Genesis, Track 2, Entangled">entangling</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=B000002J27" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <em>what</em> with <em>how</em>. I will say that it separates the concerns of what and how, and it separates them in a different way than <code>select</code> separated the concerns of what and how.<br /><br /><strong>So why does &#8220;Why Functional Programming Matters&#8221; matter again?</strong><br /><br />The great insight is that better programs separate concerns. They are factored more purely, and the factors are naturally along the lines of responsibility (rather than in Jenga piles of <code>abstract</code> <code>virtual</code> <code>base</code> <code>mixin</code> <code>module</code> <code>class</code> <code>proto_</code> <code>extends</code> <code>private</code> <code>implements</code>). Languages that facilitate better separation of concerns are more powerful in practice than those that don&#8217;t.<br /><br />WhyFP illustrates this point beautifully with the same examples I just gave: <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">first-class functions</a> and <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">lazy evaluation</a>, both prominent features of modern functional languages like Haskell.<br /><br />WhyFP&#8217;s value is that it expresses an opinion about what makes programs better. It backs this opinion up with reasons why modern functional programming languages are more powerful than imperative programming languages. But even if you don&#8217;t plan to try functional programming tomorrow, the lessons about better programs are valuable for your work in <em>any</em> language today.<br /><br />That&rsquo;s why <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a> matters.<br /><br /><hr /><ol><li>And now I&#8217;m worried: what am I <em>still</em> missing?</li><br /><li>Please let&#8217;s not have a discussion about <a href="http://en.wikipedia.org/wiki/Turing-complete">Turing Equivalence</a>. Computer Science &#8220;Theory&#8221; tells us &#8220;there&#8217;s no such thing as more powerful.&#8221; Perhaps we share the belief that <em>In theory, there&#8217;s no difference between theory and practice. But in practice, there is</em>.</li><br /><li>I am not making the claim that <em>I</em> consider memory management or unsealed base classes harmful, but I argue that there exists at least one person who does.</li><br /><li>The word &#8220;factor&#8221; has been a little out of vogue in recent times. But thanks to an excellent <a href="http://programming.reddit.com/info/18td4/comments">post on reddit</a>, it could make a comeback.</li><br /><li>So much so that we won&#8217;t even bother to show what loops looked like in the days of <code>for (int i = 0; i &lt; employeeList.size(); ++i)</code>. </li><br /><li>Another organization might merge employees and departments, or have each department &ldquo;own&rdquo; a collection of employees. This makes our example easier, but now the <em>data</em> doesn&rsquo;t factor well. Everything we&rsquo;ve learned from databases in the last forty years tells us that we often need to find new ways to compose our data. The relational model factors well. The network model factors poorly.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html" title="permanent link">10:21 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, February 26, 2007</div>
			

			<div class="Post"><a name="4134602127458276092">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">Haskell, Ruby and Infinity</a></span>
					<div style="clear:both;"></div>Languages like Haskell support <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>. In principle, you only compute what you actually need, everything else just goes away. If you usually need everything you compute, this may seem like a frill: elegant, even interesting, but having little practical importance. I find it is very much like Tail Call Optimization: if you don&rsquo;t have it, you code around it. Often it makes no difference, but from time to time there is a case where your code will be clearer and more maintainable if you express yourself succinctly and let the compiler do the work of making it efficient.<br /><br />This post is a switch from mumbling about <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y Combinators</a> and using trivial cases to explain interesting ideas: I&rsquo;m going to show some actual code I&rsquo;m writing. I apologise in advance if this adds so much background that it obscures the message about lazy evaluation: extremely simplistic examples sometimes work against the argument because it is too easy to think of other ways to accomplish the needed results.<br /><br />I don&rsquo;t apologise <em>at all</em> for the unpolished nature of the code. This isn&rsquo;t a textbook. And besides:<br /><blockquote><br />Anybody can say you can&rsquo;t write. Let no one say you don&rsquo;t.<br /></blockquote><p style="text-align: right;">&mdash;Ken Rand, courtesy of <a href="http://chalain.livejournal.com/">Chalain</a><br /><br /></p><hr /><br /><br />I&rsquo;ve been <a href="http://en.wikipedia.org/wiki/Hacker">hacking</a> some na&iuml;ve code to cluster data sets.<br /><blockquote><br />In computer programming, a hacker is a software designer and programmer who builds elegant, beautiful programs and systems… For some, &ldquo;hacker&rdquo; has a negative connotation and refers to a person who &ldquo;hacks&rdquo; or uses kludges to accomplish programming tasks that are ugly, inelegant, and inefficient.<br /></blockquote><p style="text-align: right;">&mdash;Wikipedia</p>The clustering algorithm requires a very large, fixed set of curves.<sup>1</sup> I wrote the initial curve generation by building a gigantic list of parameter tuples, and then processing the list into records. Once the &ldquo;search space&rdquo; grew beyond a trivial size, the program began to eat enormous amounts of memory. The problem was that I was trying to write the generation code as clearly as possible, and that created a massive thicket of objects that all resided in memory simultaneously.<br /><br /><div style="float: right; width: 240px; margin-left: 10px; font-style: italic; text-align: center; font-size: 80%;"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Bezier_curve.svg/800px-Bezier_curve.svg.png" height="150" width="240" />The curves being generated are paths composed of cubic beziérs. Each segment on the path requires specifications for four different control points.<br /></div>I rejected the idea of a rewrite into looping, imperative form, I wanted to separate the &ldquo;list comprehension&rdquo; code from the &ldquo;make it run in less than a gigabyte&rdquo; code. Instead, I chose to use lazy evaluation: the principle is that although the code defines a huge data structure that takes up gigabytes, we only actually evaluate things as we need them, and we discard them when we are done, so the total memory footprint for the lazy form is about the same as the memory footprint for an imperative form.<br /><br />The easiest way to perform the refactoring&mdash;besides a rewrite in Haskell&mdash;was to switch all of the arrays I used for a lazy list data structure. A lazy list is a linked list composed of head and tail tuples (known as <a href="http://en.wikipedia.org/wiki/Cons">cons cells</a>). Where a normal linked list holds an element and the rest of the list, a lazy list holds an element and a function for computing the rest of the list (<a href="http://mitpress.mit.edu/sicp/">SICP</a> calls them &ldquo;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">streams</a>.&rdquo;)<br /><br />If a modicum of care is taken not to pin objects down, you can build fantastically large lazy lists and process them at will. In fact, lazy lists can be infinitely large if you provide the appropriate function for generating the list<br /><br />For that reason, you should never append one lazy list onto another lazy list. Consider <code>odd = LazyList.unfoldr(1) { |n| n + 2 }</code> and <code>even = LazyList.unfoldr(0) { |n| n + 2 }</code>. If you append <code>odd</code> onto <code>even</code>, the resulting list in theory has both even and odd numbers. But in practice you can never reach the odd numbers because there is an infinite quantity of even numbers at the front of the list.<br /><br />Instead, <code>merge</code> them together to produce a lazy union of the two lists. Merge interleaves alternating elements from each list, so the resulting lazy list contains all the elements of each list, and if you take a finite sample, such as the first 1,000 elements, you get 500 of each. <code>even.merge(odd) => (0 1 2 3 ...)</code>. (Other interesting operations that work with infinite lists include <code>cons</code>, <code>pairwise</code> and <code>product</code>.)<br /><br /><blockquote><br />Any sufficiently complicated Lisp or Ruby program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Haskell.<br /></blockquote><br />My current version of a <code>LazyList</code> class in Ruby is <a href="http://weblog.raganwald.com/source/lazy_lists.html">here</a>. As soon as I switched from the &ldquo;eager&rdquo; code using arrays to the &ldquo;lazy&rdquo; code using lazy lists, memory use went down and performance went up. Not as much as a switch to imperative (and not even close to writing a better clustering algorithm), but enough that I can move forward.<br /><br />Here is an example of a function using arrays to enumerate choices (<code>distribute(2, 1..4) -&gt; [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</code>):<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return [] if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    return range.to_a.map { |spot| [spot] }<br />  else<br />    (range.begin..(range.end - remaining_choices)).to_a.inject([]) { |acc, first_spot| acc + (distribute(remaining_choices, (first_spot + 1)..range.end).map { |remaining_distribution| remaining_distribution.unshift(first_spot) }) }<br />  end <br />end<br /></code></pre>And rewritten with lazy lists:<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return LazyList.new() if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    LazyList.from_range(range).map { |spot| LazyList.from_element(spot) }<br />  else<br />    LazyList.from_range(range.begin..(range.end - remaining_choices)).mapr(:merge) do |first_spot|<br />      distribute(remaining_choices, (first_spot + 1)..range.end).map do |remaining_distribution| <br />        LazyList.cons(first_spot, remaining_distribution) <br />      end<br />    end<br />  end <br />end<br /></code></pre>It&rsquo;s almost identical. <code>LazyLists</code> replace arrays, <code>mapr</code> replaces accumulating a list with <code>inject</code>, and <code>cons</code> replaces <code>unshift</code>, but otherwise it&rsquo;s the same code. Mission accomplished: we&rsquo;ve changed the behaviour without having to change the way we express our algorithms. Had we wanted to, we could have supported enough array syntax that Lazy Lists look exactly like arrays, but that isn&rsquo;t necessary.<br /><br />And when running the entire generator, the memory footprint is dramatically lower. For example, this small routine quoted above no longer generates an array of arrays: it generates a structure that can generate the lists when needed. Switching the data structure changes the evaluation behaviour of the generator code: it gets us 80% of having an imperative structure without having to tie the code to the implementation.<br /><br />This is exactly what separation of concerns is all about: <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html">green code here, yellow code there</a>.<br /><br /><strong>Lazy evaluation is the red pill</strong><br /><br />It&rsquo;s great to make a change to the code&rsquo;s behaviour without changing the way we think about the solution to our problem. But you know what? It isn&rsquo;t <em>interesting</em>. In fact, if lazy optimization was something we needed on a regular basis, we ought to switch to a <a href="http://en.wikipedia.org/wiki/Miranda_%28programming_language%29">language that does it for us</a>. Implementation details ought to be left to libraries, compilers, and virtual machines. That&rsquo;s what they&rsquo;re for.<br /><blockquote><br />A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.<br /></blockquote><p style="text-align: right;">&mdash;Alan Perlis</p>Now that we hold in our hands a tool for making infinitely long lists, the question to ask is, &ldquo;how does that affect the way we think about generating sample curves?&rdquo;<br /><br />The first thing that comes to mind is to ask why the set of sample curves we generate is finite. It isn&rsquo;t really finite, there are an infinite number of curves. (And not just any infinity, it&rsquo;s Aleph One, the children&rsquo;s book <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FOne-Two-Three-Infinity-Speculations%2Fdp%2F0486256642&amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">One Two Three… Infinity</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;amp;amp;l=ur2&o=1" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> explained that forty years ago.)<br /><p></p><div class="book"><br />  <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/uploaded_images/haskell_school_of_expression.jpg" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br />I&rsquo;m not a Haskell user (yet), but <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> has received rave reviews and comes with solid recommendations. It&rsquo;s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you&rsquo;re feeling generous!<br /><br /></div>What we really want is a <em>finite sample</em> of that infinite set of curves. Now let&rsquo;s zoom in and think about a single parameter, the <code>y</code> value for one of the control points on a curve. Let&rsquo;s say it&rsquo;s a rational number between <code>0.0</code> and <code>1.0</code> inclusive. It&rsquo;s relatively easy to generate a list of rationals in that range. Say we generate <code>0.0000...00001</code> (with jillions of zeroes elided: we want the smallest number our computer can represent), followed by <code>0.0000...00002</code> (the second smallest), and so on.<br /><br />If we leave the computer running for a few months or years, we should get all of the numbers between <code>0.0</code> and <code>1.0</code> that our computer can represent. That shouldn&rsquo;t be hard. But even taking into account the finite limitations on a computer&rsquo;s representation, that list is infinitely long.<br /><br /><strong>Useful samples</strong><br /><br />We need to take a finite sample of all of the infinite possibilities in that list.<br /><br />When working with an infinite list, what we want is that the front part of the list, the part we can access before the heat death of the Universe, contains a useful sample. If we were sampling a list like <code>(0.0000...00001 0.0000...00002 0.0000...00003 0.0000...00004 ... )</code> for control points, the first values are not useful at all. We&rsquo;d just get a line along the <code>x</code> access.<br /><br />There are various strategies for generating a more useful list. We could create an infinite list of random values. I&rsquo;ll outline another method below. But the take-away idea is this: we need lists where the most useful values are first. Working with infinite lists encourage us to think of infinitely sized sets of samples, ordered by usefulness.<br /><br />Let&rsquo;s say that when we generate <code>y</code>, we devise a list like <code>(0.0 1.0 0.5 0.75 0.25 ... )</code>. We&rsquo;re successively bisecting the intervals (which is why the library method is called <code>binary_search</code>). We can stop at any time and we have decent distribution. (And we can pipe dream that in the future, we can train our generator to favour points more likely to be useful to us.) That is much more useful!<br /><br />Here&rsquo;s some Lazy List code that does just that: given two seeds and an optional bisection block, it generates an infinite list of values:<br /><br /><pre><code>def binary_search seed1, seed2, &amp;block<br />  bisection_block = block || lambda { |x, y| (x-y)/2 + y }<br />  LazyList.cons(<br />    seed1,<br />    LazyList.new(<br />      seed2,<br />      delay {<br />        bisect(seed1, seed2, &amp;bisection_block)<br />      }<br />    )<br />  )<br />end<br /><br /># infinitely bisects a space, exclusive of the seed values<br /><br />def bisect seed1, seed2, &amp;block<br />  return EMPTY if seed1 == seed2<br />  half = block.call(seed1, seed2)<br />  LazyList.new(<br />    half,<br />    delay {<br />      merge(<br />        bisect(seed1, half, &amp;block),<br />        bisect(half, seed2, &amp;block)<br />      )<br />    }<br />  )<br />end<br /></code></pre>And indeed, <code>LazyList.binary_search(0.0, 1.0) -&gt; (0.0 1.0 0.5 0.75 0.25 ... )</code>.<br /><br /><strong><a href="http://en.wikipedia.org/wiki/Hilbert%27s_hotel">The Grand Hotel</a></strong><br /><br /><div class="book"><a name="evtst|a|0974514055" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611"><img style="" src="http://raganwald.github.com/uploaded_images/satan_cantor_infinity.jpg" alt="Satan, Cantor, and Infinity" border="1" /></a><br /><br /><a href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611">Satan, Cantor, and Infinity and Other Mind-boggling Puzzles</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0192861611" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> is a five-star introduction to Cantor&rsquo;s work on infinity, including a special treat: a completely different proof that Aleph One is greater than Aleph Zero based on games, very much in the style of Conway&rsquo;s Surreal Numbers. Currently out of print, but <strong>please</strong> get yourself a used copy from a bookseller: you won&rsquo;t be disappointed!<br /><br /></div>What happens when we try to combine two infinite lists? For example, we want a list of <code>(x, y)</code> tuples, generated as the Cartesian Product of our binary search list with itself. If we use a typical breadth-first or depth-first algorithm, we&rsquo;re sunk. We get <code>( (0.0 0.0) (1.0 0.0) (0.5 0.0) (0.75 0.0) (0.25 0.0)... )</code>. That has a nice distribution along one axis but still useless. What we need is a way of combining two infinite lists such that they give us a nice useful sample when we take a finite number of elements off the front.<br /><br />Here&rsquo;s a table describing how the ‘breadth-first&rsquo; algorithm for generating the product of two lists works. Consider two lists of three elements each. In the table below, columns represent one list and rows the other. The numbers represent the order that the product of the lists is generated:<br /><br /><table><tbody><tr><th colspan="3">Breadth-first mapping from elements to integers</th><br />      </tr><tr><td>1</td><td>2</td><td>3</td></tr><br />      <tr><td>4</td><td>5</td><td>6</td></tr><br />      <tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><br />This works fine for finite lists, but as we saw above it is useless for infinite lists. But looking at it in table form is useful. The product of two lists <em>is</em> tabular, the problem with a traditional algorithm is the order that we select elements from the table, not that the elements are tabular. Just as we solved the problem of how to sample <code>y</code> magnitudes by changing the order in which we selected rationals between <code>0.0</code> and <code>1.0</code>, what we need to do with Cartesian Products, what we need to do is select the products in an order that provides useful results.<br /><br />As it happens, there&rsquo;s an order that generates useful finite samples when dealing the product of two infinite lists: Instead of generating rows and appending them to each other, it generates <em>diagonals</em> and <em>merges</em> them with each other. The first diagonal is <code>1, 5, 9</code>. The second is <code>4, 8</code>. The third is <code>2, 6</code>. And so on. The advantage of this algorithm is that if given two infinite lists, it starts in the upper left-hand corner and supplies values, working its way right and down.<sup>2</sup><br /><br />Here&rsquo;re the first four values of the product of two binary searches with each other: <code>[{:x=&gt;0.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.5}]</code>. And the next four: <code>[{:x=&gt;1.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.25}]</code>. And the next eight: <code>[{:x=&gt;0.5, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.25}, {:x=&gt;0.5, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.75}, {:x=&gt;0.25, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.75}]</code>.<br /><br />We can take as many samples as we want, and more sample give us more &ldquo;resolution.&rdquo; We now have the tools we need to get rid of all of the limits and finite combinations and focus on describing what we&rsquo;re trying to generate without intermingling a lot of generating code.<br /><blockquote><br />And I&rsquo;m thinking about eternity<br />Some kind of ecstasy got a hold on me<br /></blockquote><p style="text-align: right;">&mdash;Bruce Cockburn, <a href="http://cockburnproject.net/songs&music/wwtla.html">Wondering Where The Lions Are</a></p>Now that we can generate an infinite list of useful magnitudes, plus we can combine infinite lists in a useful way, we can define an infinite list of sample curves. Here&rsquo;s the exact definition of an infinite list of partial beziérs (there are only three control points because the origin of the beziér is always the terminus of the previous beziér in the curve we are generating):<br /><p></p><pre><code>def sample_cubic_beziers<br />  magnitudes = LazyList.binary_search(0.0, 1.0)<br />  control_points = LazyList.cartesian_product(magnitudes, magnitudes) do |x, y|<br />    { :x => x, :y => y }<br />  end<br />  LazyList.cartesian_product(control_points, control_points, control_points) do |p1, p2, p3|<br />    {<br />      :p1 => p1,<br />      :p2 => p2,<br />      :p3 => p3<br />    }<br />  end<br />end<br /></code></pre>That&rsquo;s really simple, and really easy to understand.<sup>3</sup> The domain-specific code that defines a cubic Bezi&eacute;r is concise and readable. And the infrastructure code that handles combinatorics is shunted away out of sight where it doesn&rsquo;t clutter up our thinking.<br /><br />So what have we seen?<br /><ol><br /><li>Lazy evaluation solved a performance problem without needing an extensive rewrite of our generation code;</li><br /><li>Taking the red pill, infinite lists allowed us to radically simplify the original code.</li><br /></ol>Are there some opportunities to steal an idea like lazy evaluation from other languages and use them to simplify your code?<br /><br /><hr /><br /><ol><li>The data is a set of <code>(x,y)</code> tuples where <code>x</code> is time and <code>y</code> is a magnitude. The effort remaining in a <a href="http://www.mountaingoatsoftware.com/sprint_backlog">sprint backlog</a> is an example of this kind of data set. I need a function that computes the distance between any two data sets. I already have a function that computes the distance between a curve through the <code>xy</code> space and a data set, so if I build a lot of curves and then take the distance between each curve and each data set, I can find the distance between pairs of data sets by searching for the curve with the lowest total distance.<br /><br />This operation is On<sup>2</sup>, but that&rsquo;s why we invented distributed processing. Also, this operation is done infrequently relative to operations making use of the clusters, something like Google&rsquo;s indexing being far less frequent than searching Google. And of course, when my MacBook overheats and burns its way through my desk, I can come back and replace the brute force operation with something more intelligent.<br /><br />Well, all this requires generating the sample curves. I have code that makes curves out of Beziérs, provided I supply coördinates for the control points. the curves are actually <code>ActiveRecord</code> models. So all I needed was some simple code that generates all of the possible combinations and then write them to the database. It&rsquo;s the kind of thing candidates write in job interviews where employers actually care about their stone cutting skills.</li><br /><li>This problem is congruent to the proof that the set of all points on a plane is the same size as the set of all points in a line.</li><br /><li>And it could be simpler yet: a &ldquo;list comprehensions&rdquo; DSL for lazy lists <strike>is on the wish list</strike> <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html#lcir">would make things far more readable</a>.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">1:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, February 12, 2007</div>
			

			<div class="Post"><a name="677902229715311072">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/programming-language-stories.html" title="permanent link">Programming Language Stories</a></span>
					<div style="clear:both;"></div><strong>C</strong><br /><br />A fellow needs a dog house, so he hires a contractor. This guy is a C programmer who&#8217;s between jobs at the moment, and he says forget those wimpy &#8220;agile&#8221; wooden dog houses, he can build the dog house out of bricks, it will last forever and is stronger than any wood structure.<br /><br />The client is doubtful, but that sounds very impressive, and the contractor says this is how all the real-world dog houses are made, so he agrees. Well, it takes forever: it seems every time the contractor thinks it&#8217;s finished, they discover there&#8217;s a chink between the bricks and there&#8217;s a leak. With wood you just trim to fit, but with bricks you have to plan everything in advance so that the bricks line up just right.<br /><br />But Spring turns to Summer turns to Autumn, and the job is done. The client pays up, and the contractor&#8217;s about to leave when he stops and thinks for a moment before speaking.<br /><br />&#8220;Hey,&#8221; the contractor says, &#8220;You paid for a pallet of bricks, and I used all but one. It&#8217;s a shame if it goes to waste. Why don&#8217;t I see if I can use it somewhere?&#8221; The client asks like what, and before you know it the contractor has scored a contract to build a brick path for the dog from the back door to the dog house. He orders some more bricks, gets to work right away, and this time things go a little better.<br /><br />The contractor is now doing C++ on the side. And he uses some new bricklaying techniques he learned from <a href="http://www.amazon.com/gp/product/0321334876?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321334876">Effective C++</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321334876" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: there are these funny angle braces everywhere thanks to his path building templates. Soon that job is done and the contractor collects his fee. He&#8217;s about to leave, but he reaches into his tool chest and pulls out a brick.<br /><br />&#8220;Hey,&#8221; the contractor says, &#8220;You paid for another pallet of bricks, and I used all but one on the path. It&#8217;s a shame if it goes to waste. Why don&#8217;t I see if I can use it somewhere?&#8221; The client is happy with the path, asks like what, and before you know it the contractor has scored another contract, this time to build a brick wall enclosing the yard. He orders some more bricks, and gets to work right away.<br /><br />Meanwhile, the contractor has become a Visual C++ programmer and reads MSDN magazine religiously. He applies his new skills to building the wall: he has all these fancy tools that can put up sections of scaffolding when you push a button. of course, there are huge holes you have to fill in yourself, and the scaffolding has all these crazy joins and angles, it&#8217;s hard to change anything or understand how the entire wall fits together, but it feels like you&#8217;re getting a lot done because the system seems to move a lot of bricks for you.<br /><br />Well, the wall takes forever, and it doesn&#8217;t look that good when it&#8217;s finally done. But the client pays up and the contractor is ready to leave. But he stops for a moment and pulls a brick out of his tool chest.<br /><br />&#8220;Hey,&#8221; the contractor says, &#8220;You paid for two more pallets of bricks for the wall, and I used all but one. It&#8217;s a shame if it goes to waste. Why don&#8217;t I see if I can use it somewhere?&#8221;<br /><br />The client has had enough of this, and he decides he&#8217;s going to show the contractor how he feels. &#8220;Give me that brick,&#8221; he orders. The surprised contractor hands it over. &#8220;I don&#8217;t give a rat&#8217;s ass about this brick&#8221; the client huffs, and he throws the brick clear out of his yard.<br /><br />&#8220;I need to get work done, not talk to contractors all day about bricks. And besides, I&#8217;ve talked to the big landscape contracting companies, and they all say nobody is using bricks, everyone has switched to sharp tools and netting. Now get out.&#8221;<br /><br /><strong>Ruby on Rails</strong><br /><br />Just inside the gates of heaven, St. Peter sits at a desk checking people in.<br /><br />Peter:  &#8220;Welcome to heaven.  Programming language?&#8221;<br /><br />The man at the front of the line says, &#8220;<a href="http://www.amazon.com/gp/product/0133713458?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0133713458">Smalltalk</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0133713458" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.&#8221;<br /><br />Glancing at his clipboard, Peter says, &#8220;Room 33.  Be very quiet as you pass Room Six.&#8221;<br /><br />The process repeats itself with the next person in line:<br /><br />Peter:  &#8220;Welcome to heaven.  Programming language?&#8221;<br /><br />Person #2:  &#8220;<a href="http://www.amazon.com/gp/product/1590592395?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1590592395">Common Lisp</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1590592395" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.&#8221;<br /><br />Peter:  &#8220;Room 17.  Be very quiet as you pass Room Six.&#8221;<br /><br />The next person moves to the front of the line with a look of curiosity on her face.<br /><br />Peter:  &#8220;Welcome to heaven.  Programming language?&#8221;<br /><br />Person #3:  &#8220;<a href="http://www.amazon.com/gp/product/0596009259?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596009259">Python</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0596009259" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.&#8221;<br /><br />Peter:  &#8220;Room 54.  Be very quiet as you pass Room Six.&#8221;<br /><br />Person #3:  &#8220;Why do you keep telling us to be quiet as we pass Room Six?&#8221;<br /><br />Peter:  &#8220;Because the <a href="http://www.amazon.com/gp/product/0977616630?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0977616630">Ruby on Rails</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0977616630" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> People are in Room Six, and they think they&#8217;re the only ones here.&#8221;<br /><p style="text-align: right">&#8212;Snarfed from Eric Sink&#8217;s <a href="http://software.ericsink.com/articles/Boundaries.html">Baptists and Boundaries</a></p><br /><strong>Java</strong><br /><br />A mother was preparing the pot-roast for Sunday&#8217;s big family dinner. Before searing it and placing it in the pan, she carefully sliced the ends off. Her three year-old daughter asked &#8220;Mommy, why do you cut the ends off the roast?&#8221;<br /><br />She answered, &#8220;My mom taught me to do it that way, and it&#8217;s delicious, so it must be a good idea. Maybe the juices from the meat mix with the vegetables?&#8221;<br /><br />Everyone sits down for dinner, and when Father is serving the roast, the daughter remembers her question. She turns to Grandma and asks, &#8220;Grandma, why did you teach Mommy to cut the ends off the roast?&#8221;<br /><br />Grandma thinks for a moment and says, &#8220;What a delightful question! I always used to cut the ends off the roast, it&#8217;s how <em>my</em> mother taught me. I don&#8217;t know why she did that, there must have been a good reason.&#8221; Grandma sits for a moment, remembering her mother. &#8220;Well,&#8221; she continues, &#8221; there must have been a good reason. Now eat your dinner before it gets cold!&#8221;<br /><br />The holidays roll around, and they&#8217;re having dinner at Grandma and Grandpa&#8217;s house. &#8220;Hey!&#8221; Grandma says to the little girl, &#8220;You know what, I was going through your great-grandmother&#8217;s things, and I found the old roast pan. We sure made some good pot roast in it. Let&#8217;s make pot roast with it tonight in her honour!&#8221;<br /><br />They get out the pan and wash it up. It&#8217;s old, and well-seasoned. Grandma looks it over. &#8220;It&#8217;s smaller than I remember. I was a little girl, and everything looks bigger when you&#8217;re small!&#8221;<br /><br />They put the roast on the counter before searing it. Just then, Grandpa walks by. &#8220;Do you want me to cut the ends off the roast?&#8221; he asks. &#8220;It&#8217;s the only way you&#8217;ll get it to fit in that small pan.&#8221;<br /><br />Grandma and the little girl look at each other. And they smile.<br /><br /><strong>Scheme</strong><br /><br />A fellow is on vacation, and he decides to ride one of those &#8220;scenic&#8221; double-decker buses that drive around from attraction to attraction. The upper level is open-air, and he&#8217;s the only one up there. He looks around, and decides that instead of re-reading his copy of <a href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262560992" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, he&rsquo;s going to really enjoy himself: he lights a cigar.<br /><br />No sooner has he lit the cigar when a woman comes huffing and puffing upstairs, carrying one of those sub-miniature dogs people use as fashion accessories. She takes one look at our man and demands he put the cigar out: it is <em>offensive to the dog</em>.<br /><br />&#8220;Madam,&#8221; our man asserts, &#8220;this cigar is not offensive. Let me tell you its secrets.&#8221;<br /><br />&#8220;Eschewing inferior mass-market tobacco, I order whole, functional leaves&#8212;at great expense and with difficulty&#8212;from a small collective in Cuba that still grow cigar tobacco the old-fashioned, original way.&#8221;<br /><br />&#8220;Unsullied by automatic rolling machines or other push button devices, I roll each cigar, myself, by hand. Using secret tobacco-macro techniques that are impenetrable to the typical ignorant cigarette smoker, I am able to pack as much smoking pleasure into a single cigar as would take a carton of cigarettes&#8212;nay, it is impossible to enjoy a smoke from regular cigarettes as much as I enjoy the elite, exclusive flavour of my cigars.&#8221;<br /><br />The woman is not impressed. &#8220;If your cigars are so good, how come nobody smokes them?&#8221; she asks. &#8220;If your cigars are so good, how come so many clubs and restaurants permit cigarettes but forbid cigars?&#8221;<br /><br />Our fellow is so irate he begins to splutter. &#8220;If you or your dog are unable to understand that the purity, the perfection achieved long ago on a remote island far from consumerism and mass productio&#8212;&#8221; But he is unable to finish, for the woman imperiously sweeps the cigar from his mouth and flings it over the side of the bus.<br /><br />&#8220;That&#8217;s what I think of your pompous cigar.&#8221; She tells him.<br /><br />He glares at her for a moment, then years of oppression, of being forced to live with the hated cigarettes against his will, bring him to a boil and he commits an unthinkable act. With a wrench, he seizes the dog and flings it after his cigar. There is a moment of uncomprehending shock, and then the woman begins to howl.<br /><br />Well, the bus driver hears all this and slams on the brakes. For a moment everything is higgledy-piggledy, and just as the woman&#8217;s wails return to their full volume, everyone is shocked to see the dog come trotting up, unharmed.<br /><br />And what do you know: the dog has&mdash;nestled gently in its mouth&mdash;the most unexpected thing:<br /><br /><a href="http://www.rot13.com/index.php?text=Gur%20Oevpx" title="The Brick">Gur Oevpx</a>.<br /><hr><br />If you enjoyed these stories, you may also like <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a> and more recently, <a href="http://raganwald.github.com/2007/04/venture-capitalist-passes-away.html">A Venture Capitalist passes away peacefully, and...</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/programming-language-stories.html" title="permanent link">3:10 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, February 07, 2007</div>
			

			<div class="Post"><a name="117088092580614361">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/why-ruby-is-not-acceptable.html" title="permanent link">Why Ruby is not an acceptable implementation of Lisp</a></span>
					<div style="clear:both;"></div>The other day, while actually writing software (as opposed to <em>talking about writing software</em>), I wrote the following:<br /><br /><pre><code>distance = lambda do |given_scale|<br />  (magnitudes.map { |pair| <br />    (pair.evidence - (pair.flow * given_scale)) ** 2 <br />  }).inject { |acc, distance| acc + distance }<br />end<br /></code></pre><br /><br />If you are curious, <code>distance</code> is a function that computes the distance between a curve (called a &#8216;flow&#8217;) and some evidence, given a float that scales the flow. It&#8217;s used for finding a curve that &#8216;looks like&#8217; a set of data points.<br /><br />Can you spot the bug? I&#8217;ll expunge all of the excess and give you some code you can try yourself:<br /><br /><pre><code>require 'test/unit'<br /><br />class TestRubyNames &lt; Test::Unit::TestCase<br /><br />  def test_lambda_clobbering<br />    foo = lambda { (1..3).map { |foo| foo ** 2 } }<br />    assert_nothing_raised(NoMethodError) { foo.call() }<br />    assert_raise(NoMethodError) { foo.call() } # WTF?<br />  end<br /><br />  def test_local_clobbering<br />    foo = [1, 4, 9]<br />    bar = lambda { (1..3).map { |foo| foo ** 2 } }<br />    bar.call<br />    assert_equal(3, foo) # WTF?<br />  end<br /><br />end<br /></code></pre><br /><br /><div class="book"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0974514055"><img style="" src="http://raganwald.github.com/uploaded_images/programming_ruby-742816.jpg" alt="" border="1" /></a><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0974514055">Programming Ruby: The Second Edition</a> is an indispensable reference, especially to the latest libraries.<br /><br /></div>Is this what you expect? Ruby <em>looks</em> like a nice, block-structured language with lexical scope. But its standard implementation has serious issues. I believe these are <a href="http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l8">well-known and understood</a> issues, but issues nonetheless.<br /><br />One more example. I swore I wouldn&#8217;t write anything else about fixed-point combinators for a very long time, but try this exercise at home. Here&#8217;s my <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">curry combinator</a>:<br /><br /><pre><code>require 'test/unit'<br /><br />class ExempliGratia &lt; Test::Unit::TestCase<br /><br />  CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br /><br />  def test_clean_up_loose_ends<br />    maker = lambda { |f|<br />               lambda { |func_with_me| CURRY.call(func_with_me, func_with_me) }.call(<br />                    CURRY.call(lambda { |inner_func, me, *args|<br />                                inner_func.call(CURRY.call(me, me)).call(*args) }, f)) }<br /><br />    factorial = maker.call(<br />      lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />    )<br />    assert_equal(120, factorial.call(5))<br />  end<br /><br />end<br /></code></pre><br /><br />Looks good. Now let&#8217;s prove that <code>CURRY</code> is referentially transparent by replacing every <code>CURRY</code> variable with the lambda:<br /><br /><pre><code>maker = lambda { |f|<br />           lambda { |func_with_me| (lambda { |f, a| lambda { |*b| f.call(a, *b) } }).call(func_with_me, func_with_me) }.call(<br />                (lambda { |f, a| lambda { |*b| f.call(a, *b) } }).call(lambda { |inner_func, me, *args|<br />                            inner_func.call((lambda { |f, a| lambda { |*b| f.call(a, *b) } }).call(me, me)).call(*args) }, f)) }<br /><br />factorial = maker.call(<br />  lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />)<br /><br />begin<br />  factorial.call(5)<br />  puts 'fine'<br />rescue SystemStackError<br />  puts 'wtf?'<br />end<br /></code></pre><br /><br />Hunh? Ruby <em>looks like</em> a nice language supporting anonymous functions, but sometimes they work and sometimes they don&#8217;t. <strike>I strongly suspect that this issue has something to do with the fact that with the &#8216;naked&#8217; lambdas we&#8217;re creating new functions with every call, whereas the version using a <code>CURRY</code> variable re-uses the same function, so the system stack overflows in one case and not the other.</strike><br /><br /><strong>Update</strong>: Mike Harris proved that this second problem is the same as the first problem: once again, variables are clobbering each other all over the place. In Ruby 1.8, blocks do not create new scope, <i>at all</i>.<br /><br />Here's Mike's submission, indented to fit:<br /><br /><pre><code><br />def test_full_anonymity<br />  assert_equal(120, (lambda { |f0|<br />                       lambda { |func_with_me| <br />                         (lambda { |f1, a1| <br />                           lambda { |*b1| f1.call(a1, *b1) } <br />                         }).call(func_with_me, func_with_me) <br />                       }.call(<br />                            (lambda { |f2, a2| <br />                              lambda { |*b2| f2.call(a2, *b2) } <br />                            }).call(<br />                              lambda { |inner_func, me, *args|<br />                                inner_func.call(<br />                                  (lambda { |f3, a3| <br />                                    lambda { |*b3| f3.call(a3, *b3) } <br />                                  }).call(me, me)).call(*args) <br />                              }, f0)) <br />                    }).call(<br />    lambda { |f| lambda { |n| n.zero? && 1 or n * f.call(n-1) } }<br />  ).call(5))<br />end<br /></code></pre><br /><br /><strong>Stop your sobbing</strong><br /><br />I&#8217;m <em>not</em> saying Ruby is an unacceptable Ruby.<br /><br />I&#8217;m <em>especially not</em> saying &#8220;See, that&#8217;s why we should stick with language X.&#8221; If language X doesn&#8217;t even try to support this kind of programming, it&#8217;s a lame argument to say that it&#8217;s a better choice. That&#8217;s like saying that your 1972 <a href="http://en.wikipedia.org/wiki/Ford_Pinto" title="The barbecue that seats four.">Pinto</a> is safer than my 2004 MX-3 because the Pinto doesn&#8217;t have air bags, and air bags can injure small children if they are sitting in the passenger seat.<br /><br />If you try to bend Ruby to do Scheme-ish things, you will run into some corner cases, some places where it does the unexpected. Can you figure them out and avoid them (some people will say avoiding corner cases makes for a <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">Leaky Abstraction</a>)?<br /><br />I think if you&#8217;re writing Ruby code in Ruby, you can easily avoid these problems. That&#8217;s why Ruby is an acceptable Ruby.<br /><br /><strong>Why isn&rsquo;t Ruby an acceptable implementation of Lisp?</strong><br /><br />But why isn&rsquo;t Ruby an acceptable implementation of Lisp? (Besides the lack of support for <a href="http://www.cs.indiana.edu/scheme-repository/R4RS/r4rs_12.html">hygienic macros</a>, of course!)<br /><br /><div class="book"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0130305529"><img style="" src="http://raganwald.github.com/uploaded_images/on_lisp-725931.jpg" alt="" border="0" /></a><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0130305529">On Lisp: Advanced Techniques for Common Lisp</a> is <b>the</b> definitive text on metaprogramming and macros. Although written for Common Lisp, its ideas are easily applicable to Scheme and even Ruby metaprogramming.<br /><br /></div>The problem is that Lisp or Lisp-style programming is all about metaprogramming. Code that writes code. Code that evals code. It&#8217;s easy to look at something like the curry combinator and say &#8220;no programmer would ever write that convoluted a function in production.&#8221; But macros and code generators routinely combine snippets of code to produce monstrosities that a human wouldn&#8217;t even considering writing.<br /><br />When writing a piece of code that writes code, you are heavily dependent on the underlying implementation being regular and corner-case free. The whole point of writing code-writing code is that you intend for it to generate variations and combinations on your templates or scaffolds. And it&#8217;s only a matter of time before you are combining template A with generator B and meta-programming method C.<br /><br />When the underlying language is robust, none of this matters. The result works. If you look at it under the hood, you&#8217;re horrified at the result. But frankly, that isn&#8217;t an argument against meta-programming, it&#8217;s an argument <em>for</em> it: let the machine do the dirty jobs we don&#8217;t want to do, and let us deal with a nice abstraction like <em>A plus B plus C</em> that just works, never mind what the code looks like.<br /><br />(Don&#8217;t even think about arguing that we should do away with code that writes code. That debate was won by the code generation folks back when COBOL and FORTRAN and ALGOL were young. From time to time you&#8217;re welcome to pull out your assembly if you like, but we use High Level Languages because we want the machine to write the messy crap for us.)<br /><br />My fear is that code that writes code might one day write code that clobbers a variable. <strike>Or code that writes code might write some nested lambdas that overflow the stack.</strike><br /><br />And that&#8217;s why Ruby is not an acceptable implementation of Lisp.<br /><br /><hr /><br />Well, ok, I confess: the title is a bit of muckraking. <a href="http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp">Ruby is a pretty good implementation of Lisp</a>, and anyone who has two brains to rub together can point out that the issue is not whether there&#8217;s some corner case &#8220;gotcha,&#8221; but <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">whether using Ruby is, on the whole, more beneficial than not using Ruby</a>.<br /><br />For what it&#8217;s worth, I consider corner cases like this a strong endorsement of trying new languages like Ruby: it&#8217;s like finding out that your sailplane has a tendency to go into an inverted flat spin when you loop at an unacceptably slow speed. It&#8217;s terrifying when it first happens, but you get through it and then you realize that the only reason you got into trouble was that you were pushing yourself hard.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/why-ruby-is-not-acceptable.html" title="permanent link">3:03 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, February 06, 2007</div>
			

			<div class="Post"><a name="117078492091356135">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/guest-blogger-tom-moertel-derives-y.html" title="permanent link">Guest Blogger: Tom Moertel derives the Y combinator in Ruby</a></span>
					<div style="clear:both;"></div><em>In a comment on <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>, <a href="http://blog.moertel.com">Tom Moertel</a> derived an elegant version of the actual Y combinator in Ruby. I reproduce his words here with permission.<br /><br />Tom uses the alternate syntax for </em><code>call</code>, <code>[...]</code><em>. I avoided this to keep clear of a tiresome debate about operator overloading. (On one side: those who hate it. On the other side: those that hate Ruby disallowing overloading </em><code>(...)</code><em>).<br /><br />Ok Tom, take it away!</em><br /><hr/><br />Here&#8217;s my original Ruby definition:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |*args| f[y(&amp;f)][*args] }<br />end<br /></code></pre><br /><br />To get rid of the recursive call <code>y(&amp;f)</code>, let&#8217;s replace it with a variable <code>yf</code>, whose value we&#8217;ll say is magically equivalent to the result of the recursive call. To effect the binding of <code>yf</code>, we&#8217;ll need to wrap the method body in a new lambda expression and pass in the magic value:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |yf|<br />        lambda { |*args| f[yf[yf]][*args] }<br />    }[ &lt;&lt;&lt; placeholder for yf: we'll fill this hole next &gt;&gt;&gt; ]<br />end<br /></code></pre><br /><br />So, what value should we pass in for <code>yf</code>? Because the variable represents the value that would have been computed by calling <code>y(&amp;f)</code>, which is just the body of the <code>y</code> method, we can fill the hole with a duplicate of the body:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |yf|<br />        lambda { |*args| f[yf[yf]][*args] }<br />    }[ lambda { |yf| lambda { |*args| f[yf[yf]][*args] } } ]<br />end<br /></code></pre><br /><br />And we have our Y combinator:<br /><br /><pre><code>fac = y { |rec| lambda { |n| n &lt; 2 ? 1 : n * rec[n-1] } }<br />fac[5] # ==&gt; 120<br /></code></pre><br /><br />While the combinator works, its implementation repeats itself: there are two copies of the lambda expression<br /><br /><pre><code>lambda { |yf| lambda { |*args| f[yf[yf]][*args] } }<br /></code></pre><br /><br />in the method body. To factor them out, let&#8217;s let the variable <code>x</code> represent this expression. Then the method body simplifies to <code>x[x]</code>, which is very satisfying. To set <code>x</code> to the correct value, however, we need to add a wrapper lambda that binds <code>x</code> to the original expression. Putting it all together, we arrive at the final version:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |x| x[x] } [ <br />        lambda { |yf| lambda { |*args| f[yf[yf]][*args] } } ]<br />end<br /></code></pre><br /><br />And it, too, works:<br /><br /><pre><code>acc_fac = y { |rec| lambda { |n,acc| n &lt; 2 ? acc : rec[n-1, n*acc] } }<br />tail_fac = lambda { |n| acc_fac[n, 1] }<br />tail_fac[5] # ==&gt; 120<br /></code></pre><br /><br />Cheers! &#8212;<a href="http://blog.moertel.com">Tom</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/guest-blogger-tom-moertel-derives-y.html" title="permanent link">12:58 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="117073854086425300">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html" title="permanent link">But Y would I want to do a thing like this?</a></span>
					<div style="clear:both;"></div><blockquote><br />  Choose life. Choose a job. Choose a starter home. Choose dental insurance, leisure wear and matching luggage. Choose your future. But <a href="http://en.wikipedia.org/wiki/Y_combinator" title="Y combinator">Y</a> would <a href="http://en.wikipedia.org/wiki/Combinatory_logic#Examples_of_combinators" title="Identity combinator">I</a> want to do a thing like that?<br /></blockquote>Writing about <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">first-class functions</a> and their <a href="http://raganwald.github.com/2007/02/hof-or-oop-yes.html">compatibility with object-oriented programming</a> naturally leads to the <a href="http://en.wikipedia.org/wiki/Y_combinator">Y combinator</a>. And that is the point where eyes glaze over and soft, snoring sounds rise from RSS readers everywhere.<br /><br />But please bear with me, this essay is not really about the Y combinator, it&#8217;s about learning new things and expanding our capacity to think.<br /><br /><strong>Sharpening the saw</strong><br /><br />Years ago I picked up Steven Covey&#8217;s book <a href="http://www.amazon.com/gp/product/0743269519?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0743269519">The 7 Habits of Highly Effective People</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0743269519" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. If the book is a test out of seven, I really wasn&#8217;t doing very well.<br /><br />If you&#8217;ve read the book, you probably remember that he talked about &#8220;Sharpening the Saw,&#8221; investing in your own abilities. That&#8217;s incredibly important, but I don&#8217;t need to tell you that. If you exercise with programming katas, or learn a new programming language once a year, or pick up a book like <a href="http://www.amazon.com/gp/product/0262562146?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262562146">The Reasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262562146" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <em>and actually go through the exercises</em>, then you are already in the top 1% of software developers for personal skills improvement. (Sorry, certifications <em>don&#8217;t count</em>. They are the classic case of doing the wrong thing for the wrong reason!)<br /><br />New ideas&#8212;by which I mean, new to you&#8212;are an important way to sharpen your saw. If for no other reason than this: the brain needs regular exercise to perform at or near its potential. Learning new things keeps you sharp, even if you don&#8217;t directly use the things you learned.<br /><br />Others have suggested that learning Lisp is beneficial to your programming skills in its own right. That&rsquo;s one good way to sharpen your saw. But I add to that an important caveat: to obtain the deepest benefit from learning a new language, you must learn to think in the new language, not just learn to translate your favourite programming language syntax and idioms into it.<br /><br /><strong>Think different</strong><br /><br />The interesting thing about that is that almost by definition, if you see something in, say, Lisp that solves a problem you already have, you won&#8217;t learn much from the Lisp code. It is tempting to think that Lisp (or any other language) will somehow do what you&#8217;re already doing in some wonderfully magic way that is obviously better. But no, that isn&#8217;t how it really works.<br /><br />For your problems are tuned to your existing tools. You simply can&#8217;t imagine problems that your tools can&#8217;t solve well, much less can&#8217;t solve at all. That&#8217;s why there are so few continuation-based web servers. Who&#8217;s going to invent one unless they have a programming paradigm with continuations?<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422"><img border="0" src="http://raganwald.github.com/uploaded_images/to_mock_a_mockingbird-785706"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: The most enjoyable text on the subject of combinatory logic ever written. What other textbook features starlings, kestrels, and other songbirds?<br /></div>And worse, when a new tool is applied to a problem you think you know well, you will probably dismiss the things the new tool does well. Look at how many people dismiss brevity of code. Note that all of the people ignore the statistics about the constant ratio between bugs and lines of code use verbose languages. Look at how many people dismiss continuation-based servers as a design approach. Note that all of them use programming languages bereft of control flow abstractions.<br /><br />Thus, to truly learn a new tool, you must not just learn the new tool, you must <em>apply it to new kinds of problems</em>. It&#8217;s no good learning to replace simple iteration with first-class functions: all you&#8217;ve learned is syntax. To really learn first-class functions, you must seek out problems that aren&#8217;t easily solved with iteration.<br /><br /><strong>The Why of Y</strong><br /><br />Which leads me back to fixed point combinators. They appear to have no practical (as in making money) use. And that&#8217;s why I&#8217;m suggesting to you that you figure out how to make one in your language of choice. The very fact that the problem is far outside of your realm of &#8220;practicality&#8221; guarantees that you will learn something. You won&#8217;t be simply applying your same-old, same-old techniques and patterns to a slightly new problem.<br /><br />Start your research with Richard P. Gabriel&#8217;s <a href="http://www.dreamsongs.com/NewFiles/WhyOfY.pdf">The Why of Y</a>. Try porting his examples directly to your favourite programming language. If what you want to use is too brain-damaged to support closures, you may need to do a little greenspunning and build a little <a href="http://en.wikipedia.org/wiki/Function_object">functor</a> infrastructure.<br /><br />Don&#8217;t be dissuaded if you have to follow the functor route: you are learning far more about your language and about programming in general than the shmoes that settle for learning five new buzzwords related to the latest WS-* interoperability with XPath 3.x.<br /><br />If you prefer a <a href="http://raganwald.github.com/2007/02/its-monday-its-snowing-and-im-actually.html">fun</a> approach to learning, you can do not better than Raymond Smullyan&#8217;s <a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: an enjoyable romp through the world of combinatory logic. After reading this book, you will have mastered the S, K, I, Y, and other combinators. Added bonuses include a safe that can only be opened by applying G&ouml;del&#8217;s Incompleteness Theorem to its combination. How can you read this book and <em>not</em> learn?<br /><br /><strong>Eating my own dog food</strong><br /><br />I thought of a few things to say along these lines last week and then I abruptly realizing I was asking you to &#8220;Do as I say, not as I do.&#8221; What good is recycling problems I first encountered in University textbooks two decades ago? I put this post aside and set to work on a problem of my own.<br /><br />I set out to write a function for making recursive functions&#8212;a function <a href="http://en.wikipedia.org/wiki/Extensional_equality">extensionally equal</a> to the Y combinator&#8212;in Ruby. The ultimate goal is to take something like:<br /><br /><pre><code>lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) } }<br /></code></pre><br /><br />And be able to have it call itself recursively. In this case, to compute the <code>factorial</code> function.<br /><br />This is trivial, given that Ruby supports named recursion, but if you want to write a fixed-point combinator you want to write a function that makes recursive functions <em>without using the host language&rsquo;s support for named recursive calls</em>. In other words, you are bootstrapping named recursion out of anonymous first-class functions.<sup>1</sup><br /><br />There are important theoretical implications of being able to do this, but the killer reason to try it is to learn.<br /><br />I started my quest for a function for making recursive functions with a rather trivial observation based on OO programming and the Curry function:<br /><br /><pre><code>require 'test/unit'<br /><br />class ExempliGratia &lt; Test::Unit::TestCase<br /><br />  CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br /><br />  def test_recursive_curry<br />    maker = lambda { |func_with_me|<br />      CURRY.call(func_with_me, func_with_me)<br />    }<br />    assert_equal(120, maker.call(lambda { |me, n| n.zero? &amp;&amp; 1 or n * me.call(me, n-1) }).call(5))<br />  end<br /><br />end<br /></code></pre><br /><br />In OO some language implementations, <code>this</code> (or <code>self</code>) is a hidden parameter passed to each method. Thus, there&#8217;s a parameter&#8212;<code>me</code> in the example code&#8212;that is added for handling recursion. If you write a recursive function&#8212;like the venerable <code>factorial</code>&#8212;with the extra <code>me</code> parameter, a trivial currying operation evaluates it recursively without any need for names.<br /><br />This is obviously deficient. As noted above, we want to write <code>factorial</code> like so:<br /><br /><pre><code>lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) }<br /></code></pre><br /><br />We&#8217;ll need an <code>f</code> from somewhere, and just as our Scheme colleagues do, we&#8217;ll bind one as a parameter in an enclosing lambda. So we want to write:<br /><br /><pre><code>lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) } }<br /></code></pre><br /><br />And somehow this should be transformed into a working <code>factorial</code> function. For the test-driven crowd, we want to write:<br /><br /><pre><code>def test_clean_up_loose_ends<br />  maker = ...<br /><br />  factorial = maker.call(<br />    lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />  )<br />  assert_equal(120, factorial.call(5))<br /><br />  iterative_factorial = maker.call(<br />    lambda { |f| lambda { |n, acc| n.zero? &amp;&amp; acc or f.call(n - 1, n * acc) } }<br />  )<br />  tail_factorial = lambda { |n| iterative_factorial.call(n, 1) }<br />  assert_equal(120, tail_factorial.call(5))<br />end<br /></code></pre><br /><br />Of course, we need some code for <code>maker</code>. And the <code>iterative_factorial</code> case shows that <code>maker</code> works for functions with more than one parameter. The solution I came up with is:<br /><br /><pre><code>CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br />maker = lambda { |f|<br />       lambda { |func_with_me| CURRY.call(func_with_me, func_with_me) }.call(<br />            CURRY.call(lambda { |inner_func, me, *args|<br />                        inner_func.call(CURRY.call(me, me)).call(*args) }, f)) }<br /></code></pre><br /><br />The source code with each transformation from beginning to end is <a href="http://weblog.raganwald.com/source/curry_combinator.html">here</a> (I strongly suspect that this &#8220;curry combinator&#8221; is actually the Y combinator with a huge amount of cruft hanging off it).<br /><br />Unique or derivative, crap or craft, the process of getting it to work has enriched my mind by forcing me outside of my usual problem space. I still can&rsquo;t think of a practical application for what I&rsquo;ve just written. But I know I&rsquo;ve stretched myself.<br /><br />And now back to you: perhaps you&rsquo;re rushing off to try to implement a fixed-point combinator from first principles. Perhaps your plan is to code the canonical examples in your usual language. Those are both good paths. But whether you follow them today or not, remember the underlying principle exemplified by the fixed-point combinator:<br /><br /><em>Do not dismiss impractical or weird problems. While you may not have an immediate application for the code you write to solve such problems, you are maximizing your learning when you venture outside of your usual problem space.</em><br /><br /><hr/><br /><ol><li>Named recursion is stuff like <code>foo = lambda { |...| foo.call(:bar) }</code>. It takes advantage of the host language&rsquo;s variable binding to recurse. If you want anonymous recursion, you should be able to assign the same <code>lambda</code> to another name and have it work just as well, as in: <code>fufu = lambda { |...| foo.call(:bar) }</code>. That won&rsquo;t work if you are relying on Ruby&rsquo;s name for <code>foo</code>.</li></ol><br />p.s. Don&rsquo;t miss <a href="http://raganwald.github.com/2007/02/guest-blogger-tom-moertel-derives-y.html">Tom Moertel&rsquo;s derivation of the Y combinator in Ruby</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html" title="permanent link">12:06 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, January 31, 2007</div>
			

			<div class="Post"><a name="117030666664178098">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html" title="permanent link">Closures and Higher-Order Functions</a></span>
					<div style="clear:both;"></div>There has been a great deal of interest in <em><a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html">closures</a></em> lately, driven in great part by the fact that there is talk of adding some form of anonymous functions to the Java. Most of the time, people talk about “adding closures” to Java, and that prompts a flurry of questions of the form “what is a closure and why should I care?”<br /><br />The discussion around closures tends to go on and on about the “closing over” of free variables and only lightly touch on the biggest change to Java: functions as first-class objects with a lightweight syntax for creating them. Making it easy to do something basic like define a new function is more than just a little syntactic sugar: it makes it easy to do new things with functions that were impractical when you needed a lot of boilerplate to make anything work.<br /><br /><blockquote>Without understanding functional programming, you can’t invent MapReduce, the algorithm that makes Google so massively scalable.<br /></blockquote><div style="text-align: right;">—Joel Spolsky, <a href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">The Perils of JavaSchools</a><br /></div><br />I’m going to try to explain first class functions using Ruby (it <em>is</em> possible to write code that does exactly the same thing using the current Java feature set, however the result is so wordy that it obscures the basic idea being presented: call it accidental complexity, or perhaps <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html">yellow code</a>.)<br /><br /><a href="http://www.ruby-lang.org/">Ruby</a> is a good language for demonstrating features that ought to be in Java. Like Java, Ruby uses squiggly brace syntax. Like Java, everything in Ruby is an object&mdash;whoops, Java has primitives. Okay, like Java, functions are represented as objects.<br /><br />In Java you write:<br /><br /><pre><code>interface IFromIAndI {<br />   Integer call(Integer a, Integer b);<br />}<br /><br />IFromIAndI add_two_integers = new IFromIAndI() {<br />   public Integer call(final Integer a, final Integer b) {<br />      return a + b;<br />   }<br />};<br /></code></pre><br />(The Java convention is to name things in <a href="http://en.wikipedia.org/wiki/CamelCase">lowerCamelCase</a>, but we’ll ignore that. If you need to print this essay on a dot-matrix printer you may want to make some changes first.)<br /><br />In Ruby you write the function as:<br /><br /><pre><code>add_two_integers = lambda { |a,b| a + b }<br /></code></pre><br />Later on, when you want to call your function in Java, you write:<br /><br /><pre><code>add_two_integers.call(35, 42);<br /></code></pre><br />And if you like semicolons, you write the <em>exact same thing</em> in Ruby:<br /><br /><pre><code>add_two_integers.call(35, 42);<br /></code></pre><br />You can do the same thing with multiplication:<br /><br /><pre><code>multiply_two_integers = lambda { |a,b| a * b }<br /></code></pre><br /><strong>First Class Functions</strong><br /><br />In the examples above, functions look a little like methods. The Java version is obviously implemented as a method. But what we did in both cases was assign the resulting function to a variable. In Java, assigning a method to a variable is not particularly easy (it is possible using reflection).<br /><br />Anything that can be assigned to a variable is a <em>value</em>. If it can also be passed as a parameter or returned from a method (or function), we say it is a <em>first class value</em>. Functions as first class values, or first class functions, are very interesting. For example, what can we do passing a function as a parameter to another function?<br /><br />Hmmm. Well, I am breaking a cardinal rule of selling something. We’re talking about shiny new toys without identifying a problem to be solved. Let’s talk about my favourite problem: writing the same thing more than once, violating the <acronym title="Don't Repeat Yourself">DRY</acronym> principle.<br /><br />Here are two pieces of similar Ruby code:<br /><br /><pre><code>adder_wth_acc = lambda { |acc, list|<br />   if list.empty?<br />      acc<br />   else<br />      adder_wth_acc.call(acc + list.first, list[1..-1]) # [1..-1] returns a copy of the list without the first element<br />   end<br />}<br />adder = lambda { |list|<br />   adder_wth_acc.call(0, list)<br />}<br />adder.call([1, 2, 3, 4, 5])<br /></code></pre><br />And:<br /><br /><pre><code>multiplier_with_acc = lambda { |acc, list|<br />   if list.empty?<br />      acc<br />   else<br />      multiplier_with_acc.call(acc * list.first, list[1..-1]) # [1..-1] returns a copy of the list without the first element<br />   end<br />   }<br />   multiplier = lambda { |list|<br />   multiplier_with_acc.call(1, list)<br />}<br />multiplier.call([1, 2, 3, 4, 5])<br /></code></pre><br />What do they both do? Pretty much the same thing: they accumulate the result of some binary operation over a list of values. <code>adder</code> accumulates addition, and <code>multiplier</code> accumulates multiplication. You could call this a “Design Pattern.” If you did that, you would use the exact chunk of code everywhere. I would call that retrograde. Didn’t our predecessors invent the subroutine so we could eliminate writing the exact same piece of code over and over again?<br /><br />Why can’t we do the same thing? Well, we can. A subroutine does the same thing over and over again, but it takes different parameters as it goes. What is different between adder and multiplier? Ah yes, the adding and multiplying. Functions. What we want is a function that takes a function as a parameter.<br /><br />Well, we said that with first-class functions, functions are values and can be passed as parameters. Let’s try it:<br /><br /><pre><code>folder = lambda { |default_value, binary_function, list|<br />   fold_with_acc = lambda { |acc, list|<br />      if list.empty?<br />          acc<br />      else<br />          fold_with_acc.call(binary_function.call(acc, list.first), list[1..-1])<br />      end<br />   }<br />   fold_with_acc.call(default_value, list)<br />}<br /></code></pre><br />Now we can use our function that takes functions as a parameter:<br /><br /><pre><code>folder.call(0, add_two_integers, [1, 2, 3, 4, 5])<br />folder.call(1, multiply_two_integers, [1, 2, 3, 4, 5])<br /></code></pre><br />This is <strong>much</strong> better. When functions can take functions as parameters, we can build abstractions like <code>folder</code> and save ourselves a lot of code. Note that this would be a lot harder to read if we had to surround all of our functions with Object boilerplate in Java. That’s one of the key reasons why ‘syntactic sugar’—making it brief—is a big win.<br /><br />And you know what? Functions are values, not just variables that happen to hold functions. These work just as well:<br /><br /><pre><code>folder.call(0, lambda { |a, b| a + b }, [1, 2, 3, 4, 5])<br />folder.call(1, lambda { |a, b| a * b }, [1, 2, 3, 4, 5])<br /></code></pre><br />There’s just one problem (actually two, but I’m saving one for later): everywhere you use our new <code>folder</code> function, you need to remember that <code>add_two_integers</code> needs a default value of zero, but <code>multiply_two_integers</code> needs a default value of one. That’s bad. Sooner or later you will get this wrong.<br /><br />What we need is a way to call <code>folder</code> without having to always remember the correct initial value. Should we extend our understanding of a function to include a default initial value for folding? If we’re thinking in Java, maybe our <code>IFromIAndI</code> interface needs a <code>getDefaultFoldValue</code>? I think not. Why should a function know anything about how it’s used? And besides, as we build other abstractions out of functions we’ll need more stuff.<br /><br />If we aren’t careful, we’ll end up implementing the <code>Visitor</code> pattern on functions, and all of our brevity will go out the window. No, what we want is this: in one place we define that folding addition starts with a default value of zero and in another place we say we want to fold, say, <code>[1, 2, 3, 4, 5]</code> with addition. Then when we want to fold something else with addition, like <code>[2, 4, 6, 8, 10]</code>, we shouldn’t have to say anything about zero again.<br /><br /><strong>Adding Curry</strong><br /><br />What we need is a function that folds addition. Didn’t we say that functions are values that can be returned from functions? How about a function that makes a folding function? We should pass it our initial value and our binary function, and it should return a function that performs the fold without needing an initial value as a parameter:<br /><br /><pre><code>fold_coder = lambda { |default_value, binary_function|<br />   fold_with_acc = lambda { |acc, list|<br />      if list.empty?<br />          acc<br />      else<br />          fold_with_acc.call(binary_function.call(acc, list.first), list[1..-1])<br />      end<br />   }<br />   lambda { |list|<br />      fold_with_acc.call(default_value, list)<br />   }<br />}<br /></code></pre><br />Now we can do the following:<br /><br /><pre><code>adder = fold_coder.call(0, lambda { |a, b| a + b })<br />adder.call([1, 2, 3, 4, 5])<br />adder.call([2, 4, 6, 8, 10])<br /></code></pre><br />No more remembering that addition starts with a default of zero.<br /><br /><blockquote>Actually, there’s a far simpler way to avoid having to remember the default value when you want to fold over addition. But let’s just play along so that we don’t have to come up with an entirely new set of examples to demonstrate the value of functions as first-class values.<br /></blockquote>Functional programmers (as opposed to the rest of us <em>dysfunctional</em> programmers) will recognize this as <a href="http://en.wikipedia.org/wiki/Currying">currying</a> our <code>folder</code> function. Currying is when a function takes more than one parameter and you combine one of the parameters and the function to produce a function that takes fewer parameters.<br /><br />Here’s a currying function in Ruby:<br /><br /><pre><code>curry = lambda { |fn,*a|<br />   lambda { |*b|<br />     fn.call(*(a + b))<br />   }<br />}<br /></code></pre><br />(<em>This is an improvement on an earlier version, thanks to Justin's <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html#117037273013059827">comment</a>.</em>)<br /><br />So you can use our new function to create an increment function out of our adder and a treble function out of our multiplier:<br /><br /><pre><code>plus_one = curry.call(add_two_integers, 1)<br />times_three = curry.call(multiply_two_integers, 3)<br /></code></pre><br /><br />If you are ever asked, “what good is currying?,” I hope I’ve given you an example you can use to explain why currying matters, and why people do it all the time (possibly without explicitly naming it). Although it doesn’t look like much when looking at trivial examples like functions that multiply by three, it’s much more useful when creating folders and mappers where you want some of the parameters to remain constant.<br /><br /><strong>Composition</strong><br /><br />Our examples combined functions and non-functions to create new functions. Here’s an example from a recent post, <a href="http://raganwald.github.com/2007/01/dont-overthink-fizzbuzz.html">Don’t Overthink FizzBuzz</a>, where I give a method for <em>composing</em> two functions. The idea is that if you have multiple functions that each take one argument, you can combine them using <code>compose</code>. I also have a method that generates functions, <code>carbnation</code>:<br /><br /><pre><code># fizzbuzz.rb<br /><br />def compose *lambdas<br />  if lambdas.empty?<br />    lambda { nil }<br />  elsif lambdas.size == 1<br />    lambdas.first<br />  else<br />    lambda do |n|<br />      lambdas.first.call(compose(*lambdas[1..-1]).call(n))<br />    end<br />  end<br />end<br /><br />def carbonation(modulus, printable_form)<br />  i = 0<br />  lambda do |n|<br />    (i = (i + 1) % modulus) == 0 && printable_form || n<br />  end<br />end<br /><br />print(((1..100).map   &compose(     carbonation(15, 'FizzBuzz'), carbonation(5, 'Buzz'), carbonation(3, 'Fizz'))).join(' '))<br /><br /></code></pre><br />The simple explanation of how it works is that <code>carbonation</code> generates functions that replace every so many elements of a list with a printable string. <code>Compose</code> composes any two or more methods together. So if you want to print out 100 numbers, but replace every third number with “Fizz,” every fifth with “Buzz,” and all those that are third <strong>and</strong> fifth with “FizzBuzz,” you generate a function for each replacement, compose them together with compose, and then map the numbers from one to one hundred to the resulting überfunction.<br /><br />When you look at this today, it seems weird and unreadable by Java standards. I wonder if adding first-class functions with simple syntax to Java will lead the Java community to a place where code like this will not appear out of place?<br /><br /><strong>Just one more thing</strong><br /><br />So we started by saying that people are getting hung up on what makes a closure a closure, and there has been less emphasis on the benefits of using functions as first-class values. Did you notice that our <code>folder</code> function actually includes a non-trivial closure?<br /><br />If you look at the <code>fold_with_acc</code> function, it makes use of <code>binary_function</code>, a variable from its enclosing lexical scope. This is not possible with the current version of Java: if you translate this to Java, when you make <code>fold_with_acc</code> and anonymous inner class, you will have to copy <code>binary_function</code> into a final member to use it. It simply won’t compile if you try an idiom-for-idiom translation, even adding explicit types.<br /><br />And then if you look at the anonymous function it returns, <code>lambda { |list| fold_with_acc.call(default_value, list) }</code>, that anonymous function uses <code>default_value</code>,another variable from the enclosing lexical scope. Once again you will have to fool around with final variables to make this work, or perhaps declare full-fledged object with constructors.<br /><br />(If you try writing this simple example out in Java, you quickly find yourself inventing a lot of classes or interfaces. And they have some complicated types, like a function taking an integer and a function taking two integers, returning a function taking a list of integers and returning an integer.<br /><br />After twenty minutes of that, you understand why the <a href="http://www.ml.com/">ML</a> and <a href="http://planet.haskell.org/">Haskell</a> communities use <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: If the types are that complicated, it&rsquo;s incredibly helpful to have the compiler check them for you. Yet if the types are that verbose, it&rsquo;s incredibly painful to write them out by hand. Even if your IDE were to write them for you, they take up half the code, obscuring the meaning.<br /><br />You also get why the Ruby on Rails community doesn&rsquo;t care about type checking: types for CRUD applications are way less complicated than types for first-class functional programs.)<br /><br /><strong>That’s Interesting</strong><br /><br />Part of the interest in closures is in simplifying the syntax around functions, and part of the interest is in the way that access to enclosing scope would simplify a lot of code. There’s a whole debate around the value of simplification in a world where all serious languages are <a href="http://scienceblogs.com/goodmath/2007/01/turing_equivalent_vs_turing_co.php#more">Turing Equivalent</a>.<br /><blockquote><br />I hope you’re convinced, by now, that programming languages with first-class functions let you find more opportunities for abstraction, which means your code is smaller, tighter, more reusable, and more scalable.<br /></blockquote><div style="text-align: right;">—Joel Spolsky, <a href="http://www.joelonsoftware.com/items/2006/08/01.html">Can Your Programming Language Do This?</a><br /></div><br />For me, simpler is just nicer until something reaches a certain tipping point: when it becomes so simple that the accidental complexity of using it goes away, I will start using it without thinking about it. Tail optimization is like that: as long as recursion is slower than iteration and sometimes breaks, I have to think about it too much. But when I’m not burdened with “except…” and “when performance is not a factor…” it becomes natural.<br /><br />And then something interesting happens. It changes the way I look at problems, and one day I see a whole new way to do something that I never saw before. Functions as first class values are definitely one of those things that change everything.<br /><br /><span style="font-weight: bold;">Further Reading<span style="font-weight: bold;"><br /><br /></span></span>If this has whet your appetite for more, <a href="http://www.amazon.com/gp/product/0262011530?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&camp=211189&amp;creative=373489&creativeASIN=0262011530">Structure and Interpretation of Computer Programs</a> is <span style="font-style: italic;">the</span> book on higher-order functions and how they can be used as building blocks to create more elaborate abstractions such as object-oriented programming.<br /><br /><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a> devotes an entire book to the uses of functions. Although the examples are in Scheme, the language is dead simple to learn and the techniques in the book can be applied to Ruby and Java (or at least to a future version of Java where you do not need functors).<br /><br />The second edition of <a href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&camp=211189&amp;creative=373489&creativeASIN=0974514055">Programming Ruby</a> is an indispensable guide. Even if you will not be using Ruby immediately, pick it up and discover why so many people are lauding the language's simple, clean design and powerful Lisp-like underpinnings.<br /><br />As the author says, &ldquo;<a href="http://www.amazon.com/gp/product/1558607013?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1558607013">Higher-Order Perl: Transforming Programs with Programs</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1558607013" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is about functional programming techniques in Perl. It&rsquo;s about how to write functions that can modify and manufacture other functions.<br /><br />&ldquo;Why would you want to do that? Because that way your code is more flexible and more reusable. Instead of writing ten similar functions, you write a general pattern or framework that can generate the functions you want; then you generate just the functions you need according to the pattern. The program doesn&rsquo;t need to know in advance which functions are necessary; it can generate them as needed. Instead of writing the complete program yourself, you get the computer to write it for you.&rdquo;<br /><br />It&rsquo;s worth reading even if you have no intention of using Perl: the ideas span languages, just as SICP is worth reading even if you don&rsquo;t use Scheme at work. And be sure to read <a href="http://interglacial.com/hoj/">Higher-Order JavaScript</a> and <a href="http://blog.grayproductions.net/articles/category/higher-order-ruby/">Higher-Order Ruby</a>. They translate HOJ&rsquo;s ideas to other languages.<br /><br /><i>Notable Follow-ups:</i><br /><br /><a href="http://www.randomhacks.net/articles/2007/02/01/some-useful-closures-in-ruby">Some useful closures, in Ruby</a>: &ldquo;The <a href="http://en.wikipedia.org/wiki/Dylan_programming_language">Dylan programming language</a> included four very useful functions for working with closures: <strong>complement</strong>, <strong>conjoin</strong>, <strong>disjoin</strong> and <strong>compose</strong>.  The names are a bit obscure, but they can each be written in a few lines of Ruby.&rdquo;<br /><br /><a href="http://www.wuenschenswert.net/wunschdenken/archives/117">From Functional to Object-Oriented Programming</a>: &ldquo;OO allows a traceable connection between the conceptual design level and the implementation level. Concepts have names, so you can talk about them, between programmers and architects.&rdquo;<br /><br /><a href="http://raganwald.github.com/2007/02/hof-or-oop-yes.html">HOF or OOP? Yes!</a>: &ldquo;First-class functions are a natural fit with OO, as evidenced by their presence in OO languages that aren’t glorified PDP-11 assemblers with some OO stuff bolted on the side.&rdquo;<br /><br /><a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>: &ldquo;To truly learn a new tool, you must not just learn the new tool, you must apply it to new kinds of problems. It’s no good learning to replace simple iteration with first-class functions: all you’ve learned is syntax. To really learn first-class functions, you must seek out problems that aren’t easily solved with iteration.&rdquo;<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html" title="permanent link">11:55 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, January 26, 2007</div>
			

			<div class="Post"><a name="116984285613145307">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/shortest-post-yet-written-on.html" title="permanent link">The shortest post yet written on the realtionship between Ruby Metaprogramming and slavish adherence to the Gospel of the GoF</a></span>
					<div style="clear:both;"></div>Ruby Metaprogramming elevates the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator Pattern</a> from a useful tool to a core <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html" title="Finding the Signal-to-Noise Ratio in the Never-Ending Language Debate">idiom for creating idioms</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/shortest-post-yet-written-on.html" title="permanent link">3:19 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, January 24, 2007</div>
			

			<div class="Post"><a name="116969364618986488">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/dont-overthink-fizzbuzz.html" title="permanent link">Don't Overthink FizzBuzz</a></span>
					<div style="clear:both;"></div>I noticed some traffic coming to my post on <a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html">juggling</a> from <a href="http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding">Using FizzBuzz to Find Developers who Grok Coding</a>. Like me, the author is having trouble with the fact that <a href="http://www.joelonsoftware.com/items/2005/01/27.html">199 out of 200</a> applicants for every programming job can’t write code at all. I repeat: <em>they   can’t write any code whatsoever</em>.<br /><br /><em>UPDATE: If you think that I just claimed that 199 out of 200 working programmers cannot code, stop immediately and either read my <a href="http://raganwald.github.com/2007/03/thank-you-for-writing-such-heartfelt.html">follow-up explaining the math</a>, or read Joel&rsquo;s article on <a href="http://www.joelonsoftware.com/items/2005/01/27.html">why companies aren&rsquo;t as picky as they think they are</a>. Thank you.</em><br /><br />So the author has decided to set the bar ridiculously low. As the post says:<br /><br /><blockquote>I’ve come to discover that people who struggle to code don’t just struggle on big problems, or even smallish problems (i.e. write a implementation of a linked list). They struggle with tiny problems.<br /></blockquote>He gives an example of a “tiny” problem that is quite suitable for a phone interview:<br /><br /><blockquote>Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.<br /></blockquote>One of the nice things about using a tiny problem is that anyone who has written actual code in the last six months will solve it in less than ten minutes. This is good because (a) it leaves more time for talking about important things, and (b) if the candidate can’t solve the problem you will find out right away and save yourself a lot of grief.<br /><br /><a href="http://gilesbowkett.blogspot.com/2007/03/fizzbuzters.html" title="Fizzbuzters">As you can imagine</a> from a post like this, quite a few people have stepped forward with <a href="http://programming.reddit.com/goto?id=10d7w">creative solutions</a>. Here’s mine:<br /><pre><code># fizzbuzz.rb<br /># see <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html</a><br /><br />def compose *lambdas<br />  if lambdas.empty?<br />    lambda { nil }<br />  elsif lambdas.size == 1<br />    lambdas.first<br />  else<br />    lambda do |n|<br />      lambdas.first.call(compose(*lambdas[1..-1]).call(n))<br />    end<br />  end<br />end<br /><br />def carbonation(modulus, printable_form)<br />  i = 0<br />  lambda do |n|<br />    (i = (i + 1) % modulus) == 0 &amp;& printable_form || n<br />  end<br />end<br /><br />print(((1..100).map<br />   &amp;compose(<br />     carbonation(15, 'FizzBuzz'), <br />     carbonation(5, 'Buzz'), <br />     carbonation(3, 'Fizz'))).join(' '))<br /></code></pre><br />Right away I think you want to be careful if you ever trot a solution like this out in an <em>actual</em> interview. Here are some of the things that could go wrong:<br /><ul><li>The interviewer merely wanted to go through the motions of demonstrating you could program. Now she’s going to have to get into a discussion with you about how your solution works, which is irritating and wastes time that could have been invested more profitably on a <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">design question</a>;</li><br /><li>The interviewer might presume that you will always find the most indirect route to the destination and decide you belong in an ivory tower;</li><br /><li>The interviewer might not understand your solution at first glance but will make up for this by “bikeshedding” and grilling you about some minor nit like the failure modes of using <code>&&amp;</code> and <code>||</code> instead of the <code>if</code> statement or the ternary operator;</li><br /><li>The interviewer might have just finished <a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=026256100X">The Seasoned Schemer</a> and grill you over why your solution doesn’t use the <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y Combinator</a> to implement <code>compose</code> (snap!).</li></ul>Of course, some interviewers are just looking for an excuse to talk about technical issues and will not prejudge you in any way. Speaking for myself, I would laugh if you wrote something like this out. But then again, I once worked for someone who had won the second <a href="http://fly.cc.fer.hr/ioccc/years.html#1985_lycklama" title="Ed Lycklama, 'strangest appearing program', 1985">International Obfuscated C Contest</a>.<br /><br /><span style="font-style: italic;">Update</span>: <span style="font-weight: bold;">Don’t Overthink the Interview Either</span><br /><br />If you are conducting an interview and you receive a cryptic answer, or an impossibly concise one-liner, or perhaps something like the above that is redolent of Higher Order Functions, do you embrace the candidate as a genius? Or perhaps avoid them as someone who cannot write clear, maintainable code?<br /><br /><div class="book"><a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158"><img src="http://raganwald.github.com/uploaded_images/a_little_java-777624.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262561158" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><em><br /><br />Love to program but you need to use Java? Free your mind with <a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of <a href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262560992" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> and <a href="http://www.amazon.com/gp/product/026256114X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256114X">The Little MLer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256114X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em><br /><br /></div>I suggest the best answer is <span style="font-weight: bold;">neither</span>. Stay on track: you asked the question for the purpose of eliminating the 199 out of 200 that have absolutely no hope of ever producing working software. You have just identified that this person is the one in two hundred applicants who can actually code. Mission accomplished. You aren’t trying to get to HIRE or NO HIRE over the phone.<br /><br />Invite them in for an interview: that’s the place where you can drill down and obtain their views on professional programming. Remember, this is a <span style="font-style: italic;">toy</span> problem. Unless you load the question down with requirements that their answer resemble production code, why should you have any expectation that the candidate only knows one way to write software?<br /><br />This is like trying to hire programmers who know both languages, FORTRAN <span style="font-style: italic;">and</span> COBOL.<br /><br />If you do ask them for production code, don’t be surprised if the best candidates decide not to work for you: they will rightly point out that FizzBuzz is not a realistic example of a production problem.<br /><br />Overall I think the best approach as an interviewer is the simplest: pose the simple question. Indicate it is a screener designed to confirm that they are the person described on the resume.<br /><br />If anything, tell them that there is no need for production artifacts like documentation and unit tests, you just want working code in as little time as they are able. The no-hopers won’t get it no matter how simple the question, and the good people won’t waste a lot of time with JavaDoc and xUnit.<br /><br />And then make your decision based on one objective fact: <span style="font-style: italic;">does the code run and produce the desired output</span>. Everything else is superfluous to the question of whether the candidate should be asked into your office for a face-to-face meeting.<br /><br /><span style="font-weight:bold;">Update</span>: <a href="http://raganwald.github.com/2007/03/thank-you-for-writing-such-heartfelt.html">a response to some of the criticism</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/dont-overthink-fizzbuzz.html" title="permanent link">9:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, January 02, 2007</div>
			

			<div class="Post"><a name="116777595887408279">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/where-were-you-on-saturday-november-9.html" title="permanent link">Where were you on Saturday, November 9, 2002?</a></span>
					<div style="clear:both;"></div>Had you dropped by <a href="http://www.mit.edu/">MIT</a> on November 9th, 2002, you might have seen a rather large collection of hackers, academics, tool vendors, and programming language enthusiasts gathering for the <a href="http://ll2.ai.mit.edu/" title="Lightweight Languages 2">LL2</a>  conference. It was rather like taking the current readership of <a href="http://lambda-the-ultimate.org">Lambda the Ultimate</a> and <a href="http://programming.reddit.com">programming.reddit.com</a>—no, I am wrong.<br /><br />It was rather like taking the top couple of hundred of the people who write papers and blogs <em>cited</em> on Lambda the Ultimate and programming.reddit.com and gathering them in an auditorium together to talk about programming languages.<br /><br />As the rather Spartan LL2 web page explains, the theme of the conference was:<br /><blockquote>How to get usable and useful programming tools into the hands of programmers, minimizing dogma, and maximizing flexibility.<br /></blockquote>Like any other conference, there were speakers. The speakers talked about the languages they had invented, and about how and why people ought to use them.<br /><br />Had you been there, what would you have thought about the first speaker, <a href="http://www.sics.se/%7Ejoe/index.html">Joe Armstrong</a>, and his language, <a href="http://en.wikipedia.org/wiki/Erlang_programming_language">Erlang</a>? Just another weird language for embedded telephone switches? Or an important language that is powering diverse applications such as a <a href="http://couchdb.com/" title="CouchDB">distributed, replicating database</a>?<br /><br />Joe spent a lot of time talking about unreliability. About how computers and programming languages are always designed as if everything always worked and that not working was the exception case, rather than the rule. And about how you can’t build systems out of dozens, hundreds, or thousands of pieces without assuming that everything is unreliable, all of the time.<br /><br />And how there ought to be a programming language that builds that right into the system. Like Erlang. Would your eyes have glazed over? Or would you have thought about MapReduce and grid computing and would you have taken notes furiously?<br /><br />Would you have thought that two different talks (one about persistence and another about asynchronous exceptions) were too much for an obscure language called <a href="http://en.wikipedia.org/wiki/Python_%28programming_language%29">Python</a>? Would you have marked Python down as “One to Watch”?<br /><br />And what would <a href="http://research.microsoft.com/%7Etoddpro/" title=" Todd Proebsting">some random guy</a> know about inventing “the next big programming language”? Oh, he was managing Microsoft’s Programming Languages Systems group. Well, there you go, one guy that Corporate America might care about. I wonder how many of his predictions about the next big programming language have come true? Good thing his talk is <a href="http://ll2.ai.mit.edu/talks/proebsting.ppt" title="Disruptive Programming Language Technologies (ppt)">on line</a>, we can check…<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%; font-style: italic;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0130305529"><img style="" src="http://raganwald.github.com/uploaded_images/on_lisp-725931.jpg" alt="" border="0" /></a><br /><br />Paul Graham, author of “On Lisp: Advanced Techniques for Common Lisp,” was one of the LL2 organizers.</div>After lunch, some random guys talk about getting an un-typed language running on top of the Java Virtual Machine. I mean, really, who the hell would think <em>that</em> would ever <a href="http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython" title="IronPython">become</a> <a href="http://jruby.codehaus.org/" title="JRuby">important</a>?<br /><br />Next up, the organizers had flown <a href="http://en.wikipedia.org/wiki/Yukihiro_Matsumoto" title="Matz">Yukihiro Matsumoto</a> in to talk about Ruby. Yes, in 2002 the organizers wanted a bunch of Lisp-heads—the Q &amp; A for absolutely every talk included at least one question about when macros would be added to the speaker’s language—to hear from someone who had designed a language known at the time as the most popular scripting language <em>in Japan</em>. Had you heard of Ruby in 2002? Did you care?<br /><br />And what was with him constantly talking about making programming fun and comfortable? As if a programming language was a <em>user interface</em> for programmers. Everyone knows that programmers <em>love</em> idiosyncratic tools like Emacs, right? Who designs a language for <em>usability</em>? Who indeed.<br /><br />There were other talks. They were all good, just as good. There was a spirited exchange of ideas over lunch in the lobby, again upstairs in the MIT researchers’ offices, and continuing late into the night at a nearby pub. It was a phenomenal gathering.<br /><br />Were you there?<br /><br /><em>That isn’t important right now</em>. If you were there, good for you, and I hope in the four years since you have taken some of those ideas, and a lot of that enthusiasm, and rolled it into what makes this industry great. The fact that anyone—even some guy from the other side of the world—can make something that other people like and use. Whether it’s free or for pay, whether it’s a language, a tool, an application, or a piece of hardware.<br /><br />But even if you were there, that was then and this is <em>now</em>. 2007. Here’s the important question: <em>Where is LL2 this year?</em><br /><br />I asked “where is LL2 this year.” Actually, it may not be a Lightweight Languages conference. It might have nothing to do with programming languages. But somewhere in the world, somewhen in 2007, there is going to be a conference. Or a gathering. Maybe it’s this year’s <a href="http://startupschool.org/">Startup School</a>. Maybe it’s a <a href="http://barcamp.org/DemoCamp">DemoCamp</a> in your city.<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%; font-style: italic;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0974514055"><img style="" src="http://raganwald.github.com/uploaded_images/programming_ruby-742816.jpg" alt="" border="1" /></a><br /><br />Programming Ruby: the second edition is an indispensable reference, especially to the latest libraries.</div>Wherever, and whenever it is, you are going to see and hear things that are going to matter to you over the next five years.<br /><br />They may not look like much in 2007, but they’re the seeds of the next Big Thing, the thing that will be big four or five years hence, in 2012.<br /><br /><strong>Finding the conference</strong><br /><br />In 2002, LL2 didn’t look like much. You probably couldn’t find a job using <em>any</em> of the languages discussed at the conference. Unless you wanted to work on telephony. The lone representative of a mainstream company—Microsoft—wasn’t talking about their products, he was talking about things that would <em>disrupt</em> their products.<br /><br />So if you’re looking for the right conference in 2007, there are two clues: the agenda isn’t going to include anything you can use to make money, and it isn’t going to feature anybody trying to make money off of you.<br /><br />That’s right: no consultants, no white papers, no thinly veiled sales pitches. That knocks most Ruby conferences out. Maybe not all, but most. The right conference isn’t going to be about building CRUD applications on top of MySQL with <a href="http://script.aculo.us/">AJAX goodness</a>. That may not be out of date, but it’s so 2007, and we’re looking for <strong>2012</strong>.<br /><br />In 2002, the audience was highly interactive. Most of them were working on their own projects. They were <em>practitioners</em>, not tourists. They weren’t there to get a job, or goof off work. They were there to learn stuff for themselves and share what they knew with others.<br /><br />In 2007, you should be looking for the same thing. For a conference that will be attended by people who are, as Joel would say, <em>Smart and Get Things Done</em>. Lacking a way to check the door before you show up, how do you find out?<br /><br />Naturally, you find out by talking to other would-be attendees before going. LL2 had LL1’s active <a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/maillist.html">mailing list</a>. In 2005, Startup School had a <a href="http://startupschool.infogami.com/">wiki</a>. I don’t know what the right conference in 2007 will have, but I will bet on this: if there’s no community building in advance around a wiki, a list, or some other peer-to-peer communication, it isn’t the right conference.<br /><br />The kind of conference where there is a one-way exchange between you and the organization—they tell you where to show up and you send them money—is not the right kind of conference. Look for the conferences that are built on top of active communities.<br /><br />And when you find the community, pay attention to the action-to-talk ratio. I’m terrible at this, I always have to push myself to <a href="http://homoiconic.com">work</a> and stop goofing off on my blog. But you know what’s worse? People who don’t have any work to begin with, it’s all just entertainment to them. They are <em>tourists</em>, and they are a liability to a conference.<br /><br />Here’s why.<br /><br />When tourists reach critical mass, the organizers start to cater to them. That means safe topics and safe speakers. Consultants. People with a good “patter” but not much to say that would disturb anyone.<br /><br />Also, the tourists tend to ask the wrong questions, because they aren’t the market for anything new and interesting. Say a tourist raises her hand. She’s going to ask about something she imagines might concern a user, but you know what? She isn’t a user and she really has no idea how a user thinks, because she’s not the type to learn anything new until it’s already popular, and she doesn’t have any idea how such people think.<br /><blockquote>I think the root of your mistake is saying that macros don't scale to larger groups. The real truth is that macros don't scale to stupider groups.</blockquote><div style="text-align: right;">—Paul Graham<br /></div><br />So she asks something irrelevant. Like about language performance. Or bindings to Oracle. Or whether there is an Eclipse plug-in. Or how it will scale to larger programming teams.<br /><br />But when a practitioner asks a question, it’s a smart question, it’s important. The speaker learns something important about their tool and the rest of the audience learns too. The next thing, someone asks a smarter question, and the energy builds.<br /><br />If there are too many tourists, you can’t learn anything significant in the Q & A, and that’s a shame, because Q &amp; A is where the action is.<br /><br />So, my advice for finding the right conference is, avoid anything to do with either you or the presenters making money, find a conference built on top of an active community, and go the the conference with the highest density of practitioners.<br /><br />And my question really ought to have been, <em>will you be at this year’s important conference?</em> and better still, <em>will you be presenting?</em><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/where-were-you-on-saturday-november-9.html" title="permanent link">4:57 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, October 30, 2006</div>
			

			<div class="Post"><a name="116223422144967513">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/ruby-io-and-ocaml-programming-pattern.html" title="permanent link">A Ruby, Io, and Ocaml Programming Pattern</a></span>
					<div style="clear:both;"></div><blockquote>Every 5 minutes you spend writing code in a new language is more useful than 5 hours reading blog posts about how great the language is.</blockquote><div style="text-align: right;"><a href="http://www.minds.may.ie/%7Edez/serendipity/index.php?/archives/102-Programming-Theorems.html">Programming Theorems</a><br /><br /><div style="text-align: left;">Seriously.<br /><br />If I hand you a plastic disc, are we going to spend all day debating whether Ultimate is more fun than Soccer? Do you want to investigate the physics of rotating aerofoils and how gyroscopic precession affects the flight path when the disc is released from your hand at 190 degrees?<br /><br />Or should we just go out and throw the <a href="http://www.ultimatehandbook.com/uh/training_hammer.html">Hammer</a> already?<br /><br />Reading is important. But reading (and blogging!) is no substitute for doing. And on that note, I shall return to writing unit tests...<br /></div></div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/ruby-io-and-ocaml-programming-pattern.html" title="permanent link">1:38 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, October 08, 2006</div>
			

			<div class="Post"><a name="116033648506034653">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?</a></span>
					<div style="clear:both;"></div><a href="http://en.wikipedia.org/wiki/ML_programming_language">ML</a> is a programming language featuring <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: you don’t have to encumber your code with type declarations, the compiler can figure them out for you. So… are type inference languages like ML for Sneetches <a href="http://steve-yegge.blogspot.com/2006/10/egomania-itself.html">with or without stars</a>? Or another kind of Sneetch entirely?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/Sneetches-Other-Stories-Classic-Seuss/dp/0394800893/s?ref=raganwald001-20"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/sneetches-711589.jpg" border="0" alt="" /></a><blockquote style="font-style: italic;">Now, the Star-Belly Sneetches had bellies with stars.<br />The Plain-Belly Sneetches had none upon thars.<br />Those stars weren’t so big. They were really so small<br />You might think such a thing wouldn’t matter at all.</blockquote><span style="font-style: italic;font-size:85%;" >Update</span><span style="font-size:85%;">: More than a few people have <a href="http://empathybox.com/archives/7">written</a> that Steve Yegge's association of static typing with neatness and dynamic typing with slovenliness runs opposite to their impressions of the kinds of people who strongly prefer one or the other. I used Steve's terms in the original post, partly because I thought people would get the same joke I thought Steve was making. It looks like they don't, nobody wrote to say "LOL." I have changed the terms to something that represents what I think of the cultural divide between programmers who like Java and programmers who like Ruby.</span><br /><br />Let’s review. Sneetches with stars like to use a colour-coded label maker to label the drawers, boxes, and files in their office. Once glance at everything and you know what it holds. Sneetches with stars add extra labels even when you don’t need them. For example, if a box is labeled ‘tax receipts’, each piece of paper inside has a post-it note saying tax receipt’, even if it’s obviously a tax receipt and lives inside the tax receipts box.<h4 id="what_is_stariness">What is Stariness?</h4>Sneetches with stars like these languages we say are <em>statically typed</em>. What do we mean by the word static? We mean <em>it can be resolved at compile time</em>. Other words for this idea are <em>invariant</em> or <em>constant</em>. Sneetches with stars like languages where the type of each entity can be resolved at compile time.<br /><blockquote>Some people are always critical of vague statements. I tend rather to be critical of precise statements; they are the only ones which can correctly be labelled "wrong."</blockquote><div style="text-align: right;">Raymond Smullyan<br /></div><br />Let’s dive into this a little deeper. (My apologies to my readers who were actually paying attention to the stuff in first year computer science that isn’t a requirement for <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">getting a job at BigCo</a>.) What does it mean when we say “something can be resolved at compile time”? That expression is laden with implementation details like assuming we’re using a compiler. But it’s a convenient short-hand for saying <em>something about the program that is true every time you run the program</em>.<br /><br />Consider the <code>final</code> declaration in Java. If you write:<br /><pre><code>final String snafu = "situation normal...";<br /></code></pre>We know that the variable <code>snafu</code> always holds a reference to the constant string <code>"situation normal..."</code>. No matter what data you feed to your program and how you mangle it, <code>snafu</code> will always be <code>"situation normal..."</code>. Do you agree? (Joe Campbell, put your hand down. Yes, there is a back door way you can change the contents of a <code>String</code> in Java.)<br /><br />Java can take advantage of this to perform <em>constant propagation</em>. Everywhere you write <code>snafu</code>, Java can substitute <code>"situation normal..."</code> and throw away the variable lookup. To get away from arguing about back doors in the <code>String</code> class, let’s consider one of the primitive types, a <code>boolean</code>. If you write:<br /><pre><code>final boolean foo = true;<br />    // code without assignments to foo<br />    if (foo) {<br />        // do something<br />    }<br />    else {<br />        // do something else<br />    }<br /></code></pre>Wouldn’t you agree that the compiler can get rid of the variable lookup and the <code>if</code> statement? The path through the code is always through the <code>// do something</code> path every time you run the program.<br /><br />Now back to the word <em>stariness</em>. We really mean <em>the amount of stuff about the program that can be resolved at compile time</em>, or if you prefer, <em>the amount of stuff that is true every time you run the program</em>.<br /><br />In the example above, the compiler can figure out which branch the program will follow at compile time, because that variable is true every time you run the program.<br /><br />Stuff that is always true is useful. For most programs, we have an idea in our head about “correctness.” What we mean when we talk about a program being correct is that it produces desirable results every time you run the program.<br /><blockquote>A formalist is one who cannot understand a theory unless it is meaningless.</blockquote>Stariness is thus similar to correctness. And that’s why a lot of people, the Sneetches with stars, are obsessed with it. Being able to “prove” something about their program (“the method call <code>foo.bar(5)</code> never throws a <code>MethodNotImplemented</code> exception”) feels a lot like being able to prove that their program is correct.<br /><br />It feels a lot like it, but it isn’t the same thing. The reason it isn’t the same thing is that while its true that a program throwing <code>MethodNotImplemented</code> exceptions is probably not correct, it’s not true that a program that doesn’t throw such exceptions <em>is</em> correct. It just feels, somehow, more likely to be correct because we’ve thrown out one of the infinite ways it can be incorrect.<br /><br />Now that we’ve dispatched that logically, let’s be clear about something: just because stariness does not enforce correctness, it doesn’t mean that stariness isn’t <strong>useful</strong>. Stariness is useful. Period, no debate.<h4 id="back_to_inferences">Back to inferences</h4>Type inference is also for Sneetches with stars.  A language with type inference resolves the type of each entity at compile time by inspecting the program and figuring the types out through inspection. It’s a lot like the way a compiler can look at the Java code above and figure out that you always <code>// do something</code> and you never <code>// do something else</code>. The code looks sorta like you could go either way, but the compiler knows better.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald-store-20&linkCode=ur2&camp=1789&creative=9325"><img style="float:left; margin:0 10px 10px 0;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/little_mler-705423.jpg" border="0" alt="" /></a>Languages with type inference look like variables can have any type, but the compiler knows better. Remember the labels that the verbose declaration Sneetches with stars love? Type inference languages still have labels, but the labels are hidden inside of the files and boxes where you can’t see them.<br /><br />Remember when manufacturers used to put their labels <em>inside</em> clothes instead of right across the front? Same thing. The rules for what goes where are strictly enforced, it’s just that if you can figure out what goes where with a bit of common sense, you don’t need a label or a post-it note.<br /><br />Compare these two snippets of Java:<br /><pre><code>final String[] words = { "foo", "bar", "blitz" };<br />final int word_length = words.length;<br />final String[] anagrams = new String[word_length];<br /></code></pre>…and…<br /><pre><code>final words = { "foo", "bar", "blitz" };<br />final word_length = words.length;<br />final anagrams = new String[word_length];<br /></code></pre>Hey, if a variable is final, we can figure out its type in Java through simple inspection. Making that work in the compiler is something an intern ought to be able to do over a Summer work term!<br /><br /><span style="font-size:85%;">(Frank Atanassow pointed out that techniques exist for inferring the types of nearly all Java variables through inspection of programs. But this simple case is enough for our purposes.)</span><br /><br />So if we take a valid Java program and simply erased type declarations whenever we could logically deduce the type of the variables (using our simple scheme), but left them in whenever we were not sure of the final type of the variables, we would have exactly the same program. Nothing about it has changed except it has fewer symbols. It’s just as starry, it is just as static, it is no more or less correct than it was before we erased some symbols.<br /><br />And you over there itching to say something about IDE refactorings and auto-completions: None of those go away either. You can rename things and move things and press command-tab to get an object’s methods whenever you like. So… would you agree that type inference of this sort doesn’t change a starry program into a starless program? This isn’t about stariness versus starlessness, it’s about the obsessive-compulsive desire to label everything.<br /><br />The bottom line: <em>type inference does not change a statically typed language into a dynamically typed language</em>. It’s still starry.<h4 id="so_why_can8217t_the_Sneetches without stars_use_type_inference">So why can’t the Sneetches without stars use type inference?</h4>Think of types as being like values and objects like variables. A statically typed language is one where there are no type re-assignments. Some languages enforce this. But if you write a program in a static way, you can still reason about it. This is why lots of people think that we can “neaten up” languages like Ruby by adding type inference to the compiler: they're thinking about programs that are neat to begin with, but we happen to have written them in a language for Sneetches without stars.<br /><br />And whenever someone talks about a refactoring IDE or an auto-completing IDE for a dynamic language, they’re talking about performing some type inference on Ruby programs that are written in a static way. So… what’s the holdup? We said we could add type inference to Java in a Summer. Where’s the intern to add it to Ruby?<br /><blockquote>Programmed. In me somewhere, he thought, there is a matrix fitted in place, a grid screen that cuts me off from certain thoughts, certain actions. And forces me into others. I am not free. I never was, but now I know that; that makes it different.</blockquote><div style="text-align: right;">Philip K. Dick, "The Electric Ant"<br /></div><br />The problem is that the set of all programs that are "starry" is a subset of the set of all programs that parse correctly. So either not all starless programs are neat, or not all portions of a starless program are neat, or both.<br /><br />Let’s compare back to our Java snippet. Remember:<br /><pre><code>final boolean foo = true;<br />// code without assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>The compiler could infer that we always follow the first branch because it knows that final variables are not reassigned. They’re <em>immutable</em>. What happens if we erase the <code>final</code> keyword as well:<br /><pre><code>boolean foo = true;<br />// code that might have assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>Now the job is much harder. We have to examine all the code in between the declaration and the use of foo. If there are any assignments involving things we can't know until runtime, we can't know the value of foo until runtime.<br /><br />For a very large class of programs, we cannot infer the contents of a variable with less runtime complexity than running the program for every possible input. This is why compilers have limitations on the optimizations they can perform, and humans still need to do some thinking about writing fast programs.<br /><br />This exact same thing happens with types. In statically typed languages, types are never re-assigned. Whether explicitly declared or inferred, they're immutable. But in languages like Ruby where methods can be added and removed dynamically, where messages can be forwarded dynamically, where we can even send messages dynamically, the types of objects are fully mutable.<br /><br />In starless languges, there is no <code>final</code> keyword on the types of objects. We can no longer infer the type of a variable in any but the simplest, degenerate cases.<br /><br />The type inference problem in dynamically typed languages is exactly the same as the inferring the possible contents of a variable problem. The inferring the contents of a variable problem is doable for a restricted set of programs. And the way we tell the compiler that a variable is a member of this restricted set is with the <code>final</code> keyword.<br /><br />Likewise, the way we tell a compiler that the type of a variable is also restricted is that we use a language where the type of every variable is final. It’s the same thing: we don’t reassign final variables and we don’t change types on the fly.<br /><br />Starlessness is not about writing programs without labels. Starlessness is when you write dynamic programs. Dynamic doesn’t mean ‘unlabeled’. As I showed above, if the <code>final</code> keyword is there, the label is mostly optional. But if you don’t have <code>final</code>, you’re writing dynamic programs.<br /><br />Truly starless programs have dynamic types: <em>types that change at run time</em>. they are not always one thing or another. For example, what if you write an Object-Relational Mapper (“ORM”) that reflects on the database structure at run time. That is, you can change columns in a database table and you get new getters and setter methods in your program. <em>Without recompiling</em>.<br /><br />In a fully static language (with or without type inference), you can’t do that. Think of Java’s JDBC: you have to fool around with methods that get values and pass a column name as a parameter. Or maybe you create a hash. And C# is getting this capability, but of you look closely you still have to define the “type” of a query through the LINQ syntax.<h4 id="are_neat_freaks_ever_starless">Are Sneetches with stars ever starless?</h4>A dynamically typed language lets us define an object holding a database row with methods for each column. But we can’t know at compile time whether our program will throw a <code>MethodNotImplemented</code> exception because we don’t know whether someone will monkey with the database structure. That sounds bad.<br /><br />But what happens if you write the same thing in a neat program? Aha! a <code>SQLException</code>! it seems that there are dynamic things that must be dynamic no matter what you do.<br /><br />This is a specific case of Greenspunning. There are some facilities of dynamic languages that you are going to need. If you don’t have them built into your static language, you will build them yourself or use a framework that has already built them for you. Other examples I have seen in Java programs include:<br /><br />Spring and Hibernate;<br />Any use of <code>Class.forName(...)</code>;<br />Any use of dynamic proxies;<br /><br />In essence, you’re being a Sneetch without a star but twisting your starry language to permit starlessness. And for those portions of the program that are no longer nice, starry bundles that can be examined at compile time for invariant behaviour, you are indeed in dynamic territory and have to live with the risks.<br /><br />In my experience, all non-trivial starry programs contain this kind of starlessness. To my admittedly inexperienced eyes, starlessness is the hallmark of expert programming in starry languages ("expert" does not necessarily mean "more desirable," especially in the minds of those who believe that programs should be written and maintained by mediocre developers).<h4 id="eating_cake">Eating cake</h4>So… can we say that since you can write starless programs in neat languages, you can have the useful benefits of stariness when you need it and the flexibility of starlessness when you need that too? Isn’t that better?<br /><br />Yes, you <em>can</em> say that. And you may be right, for you. The <a href="http://boo.codehaus.org/Language+Guide">Boo</a> people believe that: their language has a <code>duck</code> keyword for when you feel like a Sneetch without a star. Be aware that at this moment in history, languages designed for Sneetches without stars seem to have much better features for writing starless programs than languages for Sneetches with stars. So my observation is this:<br /><br /><em>If you dislike the verbosity of starry languages like Java but like the feeling of safety, try a type inference language. Don’t go to a starless language if you don’t intend to actually write dynamically typed programs.</em><br /><br />My experience is that if you are frustrated by the amount of work you have to do to express the algorithms in your head, you should look at a language that removes your frustration. If you're using Java and don't like the verbosity, find a language that celebrates brevity while preserving static typing. But if you're using Java and find yourself pushing more and more logic out of java because its type system is too static or too inflexible, you should consider a language with a different approach to typing.<br /><blockquote>Computer languages differ not so much in what they make possible, but in what they make easy. </blockquote><div style="text-align: right;">Larry Wall<br /></div><h4 id="why_would_the_Sneetches without stars_use_starless_languages">Why would the Sneetches without stars use starless languages?</h4><em>Writing starless programs on top of neat languages is exactly the same thing as writing automatic memory management routines on top of a manually managed programming language or writing functional programs on top of a noun-centric object-oriented language.</em><br /><br />You can take that statement as an argument in favour of specialized languages for Sneetches without stars or as an argument against them. My guess is that the above statement is true and a Rorschach Inkblot: You will interpret it as confirmation of your existing prejudices.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">3:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, August 22, 2006</div>
			

			<div class="Post"><a name="115627110102722538">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/08/anything-ridiculously-easy-is-going-to.html" title="permanent link">Anything "Ridiculously Easy" is going to attract some Ridicule</a></span>
					<div style="clear:both;"></div>Recently, Lucas Carlson <a href="http://tech.rufy.com/2006/08/mapreduce-for-ruby-ridiculously-easy.html">announced</a> <a href="http://rufy.com/starfish/doc/">Starfish</a>, an ultra-lightweight distributed processing framework, and map_reduce, his own implementation of distributed mapping and reducing based loosely on Google's famous <a href="http://labs.google.com/papers/mapreduce.html">MapReduce</a>.<br /><br />Almost immediately, people pointed out that what he had created looked to them like a toy. Some people pointed out that although its map is fully distributed, its reduce is <a href="http://tech.rufy.com/2006/08/more-advanced-starfish-feature.html">centralized in the supervisor process</a>. Others pointed out that fault tolerance was not built-in. Some even pointed out that it looked like a thin wrapper around other services (as if free software is <span style="font-style: italic;">sold by the </span><span style="font-style: italic;">pound</span>).<br /><br /><a href="http://www.flickr.com/photos/thomasb/209544848/" title="we have some stripey grass"><img src="http://static.flickr.com/79/209544848_408a5ac1f9.jpg" class="flickr-photo" alt="we have some stripey grass" border="0" /></a><span class="flickr-caption"></span><br /><br />I agree that map_reduce is not MapReduce. That's a <span style="font-weight: bold;">good thing</span>. After all, the world already <span style="font-style: italic;">has</span> MapReduce. If you want to use MapReduce just the way it is, go work for Google. Don't wait.<br /><br />You know, all the comparison to MapReduce has a strangely familiar ring. What do the following systems have in common?<br /><span style="font-style: italic;"><blockquote>Minicomputers, microcomputers, personal computers, laptop computers, <a href="http://www.businessweek.com/chapter/christensen.htm">5 1/4" disc drives</a>, <a href="http://www.businessweek.com/chapter/christensen.htm">3 1/2" disc drives</a>, <a href="http://www.businessweek.com/chapter/christensen.htm">1.8" disc drives</a>, client-server computing, PC databases, Unix, C, Ruby, Java, television, colour television, automatic transmissions, iPods, ...</blockquote></span>Must I go on? History is replete with inventions that are simplified, scaled-down versions of things that have come before (I know, Java-haters will find it hard to remember a time when Java was the new kid on the block that represented a simplified, scaled-down language compared to C++). It seems that every time some such thing comes out, somebody points out that it is a toy, not suitable for serious use.<br /><blockquote>My personal favourite example of dismissing advancement is the television. When it came out, old time radio people dismissed it as a toy. Nice call. But wait, we aren't done. When <span style="font-style: italic;">colour</span> television came out, the black and white television people dismissed it as unneeded. Somebody, as they say, wasn't dancing with the innovation they brought to the ball.<br /></blockquote>And what happens? Come on, you <span style="font-style: italic;">know </span>where this is going, it's practically a cliché: first the new, simpler, less powerful thing lives in a weird niche where people have a special need that overrides the bountiful impracticalities of the new thing. Then whole new markets are discovered where the new thing offers the perfect balance of features and before long, the new thing takes over the old markets.<br /><br />It's pretty obvious to me that when a lot of people dismiss something as being too simple, too underpowered, and lacking the wide variety of features and options of its predecessors, the right thing to do is to take a closer look and suspend final judgment. Right now <a href="http://en.wikipedia.org/wiki/Thomas_J._Watson#Famous_misquote">there's a world market for maybe five full-text web search engines</a>. If you are one of those five people trying to index the entire web, you can dismiss map_reduce immediately.<br /><br />Everyone else might want to look at map_reduce (and everything else considered too wimpy for serious work) and instead of listing all the ways it falls short of the status quo, ask yourself in what ways does the status quo falls short of mass-market appeal.<br /><br />At first glance, map_reduce looks like it makes it really easy to distribute analysis, especially of things living in your database. Hmmm. Thousands of Rails users put things in one database. Will it scale to 2,000 systems? How many of you have 2,000 systems? Next question.<br /><br />Now how many Rails programmers just ordered a shiny new Mac Pro with four cores? Nice to see a sea of hands. Guess what? You are all people who could benefit from map_reduce <span style="font-style: italic;">right now</span>. Do you have a few spare Macs or PCs in your office? All the better, put them to work while you're at it.<br /><br />I'm not in a position to recommend using map_reduce until I've tried it myself. But I can say without hesitation that there is a need for ridiculously easy distributed processing on Ruby, and it doesn't need to scale to 2,000 machines to be useful.<br /><br /><span style="font-style: italic;">Update: Lucas posted a working example from a production system: <a href="http://tech.rufy.com/2006/08/how-i-sent-emails-10x-faster-than.html">How I sent emails 10x faster than before</a>. Updated again to link to his explanation for <a href="http://tech.rufy.com/2006/08/more-advanced-starfish-feature.html">how reduce works in map_reduce</a>.<br /><br /></span><span style="font-weight: bold; color: red;">Hot news!</span><br /><br /></span>"<span style="font-style: italic;">How many of you have 2,000 systems?</span>" The answer is: <span style="font-weight: bold;">all of you</span>. Amazon's <a href="http://www.amazon.com/gp/browse.html?node=201590011">Elastic Compute Cloud</a> lets you run applications on thousands of machines and pay only for compute time and bandwidth outside of the cloud. Note to my sharp-witted readers (again, all of you): this is not a license to write and say "because I <span style="font-style: italic;">might</span> run an application on 2,000 servers, I'm dismissing Starfish without another thought." The correct thing to write is "I <span style="font-style: italic;">have written</span> an application that runs on 2,000 servers, and..."<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/08/anything-ridiculously-easy-is-going-to.html" title="permanent link">1:04 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, August 18, 2006</div>
			

			<div class="Post"><a name="115591828041681735">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/08/dynamic-is-opposite-of-static-not-of.html" title="permanent link">Dynamic is the opposite of Static, not of Explicit</a></span>
					<div style="clear:both;"></div>I recently read a post where the author said he does not care for Ruby's dynamic typing.<br /><br />When people start talking about types in programming languages, the terms fly around in a rather fast and loose manner. Here's a rather extensive and balanced discussion: the article on <a href="http://en.wikipedia.org/wiki/Type_system">Type Systems</a> in Wikipedia.<br /><br />Notice that Ruby is <span style="font-style: italic;">dynamically typed</span> (it's types are determined at run time and can change at run time), <span style="font-style: italic;">strongly typed</span> (it does not allow an operation to succeed on arguments which have the wrong type), and <span style="font-style: italic;">type-safe</span> (it does not allow operations or conversions which lead to erronous conditions).<br /><br /><a href="http://www.flickr.com/photos/raganwald/217905842/" title="Stuck on Stupid"><img src="http://static.flickr.com/62/217905842_095b0d071a_o.jpg" alt="Stuck on Stupid" border="0" height="400" width="400" /></a><br /><br />(There's another school of thought about how to name the properties of type systems. More on that at the bottom.)<br /><br />Proponents of <span style="font-style: italic;">explicit</span> <span style="font-style: italic;">types </span>may say that Ruby is not type safe because it is possible to compile programs that contain errors which will not be detected until the program is run and the erroneous condition is detected.<br /><br />Statically typed languages such as C# can detect a class of such errors at compile time. Some Ruby enthusiasts argue that they do not like the boilerplate associated with explicit typing and feel that the extra error checking does not outweigh the additional overhead.<br /><br />Both arguments are mistaken. Sorry about that. If Explicit and Implicit were the issues, we could add <a href="http://en.wikipedia.org/wiki/Type_inference">Type Inference</a> to Ruby and it would have the low overhead of implicit types as well as some extra error-checking (work on Soft Typing for languages like Scheme and Erlang aims to provide compile-time checking for implicitly typed languages). However, type inference is a feature of <span style="font-style: italic;">statically </span>typed languages.<br /><br />The trouble is that Ruby is <span style="font-style: italic;">dynamically </span>typed. Specifically, Ruby contains extensive <span style="font-weight: bold;">dynamic meta-programming</span> constructs. Type inference works with statically typed languages. The compiler must be able to infer the type or set of types possible for any variable.<br /><br />Consider a Ruby application that modifies classes and objects at run time. The simplest example is Ruby's built-in accessor methods: <span style="font-weight: bold;">attr_accessor :foo</span> is a class method that actually creates two instance methods at run time, <span style="font-weight: bold;">foo </span>and <span style="font-weight: bold;">foo=</span>. What happens when attr_accessor is called with a <span style="font-style: italic;">variable</span> as its argument, like <span style="font-weight: bold;">attr_accessor my_attribute</span>?<br /><br />If the type inference engine later looks at a call such as <span style="font-weight: bold;">bar.blitz = 'bash'</span>, how does it know whether attribute_accessor was ever called with 'blitz' or :blitz as an argument? Dynamic meta-programming makes the type inference problem undecidable.<br /><br />A lucid argument is that Ruby's dynamic typing makes it difficult to detect type errors statically. The <span style="font-style: italic;">correct </span>counter-argument is that Ruby's style of dynamic typing makes it possible to use dynamic meta-programming, such as <a href="http://rubyonrails.org">Ruby on Rails</a>' ActiveRecord, not that Ruby's implicit typing is more productive.<br /><br />Once you've made these arguments, you can decide for yourself whether the benefits of dynamic meta-programming do or do not outweigh the advantages of static type checking.<br /><br />(Updated to use the expression "dynamic meta-programming" to distinguish features like <span style="font-style: italic;">define_method </span>from static meta-programming features like macro systems, courtesy of the well-informed <a href="http://lambda-the-ultimate.org/node/1681">Lambda the Ultimate</a>).<br /><br /><div style="text-align: right;"><span style="font-style: italic;">fin</span><br /></div><br /><span style="font-size:85%;">p.s. <a href="http://c2.com/cgi/wiki?WelcomeVisitors"><span style="text-decoration: underline;">Ward's Wiki</span></a> seems to use the term <a href="http://c2.com/cgi/wiki?StaticTyping">static typing</a> to mean the same thing as explicit and strong typing. I prefer that the term static means that it doesn't change. The same wiki seems to use the term <a href="http://c2.com/cgi/wiki?DynamicTyping">dynamic typing</a> to mean the same thing as implicit and strong typing. It includes the possibility that a program is what I would call strongly, statically and implicitly typed: the checking is done at run time but the types of variables never change. The commentary suggests the phrase <span style="font-style: italic;">semantic dynamic typing</span> for the quality of dynamic typing that encompasses dynamic meta-programming. If you like these terms, please substitute "semantic dynamic typing" for "dynamic typing" above.</span><br /><br /><span style="font-size:85%;">p.p.s. And there's another argument that dynamic meta-programming, like macros, should be considered harmful. I'm saving my reply for a rainy day.</span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/08/dynamic-is-opposite-of-static-not-of.html" title="permanent link">11:11 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, July 19, 2006</div>
			

			<div class="Post"><a name="115331568432264045">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/07/car-and-cdr-have-had-their-fifteen.html" title="permanent link">car and cdr have had their fifteen minutes of fame</a></span>
					<div style="clear:both;"></div>In response to <a href="http://raganwald.github.com/2006/07/six-things-i-also-dislike-about-ruby.html">Six Things I Dislike About Ruby (and Four I Don't)</a>, someone quipped:<br /><i><blockquote>while we are stamping out those silly ungrammatical C++-isms like "puts", can we also get rid of those silly lispisms of 'car' and 'cdr'?</blockquote></i>Yeah, sister (or brother, as the case may be)!<br /><br /><a href="http://en.wikipedia.org/wiki/Car_and_cdr"><b>car</b></a> and <a href="http://en.wikipedia.org/wiki/Car_and_cdr"><b>cdr</b></a> are historical anachronisms. They are like secret handshakes: their only remaining value is to help a small cadre of enthusiasts bond around a shared collection of obscure trivia.<br /><br /><a href="http://www.flickr.com/photos/raganwald/212588975/" title="The original metacircular evaluator"><img src="http://static.flickr.com/86/212588975_5fa840ddd2.jpg" alt="The original metacircular " border="0" height="500" width="370" /></a><br /><br />I wouldn't be suprised if Lispers have droppped these from production systems in favour of the logo-isms <span style="font-weight: bold;">first</span> and <span style="font-weight: bold;">rest</span>. But then again, I wouldn't be surprised if some Lispers hang onto them either. After all, if every textbook uses them as examples, they become familiar through repetition, even if their names no longer make any sense whatsoever.<br /><br />The last time I checked nobody was running Lisp on <a href="http://www.iwriteiam.nl/HaCAR_CDR.html">IBM 704</a>s any more. These names really deserve a quiet retirement in a shady home where they can share war stories with  <span style="font-weight: bold;">puts</span> while they listen to<span style="font-weight: bold;"> goto</span> complain about what happened when <span style="font-weight: bold;">call/cc </span>made him obsolete.<br /><br />All that being said, car and cdr were rather prolific parents: Lisp implementations usually support a special syntactic sugar called <span style="font-style: italic;">composition</span> where you can make up a function with the following form: (/c[ad][ad]*r/ ...) and this is executed as if you types a series of nested cars and cdrs. For example, (caddr foo) has the same effect as (car (cdr (cdr foo))).<br /><br />I really like composition. We can sort of get that with dot notation and messages in languages like Ruby. But I secretly admire the way the German language lets you <a href="http://en.wikipedia.org/wiki/Rinderkennzeichnungs-_und_Rindfleischetikettierungs%C3%BCberwachungsaufgaben%C3%BCbertragungsgesetz">compose entirely new nouns by sticking smaller nouns together</a>.<br /><br />I think car and cdr's composition has a spiritual descendant in Ruby's metaprogramming style. For example, dynamic finders in Rails. <a href="http://railsmanual.com/class/ActiveRecord::Base">Person.find_all_by_username_and_password</a> really feels like caddaddr. Uh, maybe not.<br /><br />But it's nice to see that some of the good ideas from Lisp thrive in new homes.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/07/car-and-cdr-have-had-their-fifteen.html" title="permanent link">9:06 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, July 04, 2006</div>
			

			<div class="Post"><a name="115202765265635421">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/07/six-things-i-also-dislike-about-ruby.html" title="permanent link">Six things I also dislike about Ruby (and four that I don't)</a></span>
					<div style="clear:both;"></div><a href="http://cafe.elharo.com/ruby/10-things-i-hate-about-ruby/">10 Things Elliotte Rusty Harold "Hates" About Ruby</a>:<br /><blockquote><span style="font-style: italic;">1. initialize</span><br /><br /><span style="font-style: italic;">To create a new object in Ruby you invoke the new class method like so: c = Car.new("Toyota") Naturally you think the constructor would be defined in a method called </span><span style="font-weight: bold; font-style: italic;">new</span><span style="font-style: italic;">, right? Or just maybe a method called </span><span style="font-weight: bold; font-style: italic;">Car </span><span style="font-style: italic;">like in Java? But no, instead it has to be called </span><span style="font-weight: bold; font-style: italic;">initialize.</span></blockquote><span style="font-weight: bold;"></span>Right on. That's annoying.<br /><br /><style type="text/css">.flickr-photo { border: solid 2px #000000; }.flickr-yourcomment { }.flickr-frame { text-align: left; padding: 3px; }.flickr-caption { font-size: 0.8em; margin-top: 0px; }</style><div class="flickr-frame"> <a href="http://www.flickr.com/photos/84908131@N00/177986459/" title="photo sharing"><img src="http://static.flickr.com/77/177986459_dbf29b685b.jpg" class="flickr-photo" alt="" /></a><br /><span class="flickr-caption"><a href="http://www.flickr.com/photos/84908131@N00/177986459/">ruby </a>, originally uploaded by <a href="http://www.flickr.com/people/84908131@N00/">Victoria Wang</a>.</span></div><blockquote style="font-style: italic;">2. Weak typing</blockquote>Ahhh... I have promised not to write the same essay more than four times in any twelve-month period. Let's agree that Ruby would be <span style="font-style: italic;">even better</span> if there was some sort of type inference system that doesn't require type declarations everywhere.<br /><blockquote style="font-style: italic;">4. Global variables<br /><br />Didn’t somebody tell me Ruby was an object-oriented language?<br /><br />5. puts<br /><br />Do we have to copy C’s most ungrammatical, pointless method names?</blockquote><a href="http://en.wikipedia.org/wiki/Matz">Matz</a> was clearly in <a href="http://en.wikipedia.org/wiki/Backwards_compatibility">Raymond Chen mode</a> when he put all the perlisms in the language. As an application developer, I don't use any of them. But I'll accept it on faith that there are people using Ruby as a scripting language who like them.<br /><br />But I don't have to like them.<br /><blockquote style="font-style: italic;">6. Zero-based arrays<br /><br />C arrays began at zero to match memory addressing. In a weakly typed scripting language, there’s exactly no reason to do this. There hasn’t been for decades. Can’t we please start the arrays at 1 where God intended? Hasn’t anyone read Numerical Recipes? Aren’t we tired of fencepost errors yet?</blockquote>See above. But with extra pursing of the lips. Zero-based arrays are a perfect example of a <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">leaky abstraction</a>. Back in the days when programmers all wore beards and C was the new kid on the programming block, zero-based arrays were really just a funny kind of macro for performing a multiply and add on an integer that you hope is a pointer.<br /><br />No really, it's true. Go ahead, <a href="http://www.cs.cf.ac.uk/Dave/C/node10.html">look it up</a>. I'll wait.<br /><br />Okay, I agree with Rusty and then some. I'm perfectly okay with a new language using 1-based indexing. I think I can get over the momentary unfamiliarity as I untrain my brain to stop doing this unnatural zero-based thing.<br /><blockquote style="font-style: italic;">7. elsif<br /><br />Sorry. “elsif” is not a word in the English language, and it shouldn’t have been one in Ruby. Would typing one extra letter have been so onerous?</blockquote>Getting this wrong is almost a rite of passage when learning Ruby. Annoying. But not fatal, fortunately. At least Ruby doesn't assume els<span style="font-weight: bold;">e</span>if is a new variable declaration. I hope.<br /><blockquote style="font-style: italic;">8. $_<br /><br />Global variables suck. Did I say that already? Global variables you didn’t actually create and that pop up out of nowhere suck even worse. And global variables whose names are indistinguishable from line noise suck still more. Java’s verbose, but that verbosity is in the service of legibility. Ruby’s compactness all too often serves only to obfuscate.</blockquote>See above, again. I really suspect that the Perl-style stuff is of value when writing one-liners on the command line. It probably doesn't belong in an application longer than a page.<br /><br />I would normally say "so don't use them," but there is a small problem with globals: at least one, $=, affects the default behaviour of a kernal function: regular expression matching. For that reason, I consider it a little dangerous.<br /><br />I can live with built-in global variables that are, essentially, syntatic sugar for functions. But I'd rather that they not be syntatic sugar for method calls that change global state. No doubt you cannot have one without the other and thus I dislike them as well.<br /><br />Now about the lack of object orientation. It looks like other langauges have exactly the same problem. What's with all the <a href="www.cabochon.com/%7Estevey/blog-rants/singleton-stupid.html">singletons</a> out there? And what happens when you call java.lang.System.setProperty(...)?<br /><br />It seems that programmers like this stuff, no matter how bad it is for them. Which reminds me, <a href="http://swisschaletordering.com">ribs for lunch today</a>?<br /><blockquote style="font-style: italic;">9. Methods are public by default</blockquote>I personally don't care one way or the other about what the default access is, but I think Rusty has been perfectly cogent when <a href="http://cafe.elharo.com/java/the-three-reasons-for-data-encapsulation/">presenting his argument in favour of restricting APIs as much as possible</a>. And he goes further to suggest that restriction should be the default.<br /><br />Shrug. After all, you can choose what you want. Is there something drastically wrong with assuming that if a programmer writes a method with the default (public) visibility, that the programmer knows what she is doing and wants it that way?<br /><br />Uh, oh. I think I've also written this essay before. Let's move on.<br /><br />But I'll put this one down as a tie. I think Ruby would be a perfectly fine language if you had to take more care to make methods public.<br /><br />By the way, is there a resonance between this perspective and with the way you can declare that certain Rails controller actions must be invoked with PUTs or via XmlHttpRequest?<br /><blockquote style="font-style: italic;">10. No package access or friend functions.<br /><br />There’s no access in-between public and private. All too often different classes in the same library/application/codebase need more detailed access to their other parts than the general public should have. Ruby provides no way to manage this.</blockquote>(Something I find quite interesting: most of the Java programmers I have met do not use Java's 'default' visibility. But back to the subject at hand.)<br /><br />There are a lot of security measures you have to put in place if your objective is to hobble programmers.  Even then you may find they are motivated to work around the constraints you are attempting to impose:<br /><blockquote>Just about every developer at some point has used a library or a component developed by someone else. Just about every developer at some point has also gotten frustrated with the library to the point of being willing to find the guy who decided to make a method private and talk some sense into him. Well, most of us wouldn't go that far, but it would certainly be nice to be able to change things that make our lives miserable. It's not that libraries are written by mean people; it's just that even the brightest designers are unable to foresee all the possible ways that other developers would want to use their code.<br /><div style="text-align: right;">--<a href="http://www.javaworld.com/javaworld/jw-05-2004/jw-0510-patch.html">Hacking Java Libraries</a><br /></div></blockquote>In addition to providing various access constraints, you also have to put together security mechanisms like enforcing sealed packages. Within the Java world, researchers are also proposing <a href="http://www.haifa.ibm.com/info/ple/papers/class.pdf">sealed classes</a> and even sealed methods.<br /><br />Now I'm not going to say that just because someone can hack around your mechanisms that the mechanisms are bad. I'm perfectly okay with a language that gives you nothing better than a glorified annotation, the equivalent of a post-it note on your ham sandwich saying "mine! don't touch!!"<br /><br />It's useful to document your intentions, even if perfect enforcement is elusive. That being said, I'd like to close with the wise words of another: <a href="http://cafe.elharo.com/software/less-is-more/">Less is More</a>. For some people, fine-grained access control is important. But adding that feature is not free.<br /><br />Given the current culture of Ruby programming, I'd say that additional access control would be expensive if you go down the rabbit hole of trying to stop people using Ruby's meta-programming strengths to hack around your restrictions.<br /><br />However, lightweight mechanisms for access control and managing name spaces could be useful.<br /><br /><span style="font-weight: bold;">Conclusion</span>:<br /><br />As I suspected before I wrote this, I agree with more than half of Rusty's observations. Isn't this always the way? Most people have far more in common with each other than not.<br /><br />One of the reasons I read Rusty's work so carefully is that he has a markedly different viewpoint than my own. It's nice to read all the nice affirmation from people who seem to value the same things I value, but there is always an opportunity to learn something profound when looking at the same things from a different perspective.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/07/six-things-i-also-dislike-about-ruby.html" title="permanent link">11:36 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, January 03, 2006</div>
			

			<div class="Post"><a name="113630985287415026">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html" title="permanent link">Finding the Signal-to-Noise Ratio in the Never-Ending Language Debate</a></span>
					<div style="clear:both;"></div>Once again the web is buzzing with one of the most boring debates ever, namely "what's the best programming language?" I will not rehash the arguments. I'll try to restrain myself to stating my position, giving my reasons, and then toss in speculation on why a certain web framework is growing like wildfire.<br /><br />My position is simple: <span style="font-weight: bold;">the language operating at the highest level of abstraction while not suffering from project-killing defects is the one I want to use</span>. My algorithm is simple: throw away languages that will scuttle my project, and pick the highest level language out of those that remain. (I'm not going to discuss defects. They are a matter of taste and lead us down an unhappy path.)<br /><br />I believe that programming is an idiomatic activity. We learn idioms and then apply a kind of pattern-matching to recognise problems that can be solved with an idiom we already know. Some idioms are easier to express than others in each programming language. (Does the Weak <a href="http://en.wikipedia.org/wiki/Sapir-Whorf_Hypothesis">Sapir-Whorf Hypothesis</a> apply to programming?)<br /><br />Sure, all languages are Turing Complete and therefore equivalent in theory, but in practice you might find that the only way to express an idiom from Language A in Language B is to write a A->B compiler or interpreter in B.<br /><blockquote>  Greenspun's Tenth Rule of Programming: "Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp."</blockquote>Does that sound too academic? Consider this: how would you write a <a href="http://en.wikipedia.org/wiki/Continuation">continuation</a>-based framework (like <a href="http://seaside.st/">Seaside</a>) in <a href="http://rifers.org/wiki/display/RIFE/Web+continuations">Java</a>?<br /><br />This, incidentally, is why the language debate will never end. Programmers naturally learn and know the idioms <a href="http://en.wikipedia.org/wiki/Affordance">afforded</a> by their language. So when you say "In my language I can very easily do X and Y," the programmers using other languages always say "But nobody needs X or Y. We're busy doing Z."<br /><br />So let's talk about idioms instead of so-called features like syntax. What does it mean for one language to be "higher level" than another? To have a "higher level of abstraction"? My own interpretation is simple:<br /><br />One language is higher-level than another if it expresses more idioms in fewer bits than the other language. Or fewer lines of code. Or fewer symbols. There's a really simple language idiom for this: Programs in a higher-level language have a high <a href="http://catb.org/%7Eesr/jargon/html/S/signal-to-noise-ratio.html">signal to noise ratio</a>.<br /><br />For example, there are these "design patterns" that all of the COBOL^H^H^H^H^H Java programmers like to use. One of these is called <a href="http://128.42.6.89/JavaResources/DesignPatterns/VisitorPattern.htm">Visitor</a>: "<span style="font-style: italic;">One key advantage of using the Visitor Pattern is        that adding new operations to perform upon your data structure is very        easy. All you have to do is create a new Visitor and define the operation        there.  This is the result of the very distinct separation of variant        and invariant behavior in the    Visitor pattern.   The invariant behaviors are represented by the data  structure elements and    the abstract Visitor.   The variant behaviors are encapsulated in the concrete Visitors.</span>"<br /><br />Got that? How many lines of code do you need in Java? Here's how you express the Java idiom of the Visitor pattern in Ruby:<br /><br /><span style="font-family:courier new;">concrete.each { |thingy| visitor.visit thingy }</span><br /><br />Do you think I'm making this thing about brevity up?<br /><br />Here's something I found this morning. This fellow is explaining why interviewees can use any language they like to solve a problem, provided it's black:<br /><blockquote>When I interview someone, I usually let them use the language of their choice with between C, C++, C# and Java... It's not that I have something against Ruby or other fourth generation languages, but I found that these languages work at a level of abstraction that is a little too high to give me a meaningful insight on the candidate for a forty-five minute interview.  There are plenty of very interesting problems that are hard to solve even in Ruby or Python (and actually, it's quite likely this is the kind of problem that the candidate will be struggling with if she gets hired), but formulating the question and writing the solution would take several hours.<br /><div style="text-align: right;"><a href="http://beust.com/weblog/archives/000352.html">The Language of Interviews</a><br /></div></blockquote>Let me see if I can condense this: there is a class of problems that are non-trivial to solve in C# and Java but are trivial in Ruby and Python. Hot <a href="http://www.randsinrepose.com/archives/2006/01/01/swear_a_bit.html">damn</a>, I could have skipped writing this whole thing and simply posted the quote.<br /><br />(By the way, do you buy that something non-trivial to solve in Ruby must necessarily require hours to explain and to write out? Neither do I. I am not bashing the post here. That point is really a very small aside. But I don't have any trouble thinking of Ruby, Python, or Lisp problems that would require only a few minutes to explain and would be appropriate for an interview.)<br /><br />Now, there's some idea that you can build your own idioms in any programming language. We have various names for the technique (like procedures, subroutines, objects, modules, and macros), but the argument is that you can build up a library or framework of idioms and then you can ultimately express yourself with startling brevity.<br /><br />So some state that all languages are equal because if something is difficult to express you build your new idioms into the language and presto, you have a high signal-to-noise ratio in your programs.<br /><br />This argument has a major, glaring, flaw: <span style="font-style: italic;">the mechanism for building idioms in each language is an idiom itself, and it tends to be the most rigidly limiting idiom on the language</span>. C++ is a language for defining abstract data types that look just like built in types. In SmallTalk everything is an object that belongs to a class. And so on. Let's call this the language's "meta-idiom."<br /><br />The argument about idioms applies to meta-idioms. So if you want to build new idioms in a language, you need to use its meta-idioms. Some languages provide higher signal-to-noise on meta-idioms than others. Some languages make it easier to construct your own idioms than others. So even though all languages may provide some mechanism for raising the signal-to-noise ratio, not all are equal when it comes to using their mechanisms.<br /><br />So, I've written that I believe that not all languages are equal. I've written that I believe that an important metric for comparing languages is the signal-to-noise ratio, as measured by the brevity of expressing idioms. Now I will conclude by revisiting the affordances argument.<br /><br />Some languages make it easier to express some idioms than others. How? See the paragraph above about signal-to-noise ratio. Given that some things are easier than others in each language, wouldn't you expect that <span style="font-weight: bold;">there will be a very few languages that can express an order of magnitude more idioms in an order of magnitude less code than the 'average' language</span>?<br /><br />(If you don't think so, why not? Doesn't practically everything you've ever seen operate on a power law distribution? Why should programming languages be different?)<br /><br />So, I expect that some languages will do a better job of expressing a larger set of idioms than others. Now, here's the key question: does the number of idioms that a language affords <span style="font-style: italic;">matter</span>?<br /><br />I diverge from the wise men who write <a href="http://paulgraham.com/articles.html">essays </a>on this topic. I think it matters to me, but it is unlikely to sway anyone's decision. My simple observation is that programmers develop and use idioms that are easy to express in their language. They 'cut with the grain.'<br /><br />When considering one language over another, my first consideration, naturally, is with the idioms I already know. Does the new language help? This consideration is exactly like almost any other "upgrade" consideration. When considering an upgrade, the first thing you want to do is solve an existing problem.<br /><blockquote>When I purchased an iMac for my home, I had no need for playing DVD's. So I was very close to buying the 17" model. Luckily, I purchased the 20" model so I would have more desktop for programming. I already had a 17" monitor on my development box, and it was starting to feel cramped. Now that I have the 20" iMac, I love watching DVD's on it and I'm very happy I didn't settle for the model that seemed to suit what I thought I would need.<br /></blockquote>Once you're satisfied that the upgrade meets your needs and solves a problem, you go ahead. Later on, you'll discover a whole new world of features. These grow on you, until one day you ask yourself how you ever lived without them.<br /><br />And so it is with programming languages. I can write about meta-programming in Ruby and Scheme for six more posts, but if you aren't meta-programming now, my guess is that you won't switch. You simply don't think in terms of that idiom, so you perceive it to be a "nice to have," but not essential.<br /><br />What will get you to move up the ladder is when someone shows you how to solve an existing problem in fewer bits. This, you can recognise. Did I say signal-to-noise? Imagine your favourite music on AM radio in your grandparents' car. Now imagine you hear it on a beautiful stereo. More signal! Less noise!<br /><br />But you aren't going to switch because someone says "if you think listening to music is fantastic, just wait until you hook up a keyboard and use GarageBand to compose music..." That simply doesn't mean anything to you until you've already bought your new iMac.<br /><br />So although I fervently believe that a better language will allow you to express more idioms than you are currently using, I know that you are unlikely to switch for that reason. So I'm not going to write about how cool it is that someone could add "acts_as_versioned" to the Rails framework. You probably only care about whether "acts_as_versioned" saves you a ton of boilerplate versioning data in your application.<br /><br />Speaking of Rails, I'm going to conclude with my take on one reason why <a href="http://rubyonrails.org/">Rails</a> is taking off and Seaside is not. Rails allows programmers to express the idioms they already know (relational databases, web-backed MVC, stateless event handling plus a global session store) in fewer bits.<br /><br />Seaside provides a whole new idiom, continuations, that IMO is more powerful. I think you end up with an even higher signal-to-noise ratio with a Seaside app than with a Rails app. Why? Because continuations afford you a much higher degree of controller reuse.<br /><br />Now, here's the catch: if you try to imagine your current application running on both Rails and on Seaside, you probably won't see much difference between the two (although they'll both be an order of magnitude better than ASP.NET). They will look the same because you designed your application with idioms that both Rails and Seaside support.<br /><br />To get a big win, you'd have to rethink your application's flow and logic. You'd have to "think in Seaside." And you're not going to do that. So you pick Rails, like so many others have picked it, because it looks just like your ASP app, only all the noise has gone away. It's all signal, baby.<br /><br />Now, do you see the thing here? Ruby has been around for a while, but nobody switched. Why? Because they couldn't see how its new idioms would help them. Every time a programmer considered switching from <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a> to Ruby, she was presented with all these new idioms, like dynamic types. None of this meant anything to her, because they didn't appear to make the idioms she already knew more compact. No win.<br /><br />But now she looks and she sees her existing web idioms, and she sees them expressed with way fewer bits, and she is suddenly prepared to learn this Ruby thing if it will let her say:<br /><br /><pre>class Language &lt; ActiveRecord::Base<br />has_and_belongs_to_many :idioms<br />end<br /></pre><br />Happy New Year!<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html" title="permanent link">12:24 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, November 14, 2005</div>
			

			<div class="Post"><a name="113202013492878044">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/11/repost-closures-in-ruby.html" title="permanent link">Repost: Closures in Ruby</a></span>
					<div style="clear:both;"></div><p>(<span style="font-style: italic;">I wrote the original version of this page in 2002. I've made a few minor edits and added a comparison with Java's anonymous inner classes</span>)<br /></p> <p>I briefly worked with a team that used Perl to implement high availability web applications. When discussing the language with the team’s technical lead, I pointed out that I was impressed with the fact that Perl implemented <i>closures</i>. Having written a Scheme interpreter, I considered closures a fundamental component of modelling procedures.  </p>  <p>This led to a discussion of what was a closure, and what was it good for?</p>   <p></p><blockquote>A closure encapsulates the execution of a one or more operations for side effects and/or the return of a value in the environment of the function’s definition where the closure was created.</blockquote>From this definition, all functions, procedures, and methods in languages such as Java and Visual Basic are closures. When a programmer refers to a language as implementing closures, (s)he is really saying that the language permits the creation of arbitrary closures at run time. Scheme aficionados would say that languages like Perl, Lisp, and Ruby support <i>first class closures</i><span style="font-style: normal;">: closures can be arbitrarily created and assigned as values to variables or returned from functions.</span><br /><br /><p>Since contemporary programming languages are lexically scoped, the environment of the function refers to the variables in scope at the time the function is defined. This includes temporary variables, variables that are normally created on some sort of stack and discarded when they “go out of scope.” When a closure is created, variables in scope must be preserved until the closure itself ceases to exist.</p>  <p style="font-style: normal;">Here’s a Ruby closure demonstrating the fact that it ‘captures’ a variable in the scope of its definition:</p>  <pre>def makeCounter<br />var = 0<br />lambda do<br />var +=1<br />end<br />end<br /><br />c1 = makeCounter<br />c1.call<br />c1.call<br />c1.call<br /><br />c2 = makeCounter<br /><br />puts "c1 = #{c1.call}, c2 = #{c2.call}"</pre> <p> The two important things from this example are:</p>  <ol> <li><p>Although <i>var</i><span style="font-style: normal;"> is no  longer in scope once makeCounter returns, Ruby saves it for use in  the closure.</span></p>  </li><li><p style="font-style: normal;">Each invocation of makeCounter  creates a different <i>var</i>. The two counters do not interfere  with each other.</p> </li> </ol>  <p style="font-style: normal;">What can you do with closures? Here’s something a bit more useful, a call-by-need thunk factory:</p>  <pre>def delay(&procToDelay)<br />value = nil<br />return lambda do<br />if value.nil?<br />  value = procToDelay.call()<br />else<br />  value<br />end<br />end<br />end<br /><br />def force(thunk)<br />thunk.call()<br />end<br /><br />foo = delay do<br />puts "thinking about foo"<br />"fu"<br />end<br /><br />bar = delay do<br />puts "thinking about bar"<br />"british american racing"<br />end<br /><br />puts force foo<br />puts force bar<br />puts force foo<br />puts force bar</pre> <p> In this example, you have a simple facility for memoizing closures: they can be called repeatedly, but they only evaluate their operations once (provided the retun value is not nil). Obviously, this should not be combined with the previous example: call-by-need thunks are useful when there are no side effects of their evaluation.<br /></p> <p><span style="font-weight: bold;">Why Java's Anonymous Inner Classes do not implement closures</span><br /></p> <p>At first glance, an anonymous inner class in Java looks like it captures an environment. It has access to its enclosing instance's members. That looks an awful lot like the way a closure captures its environment.<br /></p> <p>But an anonymous inner class cannot access method variables or parameters. This is a crippling limitation. Consider:<br /></p> <pre>interface Transformer {<br />    int transform (int what);<br />}<br /><br />class TransformerConstructionKit {<br /><br />public static Transformer makeMultiplier (int timesWhat) {<br />   return new Transformer () {<br />      public int transform (int what) {<br />          return what * timesWhat;<br />      }<br />  };<br />}<br /><br />}<br /><br /></pre> <p>This is illegal in Java for some reason. Ok, I know what the reason is. But I don't have to like it, do I?<br /></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/11/repost-closures-in-ruby.html" title="permanent link">8:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://weblog.raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://weblog.raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://weblog.raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://raganwald.github.com/uploaded_images/coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://raganwald.github.com/uploaded_images/coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>