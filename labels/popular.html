<html> 
<head>
        
        <title><script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>raganwald</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
<link rel="me" href="http://www.blogger.com/profile/13132345822387028437" />
</head>

<body>

	<div id="leftcontent">
			<img src="http://raganwald.github.com/assets/raganwald_2008_350_150" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Friday, November 09, 2007</div>
			

			<div class="Post"><a name="2961100763442932381">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="permanent link">Really useful anamorphisms in Ruby</a></span>
					<div style="clear:both;"></div><a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="Really simple anamorphisms in Ruby">Really simple anamorphisms in Ruby</a> introduced a very simple <a href="http://weblog.raganwald.com/source/unfold.rb.html" title="unfold.rb">unfold</a>. Its chief characteristics were that it generated an Array from a value of some sort, and it did so by applying an incrementor block to its seed recursively until it generated nil. For example:<pre><code><br />10.class.unfold(&amp;:superclass)<br />    =&gt; [Fixnum, Integer, Numeric, Object]<br /></code></pre>A very simple modification allows us to separate the two blocks with a :while or :to pseudo-keyword, and to add a :map keyword for transforming the state into the desired result. Thus, this really simple unfold:<pre><code><br />1.unfold(<a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="String#to_proc">&amp;'_+1 unless _==10'</a>).map(&amp;'**2')<br />    =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br /></code></pre>Can also be expressed as:<pre><code><br />1.unfold(:to =&gt; '==10', :map =&gt; '**2', &amp;'_+1')<br />    =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br /></code></pre>The latter form is helpful once unfolds become larger and more complex than these simple one-liners.<br /><br />(There is another style of writing :unfold, using method chaining and lazy evaluation to eliminate lambda keywords, but we will save that for another time: it is a great examination of syntax but does not change :unfold&rsquo;s fundamental behaviour.)<br /><br /><strong>Let&#8217;s turn it up a notch</strong><br /><br />These trivial examples are not particularly compelling. Unfold is touted as the complement to :inject. So you would expect :unfold to be as useful as :inject. And :inject is very, very useful&mdash;you &#8220;reduce&#8221; lists of things to values all the time.<br /><br />But how often do you need to turn a value into a list? How often do you need to turn &#8216;10&#8217; into &#8216;[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&#8217;? And if you do, what&#8217;s wrong with using <code>(1..10).map(&amp;'**2')</code>?<br /><br />Remember that :unfold can be applied to objects with a lot more information to them. The thing that had me stuck when I first saw :unfold was thinking of it as the opposite of :inject. Or at least, the opposite of how I used :inject. I tended to use :inject in a way that reduced information. For example:<pre><code><br />[7, 6, 10, 3, 9, 4, 8, 5, 2, 1].inject(&amp;'+')<br /></code></pre>This gives us the sum of the numbers from one to ten, as it happens. It also gives us a value that is considerably simpler than the list we used to generate the number. Information is lost when we use :inject to &#8220;reduce&#8221; a list to a very simple value. So my first reaction to :unfold was to think of ways to use :unfold on very simple values, like numerics.<br /><br />But :unfold doesn&#8217;t have to work with simple values. It can work with arbitraily complex data structures. Consider:<pre><code><br />def zip(*lists)<br />  lists.unfold(<br />      :while =&gt; '.first', <br />      :map =&gt; '.map(&amp;".first")',<br />      &amp;'_.reject(&amp;".length &lt; 2").map(&amp;"[1..-1]")')<br />end<br /></code></pre>Zip is a function that takes two (or more, but let&#8217;s just say two for now) lists, and produces a list of pairs of items. So:<pre><code><br />zip([:a, :b, :c], [1, 2, 3])<br />    =&gt; [[:a, 1], [:b, 2], [:c, 3]]<br /></code></pre>How does :unfold do it? First, of course, it makes a single list of lists. It then performs an unfold on this single data structure. The incrementor successively reduces each sublist by removing the first items. So the output of the successive incrementor operations is:<pre><code><br />[<br />    [[:a, :b, :c], [1, 2, 3]],<br />    [[b, :c],      [2, 3]]<br />    [[:c],         [3]]<br />]<br /></code></pre>The :map then extracts the first items from each sublist and presents them as a list:<pre><code><br />[<br />    [:a,           1], <br />    [:b,           2], <br />    [:c,           3]<br />]<br /></code></pre>Neat. But why do we care about zip? Well, if you&#8217;ll notice, we already have a bunch of really useful things we can do with lists, like :map, :select, :reject, :detect, and so on. What would you do if you had two lists and needed to do something with each pair in the list, like&#8230; A list of first names and surnames that need to be catenated together?<pre><code><br />zip(first_names, surnames).map(&amp;'"#{_[0]} #{_[1]}"')<br /></code></pre>Zip is useful when we have a bunch of parallel lists and there&#8217;s something we want to do with each tuple from the lists.<br /><br /><strong>Generalized iteration</strong><br /><br />We recognize this &#8220;pattern,&#8221; it&#8217;s one of the most powerful in programming. Zip was one algorithm, a way of iterating over several lists simultaneously. The other algorithm was <code>"#{_[0]} #{_[1]}"</code>, a recipe for what to do with the successive tuples of values.<br /><br /><div class="book"><hr/><em><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to functional programming techniques just like these.</em><hr/></div>The powerful idea was to separate the mechanics of turning a data structure into a linear series of values&#8212;iterating&#8212;from what we want to actually do with each value. (In OO-style programming, we would define a method for lists of lists that returns an iterator over the tuples of values. Same thing, proving that how you do it is not as important as understanding <em>why</em> you do it.)<br /><br />Unfold has other uses, but this one alone is worth the trouble to understand the pattern even if you aren&rsquo;t rushing to implement this exact unfold method: Converting a single data structure to a list is one way to implement iteration: for any data structure, you can use unfold to define a linear iteration. You can then use :each or :map or :inject just as our parents before us would have used DO or FOR loops.<br /><br />Consider this (inelegant, but I&#8217;m writing this rather late at night) unfold:<pre><code><br />[[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10].unfold(<br />  :while =&gt; '.first',<br />  :map =&gt; lambda { |first|<br />    first = first.first while first.kind_of?(Array)<br />    first<br />  }<br />) { |state|<br />  state = state.first + state[1..-1] while state.first.kind_of?(Array)<br />  state[1..-1]<br />}<br />    =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br /></code></pre>This is the same idea, only we convert a tree into a list representing a depth-first search of a simple tree. You may recognize it as Array&#8217;s :flatten method. Once again, it&#8217;s really a way of iterating over the elements of a tree. So one way to think of this :unfold is that it is an iterator over a tree&#8217;s leaves:<pre><code><br />def flatten(arr)<br />  arr.unfold(<br />    :while =&gt; '.first',<br />    :map =&gt; lambda { |first|<br />      first = first.first while first.kind_of?(Array)<br />      first<br />    }<br />  ) { |state|<br />    state = state.first + state[1..-1] while state.first.kind_of?(Array)<br />    state[1..-1]<br />  }<br />end<br /></code></pre><strong>But I already know how to write Zip and Flatten methods, honest I do.</strong><br /><br />Zip and Flatten <em>are</em> relatively common, that&rsquo;s why :flatten and :zip can both be found in Ruby&rsquo;s standard Array class. And if there&rsquo;s a data structure that needs regular unfolding, you ought to weigh the advantages and disadvantages of writing an :unfold for it or using more humdrum ways of writing an iterator.<br /><br /><div class="book"><hr/><em>  <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/uploaded_images/haskell_school_of_expression.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089">The Haskell School of Expression</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is a terrific and relatively jargon-free introduction to the language that popularized fold, unfold, and all of the other functional programming idioms. As Eric Kidd says, it will make your head explode. Recommended!</em><hr/></div>However, what do you do when you only need to unfold something once? For example, perhaps you have code that obtains some data in JSON format, and having used a library to parse the JSON into a one-off list or hash, you want to iterate through it.<br /><br />With unfold, you can write your one-time, specific iterator right in place. This is no different than using blocks and lambdas in Ruby for one-off functions that really don&rsquo;t need the cermony and weight of being implemented as methods.<br /><br />When you want to iterate through something, and you want to separate the mechanism for iterating through the data from what you do with the data, :unfold should be in your tool box.<br /><br /><strong>Unfold and the bio-sciences. Not really.</strong><br /><br />I like to think of :unfold like unfolding a protein molecule. When you stare at a data structure, it&#8217;s dense, opaque. But you supply an unfold algorithm, and what looked like a messy ball of twine unravels into a long filament made up of simple elements. You can then operate on the simple elements, without getting what you want to do en-snarled in how you iterate over the data structure.<br /><br />So there you have it. Unfold can be really useful if we see it as a standardized way to write iterators for data structures.<br /><br /><hr/><em>Update: <a href="http://citeseer.ist.psu.edu/283921.html">The under-appreciated unfold</a>.</em><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="permanent link">10:46 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, November 07, 2007</div>
			

			<div class="Post"><a name="5076659457761846917">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="permanent link">Really simple anamorphisms in Ruby</a></span>
					<div style="clear:both;"></div><a href="http://tunes.org/wiki/Morphism" title="Morphisms">Anamorphisms</a> are functions that map from some object to a more complex structure containing the type of the object. They are the dual&#8212;a fancy word for complement&#8212;of Catamorphisms, functions that map from some complex structure down to a simpler object.<br /><br />In simpler terms, a Catamorphism is a function like <strong>inject</strong>: In Ruby, Inject takes a collection and produces something simpler. It is also called <strong>fold</strong> or <strong>reduce</strong> in other languages. Inject can do something like produce the sum of a list:<br /><pre><code><br />(1..5).inject <a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="String#to_proc">&amp;'+'</a> =&gt; 15</code></pre><br /><strong>Unfold</strong> does the reverse: it takes a single value and turns it into a collection. Now, a proper unfold can be configured with a seed value, a transformation, a stopping predicate, maybe a distinction between states and output values, and even the type of structure you want to create. A proper unfold would even work with <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="Haskell, Ruby and Infinity">lazy lists</a> if it didn&#8217;t have a stopping condition.<br /><br />But sometimes you want something really simple. The state and the output value could be the same thing, eliminating a transformation from state to output. The stopping predicate could simple, it could stop when it reaches <strong>nil</strong>. And it could always return Arrays. So you could use such a simple unfold whenever you have a seed value and some sort of function (expressed as a block) that returns nil when it has no more values.<br /><br />For example:<br /><pre><code><br />10.unfold { |n| n-1 unless n == 1 }.inspect =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]<br />10.class.unfold(<a href="http://pragdave.pragprog.com/pragdave/2005/11/symbolto_proc.html" title="Symbol#to_proc">&amp;:superclass</a>).inspect =&gt; [Fixnum, Integer, Numeric, Object]</code></pre><br />Hey, what happens if you combine really simple anamorphisms with really simple catamorphisms?<br /><pre><code><br />5.unfold(&amp;'_-1 unless _==1').inject(&amp;'*') =&gt; 120</code></pre><br />Here is the code <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a>. (If <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html" title="Not all functions should be object methods">overloading core classes with too much responsibility</a> is not to your taste, it is trivial to express unfold as a function taking a seed and a block as arguments).<br /><br />Now that I&#8217;ve whet your appetite, here&#8217;re <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html">Really useful anamorphisms in Ruby</a>. And for another implementation, <a href="http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/1052c289b22c60a5" title="multiple blocks (unfold)">everything you ever wanted to know about implementing a true unfold in Ruby</a>.<br /><br />Enjoy!<br /><br />(Code courtesy of <a href="http://www.mcommons.com/about/jobs">Mobile Commons</a>. Thanks!)<br /><br /><br/><em>Here&rsquo;s an interesting email from Hugh Sasse:</em><br /><br /><blockquote>I was reading <a href="http://www.amazon.com/gp/product/0735619670?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0735619670">Code Complete 2</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0735619670" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> last night and Steve McConnell says that he wouldn&#8217;t hire a programmer who wrote a recursive factorial function. [I&#8217;m not sure that would be such a crime in languages like <a href="http://www.lua.org/" title="The Programming Language Lua">Lua</a> with proper tail recursion, but still. (I&#8217;m probably wrong, now I&#8217;ve written that! &#8220;Open mouth, insert foot, echo internationally&#8221; as they used to say on Fidonet :-))] I thought &#8220;that seems a bit harsh&#8221;, especially since in real life they&#8217;d get one from a library most of the time, anyway.<br /><br />So, as I have often run out of stack on Ruby, I&#8217;ve tried to rewrite <a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="Really simple anamorphisms in Ruby">unfold</a> as an iterative function. It seems to be working. The script as modified blows up at 5000 on my system with the recursive version, but the iterative version succeeds at 5000.<br /><br />Thanks for this blog entry. There&#8217;s something REALLY nice about this idea, which I can&#8217;t put my finger on. Might be something to do with loops terminating when they should, and The Pragmatic Programmers&#8217; article about &#8220;cook until done&#8221;<br /><br /><a href="http://www.pragprog.com/articles/cook-until-done" title="Cook Until Done">http://www.pragprog.com/articles/cook-until-done</a><br /><br />Unfold feels like a &#8220;do until finished&#8221; loop.<br /></blockquote><pre><code><br />class Object<br />  # As above, but iterative, rather than recursive.<br />  def unfold2 &block<br />    result = [self]<br />    x = block.call(self)<br />    while not x.nil?<br />      result.push x<br />      x = block.call(x)<br />    end<br />    return result<br />  end<br />end<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="permanent link">5:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, October 27, 2007</div>
			

			<div class="Post"><a name="6254612993372428372">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="permanent link">String#to_proc</a></span>
					<div style="clear:both;"></div><i>Breaking news! The irb enhancement gem <a href="http://raganwald.github.com/2007/12/utility-belt.html">Utility Belt</a> includes String#to_proc</i><br /><br />String#to_proc is an addition to Ruby&rsquo;s core String class to enable <a href="http://rickyclarkson.blogspot.com/2007/09/point-free-programming-in-java-7-beyond.html">point-free</a> <a href="http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)">hylomorphisms</a>&hellip;<br /><br />I&rsquo;ll start again. String#to_proc adds a method to Ruby&rsquo;s core String class to make lots of mapping and reducing operations more compact and <em>easier to read</em> by removing boilerplate and focusing on what is to be done. In many cases, the existing black syntax is just fine. But in a few cases, String#to_proc can make an expression <em>even simpler</em>.<br /><br />String#to_proc is a port of the String Lambdas from Oliver Steele&#8217;s <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">Functional Javascript</a> library. I have modified the syntax to reflect how String#to_proc works in Ruby.<br /><br />We&rsquo;ll start with the examples from String Lambdas so you can see what is actually going on. Then we&rsquo;ll look at how to use the <code>&</code> coercion to make working with arrays really simple.<br /><br /><code>to_proc</code> creates a function from a string that contains a single expression. This function can then be applied to an argument list, either immediately:<br /><pre><code><br />'x+1'.to_proc[2];<br />     → 3<br />'x+2*y'.to_proc[2, 3];<br />     → 8<br /></code></pre>or (more usefully) later:<br /><pre><code><br />square = 'x*x'.to_proc;<br />square(3);<br />     → 9<br />square(4);<br />     → 16<br /></code></pre><strong>Explicit parameters</strong><br /><br />If the string contains a <code>-&gt;</code>, this separates the parameters from the body.<br /><pre><code><br />'x y -&gt; x+2*y'.to_proc[2, 3];<br />     → 8<br />'y x -&gt; x+2*y'.to_proc[2, 3];<br />     → 7<br /></code></pre>Otherwise, if the string contains a <code>_</code>, it&#8217;s a unary function and <code>_</code> is name of the parameter:<br /><pre><code><br />'_+1'.to_proc[2];<br />     → 3<br />'_*_'.to_proc[3];<br />     → 9<br /></code></pre><strong>Implicit parameters</strong><br /><br />If the string doesn&#8217;t specify explicit parameters, they are implicit.<br /><br />If the string starts with an operator or relation besides <code>-</code>, or ends with an operator or relation, then its implicit arguments are placed at the beginning and/or end:<br /><pre><code><br />'*2'.to_proc[2];<br />     → 4<br />'/2'.to_proc[4];<br />     → 2<br />'2/'.to_proc[4];<br />     → 0.5<br />'/'.to_proc[2, 4];<br />     → 0.5<br /></code></pre>&#8217;.&#8217; counts as a right operator:<br /><pre><code><br />'.abs'.to_proc[-1];<br /> → 1<br /></code></pre>Otherwise, the variables in the string, in order of occurrence, are its parameters.<br /><pre><code><br />'x+1'.to_proc[2];<br />     → 3<br />'x*x'.to_proc[3];<br />     → 9<br />'x + 2*y'.to_proc[1, 2];<br />     → 5<br />'y + 2*x'.to_proc[1, 2];<br />     → 5<br /></code></pre><strong>Chaining</strong><br /><br />Chain <code>-&gt;</code> to create curried functions.<br /><pre><code><br />'x y -&gt; x+y'.to_proc[2, 3];<br />     → 5<br />'x -&gt; y -&gt; x+y'.to_proc[2][3];<br />     → 5<br />plus_two = 'x -&gt; y -&gt; x+y'.to_proc[2];<br />plus_two[3]<br />     → 5<br /></code></pre><strong>Using String#to_proc in Idiomatic Ruby</strong><br /><br />Ruby on Rails popularized <code>Symbol#to_proc</code>, so much so that <a href="http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l168" title="Changes in Ruby 1.9">it will be part of Ruby 1.9</a>.<br /><br />If you like:<br /><pre><code><br />%w[dsf fgdg fg].map(&amp;:capitalize)<br />    → ["Dsf", "Fgdg", "Fg"]<br /></code></pre>then <code>%w[dsf fgdg fg].map(&amp;'.capitalize')</code> isn&#8217;t much of an improvement.<br /><br />But what about doubling every value in a list:<br /><pre><code><br />(1..5).map &amp;'*2'<br />    → [2, 4, 6, 8, 10]<br /></code></pre>Or folding a list:<br /><pre><code><br />(1..5).inject &amp;'+'<br />    → 15<br /></code></pre>Or having fun with factorial:<br /><pre><code><br />factorial = "(1.._).inject &amp;'*'".to_proc<br />factorial[5]<br />    → 120<br /></code></pre>String#to_proc, in combination with <code>&amp;</code> coercing a value into a proc, lets you write compact maps, injections, selections, detections (and many others!) when you only need a simple expression.<br /><br />Caveats: String#to_proc uses <code>eval</code>. Cue the chorus of people&#8212;pounding away on quad 3Ghz systems&#8212;complaining about the performance. You&#8217;re an adult. Decide for yourself whether this is an issue. After <a href="http://www.yourdictionary.com/wotd/wotd.pl?word=manky">mankying</a> things about to deduce the parameters, String#to_proc evaluates its expression in a different binding than where you wrote the String. This matters if you include free variables. My thinking is that it ceases to be a simple, easy-to-understand hack and becomes a cyrptic nightmare once you get too fancy.<br /><br /><blockquote>You know that Voight-Kampff test of yours&#8230; did you ever take that test yourself?</blockquote><div style="text-align: right;">&#8212;Rachael, Blade Runner</div><br /><br />I have been using <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">Functional Javascript</a> for quite some time now, and I use the String Lambdas a lot. However, Ruby and Javascript are very different languages. Once you get out of the browser&#8217;s DOM, Javascript is a lot cleaner and more elegant than Ruby. For example, you don&#8217;t need to memorize the difference between a block, a lambda, and a proc. Javascript just has functions.<br /><br />However, Javascript is more verbose: Whereas in Ruby you can write <code>[1, 2, 3].map { |x| x*2 }</code>, if Javascript had a <code>map</code> method for arrays, you would still have to write <code>[1, 2, 3].map(function (x) { return x*2; })</code>. So it&#8217;s a big win to make Javascript less verbose: code is easier to read at a glance when you don&#8217;t have to wade through jillions of function keywords.<br /><br />Nevertheless, I still find myself itching for the String Lambdas when I&#8217;m writing Ruby code. It may be a matter of questionable taste, but for certain extremely simple expressions, I vastly prefer the point-free style. <code>(-3..3).map &amp;:abs</code> is shorter than <code>(-3..3).map { |x| x.abs }</code>.<br /><br />It is also cleaner to me. <code>abs</code> is a <em>message</em>, especially in a language like Ruby that supports the sending arbitrary messages named by symbols. Writing <code>(-3..3).map &amp;:abs</code> looks very much like sending the <code>abs</code> message to everything in the list. I don&#8217;t need an <code>x</code> in there to tell me that.<br /><br />Thus, I obviously like <code>(-3..3).map &amp;'.abs'</code>. But I like <code>(1..5).map &amp;'*2'</code> for the same reason. It isn&#8217;t just shorter, it hides a temporary variable that really doesn&#8217;t mean Jack to me when I&#8217;m reading the code. And quite honestly, <code>(1..10).inject { |acc, mem| acc + mem }</code> raises more questions than it answers about what <code>inject</code> does and how it does it. <code>(1..10).inject &amp;'+'</code> gets right down to business for me. I&#8217;d prefer that it be called &#8220;fold,&#8221; but the raw, naked <code>+</code> seems to describe what I want <em>done</em> instead of how I want the computer to do it.<br /><br />Symbol#to_proc also supports named parameters, either through implication (<code>&amp;'x+y'</code>) or with the arrow (<code>'x y -&gt; x*y'</code>). I haven&#8217;t thought of a case where that would be a win over using a Ruby block: <code>{ |x, y| x*y }</code>.<br /><br />I&#8217;m divided about the underscore notation. It seems like a good compromise for expressions where there is a single parameter and it doesn&#8217;t fall on the left or the right side of an expression. Standardizing on an unusual variable name is, I think, a win. Underscore often means a &#8220;hole&#8221; in an expression or a computation, so it feels like a good fit. I would honestly much rather see something like: <code>&amp;'(1/_)+1'</code> than <code>&amp;'(1/x)+1'</code>. The underscore jumps out in an obvious way, and it wouldn&#8217;t be magically clearer to write <code>{ |x| (1/x)+1 }</code>.<br /><br />That being said, I haven&#8217;t actually written an underscore expression yet in actual code, so far I&#8217;m getting by using the point-free expressions to simplify things and using Ruby blocks for everything else.<br /><br /><strong>RSpec</strong><pre><code><br />describe "String to Proc" do<br /><br />  before(:all) do<br />    @one2five = 1..5<br />  end<br /><br />  it "should handle simple arrow notation" do<br />    @one2five.map(&amp;'x -&gt; x + 1').should eql(@one2five.map { |x| x + 1 })<br />    @one2five.map(&amp;'x -&gt; x*x').should eql(@one2five.map { |x| x*x })<br />    @one2five.inject(&amp;'x y -&gt; x*y').should eql(@one2five.inject { |x,y| x*y })<br />    'x y -&gt; x**y'.to_proc()[2,3].should eql(lambda { |x,y| x**y }[2,3])<br />    'y x -&gt; x**y'.to_proc()[2,3].should eql(lambda { |y,x| x**y }[2,3])<br />  end<br /><br />  it "should handle chained arrows" do<br />    'x -&gt; y -&gt; x**y'.to_proc()[2][3].should eql(lambda { |x| lambda { |y| x**y } }[2][3])<br />    'x -&gt; y z -&gt; y**(z-x)'.to_proc()[1][2,3].should eql(lambda { |x| lambda { |y,z| y**(z-x) } }[1][2,3])<br />  end<br /><br />  it "should handle the default parameter" do<br />    @one2five.map(&amp;'2**_/2').should eql(@one2five.map { |x| 2**x/2 })<br />    @one2five.select(&amp;'_%2==0').should eql(@one2five.select { |x| x%2==0 })<br />  end<br /><br />  it "should handle point-free notation" do<br />    @one2five.inject(&amp;'*').should eql(@one2five.inject { |mem, var| mem * var })<br />    @one2five.select(&amp;'&gt;2').should eql(@one2five.select { |x| x&gt;2 })<br />    @one2five.select(&amp;'2&lt;').should eql(@one2five.select { |x| 2&lt;x })<br />    @one2five.map(&amp;'2*').should eql(@one2five.map { |x| 2*x })<br />    (-3..3).map(&amp;'.abs').should eql((-3..3).map { |x| x.abs })<br />  end<br /><br />  it "should handle implied parameters as best it can" do<br />    @one2five.inject(&amp;'x*y').should eql(@one2five.inject(&amp;'*'))<br />    'x**y'.to_proc()[2,3].should eql(8)<br />    'y**x'.to_proc()[2,3].should eql(8)<br />  end<br /><br />end</code></pre>Go ahead, download the <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">source code</a> for yourself.<br /><hr/><em>Update: <a href="http://raganwald.github.com/2007/11/fun-with-symboltoproc.html">Reg smacks himself in the head!</a></em><br /><br />I had a look at the source code for <code>Symbol#to_proc</code>:<pre><code><br />class Symbol<br />  # Turns the symbol into a simple proc, which is especially useful for enumerations. Examples:<br />  #<br />  #   # The same as people.collect { |p| p.name }<br />  #   people.collect(&:name)<br />  #<br />  #   # The same as people.select { |p| p.manager? }.collect { |p| p.salary }<br />  #   people.select(&:manager?).collect(&:salary)<br />  def to_proc<br />    Proc.new { |*args| args.shift.__send__(self, *args) }<br />  end<br />end<br /></code></pre>Look at that: Although the examples are all of unary messages like <code>.name</code>, the lambdas created handle methods with arguments. And since almost everything in Ruby is a method, including operators like <code>+</code>&hellip; You can use Symbol#to_proc to do some of the point-free stuff I like:<pre><code><br />[1, 2, 3, 4, 5].inject(&:+)<br />     → 15<br />[{ :foo => 1 }, { :bar => 2 }, { :blitz => 3 }].inject &:merge<br />     → {:foo=>1, :bar=>2, :blitz=>3}<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/10/stringtoproc.html" title="permanent link">11:22 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 25, 2007</div>
			

			<div class="Post"><a name="5039489814009701313">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html" title="permanent link">Too much of a good thing: not all functions should be object methods</a></span>
					<div style="clear:both;"></div>OOP is several different ideas put together, the most important of which is <em>Fine-Grained Information Hiding</em>.<br /><br /><blockquote>One can think of information hiding as being the principle and encapsulation being the technique. A software module hides information by encapsulating the information into a module or other construct which presents an interface.<br /></blockquote><div style="text-align: right;">&mdash;<a href="http://en.wikipedia.org/wiki/Information_hiding" title="Information hiding - Wikipedia, the free encyclopedia">Information Hiding</a> on Wikipedia</div><br /><br />The basic principle of all OO languages is that relatively small things&#8212;such as individual accounts in a business program&#8212;each encapsulate both their data (in the form of members) and their algorithms (in the form of methods). Our notions of members and polymorphism both work to this goal of hiding information. There&#8217;s a lot more to most OO languages, such as whether they include a notion of types and what mechanisms they use for sharing common behaviour. But let&#8217;s look at this one principle: <em>objects are responsible for their data and for their algorithms</em>.<br /><br /><strong>should objects be responsible for all of their own behaviour?</strong><br /><br />There&#8217;s a general idea that in a well-constructed program, each object &#8220;knows&#8221; how it ought to behave. That&#8217;s what its methods are for. Quite obviously, objects cannot be responsible for <em>everything</em> involving them in a program. If each object completely encapsulated all of the things it could do or be involved in, you would never pass one object as a parameter in a message to another object.<br /><br /><blockquote>For every complex problem, there is a solution that is simple, neat, and wrong.<br /></blockquote><div style="text-align: right;">&mdash;H. L. Mencken</div><br /><br />For example, you would never have collections. If every object &#8220;knew&#8221; how to organize itself into collections, you wouldn&#8217;t need an Array or Hash, would you? In practice, each object in a system can be involved in many different actions. It has to be responsible for some of them, and it has to play a secondary, passive role in others. Most OO programs do not have every object implement its own collections methods. They may include some form of specialization so you can have an array of accounts, but an array of accounts is still not an account.<br /><br /><strong>subject.verb(object)</strong><br /><br />In the English language, we have the idea of a <em>Subject</em> and an <em>Object</em> in a sentence. For example, when we say &#8220;Jack loves Jill,&#8221; Jack is a subject and Jill is an object. Jack loves. Jill is loved. It&#8217;s the same in OO programs. Sometimes objects are actively doing things through their methods. Sometimes other object&#8217;s methods are doing things with them.<br /><br /><blockquote>Verbing Weirds Language<br /></blockquote><div style="text-align: right;">&mdash;Bill Watterson, <a href="http://en.wikipedia.org/wiki/Calvin_and_Hobbes" title="Calvin and Hobbes - Wikipedia, the free encyclopedia">Calvin and Hobbes</a></div><br /><br />Good OO design is, in part, doing a good job of choosing the right bifurcations: given a list of nouns and verbs, making the right decisions about which nouns ought to be the active nouns, the subjects, the ones that &#8220;own&#8221; the verb in the form of a method. And thus consciously making decisions about which objects ought to be the passive nouns, the objects of the verbs, the ones that <em>don&#8217;t</em> implement the methods.<br /><br />Unfortunately, there are lots of places where we can err on the side of giving too much responsibility to individual objects. It&#8217;s understandable, given that OO is theoretically all about objects being responsible for themselves. But as in many other things, in practice good OO is about objects being responsible for a little as possible (but no less!), not as much as possible.<br /><br /><strong>the kingdom of nouns</strong><br /><br />One common symptom of this problem is <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" title="Stevey's Blog Rants: Execution in the Kingdom of Nouns">a system that has objects for all of the obvious nouns or entities, but not for the verbs</a>. OO began with languages like <a href="http://en.wikipedia.org/wiki/Simula" title="Simula - Wikipedia, the free encyclopedia">Simula</a>, where the paradigm was trying to represent real-world entities such as automobiles on a highway. From that time forward, the emphasis has been on having objects for each noun in the problem domain. In such traditionally-organized OO programs, the &#8220;verbs&#8221; or actions are all attached to objects as methods. <br /><br /><div class="book"><hr/><em><a id="lnx0" name="evtst|a|0201379430" href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201379430"><img src="http://raganwald.github.com/uploaded_images/object_design-719894.jpg" border="0" height="160" width="128"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0201379430" href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201379430">Object Design: Roles, Responsibilities, and Collaborations</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> focuses on the practice of designing objects as integral members of a community where each object has specific roles and responsibilities. The authors present the latest practices and techniques of Responsibility-Driven Design and show how you can apply them as you develop modern object-based applications.  <br><br></em><hr/></div>Not all &#8220;verbs&#8221; have a clear separation between a single entity that is the subject or active entity that ought to own the verb&#8217;s definition and the secondary, passive subject entities that should not own the verb&#8217;s definition. The easiest examples of this are operations that are intended to be <a href="http://en.wikipedia.org/wiki/Commutativity" title="Commutativity - Wikipedia, the free encyclopedia">commutative</a>.<br /><br />For example, many languages define addition as a method belonging to numbers or magnitudes. In Smalltalk, the expression <code>1 + 2</code> actually means &#8220;<em>send the message</em> <code>+ 2</code> <em>to the object</em> <code>1</code>.&#8221; At first glance, this seems elegant: the number <code>1</code> handles the message <code>+ 2</code> as integer addition, while <code>1.0</code> would handle the same message with floating point arithmetic. What more could you want?<br /><br />Well, there is a huge problem with this arrangement: <em>Addition is commutative</em>. <code>1.0 + 2</code> must give the same result as <code>2 + 1.0</code>. Using a simple message to implement addition means that you must be excruciatingly careful to handle all of the possible cases so that you do not accidentally violate this property. Now of course, the designers of system classes like <code>Integer</code> and <code>Float</code> went to this trouble. But if you want to add another magnitude class&#8212;say <code>CurrencytwoPlaceDecimal</code>&#8212;you have to open up all of the system classes and modify them so that <code>1 + ThirtyCents</code> gives the same result as <code>ThirtyCents + 1</code>.<br /><br /><strong>beware of breaking symmetry</strong><br /><br />Of course, you may not need to implement a new magnitude class. Fine. But what about <a href="http://en.wikipedia.org/wiki/Symmetric_relation" title="Symmetric relation - Wikipedia, the free encyclopedia">symmetric relations</a> like <em>comparison</em>? This is a major pitfall for OO developers: in many cases you need to write a test of equivalence or equality (operations like <code>==</code>, <code>equal?</code>, <code>eql?</code>, <code>eqv?</code> and all of the other variations on the same theme). In every one of these cases, horrible things will happen if your operation is not symmetric. For every case, <code>x.eql?(y)</code> if-and-only-if <code>y.eql?(x)</code>.<br /><br />This is obviously easy when <code>x</code> and <code>y</code> are both the same kind of object. <a href="http://raganwald.github.com/2007/04/what-does-barbara-liskov-have-to-say.html" title="What does Barbara Liskov have to say about Equality in Java?">What happens when they&#8217;re different, but still logically equivalent?</a> It turns out that implementing commutative operations and symmetric relations as methods doesn&#8217;t work very well. It forces you to smear duplicate logic over many different classes (or prototypes, if your language swings that way).<br /><br />Here&#8217;s a practical example. Let&#8217;s say you want to implement a form of equivalence for collections. For ordered collections like lists, what you want is that if two ordered collections have the same members, in the same order, they are equivalent. It&#8217;s easy to imagine writing such a method as a <a href="http://en.wikipedia.org/wiki/Mixin" title="Mixin - Wikipedia, the free encyclopedia">mixin</a> for all of your ordered collections. It obviously knows about iterating over ordered collections (recursively, if you grew up with <a href="http://www.amazon.com/gp/product/0465026567?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0465026567" title="Amazon.com: Godel, Escher, Bach: An Eternal Golden Braid by Douglas R. Hofstadter">Godel, Escher, Bach</a> on your night stand). Note that you may not have an indexed collection: you might have a <code>list</code> where you simply retrieve values in order.<br /><br />And likewise, you can write a collection equivalence method for dictionaries like hash tables: if two objects have the same values at the same keys, they are equivalent. Again, a simple mixin will handle things for dictionaries.<br /><br />Now comes the wrinkle: you decide that an ordered collection ought to be equivalent to a dictionary where the keys are the integers ascending from zero. In other words, <code>('foo' 'bar' 'blitz')</code> ought to be equivalent to <code>{ 0 =&gt; 'foo', 1 =&gt; 'bar', 2 =&gt; 'blitz' }</code>. How are you going to code this? Well, the dictionary mixin could obviously handle equivalence to an ordered list. But we need symmetry, so we have to &#8220;open up&#8221; the ordered collection mixin and add code for equivalence to dictionaries.<br /><br /><blockquote>Actually I made up the term object-oriented and I can tell you I did not have C++ in mind. The important thing here is that I have many of the same feelings about Smalltalk.<br /></blockquote><div style="text-align: right;">&mdash;Alan Kay</div><br /><br />I&#8217;m holding my nose, we have not one but two different code smells: 1) Why is one piece of logic in two different places? 2) Why do ordered collections know anything at all about dictionaries, and why do dictionaries know anything at all about ordered collections? The latter is especially disturbing: the whole point of OO is information hiding. How does having ordered collections and dictionaries knowing about each other help us to hide information?<br /><br />The obvious answer to me is that the knowledge of how to compare an ordered collection to a dictionary does not belong in ordered collections or in dictionaries. The requirement that relations like equivalence be symmetrical across heterogeneous types implies that the types themselves cannot be responsible for implementing equivalence for themselves.<br /><br />There are similar problems of code duplication and information leakage apply to modelling relations (why do we declare <code>has_one</code> and <code>belongs_to</code> in Rails) and implementing the <code>&lt;=&gt;</code> operator in Ruby. It looks like having verbs &#8220;belong to&#8221; the subject noun is often a good idea, but not always a good idea.<br /><br /><strong>commuting the sentence of execution</strong><br /><br />Maybe some verbs belong to objects, but some are best on their own? Maybe <code>+</code> and <code>&lt;=&gt;</code> and <code>equivalent?</code> really ought to be emancipated from their subservience to objects and ought to have their own definitions.<br /><br /><blockquote>There are two real approaches to object-orientation. The first is known as message-passing. You send an object a message and ask it to deal with it. (This would not work with many people in this newsgroup.) The meaning of the message is local to the object, which inherits it from the class of which it is an instance, which may inherit it from superclasses of that class&#8230;<br />  <br />  The second approach is generic functions. A generic function has one definition of its semantics, its argument list, and is only specialized on particular types of arguments. <br /></blockquote><div style="text-align: right;">&mdash;<a href="http://groups.google.com/group/comp.lang.lisp/msg/60f4c36a707db3fe">Erik Naggum discussing CLOS on comp.lang.lisp</a></div><br /><br />What we ought to do is take some of the verbs and give them their own place in our programs, instead of hanging them off nouns. This isn&#8217;t such a revolutionary idea: Common Lisp&#8217;s <a href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262610744" title="Amazon.com: The Art of the Metaobject Protocol by Gregor Kiczales">Metaobject Protocol</a> does this exact thing, providing <a href="http://en.wikipedia.org/wiki/Generic_function" title="Generic function - Wikipedia, the free encyclopedia">generic functions</a>. A generic function is, in effect, a verb raised to the same level of abstraction as a noun.<br /><br />This isn&#8217;t some revolutionary idea limited to &#8220;powerful&#8221; languages either: the Java collections framework uses a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Comparable.html" title="Comparable (Java 2 Platform SE v1.4.2)"><code>Comparable</code></a> interface for ordering collections. The <code>compareTo(...)</code> method belongs to an object. By way of&#8212;ahem&#8212;comparison, the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Comparator.html" title="Comparator (Java 2 Platform SE v1.4.2)"><code>Comparator</code></a> interface extracts comparison out of the subject object and puts it in a separate function object. You can perform sorts in Java either way.<br /><br />If we aren&#8217;t using Common Lisp, can we build the verbs we want out of the tools at our disposal? In other words, can we <a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule" title="Greenspun's Tenth Rule - Wikipedia, the free encyclopedia">Greenspun</a> generic functions in languages like Java and Ruby?<br /><br /><strong>generic functions in java, plus a detailed look at method dispatching</strong><br /><br />Let&#8217;s start by thinking about generic functions in a Java-like language.<br /><br />Returning to our example of writing <code>equivalent?</code>, we might make an <code>Equivalent</code> class with a single method, perhaps we can call it <code>eval</code>. So we end up with something like <code>Eqivalent.eval(foo, bar)</code>. Java-like languages allow us to write different versions of the <code>eval</code> method with different type signatures, so we can write:<br /><pre><code><br />public static boolean eval (List foo, List bar) { ... }<br />public static boolean eval (List foo, Map bar) { ... }<br />public static boolean eval (Map foo, List bar) { return eval(bar, foo); }<br />public static boolean eval (Map foo, Map bar) { ... }</code></pre><br />And so forth. Are we done?<br /><br />No, our code is broken. What happens when we decide that the &#8220;default&#8221; equivalence is the <code>==</code> relationship. We can&#8217;t write:<br /><pre><code><br />public static boolean eval (Object foo, Object bar) { return foo == bar; }</code></pre><br />This is hideously broken in languages like Java. You&#8217;re almost all nodding in agreement, but please be patient while I explain it anyway: you probably want to pass this along to someone who really needs to be told why it is broken, so why don&#8217;t I go ahead and explain it for <em>them</em>?<br /><br />What you want is that if two objects are of the more specific types&#8212;<code>List</code> and <code>Map</code>&#8212;we will call the more specific version of the <code>eval</code> methods. But if we can&#8217;t &#8220;match&#8221; one of the more specific <code>eval</code> methods, we want to use <code>eval (Object foo, Object bar)</code>. Too bad, that&#8217;s not how Java works. <em>Java uses two completely different ways to figure out which method to call when you overload methods!</em><br /><br />Way number one is is for figuring out that when you call <code>noun.verb(...)</code>, where do we find the definition for <code>verb</code>? This lookup is effectively done at run time, so that even if your code looks like this:<br /><pre><code><br />public static void printSomething(Object foo) {<br />    System.out.println(foo.toString());<br />}</code></pre><br />Java will look up the method <code>toString</code> based on <code>foo</code>&#8217;s actual type when the method is called, even though you declared it to be an <code>Object</code>. That&#8217;s polymorphism at work, and it&#8217;s the information hiding working for us. Each object can do it&#8217;s own thing where <code>toString</code> is concerned, and we don&#8217;t have to worry about it. This is called <a href="http://en.wikipedia.org/wiki/Single_dispatch" title="Dynamic dispatch - Wikipedia, the free encyclopedia">single dispatch</a>, because it figures out which method to call based on just one of the nouns, the subject noun a/k/a the receiver of the method invocation.<br /><br />But that&#8217;s not what happens when we write this:<br /><pre><code><br />public static void printSomethingElse (Object foo, Object bar) {<br />    if (Equivalent.eval(foo, bar))<br />        System.out.println("2 x " + foo);<br />    else System.out.println(foo.toString() + ", " + bar.toString());<br />}</code></pre><br />It will <em>always</em> call <code>eval (Object foo, Object bar)</code>. It will <strong>not</strong> call <code>eval (List foo, List bar)</code> if you pass it two lists. That&#8217;s because although each of our methods have the same name&#8212;<code>eval</code>&#8212;Java treats them as different methods, and it figures out which one to call based on the declared types of the parameters at compile time, not on the actual types of the parameters&#8217; values at run time.<br /><br /><div class="book"><hr/><em><a id="lnx0" name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158"><img src="http://raganwald.github.com/uploaded_images/a_little_java-777624.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262561158" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><em><br><br>Free your mind with <a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of <a name="evtst|a|0262560992" href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262560992" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> and <a name="evtst|a|026256114X" href="http://www.amazon.com/gp/product/026256114X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256114X">The Little MLer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256114X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em><br><br></em><hr/></div>Besides writing a Lisp interpreter in Java, your next best bet for building a generic function the way we want it is to find a way to turn Java&#8217;s single dispatch into a multi-dispatch, to dispatch on two nouns, <code>foo</code> and <code>bar</code>.<br /><br />The good news is this: dispatching at run time on two different types is a well-known problem, and the solution is called <a href="http://en.wikipedia.org/wiki/Double_dispatch" title="Double dispatch - Wikipedia, the free encyclopedia">double dispatch</a>. The problem with double dispatch is that it moves our equivalence code back into our nouns, and we don&#8217;t want that.<br /><br />The <a href="http://en.wikipedia.org/wiki/Visitor_pattern" title="Visitor pattern - Wikipedia, the free encyclopedia">Visitor</a> pattern might be handy: it&#8217;s a way to add methods to an object at run time in a language like Java that supposedly doesn&#8217;t do that. If we decide that everything to be compared using <code>Equivalent.eval</code>implements an interface called <code>Visitable</code>, we can build a double dispatch system that doesn&#8217;t require putting an <code>equivalent?</code> method in the entities being compared:<br /><pre><code><br />interface Visitable {<br />    Object accept(final Visitor visitor);<br />}<br /><br />interface Visitor {<br />    Object visit(final Object obj);<br />    Object visit(final List list);<br />    Object visit(final Map map);<br />}<br /><br />public class Equivalent {<br /><br />    static boolean list_list (List foo, List bar) { ... }<br />    static boolean list_map (List foo, Map bar) { ... }<br />    static boolean map_map (Map foo, Map bar) { ... }<br />    static boolean object_object (Object foo, Object bar) { ... }<br /><br />    public static boolean eval (final Visitable foo, final Visitable bar) {<br />        return foo.accept(<br />            bar.accept(<br />                new Visitor () {<br />                    public Object visit(final Object bar) {<br />                        return new Visitor () {<br />                            public Object visit(final Object foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final List foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final Map foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                        }<br />                    }<br />                    public Object visit(final List bar) {<br />                        return new Visitor () {<br />                            public Object visit(final Object foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final List foo) {<br />                                return list_list(foo, bar);<br />                            }<br />                            public Object visit(final Map foo) {<br />                                return list_map(bar, foo);<br />                            }<br />                        }<br />                    }<br />                    public Object visit(final Map bar) {<br />                        return new Visitor () {<br />                            public Object visit(final Object foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final List foo) {<br />                                return list_map(foo, bar);<br />                            }<br />                            public Object visit(final Map foo) {<br />                                return map_map(foo, bar);<br />                            }<br />                        }<br />                    }<br />                }<br />            )<br />        )<br />    }<br />}</code></pre><br />If that looks like a lot of work to you, I agree. You&#8217;re basically replicating Java&#8217;s run time dispatching on two types, so you need a bit of a matrix. Is it worth the effort? Let&#8217;s consider what this wins you:<br /><br /><ul><li>Your entities or objects no longer need to know all about other types of entities;</li><br /><li>It&#8217;s easier to make sure that commutation and symmetry are preserved when the code for a relationship is in its own class and not smeared over multiple entities.</li></ul><br />And best of all, you have a nice place for your verbs, and they are no longer second-class citizens behind the nouns.<br /><hr/><br />Update: A few people have suggested alternate approaches to implementing multiple dispatch in Java. I think there are various trade-offs to be made, and several different implementations ought to be considered before you write production code.<br /><br />However, the point of the article is to suggest that not all functions should be implemented as methods of subject objects. I think it makes that point regardless of what you think of using a Visitor and a double dispatch.<br /><br />Here&rsquo;s an alternate approach from <a href="http://programming.reddit.com/user/LaurieCheers/">Laurie Cheers</a>:<br /><pre><code>interface Classifiable<br />{<br />    int classify();<br />}<br /><br />// I know this isn't valid Java, but it makes the example much clearer. The alternative is to tiresomely spell out every combination.<br />#define PAIR(a,b) (a|(b&lt;&lt;4))<br /><br />abstract class DoubleDispatchable<br />{<br />    abstract Object list_list(List a, List b);<br />    abstract Object list_map(List a, Map b);<br />    abstract Object map_map(Map a, Map b);<br />    abstract Object object_object(Object a, Object b);<br /><br />    const int OBJECT = 0;<br />    const int LIST = 1;<br />    const int MAP = 2;<br /><br />    Object dispatch(Classifiable a, Classifiable b)<br />    {<br />        switch(PAIR(a.classify(), b.classify))<br />        {<br />            case PAIR(LIST, MAP): return list_map(a,b);<br />            case PAIR(MAP, LIST): return list_map(b,a);<br />            case PAIR(LIST, LIST): return list_list(a,b);<br />            case PAIR(MAP, MAP): return map_map(a,b);<br />            default: return object_object(a,b);<br />        }<br />    }<br />}<br /><br />class Equivalent extends DoubleDispatchable<br />{<br />    Object list_list(List a, List b) {...}<br />    Object list_map(List a, Map b) {...}<br />    Object map_map(Map a, Map b) {...}<br />    Object object_object(Object a, Object b) {...}<br /><br />    bool eval(Classifiable a, Classifiable b) { return dispatch(a,b) != false; }<br />}<br /></code></pre><br />What trade-offs, you ask? The Visitor pattern given gets the compiler to guarantee that you write each of the nine cases, whereas hand-written tests and logic simplifies the code.<br /><br />I specifically chose the Visitor pattern because it seemed more in keeping with the spirit of the Java language and culture, trading verbosity for compiler safety.<br /><br />I'm extremely comfortable with the other trade-off, emphasizing readability and simplicity. Although, if you go far enough down that road, you might as well look at other languages ;-)<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html" title="permanent link">11:24 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 11, 2007</div>
			

			<div class="Post"><a name="8205454705814141744">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html" title="permanent link">Three stories about The Tao</a></span>
					<div style="clear:both;"></div><blockquote>That maverick framework author is self-centred and vain. His framework is all about solving his problems, his way, he refuses to look at what the market wants and build something that could be more popular.</blockquote><br />There was once a monk who would carry a mirror where ever he went.  A priest noticed this one day and thought to himself &#8220;This monk must be so preoccupied with the way he looks that he has to carry that mirror all the time.  He should not worry about the way he looks on the outside, it&#8217;s what&#8217;s inside that counts.&#8221;  So the priest went up to the monk and asked &#8220;Why do you always carry that mirror?&#8221; thinking for sure this would prove his guilt.  <br /><br />The monk pulled the mirror from his bag and pointed it at the priest.  Then he said &#8220;I use it in times of trouble.  I look into it and it shows me the source of my problems as well as the solution to my problems.&#8221;<br /><br /><blockquote>Sure, the big corporate framework and its language have problems, but they pay the bills.</blockquote><br />Once there was a horse tied up on the side of the street.  Whenever someone tried to pass, the horse would kick them.  Soon a crowd gathered around the horse until a wise man was seen coming close.  The people said &#8220;This horse will surely kill anyone who tries to pass.  What are we going to do?&#8221;  The wise man looked at the horse, turned and walked down another street. <br /><br /><blockquote>Those rabid evangelists turned me off with their attitude, so I determined then and there to never look into their stuff, ever.</blockquote><br /><div class="book"><em><hr/><br /><a href="http://www.amazon.com/gp/product/0385472595?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0385472595"><img border="0" src="http://raganwald.github.com/uploaded_images/tao_speaks.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0385472595" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><a href="http://www.amazon.com/gp/product/0385472595?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0385472595">The Tao Speaks: Lao-Tzu's Whispers of Wisdom</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0385472595" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><hr/></em></div>A monk and his novice were walking through the forest. They come to a stream. On the bank there was a beautifully dressed woman, crying. The monks asked her what was the matter. &#8220;I am on my way to a wedding. I have to cross the stream to get there, but the bridge has been washed away. I was searching for a place to cross where I wouldn&#8217;t ruin the dress, but I can&#8217;t find one and if I don&#8217;t make it across soon, I will be late.&#8221;<br /><br />Without a word, the elder monk scooped her into his arms, waded across the stream, and deposited her on the other side. Ignoring her thanks, he waded back and the two monks resume their walk. They continued on their journey, but the younger monk was agitated and obviously had something on his mind. The elder monk stopped and asked him what was the matter.<br /><br />&#8220;Elder, I am confused. Our vows prohibit us from fleshly contact with women, yet you embraced that woman in your arms. How can this be?&#8221; The elder monk eyed his novice with kindly concern. &#8220;Novice,&#8221; he asked, &#8220;I left her on the bank of the stream. <em>Why do you still carry her?</em>&#8221;<br /><br /><font size="-2">I've read or heard these stories (and quite a few more) many times and in many forms. I borrowed the wording for the first and second story from <a href="http://www.adamlein.com/zen_stories.asp">this good page</a>. Also, someone was kind enough to point outthat  these stories are not necessarily about the Tao, and how Taoism is different from Zen, and so forth. Just so you know :-)</font><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html" title="permanent link">3:07 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, October 03, 2007</div>
			

			<div class="Post"><a name="5163319104241416955">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/10/three-blog-posts-id-love-to-read-and.html" title="permanent link">Three blog posts I'd love to read (and one that I wouldn't)</a></span>
					<div style="clear:both;"></div>&ldquo;Blogging about blogging&rdquo; is tiresome, and I apologize in advance for inflicting this on you: I promise to return to technical subjects immediately. But I really do want to read what <em>you</em> have to say, and what better way than to full-on ask you to write?<br /><br />So here are three blog posts I&#8217;d love to read. Write any or all of these, and you have a guaranteed bookmark in <a href="http://del.icio.us/raganwald/weblog">my delicious feed</a> and my vote on sites like <a href="http://programming.reddit.com/submit?url=http%3A%2F%2Fraganwald.github.com%2F2007%2F10%2Fthree-blog-posts-id-love-to-read-and.html&title=Three%20blog%20posts%20I'd%20love%20to%20read%20(and%20one%20I%20wouldn't)">programming.reddit.com</a> and <a href="http://www.dzone.com/links/add.html?description=&url=http%3A%2F%2Fraganwald.github.com%2F2007%2F10%2Fthree-blog-posts-id-love-to-read-and.html&title=Three%20blog%20posts%20I'd%20love%20to%20read%20(and%20one%20I%20wouldn't)">dzone.com</a>.<br /><br /><strong>What I learned from Language X that makes me a better programmer when I use Language Y</strong><br /><br />Everybody has a pet language. And many smart people take a crack at learning a new language. Some take two years to try to port an existing, production application. Some read a book and throw it across the room, unconvinced that the new language offers much in the way of value. Whether you immersed yourself in the new language or merely skimmed it, what did it teach you that you can apply to your everyday work?<br /><br />I disqualify things like &#8220;Programming in Assembler reminded me how much I love Object-Oriented Programming in Common Lisp.&#8221; Bzzzt! It has to be something you didn&#8217;t know before you tried Assembler. Here&#8217;s one of my own: <em>Ruby and Javascript support a rich literal notation for collections that made me a better Java programmer: I learned the double-brace initialization idiom and now use it regularly</em> (I liked it so much, I wrote <a href="http://raganwald.github.com/2007/04/rails-style-creators-in-java-or-how-i.html" title="raganwald: Rails-style creators in Java, or, how I learned to stop worrying and love anonymous inner classes">an entire post about it</a>.)<br /><br /><blockquote>LISP is worth learning for a different reason&mdash;the profound enlightenment experience you will have when you finally get it.<br /></blockquote><br />The most amazing example of this kind of thinking is Eric Raymond&rsquo;s famous quote: &ldquo;LISP is worth learning for a different reason&mdash;the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot.&rdquo;<br /><br />You may not experience a <em>profound</em> enlightenment from your next language. But if your mind is open to the possibilities, I bet you&rsquo;ll learn a lot that will make you a better programmer for the rest of your days. Tell us about it.<br /><br /><strong>Something surprising that you probably wouldn&#8217;t guess about Language X from reading blog posts</strong><br /><br />I get that Java is verbose, that static typing finds bugs and makes it easy to add certain features to IDEs, that there are a lot of jobs writing Java programs, and that there are a lot of frameworks and libraries written in Java. Great. But one more post about those subjects had better be really, really insightful if it is going to get me excited.<br /><br /><div class="book"><hr><em><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;tag=raganwald001-20&amp;linkCode=ur2&amp;camp=1789&amp;creative=9325"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/little_mler-705423.jpg" alt="" border="0" height="180" width="180"></a><br><br>The Little MLer introduces ML (and its object-oriented variant Ocaml) through a series of entertaining and straightforward exercises working with lists, structures, and even deriving arithmetic from types.<br><br>Learning ML through the book&rsquo;s ten brief chapters will stretch your understanding of how to leverage types and type checking to write programs that are more than just type-safe but are also semantically correct.<br /><br />The surprising thing I learned from ML is the power of expressing a program&rsquo;s semantics with types. It has made me a better programmer whether I&rsquo;m using a weakly but statically typed language like Java or a dynamically typed language like Ruby.<br></em><hr></div>What can you tell me that might not be obvious from reading the same-old, same-old blog posts out there? For example: <em>Java&#8217;s Annotations provide a unique meta-programming mechanism that allows you to write programs that are familiar to the everyday programmer but add code-generation magic</em>.<br /><br />If I were coming to Java from the Ruby world, this might get me excited enough to really learn how to make my programs sing. I was excited to discover that the IntelliJ people have developed <a href="http://www.jetbrains.com/idea/documentation/howto.html" title="IntelliJ IDEA :: Nullable How-To"><code>@Nullable</code> and <code>@NotNull</code> annotations that add null-checking to Java at compile time</a>.<br /><br />The canonical example of this type of post is probably Douglas Crockford&#8217;s essay describing how <a href="http://www.crockford.com/javascript/javascript.html" title="JavaScript: The World's Most Misunderstood Programming Language">Javascript is The World&rsquo;s Most Misunderstood Programming Language</a>.<br /><br /><strong>My personal transformation about Idea X</strong><br /><br />Bob Sutton wrote an amazing article about one kind of smartness, <a href="http://bobsutton.typepad.com/my_weblog/2006/07/strong_opinions.html" title="Bob Sutton: Strong Opinions, Weakly Held">Strong Opinions, Weakly Held</a>. Now it&#8217;s great if learning a language or trying a new methodology taught you something new.<br /><br />But it&#8217;s <span style="font-style:italic;">really, really</span> fascinating if you happened to change your mind about something you used to think was critical. If you have had a 180 degree change of heart and embraced what you formerly shunned, or now shun what you formerly embraced.<br /><br />And I don&#8217;t just mean write and tell me the logical reasons that <a href="http://raganwald.github.com/2007/07/can-your-type-checking-system-do-this.html" title="raganwald: Can your type checking system do this?">Ocaml taught you how strong typing can be much more powerful than what lame-ass Language X provides</a>. That&#8217;s true. But please, if that&#8217;s all you want to write, write &#8220;Five new things I learned from Ocaml that made me a better programmer when I use Lame-Ass language X&#8221; or &#8220;Something surprising that you probably wouldn&#8217;t guess about Ocaml from reading blog posts.&#8221;<br /><br /><em>This</em> blog post is about YOU. Tell me about your personal journey. Give me the human story. When was it exactly that you had your Aha! moment? How did it feel to let go of years of prejudices and preconceptions? What did it feel like to take <a href="http://bc.tech.coop/blog/060811.html" title="Bill Clementson's Blog: Lisp is the Red Pill">the red pill</a>?<br /><br />Now that Ruby on Rails is having its <a href="http://blog.bwtaylor.com/java/ruby_meet_erlang" title="Rails, the 15 minutes is Almost Up. Meet Erlang.">fifteen minutes of fame</a>, people are lining up on either side of the love/hate divide and everybody seems to take its pluses and minuses for granted. But do you remember how dramatic it was when people like <a href="http://weblogs.java.net/blog/batate/archive/2005/02/the_toy_1.html" title="Bruce Tate's Blog: The toy?">Bruce Tate had their &#8220;Born Again&#8221; moments</a>? Maybe today their enthusiasm seems subjective and &#8220;unprofessional.&#8221; But there&#8217;s a human story there: when people turn their back on two, five, or even ten years of belief in something, there is a powerful story to be told.<br /><br />And honestly, I want to hear <em>your</em> story, if you would care to tell it.<br /><br /><em>I would read any and all of the above three posts with enthusiasm and a deep respect for you stepping outside of the usual same-old, same-old blog posts about languages and tools. But if you choose to write the next kind of post, it&#8217;s going to be hard for me to get excited:</em><br /><br /><strong>Here&#8217;s why such-and-such <a href="http://www.rot13.com/index.php?text=fhpxf%20tbng%20qvpx">fhpxf tbng qvpx</a></strong><br /><br />I am not criticizing anyone who has strong opinions about why certain things are lame.<br /><br /><div class="book"><em><hr/><a id="lnx0" name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://raganwald.github.com/uploaded_images/seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is devoted to first class functions (&ldquo;closures,&rdquo; as they are known to many). This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will have learned how to compose functions out of other functions, whether you code in Java, Ruby, Javascript or just about anything else.<br><hr/></em></div>Just because it&#8217;s hard to prove something is lame doesn&#8217;t mean we should wander around saying that everything has its place and they&#8217;re all equally valuable and they all deserve the same real-estate in our minds.<br /><br />We have to wield the axe and say NO to things, to decide that life is too short for programming in Language Z, or for struggling with Tool Omega, or for hiring people <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html" title="raganwald: Why You Need a Degree to Work For BigCo">who don&#8217;t have a certain kind of degree</a>, or whatever else you know in your heart to be lame.<br /><br />But speaking as your reader, posts telling me why you&rsquo;re saying &ldquo;no&rdquo; aren&#8217;t that helpful. They tell me a lot&#8230; about YOU and your preconceptions, not about the lame things. When I re-read my own posts about <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html" title="raganwald: What I've learned from failure">failure</a> or about <a href="http://raganwald.github.com/2007/08/bricks.html" title="raganwald: Bricks">metaphors for software development</a>, I now think they say more about me and my journey than they do about shipping software.<br /><br />The most useful purpose posts about &#8220;how lame things are&#8221; serve is to help people rationalize <em>decisions they have already made</em>.<br /><br />If <a href="http://raganwald.github.com/2007/02/why-ruby-is-not-acceptable.html" title="raganwald: Why Ruby is not an acceptable implementation of Lisp">I have already decided that Ruby is flawed</a>, your post giving your seven reasons is useful ammunition when somebody asks me to justify writing Project Foo using server-side Javascript. But am I really sitting on the fence, unsure of what to do until I read your detailed critique? No.<br /><br />The post that is going to push me away from the lame thing isn&#8217;t the post about how lame it is. It&#8217;s the post about the useful idea and how good it is. And that&#8217;s why I am asking&#8212;or even begging&#8212;you to write a post describing &#8220;Five new things I learned from <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="raganwald: Which theory fits the evidence?">Methodology P</a> that makes me a better team leader when I use Methodology D,&#8221; or &#8220;Something surprising that you probably wouldn&#8217;t guess about the <a href="http://factor-language.blogspot.com/" title="Factor: a practical stack language">Factor</a> language from reading blog posts,&#8221; or especially &#8220;My personal transformation about <a href="http://www.joelonsoftware.com/articles/fog0000000245.html" title="Painless Software Schedules - Joel on Software">estimating software schedules</a>.&#8221;<br /><br />Thanks in advance.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/10/three-blog-posts-id-love-to-read-and.html" title="permanent link">4:03 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, September 12, 2007</div>
			

			<div class="Post"><a name="7738642682231378155">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html" title="permanent link">We have lost control of the apparatus</a></span>
					<div style="clear:both;"></div>I am writing to you as a fellow programmer and software developer. I write in friendship and brotherhood. My heart is heavy, and the news I impart is not good: We have lost control of the apparatus.<br /><br />I know, the IT department soldiers on grimly. They lost a great battle to the PCs more than twenty years ago, and it took years of struggle with NT Domain Controllers and web proxies before control could be wrestled back from the users. In some places I hear battles are still being waged over USB ports and Bluetooth. IT was lucky to find a new ally against the users in <a href="http://finance.yahoo.com/q/bc?s=MSFT&c=AAPL&t=">MSFT</a> just when their ancient supporter IBM&#8217;s star was fading.<br /><br /><blockquote>We&#8217;ve taken care of everything<br />  The words you hear the songs you sing<br />  The pictures that give pleasure to your eyes<br />  It&#8217;s one for all and all for one<br />  We work together common sons<br />  Never need to wonder how or why  <br /></blockquote><br />But we programmers have lost and we must be realistic about things. The fact of the matter is this: people own their own computers, and our applications are no longer the primary way they learn how computers ought to work.<br /><br />I know, I know, they stare at our work for eight, ten, or twelve hours a day. So you would think that we would set the standard for how computers ought to be. But the Good Old Days when most of users had never seen a computer before work have gone. Some of our users, fresh out of school, have already been using computers for ten years!<br /><br />As if that wasn&rsquo;t enough, the really bad news is, when our users go home they have this thing called the Internet. I know, IT locked that down in the office. But we can&#8217;t stop them from getting on it at home, on their mobiles, and now even on those insidious <a href="http://www.amazon.com/gp/product/B000JNYWBG?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B000JNYWBG">Apple iPods</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=B000JNYWBG" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />! And when people use the Internet, they are actually  using <em>other people&#8217;s applications</em>.<br /><br />I&#8217;m not kidding. Our users are being exposed to <em>applications we don&#8217;t control</em>. And it messes things up. You see, the users get exposed to other ways of doing  things, ways that are <em>more convenient for users</em>, ways that <em>make them more productive</em>, and they incorrectly think we ought to do things that way for them.<br /><br /><strong>computers</strong><br /><br />This business of users buying their own computers is really troublesome. For one thing, they can buy a computer in the store for a few hundred dollars that is twice as good as the warmed-up left-over IT put on their desk. Until recently, we could shrug our shoulders. We weren&#8217;t the ones that had to explain that to get an up-to-date model, they needed to fill out a <a href="http://www.imdb.com/title/tt0088846/quotes" title="Brazil (1985) - Memorable quotes">twenty-seven-b-stroke-six</a>. Which needed approval. Against budget. And then IT would order it from <a href="http://finance.yahoo.com/q/bc?s=DELL&c=AAPL&t=">DELL</a>. <a href="http://www.joelonsoftware.com/news/20030115.html" title="Local Optimization, or, The Trouble With Dell">Who don&#8217;t have the CPUs in stock</a>.<br /><br /><div class="book"><em><hr/><br /><a href="http://www.amazon.com/gp/product/B000JNYWBG?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B000JNYWBG"><img border="0" src="/uploaded_images/ipod_touch.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=B000JNYWBG" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br />Blatant plug: Pre-order your <a href="http://www.amazon.com/gp/product/B000JNYWBG?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B000JNYWBG">Apple 16 GB iPod Touch</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=B000JNYWBG" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> with this affiliate link. You&rsquo;ll get the most revolutionary device ever made and you&rsquo;ll support ragawald, <strike>a worthy</strike> <strike>a pretty-good</strike> ok, a drivellous weblog but at least it&rsquo;s entertaining. Please. And thank you, I really do appreciate the clicks!<br /><hr/></em></div>And meanwhile, the very same users could walk across the street and buy themselves a much better PC for less money than we pay and take it home the same day. And until now, we didn&#8217;t worry about it. We&#8217;re the programmers.<br /><br />But now it&#8217;s a problem. Here&#8217;s the thing: those PCs they buy at home? The ones that are two, three, or even five times better than the ones on their desk? With huge drives, and lots of memory? The thing is, they run <em>much richer applications</em> than the warmed-over TTY stuff we&#8217;ve been feeding them under the guise of &#8220;being hip to the Internet revolution.&#8221;<br /><br />For example, my Mother uses Skype to talk to her friends. She thinks it&#8217;s normal to see all of your voice mail messages in a list on the screen. If I tried to give her a CRM application for managing contacts, the very first question she would ask would be, &#8220;Why can&#8217;t I listen to all of the voice mails from that contact in the application?&#8221;<br /><br />Do you think she would have patience for my explanation that the company&#8217;s phone systems are complex and proprietary and that we can&#8217;t install <a href="http://www.asterisk.org/" title="Asterisk :: The Open Source Telephony Platform |">Asterix</a> just for her? She would grab me by the ear and drag me to my desk to get cracking on it!<br /><br />You laugh, but users are used to a lot more functionality than a web page with a form on it these days, and if we don&#8217;t give it to them, the noise from all the whining is going to drive us insane. <br /><br /><blockquote>I tried telling them that databases were not designed for multi-megabyte Word files and PowerPoint presentations, and they just goggle at me like I&#8217;m a circus freak and ask me why I&#8217;m using a database if it doesn&#8217;t do what they want for them?<br /></blockquote><br />Here&#8217;s another thing. How many monitors do your users have? One, right? There&#8217;s no point in giving them more, because we build our applications with session management that basically goes insane if they try to open two windows at once, right? Well guess what? Users have multiple monitors at home for games, and they want them at work.<br /><br />And when they have them at work and you explain that no, they can&#8217;t be in the middle of doing something for XYZCorp in one window, and open a new window when a call comes in from ABCLimited, because that screws up the session, they are going to bitch and moan, because they can do two things at once in their mail application and their social network and their game. Sucks to be us.<br /><br />And don&#8217;t get me started about had drives. Would you believe that users now expect&#8212;as if anyone gave them permission to have expectations&#8212;what was I saying? Oh yes, users now expect that we should store everything and anything. That&#8217;s right, they think we should be able to handle arbitrarily large text fields, with styling, and pictures, and even sound or video, all stashed away where they can find it again. They want to be able to store everything to do with an account or a customer or a project or whatever right in our applications.<br /><br />I tried telling them that databases were not designed for multi-megabyte Word files and PowerPoint presentations, and they just goggle at me like I&#8217;m a circus freak and ask me why I&#8217;m using a database if it doesn&#8217;t do what they want for them? I try to tell them that we don&rsquo;t have a budget for buying bigger drives, and the poor, deluded fools pull out their credit cards and offer to buy a terabyte drive over the Internet for less money than our vendors charge us per phone call.<br /><br />I tell you, users refuse to sit and be trained like puppies. And the bottom line is this: we can&#8217;t keep putting HTML lipstick on a 1960s pig forever. We have to get out of the office and look at what a modern PC looks like&#8212;drive, speed, RAM, monitors, everything&#8212;and write applications that can take advantage of it.<br /><br /><strong>fields</strong><br /><br />You know how all of our applications have a <code>first-name</code> and a <code>last-name</code>? This has worked for decades, you would think people would understand the value of <em>standards</em>, of <em>consistency</em>. But out there in the Internet, where there is no Adult Supervision, some of those applications have just one field for a name. You put spaces in it to separate first and last, just like writing a letter, I guess.<br /><br /><blockquote>When I told one of our users, a business analyst, that using just one field for the name meant a huge amount of work for programmers, she actually asked me what our job was, if not to do the work that makes users productive.<br /></blockquote><br />Please, stop laughing. I had the same reaction. How could that possibly work? But the rogues who build that kind of heresy put in a lot of clever little rules and things so that the single field can handle case like <code>Braithwaite, Reginald</code> or <code>Geroge Smithers, Esq.</code> or even <code>Doctor Wu</code> properly.<br /><br />When I told one of our users, a business analyst, that using just one field for the name meant a huge amount of work for programmers, she actually asked me what our job was, if not to do the work that makes users productive. I&#8217;m very much afraid that things are out of hand. I tried to explain how our database schema works, and so on, but she impatiently insisted that it was our job to make things work.<br /><br />She then started lecturing me&#8212;lecturing ME!&#8212;about copy and paste, of all things. She said that it should be convenient to copy and paste between our application and other applications like Word, Excel, and even Outlook. With separate fields, you need to do multiple steps to copy a name between our applications and a letter.<br /><br />I felt betrayed by Microsoft. Whatever happened to the days when people used just one application, and if they needed another we would give them an export routine? Now she wants to be able to copy a name out of an email and paste it into our application without carefully selecting the last name, first name, and honorific separately.<br /><br />When I left her office, she was mumbling something about <a href="http://en.wikipedia.org/wiki/Software_as_a_Service" title="Software as a service - Wikipedia, the free encyclopedia">SaaS</a> or some such. I don&#8217;t remember what she meant, but &#8220;sass&#8221; just about sums up her attitude. <br /><br />If she was just one lone uppity user, I could handle it. But they&#8217;re popping up like toadstools. Just the other day another user was asking why he couldn&#8217;t paste an address as one field, including zip code. I told him I didn&#8217;t have time to explain how database columns worked, but again he muttered something disrespectful and later I saw him hefting his swingline rather menacingly while looking at our application on his screen.<br /><br />Brothers and sisters, I know this is hard to take, but we&#8217;re losing this war. Our DBA cousins have brainwashed Corporate into believing that they are the custodians of the data, and of the sacred Stored Procedure that Controlleth Access. We have very little choice about how things work.<br /><br />But still, the users expect <em>us</em> to make applications every bit as useful for them as the applications they use on the Internet, and I fear that they will rise up and revolt very soon if we don&#8217;t find a way to make the database invisible and make user applications conform to these horribly user-centric heresies.<br /><br />I know, I see the pitchforks in your hands, and your desire to maul, hang, and burn the messenger is understandable. But that won&#8217;t fix things, so please put them down, ok?<br /><br /><strong>stories</strong><br /><br />And don&rsquo;t give me that &ldquo;User Stories&rdquo; flim-flam, please. I practically <em>invented</em> bamboozling users into doing what we want by pretending to put them in charge of an Agile Process. Agile Process indeed, anybody ought to know that if it&rsquo;s a Process, it sure as heck can&rsquo;t be Agile.<br /><br />So you think you can do what we&rsquo;ve always done, hunh? When they complain about copy and paste, write it up as a story, put it in the backlog, and then&mdash;look at that&mdash;there&rsquo;s always a higher priority story to do. There&rsquo;s always some new functionality that offers a greater ROI than polishing an old feature.<br /><br />Well, sister, where that goes wrong is that this isn&rsquo;t polish: it&rsquo;s what our users expect as basic functionality. You might think it is new and improved and doesn&rsquo;t add value, but what our users think is that our applications are old and broken and waste their time.<br /><br />So while on paper a new feature is more important than making paste work, in practice it looks like we build software that slows the organization down.<br /><br />So save your breath and stop using Agile as an excuse for slapping the crudest crap together and putting fast in front of finished.<br /><br /><strong>search</strong><br /><br />You would things couldn&#8217;t get any worse. But they are worse, much worse. I&#8217;ll just say one word. Google. Those bastards are practically the home page of the Internet. Which means, to a close approximation, they are the most popular application in the world.<br /><br /><div class="book"><em><hr/><br /><a href="http://www.amazon.com/gp/product/1933988037?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1933988037"><img border="0" src="/uploaded_images/prototype_and_scriptaculous.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1933988037" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br />The authors of <a href="http://www.amazon.com/gp/product/1933988037?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1933988037">Prototype and Scriptaculous in Action</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1933988037" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> are the people who brought you the incredible <a href="http://www.prototypejs.org/">Prototype</a> and <a href="http://script.aculo.us/">script.aculo.us</a> Javascript libraries. This book explains how to use them to build reusable, literate Javascript, how to build dynamic, Web 2.0 applications, and best of all, how to write web applications without tearing your hair out in frustration with Javascript.<br /><br />With this book and these libraries, you&rsquo;ll learn how to write better Javascript in a Lisp-like functional style, and as a bonus you&rsquo;ll also learn how to write better Javascript in a conventional OO style.<br /><hr/></em></div>And what have they taught our users? <strong>Full-text search wins</strong>. Please, don&#8217;t lecture me, we had this discussion way back when we talked about fields. Users know how to use Google. If you give them a search page with a field for searching the account number and a field for searching the SSN and a field for searching the zip code and a field for searching the phone number, they want to know <em>why they can&#8217;t just type <code>4165558734</code> and find Reg by phone number?</em> (And right after we make that work for them, those greedy and ungrateful sods&#8217;ll want to type <code>(416) 555-8734</code> and have it work too. Bastards.)<br /><br />I have tried explaining that there&#8217;s an ambiguity if an account number is also <code>4165558734</code>. But those damn users just give me that &#8220;Boy, you are stupid&#8221; look that made Samuel Jackson famous. They think we should just show them what we find and let them sort it out. They&#8217;re idiots, obviously, but they&#8217;re <em>our</em> idiots and I&#8217;m pretty sure that if we fire them all we&#8217;ll have to clean our own desks out the following day.<br /><br />They don&#8217;t even get that search results should always show stuff from the same table. Would you believe, if they type a phone number, they want us to search <code>companies</code> and <code>persons</code>. They have no respect for our careful husbanding of hardware resources. The profligate spendthrifts think that just because they have a two gigahertz PC at home that can search their entire hard drive for a phone number as fast as they can type it&#8212;<a href="http://desktop.google.com/features.html" title="Google Desktop - Features">thanks again, Google</a>&#8212;we should make search as fast and as easy to use in our applications.<br /><br />We can use tools like <a href="http://en.wikipedia.org/wiki/Nutch">Nutch</a> and what-not for full-text search. But users want to search everything, everywhere, just like Google. And try as we might to get them to use <a href="http://nkilkenny.wordpress.com/2006/11/13/whats-wrong-with-sharepoint/" title="What’s wrong with Sharepoint?">Sharepoint</a>, they just deride it as a heap of junk. We are going to wind up ceding control of our data to Google sooner or later. I hate to be the one to tell you this, but you might as well hear it from a friend:<br /><br />You need to start coding your applications so that an <em>external search engine</em> can search them. That&#8217;s right, you need to work <em>with</em> a desktop search tool and a network search tool so that people can type <code>4165558734</code> and see everything, mail, word docs, and records in your database, in one place.<br /><br />It&#8217;s the future. A miserable, groveling future where our applications work for the users instead of the users working for our applications, but it&#8217;s our future.<br /><br />Suck it up and roll with it.<br /><hr/><br /><font size="-1">Psst! Are you Smart? Do you Get Things Done? Do you want to work in New York City using Rails and Java? <a href="http://mcommons.com/about/jobs">Mobile Commons is hiring developers!</a></font><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html" title="permanent link">2:37 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, August 26, 2007</div>
			

			<div class="Post"><a name="4181946194975037390">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/08/ruminations-about-performance-of.html" title="permanent link">Ruminations about the performance of anonymous functions in naive Javascript implementations</a></span>
					<div style="clear:both;"></div><a href="http://raganwald.github.com/2007/08/block-structured-javascript.html" title="raganwald: Block-Structured Javascript">Block-Structured Javascript</a> (better known as the <em>Module Idiom</em>) looks like this:<br /><pre><code><br /> (function () {<br />    var something_or_other;<br />    // code elided<br />    return something_or_other;<br /> })()<br /></code></pre><br />This creates a new, anonymous function with its own local scope. Whenever this code is execututed, the interpreter creates a function record in its memory. The exact same thing happens if you create a function and bind it to a variable with <code>var foo = function (...) { ... };</code>.<br /><br /><div class="book"><em><hr><br /><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://raganwald.github.com/uploaded_images/seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is devoted to the myriad uses of first class functions. Luckily for us, the ideas in this provocative book map directly to Javascript (see the plug for <a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668">Lisp in Small Pieces</a> below).<br /><br />When you close the back cover you will be able to compose programs from functions in powerful new ways, and you can use these new techniques in Scheme, Ruby, and Javascript immediately.<br /><hr></em></div>Now let&rsquo;s consider another common pattern, the <em>Inner Function</em>: we have a function, and the function needs a helper function. We define the helper function inside our function to make our code more <em>encapsulated</em>:<br /><pre><code><br /> var factorial = function (n) {<br />     var factorial_acc = function (acc, m) {<br />         if (0 == m) {<br />             return acc;<br />         } else {<br />             return factorial_acc(m * acc, m - 1);<br />         }<br />     };<br />     return factorial_acc(1, n);<br /> };<br /></code></pre><br />What happens when we invoke <code>factorial</code> it six times?<br /><br />When the interpreter first encounters the code defining <code>factorial</code>, it creates a function and assigns it to the variable <code>factorial</code>. Then each time we invoke the <code>factorial</code> function, the interpreter creates a new function record for <code>factorial_acc</code>. So in total, the interpreter creates <em>seven</em> functions in memory, not two.<br /><br /><strong>hand-rolling</strong><br /><br />If this code needed hand optimization, you might want to consider ‘lifting&rsquo; the definition of <code>factorial_acc</code> outside of factorial, so it doesn&rsquo;t get recreated with every invocation:<br /><pre><code><br /> var factorial_acc = function (acc, m) {<br />     if (0 == m) {<br />         return acc;<br />     } else {<br />         return factorial_acc(m * acc, m - 1);<br />     }<br /> };<br /> var factorial = function (n) {<br />     return factorial_acc(1, n);<br /> };<br /></code></pre><br />This produces exactly the same result as our Inner Function version. <code>factorial_acc</code> doesn&rsquo;t use any of <code>factorial</code>&rsquo;s parameters or variables, so it does not really need to be inside its scope to produce the correct result.<br /><br />Now you only need two function records, not seven. Two is cheaper than seven. The problem with this approach is that you are proliferating names. If you are binding functions to names in the global environment, it quickly becomes crowded. And you also have a readability issue. Does anything else need to use <code>factorial_acc</code>? The original code made it very obvious that <code>factorial_acc</code> is only ever used by <code>factorial</code>.<br /><br />A block can help. Yes, the cause of our performance consideration—dynamically creating functions—can actually be part of the solution:<br /><pre><code><br /> var factorial = (function () {<br />     var factorial_acc = function (acc, m) {<br />         if (0 == m) {<br />             return acc;<br />         } else {<br />             return factorial_acc(m * acc, m - 1);<br />         }<br />     };<br />     return function (n) {<br />         return factorial_acc(1, n);<br />     }<br /> })();<br /></code></pre><br />Now what happens? Well, we create an anonymous function for our block. One function record. Within that block&rsquo;s execution, we create two more functions,  one assigned to the variable <code>factorial_acc</code>, and one returned from the block (and then assigned to the variable <code>factorial</code>). This code creates three function records, which is still much better than seven.<br /><br />As a correspondent summarized in email, &ldquo;we&rsquo;ve shown how to replace a simple function containing an inner function with a block call that returns a closure referencing the inner function so as to avoid re-defining it on each call. That&rsquo;s all there is to it.&rdquo;<br /><br />(By the way, <a href="http://crockford.com/">Douglas Crockford</a> has done a very good job of explaining this idiom in Javascript, and named it the <em>Module Pattern</em>. Here&rsquo;s <a href="http://www.wait-till-i.com/index.php?p=467">a discussion</a> with particular emphasis on OO-style programming. And here&rsquo;s <a href="http://yuiblog.com/blog/2007/06/12/module-pattern/">a really detailed examination</a> from the YUI team.)<br /><br />So should you always rewrite inner functions to use a block like this?<br /><br />I don&rsquo;t personally fool around with this kind of hand optimization willy-nilly (Of course, you may find the block version more readable than the inner function version. If you do, it&rsquo;s a win to write it that way). It has a cost: in a more complex function, defining helpers outside of the function may be moving them further away from where they are used, which is a loss for readibility. If you prefer the inner function version, you should be very sure you have a performance problem before you leap to the conclusion that you should rewrite it.<br /><br /><strong>a heuristic for automatic optimization of inner functions and blocks</strong><br /><br />Lisp implementations have been optimizing this kind of code, automatically, for decades. That&rsquo;s because Lisp programmers have been writing programs in this style for decades, either directly or using macros like <code>let</code>. Here&rsquo;s the basic heuristic:<br /><br /><div class="book"><em><hr><br /><a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668"><img src="/uploaded_images/lisp_in_small_pieces.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521545668" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668">Lisp in Small Pieces</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521545668" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is one of the most important books about Javascript ever written. WTF!? may be your first thought. Hold on. Javascript at its heart, a very Lisp-like language with C syntax. So understanding Lisp helps you understand Javascript.<br /><br />What makes <a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668">Lisp in Small Pieces</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521545668" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> special for Javascript programmers is that it illustrates the principles underlying Lisp (and therefore Javascript) by creating a series of implementations, each of which illustrates the basic mechanisms in the language.<br /><br />These deep ideas are exactly the things that make Javascript different from other C-syntax languages like Java or Visual Basic. This book, more than any other, will take your understanding from knowing what works on the surface to understanding why and how it works.<br /><hr></em></div><ul><li>Find every <code>function</code> invocation that is nested inside another <code>function</code>.</li><br /><li>Analyze all of its variable references lexically. If there are no references to a parameter or local variable of its immediate parent,<sup><font size="1">1</font></sup> promote the function by defining it in its grand-parent and assigning the definition to a new variable in the grand-parent.</li><br /><li>Replace the original definition in the parent with a reference to the variable you just created in the grand-parent.</li><br /><li>Repeat until all functions are either global or refer to variables in their immediate parent functions.</li></ul><br />There&rsquo;s also a well-know optimization for making blocks themselves free or nearly free: <a href="http://en.wikipedia.org/wiki/Lambda_lifting" title="Lambda lifting - Wikipedia, the free encyclopedia">lambda lifting</a>. So before optimizing things prematurely, test your implementation and see if it is already fast enough for your purposes.<br /><br />You may discover that you don&rsquo;t save anything by rewriting things yourself. (You may make your code slower: some optimizations rely on knowing the exact scope of the code being optimized. If you proliferate names by lifting things yourself, the optimizer may not be able to use all of its tricks.)<br /><br />These techniques have been known for <em>twenty-five years</em>. If a <a href="http://en.wikipedia.org/wiki/Internet_explorer" title="Internet Explorer - Wikipedia, the free encyclopedia">Javascript implementation that you are forced to target</a> doesn&rsquo;t include it, why not demand that the implementers get with the program and, you know, use some of the stuff we&rsquo;ve known about programming for almost as long as they&rsquo;ve been alive? Especially if they brag about their prowess at creating programming languages?<br /><br /><strong>conclusion: nice-to-know, but not essential</strong><br /><br />My personal conclusion is that the behaviour of a naïve implementation is a &ldquo;nice-to-know.&rdquo; I don&rsquo;t personally worry about optimizing it until I have a known performance issue, at which point it is essential to test to see whether some of the hand-optimizations will actually help.<br /><br />YMMV.<br /><hr><br />1. Full closures make things tricky:<br /><br />Functions that refer to variables in their immediate parent scope are much trickier to optimize away. Sometimes, such a function is supposed to be created anew for each invocation of its parent.  For example, if you want to construct a bank balance thingy without using objects, you might write:<br /><pre><code><br />    function (balance) {<br />      return function (amount) {<br />          balance = balance + amount;<br />          return balance;<br />        };<br />    };<br /></code></pre><br />You pass in an initial balance, and it gives you a single function that you can use to deposit (pass a positive number), withdraw (pass a negative number), or check the balance (pass zero). It returns the updated balance in each case.<br /><br />The inner anonymous function cannot be lifted or optimized away because of its reference to <code>balance</code> in its parent and because the function can be shown to &ldquo;escape&rdquo; its parent.<br /><br />Whereas in this contrived example:<br /><pre><code><br />    function (balance, owner) {<br />      return function (amount) {<br />          return {<br />              new_balance: (function () {<br />                  if (balance + amount &gt;= 0)<br />                      return balance + amount;<br />                  else return balance;<br />              })(),<br />              account_owner: owner<br />          }<br />        };<br />    };<br /></code></pre><br />Although the inner function still cannot be optimized away, the block within it can be lifted into the inner function and removed, producing:<br /><pre><code><br />    function (balance, owner) {<br />      return function (amount) {<br />          var __temp;<br />          if (balance + amount &gt;= 0)<br />              __temp = balance + amount;<br />          else __temp = balance; <br />          return {<br />              new_balance: __temp,<br />              account_owner: owner<br />          }<br />        };<br />    };<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/08/ruminations-about-performance-of.html" title="permanent link">11:44 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, August 20, 2007</div>
			

			<div class="Post"><a name="8261916568550175558">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/08/block-structured-javascript.html" title="permanent link">Block-Structured Javascript</a></span>
					<div style="clear:both;"></div>Javascript provides <em>closures with first-class access to variables declared in the enclosing environment</em>. Besides being a handy piece of trivia if you are ever playing Programming Jeopardy, what use is this to the actual working programmer?<br /><br />There are a lot of ways to take advantage of Javascript&#8217;s closures, I am going to describe just one, replicating Algol&#8217;s block structure (or Lisp&#8217;s <code>let</code> and <code>begin</code> macros, if you prefer). When we&#8217;re all done you&#8217;ll have a handy tool for making your code more readable, separating its concerns, and generally making life easier for programmers who have to read what you&#8217;ve written.<br /><br /><strong>From Bricks to Blocks</strong><br /><br />A block is a chunk of code inside a function. Blocks have well-defined entry and exit points. Blocks have their own local variables and functions, and they also have first-class access to variables and functions defined around them. Blocks may nest.<br /><br />Structuring code into blocks makes large functions more readable and easier to refactor. All of the variables and logic needed for one thing are encapsulated together in the blocks where they are needed, not scattered about in functions everywhere.<br /><br /><blockquote>when a better design&mdash;if unfamiliar&mdash;is shown to developers or experienced users, they tend to reject it. Often, it takes careful explanation and having them gain experience with it before the improvement is understood.<br /></blockquote><div style="text-align: right;">&mdash;Jef Raskin</div><br /><br />While the idiom may be slightly unfamiliar to some, I think you&#8217;ll agree that it is highly accessible and not some sort of &uuml;ber-contruct of interest only to the self-professed hacker. And when a programmer encounters it in your code, she will have no trouble figuring out what it does and how it does it.<br /><br /><strong>block structured code</strong><br /><br />I think everyone can agree that structured programming is a good thing. Functions should be composed of blocks, with the blocks linked together by constructs such as <code>if</code> statements:<br /><pre><code><br />if (some_condition) {<br />    // a block<br />}<br />else {<br />    // another block<br />}<br /></code></pre><br />Back before structured programming was introduced, there were <code>gotos</code> everywhere. Looking at a piece of code with labels, it was hard to know what the flow of control might be at run time. In short, you never had the confidence that everything you needed to know about that code was right there next to that code.<br /><br />Like almost all modern languages, Javascript&#8217;s blocks do structure the flow of control so that you have nice clean entries and exits from each block. And also like most other modern languages, Javascript does nothing to structure access to variables inside blocks. For example:<br /><pre><code><br />var j = 0;<br />if (some_condition) {<br />    // a block with some code elided<br />}<br />alert(j);<br /></code></pre><br />What will be shown? You can&#8217;t guarantee that zero will pop up, because the blocks might modify <code>j</code>, like this:<br /><pre><code><br />var j = 0;<br />if (true) {<br />    var j = 42;<br />}<br />alert(j);<br /></code></pre><br />This looks like a programmer error. After all, the <code>var</code> keyword should be used to declare a new variable. The code between the braces isn&#8217;t really a new block of code with its own variables. This is hardly a problem with trivial examples. But if you start building some larger functions, the possibility of accidentally overwriting some code looms larger. Especially once you start refactoring and moving blocks of code around.<br /><br />What can we do? How about this: the &#8220;block&#8221; idiom (you can also call it  <code>let</code> or <code>begin</code> if you want to sound like a Schemer). Here&#8217;s the code:<br /><pre><code><br />var j = 0;<br />if (true) <br />    (function () {<br />        var j = 42;<br />    })();<br />alert(j);<br /></code></pre><br />There&#8217;s a lot of syntactic noise, what does it mean? In short, we said: &#8220;Create a new function. In the body of the new function define a variable called <code>j</code> and assign 42 to it. Then call that function without any parameters.&#8221; Because our new instance of <code>j</code> is inside a function, it is not the same variable as the <code>j</code> outside of the function. That can be handy.<br /><br />Are there any other benefits of this idiom? Yes indeed. Sometimes you have an assignment and you need some logic on the right hand side. How do you write:<br /><pre><code><br />var proven = {<br />    var n = Math.round(100*Math.random());<br />    var total = 0;<br />    for (var i = 0; i &lt;= n; ++i) {<br />        total = total + (2*i) + 1<br />    }<br />    return total == ((n + 1) * (n+1));<br />};<br />alert(proven);<br /></code></pre><br />You can&#8217;t, of course. There are two problems with trying to use braces in this case. First, Javascript only allows braces to form code blocks in conjunction with specific keywords like <code>if</code> and <code>function</code>. Second, Javascript code blocks are not <em>expressions</em>&mdash;they do not produce values. This is why languages like Javascript need an if statement <em>and</em> a ternary operator: if blocks produced values, you would only need if expressions. <br /><br />So in traditional Javascript style, you have to define a function somewhere else and call it&#8230; You&#8217;ll notice our block idiom includes defining and calling a function. What if our function returns a value? In that case, we can use a block anywhere we want a value, for example:<br /><pre><code><br />var proven = (function () {<br />    var n = Math.round(100*Math.random());<br />    var total = 0;<br />    for (var i = 0; i &lt;= n; ++i) {<br />        total = total + (2*i) + 1<br />    }<br />    return total == ((n + 1) * (n+1));<br />})();<br />alert(proven);<br /></code></pre><br />This new idiom allows us to make first-class blocks anywhere we like. Our blocks are <em>expressions</em>, and we can use them anywhere we need a value. And as above, Our variables are fully encapsulated, they do not overwrite variables defined elsewhere.<br /><br /><strong>blocks vs. named functions</strong><br /><br />You may be wondering, "Why can&rsquo;t we use a named function?" This is the style in languages like Python, where the Benevolent Dictator does not permit constructions like this. Here is the above code using a named function:<br /><pre><code><br />var proven_helper = function () {<br />    var n = Math.round(100*Math.random());<br />    var n_plus_1_squared = function (n) {<br />        return (n + 1) * (n+1); <br />    };<br />    var sum = function (n) {<br />        var total = 0;<br />        for (var i = 0; i &lt;= n; ++i) {<br />            total = total + (2*i) + 1<br />        }<br />        return total;<br />    };<br />    return sum(n) == n_plus_1_squared(n);<br />};<br />var proven = proven_helper();<br />alert(proven);<br /></code></pre><br /><br />I find this almost as good as the block. Since you only use it in one place, it is defined where you use it. That is good. And the name might be helpful documentation, just like a one or two-word comment. Balanced against this is the fact that you have added a new function to the outer scope. Reading it later, you might have to scan the rest of the code to see if it is used elsewhere.<br /><br />There's also a very small advantage of the block over the named function: since you need two statements (one to name a function, another to use it), you can only use a named function in normal code blocks. You cannot use a named function when you need an expression, unless you resign yourself to naming the function in one place and using it somewhere else.<br /><br />For example, when constructing array or hash literals, you can use expressions. A block is an expression, while two statements (one to create a named function and one to call it) are not an expression. So a named function would need to be defined outside of an array or hash literal, while a block can be used inside it, placing the code closer to where it is used.<br /><br /><strong>block structure and cleaner code</strong><br /><br /><div class="book"><em></em><hr><em><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596101996"><img border="0" src="/uploaded_images/javascript.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0596101996" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596101996">JavaScript: The Definitive Guide</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0596101996" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> takes the time to actually discuss the language, to explain what Javascript can do and how to do it. And of course, the book also provides an in-depth reference of every function and object you are likely to encounter in most implementations. Recommended.<br /></em><hr></div>Structuring code into blocks makes large functions more readable and easier to refactor. All of the variables and logic needed for one thing are encapsulated together in the blocks where they are needed, not scattered about in functions everywhere. If you see a variable declared inside a block, you know it is only used inside the block. If you see a variable with the same name outside the block&#8212;a regrettable occurrence&#8212;you know that moving or changing the block will not affect the code working with variables outside of the block.<br /><br />You probably know that you can put a function inside of a function in Javascript:<br /><pre><code><br />var factorial = function (n) {<br />    var factorial_acc = function (acc, n) {<br />        if (0 == n) {<br />            return acc;<br />        } else {<br />            return factorial_acc(n * acc, n - 1);<br />        }<br />    };<br />    return factorial_acc(1, n);<br />}<br />alert(factorial(6));<br /></code></pre><br />And this is a good thing, it keeps the function <code>factorial_acc</code> inside of <code>factorial</code>. Since that&#8217;s the only place you need it, why declare it anywhere else? The fact that you can put a function inside of a function implies that you can put a function inside of a block as well:<br /><pre><code><br />var proven = (function () {<br />    var n = Math.round(100*Math.random());<br />    var n_plus_1_squared = function (n) {<br />        return (n + 1) * (n+1); <br />    };<br />    var sum = function (n) {<br />        var total = 0;<br />        for (var i = 0; i &lt;= n; ++i) {<br />            total = total + (2*i) + 1<br />        }<br />        return total;<br />    };<br />    return sum(n) == n_plus_1_squared(n);<br />})();<br />alert(proven);<br /></code></pre><br />If you only need the functions <code>n_plus_1_squared</code> and <code>sum</code> to do this one job, in this one place, why should they be defined at top level cluttering up your code? Why force other programmers to search through your code figuring out where they are used before making changes?<br /><br />Block structure may seem <i>unfamilar</i> at first, but give blocks a try and see whether you start finding the code even easier to read and refactor with blocks. Like me, you will find that structuring your code with blocks puts the things you use right where you use them.<br /><br /><strong>update</strong>: <a href="http://raganwald.github.com/2007/08/ruminations-about-performance-of.html">Ruminations about the performance of anonymous functions in naive Javascript implementations</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html" title="permanent link">10:08 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="5994980098191071116">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/08/bricks.html" title="permanent link">Bricks</a></span>
					<div style="clear:both;"></div>I&#8217;m just finishing off some work with a corporate client before moving back to my natural position in product development (with a <a href="http://mcommons.com/" title="Mobile Commons | Services and Tools to Mobilize Your Cause">really exciting company</a>!).<br /><br />It&#8217;s a good time to reflect back over what was straightforward and what was difficult, what worked and what didn&#8217;t. It has been a very positive experience overall, and I have learned a few more things. Here are a hotch-potch of thoughts about corporate projects, clumsily organized around a single metaphor.<br /><br /><strong>software is not made of bricks</strong><br /><br />Although very few managers ever express it directly this way, many behave as if developing a piece of software is like building something fairly simple out of bricks. It might be <a href="http://en.wikipedia.org/wiki/Great_Pyramid_of_Giza">something large</a>. But it&rsquo;s still fairly simple.<br /><br />This is tempting. The inexperienced person thinks that bricks are easy to understand: they&#8217;re all the same: if you know how to work with one, you know how to work with them all. You can measure the progress of building something out of bricks by counting the bricks in place. And anyone can contribute, even if only by moving bricks from one place to another using brute force.<br /><br /><div style="text-align: center;"><a href="http://www.flickr.com/photos/lefty/10609694/in/photostream" title="Lego Team Building on flickr"><img border="0" src="/uploaded_images/3114_bricks.jpg"/></a><br/><font size="-2"><a href="http://www.codinghorror.com/blog/archives/000834.html" title="Thirteen Blog Clichés">Why this image is a clich&eacute;</a></font></div><br />When you have a brick by brick mentality, deep in your soul you believe that a project contains a fixed amount of work. <strong>It&#8217;s just a pile of bricks</strong>. There are so many screens, so many lines of code. You think this to be true because when you examine finished applications, you can count these things. So you engage in a discovery step up front where you estimate how many screens and how much code will be needed, then you play some games with numbers of people and the amount of work they can do per day, and out comes an estimated ship date.<br /><br />You believe that since the finished work contains a fixed number of bricks, <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="Which theory fits the evidence?">it is possible to know in advance how many bricks will be needed, and where they belong in the finished software</a>.<br /><br />This model of software development leads to several natural assumptions about how to organize a project. These assumptions are logical consequences of the belief that software is made of bricks:<br /><br /><strong>assumption: it&#8217;s all abut moving bricks</strong><br /><br />The brick by brick mentality thinks of software development as making a pile of bricks. Think of the stereotypical Egyptian Pyramid as an example. There are so many bricks to pile and then you&#8217;re done. If it&#8217;s all about moving bricks, <strong>any work that moves bricks contributes to the success of the project</strong>.<br /><br />That&#8217;s a comforting thought. Just keep those bricks moving. This helps us with all sorts of problems. Some people debate whether star programmers really are twenty times more productive than doofuses. Who cares? As long as the doofus can move bricks, eventually the work will get done. <br /><br />So if you have a poor performer, someone who is slow and not very careful, you can use them on a project. Just find the right place for them where they can&#8217;t accidentally wreck the whole pyramid, and they can help. Ok, they are not good with the tricky booby traps or aligning the windows to allow light to strike the altar at the solstice. Fine. But what about ferrying bricks from the <a href="http://en.wikipedia.org/wiki/Dhow" title="Dhow - Wikipedia, the free encyclopedia">dhow</a> to the base of the pyramid? Doesn&#8217;t that move the project forward?<br /><br />Can&#8217;t you hire almost any warm body with ten working fingers and put them to work <em>somewhere</em>? Perhaps they can fiddle with page layouts, or copy the work of more experienced developers when implementing new features that are similar to existing features. But an extra pair of hands is always helpful, right?<br /><br /><em>software is more complicated than bricks</em><br /><br />This assumption is wrong. The reason it is wrong is that software is deep. It is not a simple pile of bricks. Examining a finished piece of software, it is easy to discern surface forms like patterns, variable names, or rough organization. But the motivations for these choices are often subtle and opaque to the journeyman.<br /><br />You can observe this the next time you are interviewing developer candidates. Ask them to name a design pattern: perhaps they respond, &#8220;<a href="http://steve.yegge.googlepages.com/singleton-considered-stupid" title="Stevey&#39;s Home Page - Singleton Considered Stupid ">Singleton</a>.&#8221; Design patterns are surface forms. Now ask them to explain what problem the pattern solves. They respond, &#8220;Ensuring there is exactly one of something.&#8221; We are still working with the surface form.<br /><br />Ask <em>why</em> we just want just one of something like a database connection pool. What problem are we solving? Why can&#8217;t we use class or static methods to solve this problem? What are the real-world issues with having 1,000 threads sharing a single database connection pool? How would you build ten pools? Or share connections without a single pool?<br /><br /><div class="book"><em></em><hr><em><a name="evtst|a|0884271536" href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0884271536"><img src="http://raganwald.github.com/uploaded_images/critical_chain.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271536" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0884271536" href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0884271536">Critical Chain</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271536" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is an amazing book. The narrative form—a novella detailing a technical project team and their search for a way to manage an uncertain process—is a big win, it highlights the important ways that Critical Chain Project Management handles risks and uncertainty and makes it visible where everyone can manage it.<br><br>The section on estimating tasks alone is priceless. If you can’t afford a copy and your library doesn’t stock it, borrow mine. You <strong>must</strong> read this book if you participate in software development teams.<br></em><hr></div>All of these questions drive at the deeper issues underlying development choices. A developer who treats their work as moving bricks, who simply copies the surface form of code they encounter, is oblivious to the motivations behind the code. They do not know when to use it and when to forgo it. They do not understand alternative ways of solving the same problem. They reproduce it blindly (and often incorrectly).<br /><br />The result is software that superficially appears to be of acceptable quality because its surface form has things in common with good software. However, just because good software may be constructed out of <a href="http://en.wikipedia.org/wiki/Command_pattern" title="Command pattern - Wikipedia, the free encyclopedia">commands</a> and <a href="http://en.wikipedia.org/wiki/Strategy_pattern" title="Strategy pattern - Wikipedia, the free encyclopedia">strategies</a>, this does not mean that software constructed of commands and strategies is good.<br /><br />What is needed on a software development project are people who understand the nuances, the requirements, the underlying problems. If you think that you are building a pyramid, what you want are architects, not slaves.<br /><br />When you add people to a project who do not deeply understand their work or the problems the project faces, you create the superficial appearance of progress (look at all the bricks!), but you are slowly building up a mass of unworkable code. You may not see the problems immediately, but in time you will discover that everything they have touched needs to be re-written.<br /><br /><em>determine the baseline competence required for a project and don&#8217;t violate it</em><br /><br />Once you understand that software is not a simple pile of bricks, you understand that the minimum level of competence required to contribute positively to a project is non-trivial. You can decide for yourself whether you need the mythical great hackers or not. But there is a minimum level of competence, and if you do not allow persons below that level onto your project, you will succeed.<br /><br />If fact, you are far better off with a core of competent people and no sub-competent help than you are with the same group of people and the assistance of &#8220;helpers&#8221; on the side. Those &#8220;helpers&#8221; require three or four times as much management attention as the core contributors if you are to keep them from breaking things. And as we&#8217;ll see below, re-organizing your project such that there are tasks to keep them busy is usually harmful in and of itself.<br /><br />Protecting yourself from people unlikely to make a positive contribution may require adroit maneuvering on your part. On one project, I explained that we could not complete the work in the time requested by the client. The response was to offer us some part-time assistance by employees of the client. Those particular employees may have been talented, but their experience was not a direct fit for the technical work of the project, and they did not have a full-time commitment to the success of the project.<br /><br />Rejecting such &#8220;assistance&#8221; is tricky: other managers may have trouble with the idea that the project will move more slowly with the extra help, rather than move more quickly. Those managers see your project as a pile of bricks, and you&#8217;ll need to educate them if you are to avoid disaster.<br /><br /><strong>software development is difficult to parallelize</strong><br /><br />The metaphor of a pyramid being built, brick by laborious brick is useful for illustrating another principle. When you assume that an application is a pile of a million bricks, you assume that you can move bricks in parallel. You can have one thousand people on the project, and if each places one brick per hour you will move forward at a constant rate of one thousand bricks per hour.<br /><br />Software is not like this. Parallelizing development has serious and sometimes fatal consequences. The main problem is that the pieces are usually coupled in some way. There are techniques for lowering coupling between &#8220;bricks,&#8221; but when you set out to place two related bricks simultaneously, you must, perforce, do some kind of design or thinking ahead of time as to how they relate so that you can place them properly.<br /><br />Consider two pieces, <code>A</code> and <code>B</code>. The natural dependency between them is that <code>B</code> depends on <code>A</code>. The right thing to do is to build <code>A</code>, and then <code>B</code> when you are happy with <code>A</code>. But the zealous manager with bricks on her mind asks, &#8220;why can&#8217;t we decide on an interface, <code>I</code>, between <code>A</code> and <code>B</code>, then build both at once?&#8221; They want to build <code>I</code>, then <code>A</code> and <code>B</code> simultaneously.<br /><br />Of course, this constrains <code>A</code> and <code>B</code> tremendously. As you are building them, any flaw or shortcoming with <code>I</code> you discover as you build the pieces will result in rewriting both <code>A</code> and <code>B</code>. Only you are under time constraints so, you just patch and kludge, because the schedule does not have time allocated for redoing things: your motivation in parallelizing <code>A</code> and <code>B</code> was to save time, so the schedule has no room for the possibility that it will take <em>longer</em> to write <code>A</code> and <code>B</code> in parallel than in series.<br /><br />This makes no sense to the person who thinks software is made of bricks! Looking at the <em>finished</em> brick, what&#8217;s the problem, it takes <code>x</code> hours to make <code>A</code>, <code>y</code> hours to make <code>B</code>, why would making them in parallel take longer than <code>x + y</code> instead of roughly <code>max(x, y)</code>?<br /><br />Try the following: give piece <code>A</code> to one person, wait for it to be done, and then give piece <code>B</code> to another. Whoops, when the person working on <code>B</code> has a question about how <code>A</code> works, they have to track down the author and <a href="http://raganwald.github.com/2007/06/r-e-s-p-e-c-t.html" title="raganwald: R-E-S-P-E-C-T">interrupt</a> her. And if working on <code>B</code> teaches you something about <code>A</code>, is the person working on <code>B</code> supposed to change <code>A</code>? Or is the original developer supposed to backtrack and change it?<br /><br />This explains a well-known nugget of wisdom: One reason adding people to a late project will cause it to slip further is that you are increasing parallelism. If the project was originally at or beyond its natural limit, further parallelism lowers productivity.<br /><br />Or another example. You have 100 reported bugs to fix. You have 100 people. Do you assign one bug to each person? No way! Experience shows that bugs are rarely fully de-coupled form each other. You have to analyze the bugs as a team and try to guess their causes and relationships. If bug forty-nine is a simple text change on a page, anyone can fix it. But if bugs one, four and nine are all related, you need one contributor to address them simultaneously. Sending three people in to fix them in parallel thing would be a disaster.<br /><br />Any time two or more pieces are strongly related either by design or by coupling in the application, it is a mistake to give each one to different people to build or fix.<br /><br />In software, you want to <em>minimize</em> dependencies between pieces, which in turn means being very, very careful to minimize parallelism. Obviously, there must be some parallelism on any project with more than one contributor. But every project has a natural maximum amount of parallelism. Gratuitously chopping tasks into bricks to increase parallelism beyond this natural limit lowers productivity rather than increases it.<br /><br /><em>how to make the team twice as productive without parallelizing everything</em><br /><br />What if you need two pieces, <code>A</code> and <code>B</code>, and you can&#8217;t wait for the normal amount of time to develop <code>A</code> and then <code>B</code>? Here&#8217;s an idea: instead of treating them like bricks and trying to develop <code>A</code> and <code>B</code> in parallel, why not simply hire one person who works twice as quickly? And have them develop <code>A</code> and <code>B</code> in series?<br /><br />Think about this for a moment. There are a lot of claims out there that good people are three, five, ten, even twenty times as productive as the average. This seems intuitively wrong: when you look at their finished work, it rarely looks that much different from the work of the average person. So you figure the claims can&#8217;t be correct.<br /><br />The finished work of the allegedly great person doesn&#8217;t look too outlandish. Ok, it has <code>map</code> and <code>reduce</code> instead of loops, and now that we look at it, the so-called great person seems to deliver fewer bricks, not more. What&#8217;s going on?<br /><br />Let&#8217;s think about bricks for a moment. What if this essay right, and many times building bricks in parallel takes more time than building bricks serially? What if it&#8217;s very hard to co&ouml;rdinate the interfaces and contracts between pieces that are built by different people?<br /><br /><div class="book"><hr><em><br><a name="evtst|a|0201835959" href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201835959"><img src="/uploaded_images/mythical_man_month.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br>Twenty years later, <a name="evtst|a|0201835959" href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201835959">The Mythical Man-Month: Essays on Software Engineering</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is still one of the most important books ever written about developing software, from the small to the large. Read the book that spawned the expression, &ldquo;there is no silver bullet.&rdquo;<br></em><hr></div>If most projects assign related bricks to different people, and most projects further compound this error by trying to &#8220;exploit parallelism,&#8221; you can get a big productivity win just by bucking the popular choice and asking one person to do all of the related work themselves. They&#8217;ll be as productive as a team of other people simply because they aren&#8217;t burdened with the heavy cost of parallelism and from the wrong people working on pieces.<br /><br />Of course, you need someone who is able to keep two pieces in their head at one time. That&#8217;s one of the advantages of hiring good people: they don&#8217;t necessarily need to build things that are twice as complicated: if they can keep twice as much in their head at one time, they can build related things without incurring the costs of splitting development between people.<br /><br /><strong>software is transfinite</strong><br /><br />The other wrong assumption about software being like bricks is that you can measure progress on a software development project by examining physical features of the software, by counting bricks.<br /><br />The underlying thought is that you imagine the finished software as a pyramid of bricks, a pile of them. You count how many bricks will be in the finished application. Now you can measure your progress by counting how many bricks are &#8220;done.&#8221;<br /><br />This is very wrong, and it leads to troubled projects. The first problem with this assumption has been given above: if you need a million bricks for your application, you ought to be able to make use of absolutely anyone to move the project forward in some small capacity. As long as they move a brick an hour, they are helping. So, a brick a day, a million bricks&#8230; let&#8217;s employ 1,000 sweating slaves for ten hours a day for one hundred days and we&#8217;ll have our pyramid. All we need are an architect and a team of overseers with sharp whips to see to it that they work without flagging.<br /><br />But what happens when the millionth brick is placed and we are nowhere near completion? It turns out that software&#8217;s requirements are fluid, so fluid that you could place as many bricks as you like and still not be finished.<br /><br /><blockquote>Measuring software productivity by lines of code is like measuring progress on an airplane by how much it weighs.</blockquote><div style="text-align: right">&mdash;Bill Gates</div><br /><br />In fact, moving a lot of bricks is counterproductive: the physical manifestation of software, like written code, design specifications, unit tests, and so forth, have <em>mass</em> just like bricks. And if you want to redo things, the more mass you have, the harder it is to move and reshape it. In that sense, software is exactly like bricks.<br /><br />Only, what you want to is to move the <em>minimum</em> number of bricks required to test your assumptions about whether the software is complete enough. It will never be complete, but trying to measure completeness by bricks is wrong.<br /><br />There are only two meaningful ways to measure progress on a software development project: the first is to ask the team to estimate how much work remains, given the most up-to-date expectation for the form of the finished application. The second is to measure customer satisfaction.<br /><br /><em>how to measure progress on software development projects with estimated work remaining</em><br /><br />Given the most current understanding of what is to be done to complete the application, it is meaningful to ask the team to estimate how much time will be required to complete the work.<br /><br />This sounds conservative, even traditional. Doesn&#8217;t every project do this when they prepare the plan? What&#8217;s the catch? The catch is, if you only do it once, you only know your progress once. This differs markedly from the traditional model, where you plan once, estimate once, and thereafter you measure progress against your plan, rather than estimating again.<br /><br /><blockquote>As the project progresses, the client&#8217;s requirements change. This is especially true if the client is given the opportunity to interact with the team and engage in the learning process: Agile&#8217;s claim that requirements are subject to change is a self-fulfilling prophesy.</blockquote><br /><br />To measure meaningful progress, you must re-estimate on a regular basis. If you wish to give a meaningful progress report every two weeks, you must ask the team to estimate the work remaining every two weeks. if, instead, you simply take how many bricks you thought you needed a few months ago, count how many have been moved to date, and calculate the work remaining through simple subtraction, your reports are drifting further and further away from reality every fortnight.<br /><br />We know that this does not work, both from experience in the field and from critical thinking: as the project progresses, the client&#8217;s requirements change. This is especially true if the client is given the opportunity to interact with the team and engage in the learning process: Agile&#8217;s claim that requirements are subject to change is a self-fulfilling prophesy.<br /><br />We also know that as we work with the software itself, we learn more about how much work is required to complete the software. For example, if you load a project&#8217;s team up with in appropriate contributors, maximize parallelism, and perhaps go three for three by minimizing testing and bug fixing, you will compound a tremendous &#8220;technical debt&#8221; over time.<br /><br />Measuring &#8220;progress&#8221; against the original plan does not include the technical debt in your estimate of the work to be completed. Asking the team to estimate the amount of work to be done gives them an opportunity to factor the consequences of technical debt into their estimates. Or of any other factor that reflects what the team is learning over time.<br /><br />In essence, you have an opportunity to include <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html" title="raganwald: Still failing, still learning">off-balance sheet items</a> in your measurement of progress, whereas measuring against bricks would have excluded those factors.<br /><br /><em>how to measure progress on software development projects with customer satisfaction</em><br /><br />Measuring customer satisfaction is easy. All you have to do is ask the customer. A successful project increases satisfaction over time. An unsuccessful project does not. I boldly posit that any project that increases customer satisfaction over time is a successful project, regardless of what was originally written in a specification.<br /><br /><blockquote>There is no simpler or surer way to increase customer satisfaction over the long term than to let them experience the application as it grows and to rate your progress by how much their satisfaction increases with the software itself.</blockquote><br />Customer satisfaction is a key metric because software is not a pile of bricks. It is impossible to predict with certainty the set of requirements that will result in maximum customer satisfaction at the end of the project, so you must measure satisfaction as you go. That being said, there is a pitfall looming when you ask the customer to judge their own satisfaction.<br /><br />Some customers have difficulty understanding the features and characteristics of software that will meet their needs in a cost-effective way. They have trouble distinguishing good software from bad, good applications from lemons.<br /><br />Although such a customer may need a <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title="raganwald: The Not So Big Software Design">not-so-big application</a>, they may demand an <a href="http://raganwald.github.com/2007/08/people-you-have-to-please-in-enterprise.html" title="raganwald: The people you have to please in the enterprise market are the ones purchasing and supporting the products, not the poor schmucks who use them">Enterprise Solution</a>.<br /><br />This manifests itself in the customer demanding proof of progress in the form of elaborate documents, plans, and diagrams instead of working software that solves a portion of their problem. It manifests in the customer demanding proof that you&#8217;ve &#8220;hired up&#8221; to meet their needs. Although these things have their place, none of them are working software. They are promises to develop software, and <a href="http://en.wikipedia.org/wiki/Subprime_mortgage" title="Subprime lending - Wikipedia, the free encyclopedia">subprime</a> promises at that.<br /><br /><div class="book"><a name="evtst|a|0192801422" href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0192801422"><img src="http://raganwald.github.com/uploaded_images/to_mock_a_mockingbird-785706" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0192801422" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br>Life is not all project management and wrestling with customers. <a name="evtst|a|0192801422" href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0192801422" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the most enjoyable text on the subject of combinatory logic ever written. What other textbook features starlings, kestrels, and other songbirds? Relax with a copy and let your mind process the business side of development in the background. You&rsquo;ll be a better manager for it!<br></div>It is easy to obtain short-term success with such a client: deliver what they ask for. This is the exact business model followed by real estate developers specializing in inexperienced, first-time buyers: offer the superficial features that provide short-term excitement at the expense of long-term satisfaction. In the case of software, you can dazzle the inexperienced customer with head counts, power points, and diagrams showing Jenga-piles of technology.<br /><br />Should you do this? That is up to you, it depends on whether you wish to build short-term customer satisfaction at the expense of long-term satisfaction with the software itself. If you wish to deliver long-term satisfaction with the software, you may need to educate the customer to focus on the software itself.<br /><br />And that means delivering increments of a functioning application for the client to experience. There is no simpler or surer way to increase customer satisfaction over the long term than to let them experience the application as it grows and to rate your progress by how much their satisfaction increases <em>with the software itself</em>.<br /><br /><strong>building software without treating it like a pile of bricks</strong><br /><br />Sometimes, it really does boil down to a few simple ideas, working in concert:<br /><br /><ol><li>Hire people with a minimal competency. Do not be seduced into accepting &#8220;help&#8221; from people who are not able to contribute to the team at this level.</li><br /><li>Minimize parallelism. Exploit the talent of your best developers by giving them chunks of related work.</li><br /><li>Measure progress by continually re-estimating the work to be done and by customer satisfaction. Educate the customer to prefer completed work over documentation and promises.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/08/bricks.html" title="permanent link">11:56 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, July 31, 2007</div>
			

			<div class="Post"><a name="7934863193248007983">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/07/abbreviation-accidental-complexity-and.html" title="permanent link">Abbreviation, Accidental Complexity, and Abstraction</a></span>
					<div style="clear:both;"></div>Modern programming languages provide a variety of mechanisms for translating a relatively short program into a huge number of instructions for the computer&#8217;s CPU. It is tempting to think that the purpose of &#8220;high level languages&#8221; like Java, C#, Smalltalk, Ruby, or even Lisp is to be a kind of decompression algorithm: you type 147 lines of code, and the compiler elaborates each line of code, producing several megabytes of executable.<br /><br />If it were as simple as that, we would say that the &#8220;highest level language&#8221; is the one that allows us to express our programs in the smallest source code, perhaps in fewer symbols or lines of code. For example, we would say that <a href="http://montreal.pm.org/tech/neil_kandalgaonkar.shtml" title="Perl tricks by Neil Kandalgaonkar"><code>(1 x shift) !~ /^1?$|^(11+?)\1+$/'</code></a> is superior to:<br /><br /><pre><code>function (x) {<br />        y = Math.floor(Math.sqrt(x));<br />        var a = new Array();<br /><br />        a.push(2);<br />        for (i = 3; i &lt;= x; i+=2) {<br />                a.push(i)<br />        }<br />        a.reverse();<br />        var primes = new Array();<br />        while ((current_prime = a.pop()) &lt; y) {<br />                primes.push(current_prime);<br />                for (index in a) {<br />                        if (a[index] % current_prime == 0) {<br />                                a.splice(index,1);<br />                        }<br />                }<br />        }<br />        return a[0] == x;<br />}<br /></code></pre><br />Strictly because it is smaller by all obvious metrics (<a href="http://badcomputer.org/unix/code/eratos/javascript1.bot" title="sieve of Eratosthenes | code | unix stuff | badcomputer">source</a>).<sup><font size='-1'>1</font></sup><br /><br /><div class="book"><hr/><em><br /><a href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201835959"><img border="0" src="/uploaded_images/mythical_man_month.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />Twenty years later, <a href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201835959">The Mythical Man-Month: Essays on Software Engineering</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is still one of the most important books ever written about developing software, from the small to the large. It&#8217;s time to read the book that spawned the expression, &#8220;there is no silver bullet.&#8221;<br /></em><hr/></div>This explanation is clearly wrong. Even if both examples produced exactly the same result, the former is almost impossible to use by mortals: its form obfuscates its output. Clearly, writing the smallest possible program is not the goal.<br /><br />Writing smaller programs is also not an anti-goal: longer programs are not automatically &#8220;easier to read and understand.&#8221; One of the problems with longer programs is that they often are longer by virtue of containing <a href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201835959" title="The Mythical Man-Month: Essays on Software Engineering, 20th  Anniversary Edition">accidental complexity</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, swathes of <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html" title="Economizing can be penny-wise and pound foolish">yellow code</a>.<br /><br /><strong>abbreviations</strong><br /><br />Some shorter programs are shorter merely because they contain shorter constructs. For example, if you perform some regular expression pattern matching in Ruby, you can use <code>/</code> characters to delimit your regular expression. That&#8217;s an abbreviation for the more tedious <code>Regexp.new()</code>. And there are some global variables that are automatically set for you. For example, <code>$1</code>, <code>$2</code> and so on are set to the matching groups.<br /><br />So if you write <code>/(fu|foo)(bar|blitz)/ =~ 'my program went fubar'</code>, <code>$1</code> is automatically assigned the string <code>'fu'</code> and <code>$2</code> is assigned the string <code>'bar'</code>.<br /><br />Compare and contrast this to: <code>my_matcher = Regexp.new('(fu|foo)(bar|blitz)').match('my program went fubar')</code>. Now you can use <code>my_matcher[1]</code> and <code>my_matcher[2]</code> to extract <code>'fu'</code> and <code>'bar'</code>.<br /><br />Obviously, the former expression is shorter, and quite handy. And while it may look a little cryptic to someone raised on Java&#8217;s one-size-fits-all syntax of everything is a .message, it really isn&#8217;t an obfuscation. It&#8217;s an abbreviation, nothing more. It makes programs shorter without changing their meaning in any substantial way.<br /><br /><strong>accidental complexity</strong><br /><br />We mentioned earlier that longer programs are sometimes longer by virtue of containing accidental complexity. There&#8217;s a good point of comparison. If a shorter program is shorter by virtue of having less accidental complexity, it&#8217;s better. <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html" title="raganwald: Finding the Signal-to-Noise Ratio in the Never-Ending Language Debate">It has a higher ratio of signal to noise</a>.<br /><br />For example, here is one of the new <code>for</code> loops in Java:<br /><br /><pre><code>for (Account account: customer.getAccountList()) {<br />    // do something<br />}<br /></code></pre><br />This is shorter than:<br /><br /><pre><code>Iterator iAccount = customer.getAccountList().iterator();<br />while (iAccount.hasNext()) {<br />    final Account account = (Account) iAccount.next();<br />    // do somethinmg<br />}<br /></code></pre><br />It also removes some of the accidental complexity of the iterator. The new <code>for</code> loop removes some accidental complexity, raising the signal by eliminating noise. To continue with the same example, let&#8217;s look at an old <code>for</code> loop:<br /><br /><pre><code>for (int i = 0, i &lt; customer.getAccountList().size(); ++i) {<br />    final Account account = customer.getAccountList().get(i);<br />    // do something<br />}<br /></code></pre><br />This has even more accidental complexity, a loop index variable. Eliminating the loop index is a decent win, it eliminates fence post errors. But there is a bigger win in moving from an index-based loop to an iterator based loop or a new for loop: we have abstracted away the notion that the collection must be indexed by consecutive integers.<br /><br /><strong>abstractions</strong><br /><br />The iterator (and the new <code>for</code> loops) work with all kinds of collections, including linked lists and sets. Moving from a loop index variable to an iterator does more than just abbreviate the code, it does more than hide some accidental complexity, it provides a general-purpose abstraction for operations on collections.<br /><br /><div class="book"><hr/><em><br /><a href="http://www.amazon.com/gp/product/0596510047?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596510047"><img border="0" src="/uploaded_images/beautiful_code.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0596510047" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />How do the experts solve difficult problems in software development? In <a href="http://www.amazon.com/gp/product/0596510047?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596510047">Beautiful Code</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0596510047" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, leading computer scientists offer case studies that reveal how they found unusual, carefully designed solutions to high-profile projects. You will be able to look over the shoulder of major coding and design experts to see problems through their eyes.<br /><br />This is not simply another design patterns book, or another software engineering treatise on the right and wrong way to do things. The authors think aloud as they work through their project&#8217;s architecture, the tradeoffs made in its construction, and when it was important to break rules. Beautiful Code is an opportunity for master coders to tell their story.<br /></em><hr/></div>So here is another point of comparison: does the shorter program provide us with a useful <em>abstraction</em>? Some programs are shorter through mere abbreviation, some are shorter through hiding accidental complexity, and some are shorter by providing useful abstractions.<br /><br />The difference between a new <code>for</code> loop and an index variable <code>for</code> loop may seem subtle. So let&#8217;s bring out a canonical example, one we touched on earlier: regular expressions. Can anyone seriously doubt that <code>/(fu|foo)(bar|blitz)/</code> provides a powerful abstraction compared to a stack of loops and <code>indexOf</code> method calls?<br /><br />There is more than abbreviation involved, more than hiding the accidental complexity of <code>indexOf</code>, there is a whole new mental model involved. A regular expression is <em>declarative</em>, it specifies what you what to find, and leaves the how to the language implementation. It is shorter, yes. But it is also much more powerful because it provides the programmer with a huge mental lever.<br /><br />Active Record provides a very useful abbreviation that eliminates a large chunk of accidental complexity, <a href="http://blog.hasmanythrough.com/2006/8/13/how-dynamic-finders-work" title="has_many :through: How dynamic finders work">dynamic finders</a>. You can write <code>User.find_all_by_street_and_city(street, cities)</code>. I won&#8217;t say what it returns, I trust it&#8217;s obvious.<br /><br />You could easily write a <code>find_all_by_street_and_city</code> method in any language you care to name. Agreed. But if you write one yourself, you have to write one for ever different kind of query you need to make. And if you write it, you trust it.<br /><br />But if you are maintaining someone else&#8217;s code, do you <em>really</em> trust it without reading it? Or do you have a peek to see whether there&#8217;s some weird business logic in there, like some special case treating the abbreviation &#8220;Hogtown&#8221; as a substitute for &#8220;Toronto&#8221;? Repeat this process for each search abbreviation method in the code base. What if one has a bug? Or another has a specific eager loading behaviour?<br /><br />If you are using an ORM like ActiveRecord, once you&#8217;ve learned how dynamic finders work, you know how they all work. Furthermore, you have an abstraction you understand, you don&#8217;t have to peek under the hood to see what&#8217;s going on. Abstractions are better than abbreviations.<br /><br /><strong>abstractions are not abbreviations</strong><br /><br />Abbreviations are useful. They can make code more readable by putting the all of the essential workings in one visible chunk. But they aren&#8217;t as powerful as constructs that remove accidental complexity or provide abstractions.<br /><br />And some times, abbreviations are even harmful. If the programmer reading code must understand what is being abbreviated in order to understand the code, then the abbreviation merely forces the programmer to jump around the code to figure anything out. When programs are written like this as a matter of course, the poor programmer is forced to rely on powerful IDEs that can jump to method definitions or find references quickly. She has to have these tools, because she must read <em>all</em> of the code to understand what it does.<br /><br />The abbreviations have introduced complexity, not removed it.<br /><br />Where do such programs come from, programs where the abbreviations are not useful abstractions? From those same IDEs, of course, from mindlessly refactoring to eliminate duplicate code without stopping to <em>design</em> the program&#8217;s mental model.<br /><br />This is not a knock against powerful IDEs, far from it. But we should realize that all the same arguments raised about powerful programming languages (&#8220;operator overloading is dangerous in the hands of mediocre programmers,&#8221; &#8220;macros enable people to write unreadable programs,&#8221; and so forth) apply to tools that shuffle code around, especially when the same tools seem to make it easy to navigate the shuffled program.<br /><br />When composing our own programs, when using these tools, it is not enough to merely seek to eliminate duplication. We must be mindful of the distinction between abbreviation, removing accidental complexity, and introducing useful abstractions.<br /><br />It is not wrong to eliminate redundancy in code. But when we do so, we mustn&rsquo;t follow the path of least resistance and mindlessly perform the refactorings suggested by our tools. This argument exactly parallels the argument about making code shorter for its own sake. Code brevity in and of itself is not desirable, well-abstracted code with a minimum of accidental complexity is desirable, and brevity follows when these goals are attained.<br /><br />Likewise, elimination of redundancy is not desirable in and of itself. But it serves to warn us of the need to seek useful abstractions and to remove accidental complexity. When we work with those goals in mind, the redundancy likewise melts away, and we are able to use the tools to improve our code.<sup><font size="-1">2</font></sup><br /><br />Abbreviations might be good.<br />Removing Accidental Complexity is better.<br />And providing Useful Abstractions is best of all.<br /><br /><hr/><br /><ol><li>And there's another difference: is 121 a prime number?</li><li>Thanks, <a href="http://programming.reddit.com/user/jbstjohn">jbstjohn</a>!</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/07/abbreviation-accidental-complexity-and.html" title="permanent link">10:19 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, July 16, 2007</div>
			

			<div class="Post"><a name="4267051248388428321">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/07/javascript-on-jvm-in-fifteen-minutes.html" title="permanent link">How to Run Javascript on the JVM in Just Fifteen Minutes</a></span>
					<div style="clear:both;"></div><strong>what and why</strong><br /><br />This post is about executing Javascript inside the JVM without using a browser. Besides the fact that people are talking about <a href="http://steve-yegge.blogspot.com/2007/06/rhino-on-rails.html" title="Stevey's Blog Rants: Rhino on Rails">running Javascript on the server</a> (<a href="http://helma.org/" title="Helma - Javascript Web Application Framework">again</a>, and <a href="http://peter.michaux.ca/article/3001" title="Server-Side JavaScript with Rhino and Jetty">again</a>), here&#8217;s why my colleagues and I used it on a recent project:<br /><br />We have some logic that needs to run on the server and on the client, depending on when the application applies it. There is like an incredibly complex form validation involed. Think of a loan application, for example. Zillions of rules like &#8220;at least five years at current location <em>or</em> at most three locations in ten years <em>or</em> owns current location for at least one year.&#8221; The whole thing forms a big logical expression that needs to be evaluated in such a way that we can report which pieces are missing or do not meet requirements (<em>Declined because income is insufficient and does not state purpose of loan</em>).<br /><br />There are a couple of ways to handle this. One is to submit the form back to the server for validation. Another is to write everything in Java, but use <a href="http://code.google.com/webtoolkit/" title="Google Web Toolkit">a sophisticated tool to render the Java into Javascript</a>. Naturally, our team chose a third option, The Rails Way (available for <a href="http://www.amazon.com/gp/product/0321445619?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321445619" title="The Rails Way (Addison-Wesley Professional Ruby Series)">pre-order</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0321445619" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />).<br /><br />We have a Domain-Specific Language for describing the rules. Business users use the DSL, and another tool writes code from that. We could, in theory, write Java methods for the server <em>and</em> write Javascript for the client. We chose to start with Javascript, and we&#8217;ll write Java for the server if running Javascript on the server turns out to be <strike>unperformant</strike> slow.<br /><br />In the mean time, we decided that having some Java make a simple function call to a Javascript function and process a simple result was a reasonable first step. As a side benefit, we run all our server-side Javascript unit tests in Java test suites alongside our Java unit tests.<br /><br />And after some fiddling around, we got Javascript working on the JVM. My bet is that you can get it working too, and it won&#8217;t take more than fifteen minutes.<br /><br />Care to try it?<br /><br /><strong>step zero: the Java Virtual Machine (JVM)</strong><br /><br />You&#8217;ll need JDK 1.5 or 1.6 from Sun. If you already have this, move on to step one. Still reading? You&#8217;ll need to do a big install before we go further.<br /><br />Go to the <a href="http://java.sun.com/javase/downloads/index.jsp" title="Java SE Downloads">downloads page</a> and download the latest thing they have on offer with the words &#8220;JDK&#8221; in it. You won&#8217;t need JEE (the framework formerly known as J2EE) for this exercise, but if you know what it is you know enough to decide whether to download it.<br /><br />Right now, you want <strong>JDK 6u2</strong>. Go get it and suffer through the installation process.<br /><br /><strong>Step one: Bean Scripting Framework</strong><br /><br />Java6 has a new framework for running &#8220;scripting&#8221; languages, and it&#8217;s built into Java6. We&#8217;re not going to use it today, just because some of you may still need to make stuff work with JDK 1.5 in production. Instead, we&#8217;re going to go get the Jakarta Bean Scripting Framework (BSF). <a href="http://jakarta.apache.org/bsf/" title="Jakarta BSF - Bean Scripting Framework">You can download it here</a>. We&#8217;ll need <code>bsf.jar</code>.<br /><br /><strong>step two: fix gotchas</strong><br /><br />YMMV, but I found that I couldn&#8217;t get BSF working without including the <a href="http://jakarta.apache.org/commons/logging/" title="Commons - Logging">Jakarta Commons-Logging</a> jar. So if you don&#8217;t have this floating around, go <a href="http://jakarta.apache.org/site/downloads/downloads_commons-logging.cgi" title="The Jakarta Site - Commons Logging Downloads">here</a> and download it. I experimented, and I could ignore everything except <code>commons-logging-1.1.jar</code>. If that was missing, BSF kakked.<br /><br /><strong>step three: Rhino</strong><br /><br />Since we&#8217;re going to run Javascript, we need an interpreter. <a href="http://www.mozilla.org/rhino/" title="Rhino - JavaScript for Java">Rhino</a> to the rescue. <a href="http://www.mozilla.org/rhino/download.html" title="Rhino Downloads">Download it</a>. We&#8217;ll need <code>js.jar</code>.<br /><br /><strong>step four: keeping things organized</strong><br /><br />Ready to code? Let&#8217;s start with a directory for all of our stuff. Call it <code>hello_javascript</code>. For the sake of keeping thing simple, set up the sub-structure as follows:<br /><br /><code>hello_javascript</code><br /><code>hello_javascript\lib</code><br /><br />You may be using a fancy IDE, you may be using a text editor and have to graft your classpaths together with chicken wire. The important thing is that your classpath, besides including all of Java&#8217;s required stuff, and your own Java classes, also includes <code>bsf.jar</code>, <code>commons-logging-1.1.jar</code> and <code>js.jar</code>.<br /><br />We&#8217;ll put all three in the <code>lib</code> subdirectory:<br /><br /><code>hello_javascript\lib\bsf.jar</code><br /><code>hello_javascript\lib\commons-logging-1.1.jar</code><br /><code>hello_javascript\lib\js.jar</code><br /><br /><strong>step five: &#8220;Hello, Javascript&#8221;</strong><br /><br />Let&#8217;s write some Java: create the following subdirectories and put a file called <code>HelloJavascript.java</code> in it:<br /><br /><code>hello_javascript\com\raganwald\public\HelloJavascript.java</code><br /><br />Let&#8217;s give it some code:<br /><br /><pre><code>package com.raganwald.public;<br /><br />import org.apache.bsf.BSFManager;<br /><br />public class HelloJavascript {<br />    public static void main (final String[] argv) {<br />        final BSFManager manager = new BSFManager();<br />        final Object jso = manager.eval("javascript", "(java)", 1, 1, "'hello, Javascript'");<br />        System.out.println(jso.toString());<br />    }<br />}<br /></code></pre><br /><br />Run your new Java application. Did you see that? It interpreted some Javascript <em>in the JVM without a browser</em>. Check your watch. Did you need more than a quarter of an hour? I didn&#8217;t think so.<br /><br />You can try more ambitious code:<br /><br /><pre><code> manager.eval(<br />    "javascript", "(java)", 1, 1, <br />    "var f = function (what) { return 'hello, ' + what; }; f('Javascript);");<br /></code></pre><br /><br /><strong>including other files is an exercise left for the reader</strong><br /><br />I didn&#8217;t find an easy way to get Javascript files to include other Javascript files. This isn&#8217;t the worst thing in the world, but you certainly don&#8217;t want to write anything substantial inside of Java strings. So try experimenting with reading javascript files right off the classpath.<br /><br />I created a subdirectory called <code>javascript</code>:<br /><br /><code>hello_javascript\javascript</code>  <br /><br />And you can read Javascript into your strings or Stringbuffers with some fairly simple code, thanks to a utility built into BSF:<br /><br /><pre><code>import org.apache.bsf.util.IOUtils;<br /><br />// ...<br /><br />static String readScript(final String fileName) throws Exception {<br />    final FileReader in = new FileReader(fileName);<br />    return IOUtils.getStringFromReader(in);<br />}<br /></code></pre><br /><br />That reads some script into a string. You can then prepend it to whatever you want to evaluate. Note that if you want to set up some sort of simple checking to make sure that you don&#8217;t &#8220;include&#8221; the same file twice, you will need to write yourself a little framework for that, perhaps using a <code>Set</code> to keep track of what you&#8217;ve already loaded.<br /><br /><strong>garbage in, garbage out</strong><br /><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/1933988037?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1933988037"><img border="0" src="/uploaded_images/prototype_and_scriptaculous_in_action.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1933988037" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.prototypejs.org/">Prototype</a> and <a href="http://script.aculo.us/">Scriptaculous</a> are the Javascript libraries that make slick transitions and UI effects easy one-liners. Prototype does more than just make an application look good: it adds Ruby and Smalltalk-like methods for handling Hashes, Arrays, and the DOM.<br /><br />This book is one of the fastest ways to get up to speed on taking Javascript to the next level.<br /></em><hr/></div>This is nice, and with a little work you could make a program that reads paths to Javascript files off the commend line and executes them. But to make things really interesting, you want to find a way to get Java data into your JavaScript and do something useful with the results, not just print it as a String.<br /><br />BSF provides a way to inject objects into the scripting language&#8217;s environment, so you could use that facility. When writing automated unit tests for that particular project, I chose a simpler route: I serialized the data into JSON and used that to call a Javascript function directly via BSF:<br /><br /><pre><code>manager.eval("javascript", "(java)", 1, 1, <br />    "myJavascriptFunction(" + myJSONString + ");");<br /></code></pre><br /><br />This is a <em>really bad idea</em> if your JSON is handed you from an insecure source, such as a public web page calling you back via <code>XMLHttpRequest</code>, but if you trust your source, this works wonderfully.<br /><br />Now what do you do with the result? If you are generating something esoteric like a Javascript function, I have no idea. In my own case, I return all values as simple trees of Hashes (Javascript objects without any special methods) and Arrays. I convert those into Java trees of Maps and Arrays:<br /><br /><pre><code>import org.mozilla.javascript.NativeArray;<br />import org.mozilla.javascript.ScriptableObject;<br /><br />import java.util.ArrayList;<br />import java.util.Arrays;<br />import java.util.HashMap;<br />import java.util.List;<br />import java.util.Map;<br /><br />// ...<br /><br />static List unwrapNativeArray (final NativeArray na) {<br />    return new ArrayList&lt;Object&gt; () {{<br />        for (int i = 0; i &lt; na.getLength(); ++i) {<br />            add(unwrapNative(na.get(i, null)));<br />        }<br />    }};<br />}<br /><br />static List unwrapPrototypeArray (final ScriptableObject sObj) {<br />    return new ArrayList&lt;Object&gt; () {{<br />        final List&lt;Object&gt; sObjIds = Arrays.asList(sObj.getAllIds());<br />        for (int i = 0; sObjIds.contains(i); ++i) {<br />            add(unwrapNative(sObj.get(i, null)));<br />        }<br />    }};<br />}<br /><br />static Map unwrapObject (final ScriptableObject sObj) {<br />    return new HashMap&lt;String, Object&gt; () {{<br />        for (Object id: sObj.getAllIds()) {<br />            put(id.toString(), unwrapNative(sObj.get(id.toString(), null)));<br />        }<br />    }};<br />}<br /><br />static Object unwrapNative (final Object obj) {<br />    if (obj instanceof NativeArray) {<br />        return unwrapNativeArray((NativeArray) obj);<br />    }<br />    else if (obj instanceof ScriptableObject) {<br />        final ScriptableObject sObj = (ScriptableObject) obj;<br />        final List&lt;Object&gt; sObjIds = Arrays.asList(sObj.getAllIds());<br />        if (sObjIds.contains("keys")) { // a prototype enumerable/hash<br />            return unwrapObject(sObj);<br />        }<br />        else if (sObjIds.contains("flatten")) { // a prototype enumerable/array<br />            return unwrapPrototypeArray(sObj);<br />        }<br />        else return unwrapObject(sObj);<br />    }<br />    else return obj;<br />}<br /></code></pre><br />Check your watch. Are you still under fifteen minutes? Great!<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/07/javascript-on-jvm-in-fifteen-minutes.html" title="permanent link">4:58 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, July 04, 2007</div>
			

			<div class="Post"><a name="7513586702604711513">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/07/certification-bring-it-on.html" title="permanent link">Certification? Bring It On!</a></span>
					<div style="clear:both;"></div>Not too far in the distant past, I was persuaded to give my r&eacute;sum&eacute; to a recruiter. He was trying to place a development manager for a growing company, and they wanted heavy Agile experience, deep management experience, and someone with some technical chops. Well, I figured that twenty-plus year of experience, with something like eight years of legitimate Agile, leading a team of twenty-plus, producing a product that won several Jolt awards and a JDJ Editor&#8217;s Choice award&#8230; I thought I was a lock for an interview.<br /><br />But an email came right back: <em>The client is wondering where you got your degree</em>. Twenty years of experience, and they want to know how I spent my time in the mid-eighties.<br /><br />This got me thinking about certification. It&#8217;s another long-running debate. And something funny has happened to me. <em>I&#8217;ve switched sides</em>. I&#8217;m actually in favour of certifying software developers. Yes, I am in favour of disqualifying intelligent programmers from professional employment if they do not possess a little piece of paper from a certifying agency.<br /><br />Deep breath. Wait for the room to stop spinning. Or is my head spinning around on my shoulders (<a href="http://www.amazon.com/gp/product/B0000524CY?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B0000524CY">heh</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=B0000524CY" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />)?<br /><br /><strong>the catch</strong><br /><br />Like everyone else in favour of certification, I have my own ides about what skills and knowledge you need to demonstrate to get your certification. Unlike everyone else, I think I would fail my own certification if I didn&#8217;t do a whole lot of studying. That&#8217;s because I think our industry is undemanding, very undemanding. I know a few people who would pass my certification without studying. But only a few.<br /><br />Before I tell you what&#8217;s on the final examination, let&#8217;s talk about what <em>isn&#8217;t</em>:<br /><br /><ul><li><strong>Object oriented programming</strong>: <em>not</em> on the exam. Use OO on a project, don&#8217;t use OO on a project, I don&#8217;t care. Throw in dependency injection, MVC, everything to do with industry standard architecture. I still don&#8217;t care, you can get certified without it.</li><br /><li><strong>Functional programming, metaprogramming, macros</strong>: <em>not</em> on the exam. Be an <a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">academic</a>, be a <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html">language weenie</a>. Or not. I don&#8217;t care.</li><br /><li><strong>Static typing, type inference, annotations, category theory</strong>: <em>not</em> on the exam. Save it for your <a href="http://raganwald.github.com/2006/03/fair-and-balanced-look-at-static-vs.html">blog post</a>, I don&#8217;t care.</li><br /><li><strong>Knowing who Alan Kay, John McCarthy, or Ted Nelson are</strong>: <em>not</em> on the exam. I think it&#8217;s great to know the history of our industry, but I don&#8217;t care.</li><br /><li><strong><a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201633612">Design Patterns</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0201633612" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></strong>: See OO above. I really don&#8217;t care. Write spaghetti code. Be <a href="http://www.pbm.com/~lindahl/mel.html">Mel</a>. I don&#8217;t care.</li><br /><li><strong>Agile Development, Waterfall, GTD, or anything else to do with Getting Things Done</strong>: I really don&#8217;t care. I will certify you <a href="http://raganwald.github.com/2007/06/my-working-day.html">whether you can execute or not.</a></li><br /><li><strong>Deep knowledge of programming language syntax or semantics</strong>: I&#8217;ll certify PHP programmers. I&#8217;ll certify Java programmers that don&#8217;t understand generics. I don&#8217;t care if you know what a <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">closure</a> is. I don&#8217;t care if you believe that recursion is retrograde.</li></ul><br />By now, you are thinking, &#8220;Raganwald, this certification is worthless. You are excluding just about everything we know about writing great software. What&#8217;s the point?&#8221;<br /><br />Let me explain. My certification does not say you are any good at coding software. Let me repeat. <strong>My certification does not say that you are any good at coding software</strong>. I&#8217;ll let the marketplace decide. I am not telling businesses, &#8220;Hire certified programmers, they are great coders.&#8221; <br /><br />Why should I? Business is perfectly happy to hire programmers with Comp. Sci. degrees, and there seems to be little or no evidence that a Comp. Sci. degree says anything about your ability do deliver working software. So why should my certification raise that bar?<br /><br /><strong>what&#8217;s on the exam</strong><br /><br />Now let&#8217;s talk about what <em>is</em> on the exam. Just one subject, but the exam goes into excruciating detail about that subject. If you don&#8217;t know this subject cold, I am <em>not</em> going to certify you. Period. No debate, no negotiation, no &#8220;equivalent experience.&#8221;<br /><br />The one subject? <em>Testing and Quality Control</em>. That&#8217;s right. All I care about is that if you are asked to make bulletproof software, you know how. I&#8217;m going to ask you about:<br /><br /><ul><li>Continuous integration.</li><br /><li>Black box testing.</li><br /><li>White box testing.</li><br /><li>Design for testing.</li><br /><li>Probabilistic testing.</li><br /><li>Testing tools.</li><br /><li>Testing metrics.</li><br /><li>Testing methodologies.</li></ul><br />And more:<br /><br /><ul><li>Security concepts.</li><br /><li>Preventing vulnerabilities.</li><br /><li>Privacy and data management concepts.</li><br /><li>Encryption and verification concepts.</li></ul><br />And a whole lot more on top of that. There is room for debate about whether to have separate testers or whether programmers should test themselves. You are not getting certified with me unless you know how to do it both ways, and can write a comprehensible essay describing the relative advantages and disadvantages of both. I am not going to require you to know the latest programming frameworks, but you are not getting certified unless you demonstrate up-to-date knowledge of the latest continuous integration tools.<br /><br /><div class="book"><em><hr/><a href="http://www.amazon.com/gp/product/0321146530?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321146530"><img border="0" src="/uploaded_images/test_driven_development.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321146530" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0321146530?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321146530">Test Driven Development: By Example</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321146530" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is THE book that ignited a revolution in software development practices. Whether you are developing in an Agile environment or working from a telephone book specification in a Waterfall project, Test-Driven Development will show you how to write automated tests that work to actually shorten your development time and clarify your code.<br /><br />And best of all, this book uses actual projects as an example. This is not an exercise in theory, this is a practical tome full of practical advice. You&rsquo;re already familiar with the concepts, reading this book will dive into the details that will make your coding more effective.<br /><hr/></em></div>I don&#8217;t care if you know how to write a great architecture document. But I will fail you if you can&#8217;t write a good code review. The same goes for everything else. I will not demand that you do it a specific way, but you will prove that you have state-of-the art knowledge of how to ensure that software is solid and does what you expect it to do, no more, no less.<br /><br />And you know what? After you get your piece of paper, you&#8217;ll need to work for at least a year under the supervision of a certified leader to get your upgraded &#8220;practitioner&#8221; certification. I want you to practise continuous education.<br /><br />Does this mean that I am going to certify all of the QA Analysts in the industry while barring the programmers from work? Well, let me ask you: do most, a few, or any of the QA Analysts you know have a deep knowledge of software quality and methodologies? Can they write an essay describing the cost of bug fixing comparing early vs. late detection? Can they talk about various unit testing tools? Can they measure code coverage? Can they look at a piece of code with 93% coverage and tell whether the missing 7% has one or more crucial cases missing?<br /><br />If so, I want to certify them. If not, they need to hit the books with me.<br /><br /><strong>where did I get this crazy idea?</strong><br /><br />In our industry we have wasted millions of person-years debating the relationship between software development and architecture/engineering. Last weekend I went to see Pixar&#8217;s Ratatouille with my son. And it struck me: we should be like chefs.<br /><br />Do I demand that the chef in a restaurant use a certain kind of stove? Cook a certain kind of food? Manage her kitchen a certain way? <span style="font-style:italic;">Non!</span> The marketplace decides all these things. And the marketplace works for this. What do we demand? What do we <em>require</em> of restaurants?<br /><br /><span style="font-weight:bold;">Safety</span>. We demand that if they serve the public, that they have certain fire safety standards. That they have certain food cleanliness standards. That they know enough about food not to poison us by accident. Of course, a cook learns to cook when getting their designation. But the thing we really <em>demand</em> of them is that they keep us safe!<br /><br />If we order Chicken, we do not want the Fish to come out and put us into Anaphylactic Shock. Cooks know that mixing up Chicken and Fish is fatal, while mixing up Basil and Oregano is not. So they have a different protocol for handing the two kinds of food. They keep us safe. <br /><br />And if I am placed in charge of certification one day, that&#8217;s what I will demand. <em>Keep us safe</em>. Don&#8217;t leave <a href="http://en.wikipedia.org/wiki/2005_Sony_BMG_CD_copy_protection_scandal">back doors</a> and XSS vulnerabilities in your code. Don&#8217;t store our passwords in the database. Don&#8217;t deliver code that is full of undiscovered bugs.<br /><br />If someone can be relied upon to write software that is safe, I will not dictate how they do it, or how long it takes to do it. The marketplace can decide whether they are employable, much as a restaurant can decide whether to hire someone whose food is bland and unappetizing.<br /><br />I am not telling businesses that they can&#8217;t ship software full of bugs. You have Product Managers, they can decide whether it is more important to build new features or fix the old ones. Microsoft, do your thing! But business can&#8217;t make those decisions unless they have an accurate view of what the software actually does, of which parts are solid and which are brittle.<br /><br />And I am not telling managers how to run projects. But I do expect that a certified manager understands the trade-offs when she chooses BDUF over Agile, <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="raganwald: Which theory fits the evidence?">Theory D over Theory P</a>. She can do as she please, provided her eyes are wide open to the consequences.<br /><br />Well, that&#8217;s my thought about certification. I&#8217;m all for it, don&#8217;t let anyone say otherwise. And like everyone else, I want it to reflect what my experience tells me is important about software development in the commercial environment, namely safety and a clear view of what works and what doesn&#8217;t.<br /><br /><hr/><br />This is obviously a pipe dream, the product of Dark Horse Caf&eacute;&rsquo;s &#8220;Ruby&#8217;s Pride&#8221; French Press coffee. But what do <em>you</em> think? Would such a certification be useful?<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/07/certification-bring-it-on.html" title="permanent link">10:14 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, June 29, 2007</div>
			

			<div class="Post"><a name="454947708026296695">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="permanent link">Which theory fits the evidence?</a></span>
					<div style="clear:both;"></div>There are two schools of thought about the practice of managing software development (the <em>theory</em> of managing software development is of little use to us because &ldquo;the gap between theory and practice is narrower in theory than it is in practice&rdquo;).<br /><br />One school is that everything is fully deterministic in practice (&ldquo;Theory D&rdquo;). If development appears, from the outside, to be probabilistic, it is only because we haven’t discovered the &ldquo;hidden variables&rdquo; that fully determine the outcome of software development projects. And, since we are talking about development in practice, it is practical to measure the variables that determine the outcome such that we can predict that outcome in advance.<br /><br />The other school of thought is that development is fully probabilistic in practice (&ldquo;Theory P&rdquo;), that there are no hidden variables that could be used to predict with certainty the outcome of a software development project. Theory P states that the time and effort required to measure all of the variables influencing a software development project precisely enough to predict the outcome with certainty and in advance exceeds the time and effort required develop the software.<br /><br />Theory P does not mean that software development cannot be managed in such a way that the desired outcome is nearly certain: the flight of an airplane is fully probabilistic as it encounters atmospheric conditions, yet we have a huge industry built around the idea that airplanes arrive at their destinations and land on the runway as planned.<br /><br /><strong>why do theory p and theory d matter?</strong><br /><br />Understanding whether software development follows the Theory D (fully deterministic) model or the Theory P (probabilistic) model helps us set our expectation for the relationship between what we plan and what transpires.<br /><br />If we believe Theory D, we believe that it is possible and practical to plan software development entirely in advance. Therefore, when things do not go as planned, our first reaction is to either blame the planners for faulty planning or to blame the implementers for failing to carry out a reasonable plan. Believing in Theory D, we believe that we ought to have a <em>plan</em> that can be carried out to perfection.<br /><br /><blockquote>Programming is not complicated because computers are complicated&mdash;it&rsquo;s complicated because your requirements are complicated (even if you don&rsquo;t know it yet).</blockquote><div style="text-align: right;">&mdash;<a href="http://blogs.msdn.com/cashto/">Chris Ashton</a></div><br />If we believe Theory P, we believe that it is only possible and practical to plan some part of software development in advance. Therefore, when things do not go as planned, our first reaction is to embrace the new information and update our expectations. Believing in Theory P, we believe we ought to have a <em>process</em> for continually updating a plan that asymptotically approaches a description of reality as the project nears its conclusion.<br /><br /><strong>belief drives behaviour</strong><br /><br />Our belief about which theory is true drives the way we manage software development projects in almost every way. Here are three examples: the way we manage <em>software design</em>, the way we manage <em>time estimates</em>, and the way we manage <em>selecting people</em>.<br /><br /><blockquote>If extra time is required, people on Theory D projects work nights or weekends, or they cut testing time. They do this because their belief is that if a task takes too long, the fault lies with the estimate or with the worker carrying out the task, and by working overtime they can &#8220;make up for their fault.&#8221;</blockquote><br />Theory D adherents believe you can design software in advance. They believe it is possible to collect all of the information needed about software&#8217;s requirements and the technical elements of its construction, such that you can fully specify how to build it before you start. In short, Theory D adherents believe in Big Design Up Front.<br /><br />Theory P adherents believe that software can only partially be designed in advance. They believe that requirements suffer from observation, that the act of building software causes the requirements to change. Theory P adherents also believe that technical factors cannot be perfectly understood, that only the act of trying to build something with specific components will reveal all of the gotchas and who-knews associated with a chosen technology strategy. They believe that software design is an iterative process, starting with a best guess that is continually refined with experience.<br /><br />Theory D adherents believe it is possible to estimate the amount of time required to develop software (in both the large and the small) with precision. This is partly a consequence of their belief that you can know the requirements and design in advance, and therefore you can plan the activities required without uncertainty. Theory D adherents do not plan to miss milestones. Theory D adherents do not, in fact, have a process around re-estimating tasks; instead, they have a mechanism for raising exceptions when something goes wrong.<br /><br />Theory D adherents believe that the <em>normal case</em> for software projects is that tasks are completed within the time estimated. (If extra time is required, people on Theory D projects work nights or weekends, or they cut testing time. They do this because their belief is that if a task takes too long, the fault lies with the estimate or with the worker carrying out the task, and by working overtime they can &#8220;make up for their fault.&#8221; Theory D managers often &#8220;game&#8221; their workers by &#8220;negotiating&#8221; estimates downward in a cruel game of &#8220;guess the estimate I&#8217;m think of.&#8221;)<br /><br /><div class="book"><em></em><hr><em><a name="evtst|a|0884271536" href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0884271536"><img src="http://raganwald.github.com/uploaded_images/critical_chain.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271536" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0884271536" href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0884271536">Critical Chain</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271536" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is an amazing book. The narrative form—a novella detailing a technical project team and their search for a way to manage an uncertain process—is a big win, it highlights the important ways that Critical Chain Project Management handles risks and uncertainty and makes it visible where everyone can manage it.<br><br>The section on estimating tasks alone is priceless. If you can’t afford a copy and your library doesn’t stock it, borrow mine. You <strong>must</strong> read this book if you participate in software development teams.<br></em><hr></div>Theory P adherents believe that there are lies, damned lies, and software development estimates. This is partly a consequence of their lack of faith that the requirements are truly fixed and that the technology is fully understood. If you don&#8217;t know what you&#8217;re doing and how you&#8217;ll do it with precision, how can you know when it will be done? Theory P adherents build processes around re-estimating estimates, such as <a href="http://www.controlchaos.com/about/burndown.php" title="about scrum - work burn-down">burndown charts</a> and time-boxed iterations.<br /><br />Theory P adherents are always fussing with an updated view of how long things will take. They talk about &#8220;velocity&#8221; or &#8220;effective vs. actual programmer-hours.&#8221; Theory P adherents believe that the normal case for software projects is that tasks are rarely completed exactly as estimated, but that as a project progresses, the aggregate variance from estimates falls.<br /><br />Theory D adherents believe that the most important element of successful software development is <em>planning</em>. If a plan is properly constructed for the design and development of a software project, the actual implementation is virtually guaranteed. Theory D adherents invest most of their human capital in &#8220;architects&#8221; and &#8220;managers,&#8221; leaving little for &#8220;programmers.&#8221; They often have architects, senior developers, and other &#8220;valuable resources&#8221; involved in the early stages of projects and then moved to the early stage of other projects, leaving the team to implement  their &#8220;vision.&#8221; They likewise believe that you can &#8220;parachute&#8221; rescuers into a troubled project. Since the plan is perfect, it is easy to jump in and be productive.<br /><br />Theory D adherents believe in &#8220;architecture by proxy,&#8221; the belief that using frameworks, components, programming languages, libraries, or other golden bullets makes it possible to employ lesser talents to perform the implementation of software, since the difficult decisions have been made by the creators of the pre-packaged software. Theory D adherents also believe in &#8220;success by proxy,&#8221; the belief that using methodologies, practices, SDLCs, or other buzzwords makes it possible to employ lesser talents to perform the management of software development, since the difficult project management decisions have been made by the &#8220;thought leaders&#8221; who coined the buzzwords.<br /><br />Theory P adherents believe that the most important element of successful software development is <em>learning</em>. They invest their human capital more evenly between implementers and architects, often blurring the lines to create a flatter technical structure and a more egalitarian decision-making environment. This is a consequence of the belief that learning is important: if you invest heavily in a few &ldquo;smart&rdquo; people, you have a very small learning surface exposed: there is only so much even very bright people can learn at one time. Whereas when the entire team meets a certain standard for competence, there is a very large learning surface exposed and the team is able to absorb more information.<br /><br /><blockquote>Theory P adherents believe that there are lies, damned lies, and software development estimates.</blockquote><br />They strongly prefer to have the same team work a single project from start to finish, believing that when a member moves on to another project, crucial knowledge moves on with them. They likewise abhor bringing new members onto a team late in a project, believing that the new people will need experience with the project to &#8220;get up to speed.&#8221;<br /><br />Theory P adherents use frameworks (especially testing frameworks), but are skeptical of claims that the framework eliminates technical risk or the need for talented contributors. Theory P adherents, even Agilists, are skeptical of methodology claims as well. They do not believe that a deck of slides and a nicely bound book can capture the work required to learn how to develop software for a particular user community in a particular environment.<br /><br />Theory D and Theory P adherents are easy to distinguish by their behaviour.<br /><br /><strong>so which theory fits the evidence?</strong><br /><br />Which theory fits the evidence collected in sixty years of software development?<br /><br />To date, Theory P is the clear winner on the evidence, and it&rsquo;s not even close. Like any reasonable theory, it explains what we have observed to date and makes predictions that are tested empirically every day.<br /><br />Theory D, on the other hand, is the overwhelming winner in the marketplace, and again it&rsquo;s not even close. The vast majority of software development projects are managed according to Theory D, with large, heavyweight investments in design and planning in advance, very little tolerance for deviation from the plan, and a belief that good planning can make up for poor execution by contributors.<br /><br />Does Theory D reflect reality? From the perspective of effective software development, I do not believe so. However, from the perspective of organizational culture, theory D <em>is</em> reality, and you ignore it at your peril.<br /><br /><em>Do not confuse Computer Science—the study of the properties of computing machines—with Software Development, the employment of humans to build computing machines. The relationship between Computer Science and Software Development parallels the relationship between Engineering, the hard science of the behaviour of constructions, and Project Management, the employment of humans to construct engineered artefacts.</em><br /><hr/><br />(A portion of this essay originally appeared in <a HREF="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">What I&rsquo;ve Learned from Sales, Part II: Wanna Bet?</a>.<br /><br /><em>Update</em>: <a href="http://raganwald.github.com/2007/10/d-is-for-doh-we-should-have-gone-with-p.html">D is for &ldquo;D&rsquo;oh! We should have gone with P!&rdquo;</a> and <a href="http://www.thisisby.us/index.php/content/the_myth_of_project_management">The Myth of Project Management</a>, a SFW retelling of <a href="http://angryaussie.wordpress.com/2007/07/25/project-management-is-bollocks/">Project Management is Bollocks!</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="permanent link">11:38 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, June 08, 2007</div>
			

			<div class="Post"><a name="7807584909754823107">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html" title="permanent link">Still failing, still learning</a></span>
					<div style="clear:both;"></div><strong>The good new</strong>s: I&#8217;m still learning. <br /><strong>The bad news</strong>: &#8230;<em>from <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html" title="raganwald: What I've learned from failure">failure</a></em>.<br /><br />This post officially announces that my side project (originally named <em>cause &amp; effect</em> and later named <em>certitude</em>) is over.<br /><br /><strong>What I wanted to achieve</strong><br /><br />For those of you who weren&#8217;t subjected to one of my enthusiastic rants, here was my <a href="http://raganwald.github.com/2005/10/im-not-young-enough-to-know-everything.html" title="raganwald: I'm not young enough to know everything">Graham Question</a>: Can we predict the outcome of a software development project with objective observation?<br /><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/0071460829?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0071460829"><img border="0" src="http://raganwald.github.com/uploaded_images/marketing_warfare.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0071460829" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />Although most businesspeople would soil their khakis if they had to ride a tank into action, Reis and Trout are right on when they compare the four major strategies of War&mdash;Offense, Defense, Flanking, and Guerrilla&mdash;to businesses, especially start ups. I rate this even higher than <a href="http://www.amazon.com/gp/product/0060517123?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0060517123">Crossing the Chasm</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0060517123" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> for its ability to succinctly explain what growing companies have to do and how to do it to succeed.<br /><br />After you&rsquo;ve read what I have to say here about my failure, I invite you to read what <a href="http://www.amazon.com/gp/product/0071460829?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0071460829">Marketing Warfare</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0071460829" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> has to say about Guerrilla Warfare (just three tactics to pursue!) and see if I'm a case in point.<br /></em><hr/></div>I have always believed that the answer is <em>Yes</em>. And I manage projects that way. But I also strongly believe that the only way to prove that we have an objective understanding of an algorithm is to mechanize it, to write a piece of software that executes your algorithm. <br /><br />So I set out to write a piece of software that, pure and simple, would look at a software development project and show you a traffic light: a green light would mean that the project looks like it&#8217;s on track, a yellow light would mean that the project needed help, and a red light would mean that there is no hope.<br /><br />I won&#8217;t go into a lot more detail, mostly because this isn&#8217;t a story about teeming hordes of customers and me not being able to finish by deadline. It&#8217;s a story of inventing a great solution to a problem nobody cares about. But if you absolutely must visualize the application, think of something that gobbles up your MS project files, your bug tracking data, even your burn down spreadsheets, and belches out that traffic light when it&#8217;s done. That&#8217;s it.<br /><br />So how and why did I fail?<br /><br /><strong>Project management software is social software</strong><br /><br />Reason zero, just as Paul Graham warned, my age. Really. I remember how much code I could crank at age 22, and now that I am double the age, I write an order or magnitude less. I&#8217;d like to say that my code is that much better that it makes up for the lack of volume. That might be true if I start a project with a specific end in mind, but the act of experimenting, tinkering, and exploring benefits from being able to turn large amounts of code around in short amounts of time.<br /><br />This is reason zero because I wanted to get it out of the way before explaining why I think I still would have failed if I were 22. But it&#8217;s still important to understand, because I might have known that I was going to fail two years ago, instead of today.<br /><br />Reason one that I failed&#8212;and this is the most important reason I failed&#8212;is that I was trying to tackle a social problem with technology. This can work&#8212;ask any dating site zillionaire&#8212;but it is a very high-risk strategy for software. Not just for making money, but for what really matters, adoption.<br /><br /><blockquote>Project management is a <em>social problem</em>.</blockquote><br />Project management is a <em>social problem</em>. It is 99.5% about getting everyone who knows something about the state of the project to share what they know with everyone else. Getting all the relevant information is 99.5% of the problem, analyzing the information is 0.5% of the problem.<br /><br />Joel likes to brag about how much trouble FogBugz goes to to make it easy to enter bugs, about how certain kinds of reports are not available to discourage punitive social behaviours like punishing developers who generate too many bugs. This is a strong hint that getting good information is all about managing people&#8217;s perception of the likelihood of punishment for telling the truth.<br /><br />Sitting here typing this, I think the company who can do the best job of predicting the outcome of software development projects is <a href="http://inklingmarkets.com/" title="Inkling Markets">Inkling Markets</a>. That&#8217;s because their entire business is about finding a way for people to communicate what they really think of something, not just what they think other people want them to say about something. I think <a href="http://news.com.com/Tech+lessons+learned+from+the+wisdom+of+crowds/2100-1014_3-6143896.html?tag=st.num" title="Tech lessons learned from the wisdom of crowds | CNET News.com">Todd Proebsting would agree</a>.<br /><br />This problem isn&#8217;t limited to dysfunctional environments where people cower in fear of saying anything except &#8220;Sir, Yes Sir&#8221; when told to <a href="http://tuxdeluxe.org/node/213" title="&quot;Ye cannae change the laws of physics!&quot; | Tux Deluxe">change the laws of physics</a>.<br /><br /><strong>Lemons, damned lemons, it&#8217;s always lemons</strong><br /><br />Project management suffers from a real lemon problem. I <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title="raganwald: The Not So Big Software Design">quoted Bruce Schneier at length</a> about this already, so this time I&#8217;ll explain things directly:<br /><br />Most managers, especially those with limited experience shipping software on a predictable schedule, do not know how to correlate what they&#8217;re told about the project with the likelihood that the project will succeed.<br /><br />Some information is valuable, some is junk. The problem is, managers &#8220;buy&#8221; information. They trade favours like letting you keep your job for information about how well you are doing your job. So there is a market for information just like a market for cars.<br /><br />They also &#8220;sell&#8221; information, literally: they have to make a report or a presentation to their superiors, or to stake holders, or to their fellow founders at the <a href="http://ycombinator.com/" title="Y Combinator">YCombinator</a> dinner.<br /><br />When a manager cannot tell the difference between information that is useful for predicting the outcome of a project and information that is not useful for predicting the outcome of a project, she thinks about the next best thing: the &#8220;resale value&#8221; of the information with people one step removed from the project, like her own manager. So she values things like pretty PowerPoints about the architecture higher than finished pieces of functionality.<br /><br />(This is why I have always sweated my heart out to give good presentations. My teams have depended on me being able to take good information and sell it upstream just as if it were CMM Level Five Buzzword-Compliant Junk).<br /><br />Do managers further removed from a project always value pretty junk more than good, solid information? Not always, but often. And that&#8217;s enough for people to be pressured to give the bad information that sells to their manager, while hiding the good information that doesn&#8217;t sell. Exactly like the owners of good cars taking their treasures off the market.<br /><br /><strong>Lemon and bay leaf cr&egrave;me br&ucirc;l&eacute;e</strong><br /><br />Why does junk information outsell good information? Nice PowerPoint isn&rsquo;t a good explanation by itself: there are nice PowerPoints explaining Agile, but managers still prefer waterfall.<br /><br />Consider a <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title=" The Not So Big Software Design">not so big design</a>. Let&rsquo;s call completing that design good information: we&rsquo;ve done a good job finding out what&rsquo;s really important for the project and making a design that emphasizes the way this project is unique, not the technology stack.<br /><br />Now consider a typical technology design, emphasizing frameworks and technologies. Fully buzzword-compliant.<br /><br />Which one sells better? The <em>technology stack does</em>. Why? Well, for starters, managers have been exposed to seventeen billion dollars worth of advertising talking about the benefits of technology stacks. Nobody is advertising the specific ways the not so big design helps the project. How could they? Those are <em>specific to the project</em>, that&rsquo;s the whole point.<br /><br />And managers are like anyone else, they compare what you are doing to successful projects they have seen in the past. Once again, the not so big design doesn&rsquo;t have anything in common with other projects, but the technology stack does. (There are lots of failed projects with technology stacks, of course. But who cites those when bugging the team about whether they will use Hibernate as their ORM?)<br /><br />How did this happen? How did things that have no correlation to the success of a project become more attractive than things that do?<br /><br /><div class="book"><em><hr/><a href="http://www.amazon.com/gp/product/1580630081?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1580630081"><img border="0" src="http://raganwald.github.com/uploaded_images/creme_brulee.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1580630081" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />Mmmmmm... <a href="http://www.amazon.com/gp/product/1580630081?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1580630081">Elegantly Easy Cr&egrave;me Br&ucirc;l&eacute;e</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1580630081" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />... The title doesn&rsquo;t lie, the recipes are easy: even I was able to make tasty desserts! For motivating a team or thanking your family for putting up with your devotion to your start up, dessert is always a good choice :-)<br /><hr/></em></div>Quite simply, people have an incentive to look successful. So they imitate the outward appearances of successful projects. We have a really simple way of completing successful software projects: <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="Wasabi cannot cure rotten fish">we put successful people on them</a>. But we have a broken way of thinking about it: we don&rsquo;t like to think of the people as being special, we think that what the people do is successful.<br /><br />And by that logic, we can take <em>anyone</em>, have them do the same things as successful people, and our projects will succeed.<br /><br />In a manager&rsquo;s mind, the measure of whether information is good or not is, <em>Does it measure whether people are doing the same things that successful people have done on projects I&rsquo;ve been told were successful</em>?<br /><br />This is not the same thing as measuring whether the project is on its way to success at all. This measures the outward appearance of a project. Things that can be measured easily are rarely the most significant things. Behaviours that can be &ldquo;gamed,&rdquo; like how many hours a team is working, will be gamed.<br /><br />And as above, even if a manger knows better, does her manager know better? If not, good information will be difficult to sell and she will be under a lot of pressure to serve Lemon Pie.<br /><br /><strong>Off balance sheet transactions</strong><br /><br />There&#8217;s another important reason that projects have bad information: the best information is <em>off balance sheet</em>. That&#8217;s an expression meaning something a businessperson sweeps under the rug. Try Googling <a href="http://www.google.ca/search?q=Off+Balance+Sheet+Transaction" title="Off Balance Sheet Transaction - Google Search">Off Balance Sheet Transaction</a>. It&#8217;s never pretty.<br /><br />In essence, project plans and reports never include the most important information about the likelihood of project success. Never. (I mean never in the same sense that Joel Spolsky means &#8220;nobody,&#8221; as in &#8220;<a href="http://www.joelonsoftware.com/articles/APIWar.html" title="How Microsoft Lost the API War - Joel on Software">fewer than 10,000,000 project plans</a>&#8221;).<br /><br />Let me give you a recent example. I was discussing a project with a certain manager in a client organization, and there was a rather linear series of releases. Her question was, <em>Can&#8217;t we shorten the plan by looking at the dependencies and starting some releases in parallel with others</em>?<br /><br />Of course we could, but in doing so, we increased the project risk. Just as a single developer has a problem keeping multiple tasks in one brain, a team has the same problem: when working on several unrelated pieces of software at the same time, the individual developers may only work on one thing at a time, but the managers and the testers and especially the stake holders who are thinking about functionality and exercising change control are overloaded, so they will make poorer decisions.<br /><br />And worse, although you might <em>think</em> that there are no dependencies, you only think that at the outset of a project because of assumptions you are making <em>now</em>, before you fully understand what you are getting into. All in all, there&#8217;s a reason Agile projects have a practice of working on iterations with single themes, and the reason is to reduce risk.<br /><br />Does this mean that manager wasn&#8217;t making a reasonable trade off between risk and time? Maybe she was making a very reasonable choice. But let me ask you this: where on the plan would you see the risk component of the decision? If you were comparing Plan &#8220;A,&#8221; with the linear releases that finish in August, and Plan &#8220;B&#8221; with some parallel releases finishing in July, how do you decide which plan is better?<br /><br />Right, you can&rsquo;t see anything except the difference in dates, so you choose Plan B. The risk component of the plan is off balance sheet. Enjoy your lemon.<br /><br />(And it is very hard for a manager&rsquo;s people to explain, for the twentieth time, that <em>it is a mistake to try to optimize a project by having everybody working at once, because that crystallizes certain architecture decisions too early, and haven&#8217;t you read any Eliyau Goldratt, whose novel <a href="http://www.amazon.com/gp/product/0884271781?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0884271781">The Goal</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271781" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> explains what&#8217;s wrong with optimizing resource engagement when you should be managing project risk</em>? The incentive is for them keep their own counsel and put their <a href="http://reginald.braythwayt.com/RegBraithwaiteDevJune2007_en_US.pdf" title="Reginald Braithwaite">résumés</a> up on the web. Such is life.)<br /><br />A more striking example comes from another project where, for various reasons, there was nearly 100% turnover of the senior staff, and finally an outside firm was brought in to clean it up. Do you think there was a notation on the plan for staff turnover? That has to have a huge risk implication, but the plan where you use the same team from start to finish looks exactly like the plan where new people are brought in for each phase or iteration.<br /><br />Why is risk off balance sheet? I think it&#8217;s because people have a blind spot for risk in projects. After the fact of a project, you can always do a postmortem and say, &#8220;if we had done this, and this, and if we didn&#8217;t do that, we would have succeeded.&#8221; So you blame yourself for poor execution.<br /><br />There&#8217;s a culture of <em>Boolean thinking</em> about projects and plans. They worked or they didn&#8217;t. We&#8217;ll be done in July or August. Not &#8220;With Plan A, we&#8217;re 90% August, 8% September&#8221; and &#8220;With Plan B, we&#8217;re 12% July, 56% August, but 23% September and 7% October!&#8221;<br /><br />Decisions that add risk to a project, such as excessive parallelization, or the use of unproved people, or the use of team who have never worked together in the past, or of forcing decisions prematurely, all of these things are not reflected in the plan.<br /><br />(This is another reason there is pressure downwards on developer competence in many organizations. Consider two managers: the first staffs up quickly by selecting available developers, who may not be particularly good. In fact, they are less good then the existing team average. The second moves more cautiously, only adding to the team when the addition improves the average competency of the team. Do you think the second manager will keep their job long enough to finish a project? No, because the ticking time bomb of hiring certain types of developers is off balance sheet, but being understaffed is out there for everyone to criticize.)<br /><br />I had this hope that through a kind of collaborative filtering I could have a piece of software notice that linear plans or plans involving hiring too quickly or whatever had less variance than parallel plans, and adjust the traffic light accordingly. Regardless of what people would say, it would shrug its shoulders and remorselessly remark on the actual historical averages.<br /><br />Nice idea? No, it&#8217;s a dud. (Or at least, my execution was a dud!)<br /><br /><strong>Somebody set up us the bomb</strong><br /><br />The second major reason I bombed is that I couldn&#8217;t find any buyers. Quite simply, the people who understand these principles are running successful projects. I know lots of people who agree that there is a problem and agree this would help, but <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="raganwald: What I've Learned From Sales, Part I: Don't Feed the Trolls">they don&#8217;t think they need help</a>.<br /><br />I couldn&#8217;t find anyone holding their head in their hands, saying, &#8220;If only I could get the <em>truth</em> about our projects, I could open my budget and shower you with gold.&#8221; The people who were aware of the problems with project information were busy using decidedly low tech tools&#8212;like hiring good people and having daily meetings and estimating tasks in spreadsheets&#8212;to solve their problems.<br /><br />And the people who could use some help quantifying the consequences of their choices&#8212;like managers who insist on calcifying decisions very early in a telephone book design document so that they can demonstrate progress in the form of an architecture&#8212;they don&#8217;t think there&#8217;s anything wrong with their approach.<br /><br />Why is that? My conjecture is that people want help with things that fit their model of what&rsquo;s important. Someone who uses skilled practitioners and XP thinks that limiting risk is important: that&rsquo;s why they use two week iterations and merciless refactoring rather than up-front design.<br /><br />Someone using a classical BDUF management approach thinks maximizing resource allocation and managing task dependencies is important, that&rsquo;s why they spend all of their time looking at GANNT and PERT charts. When you try to sell either of them something, they want to know how it will fit the model they have in their head about how to succeed with software development, not why they should consider a new model.<br /><br />And I&rsquo;m not sure they&rsquo;re wrong about what&rsquo;s important to them, personally.<br /><br />If one of those <acronym title="Big Design Up Front">BDUF</acronym> projects fails due to the architecture being a poor fit for what the team discovers is really important about the projects, or from poor decisions being made in haste at the beginning of the project, well&#8230; managers will say that the problem was with the people making poor decisions. Such managers are not shopping for tools to help them understand the trade-offs, because they do not believe they are making trade-offs.<br /><br /><div class="book"><em><hr/><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536"><img border="0" src="http://raganwald.github.com/uploaded_images/critical_chain.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0884271536" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536">Critical Chain</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0884271536" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is an amazing book. The narrative form&mdash;a novella detailing a technical project team and their search for a way to manage an uncertain process&mdash;is a big win, it highlights the important ways that Critical Chain Project Management handles risks and uncertainty and makes it visible where everyone can manage it.<br /><br />The section on estimating tasks alone is priceless. If you can&rsquo;t afford a copy and your library doesn&rsquo;t stock it, borrow mine. You <strong>must</strong> read this book if you participate in software development teams.<br /><hr/></em></div><!--One manager I know told me that Project Management is about managing risks, as if knowing you have only a 5% chance of succeeding means you can always find a way. Given that perspective, how do you sell him a tool that tells him the difference between &#8220;With Plan A, we&#8217;re 90% August, 8% September&#8221; and &#8220;With Plan B, we&#8217;re 12% July, 56% August, but 23% September and 7% October&#8221;? I also believe project Management is about managing risks, and the way I do that is by avoiding them.<br /><br />Can such managers be sold? Of course, eventually. -->Something I learned from selling Macintoshes back in the day is this: <em>only make one sale</em>. Convincing someone they have a problem is one sale. Convincing them you have the solution is another. And convincing them that today is the day to act is a third. If you have to do all three at the same time, you are doomed.<br /><br />This is why experienced companies distinguish <a href="http://raganwald.github.com/2004/07/selling-agile-difference-between-sales.html" title="raganwald: Selling Agile: The Difference Between Sales and Marketing">sales from marketing</a>. The first two steps are marketing, the third is selling. When you are a new company, you don&#8217;t have the resources to market and sell. You have to work with an established pain point (eliminating the first hurdle), then use PR and limited marketing funds to get the word out that you have solved the problem (the second hurdle). You only have time and energy for the third sale, separating customers from their money.<br /><br />But trying to convince managers that they&#8217;re doing it wrong (tactfully), then convince them that they want your product rather than some big rigid waterfall thing or three by five cards and XP, and then convince them that they should write a cheque today&#8230;<br /><br />Bad idea. I should know, I discovered that I was trying to do exactly that.<br /><br />Now you understand why I have used so much of this post to rant about the state of project management in software development. When you understand what most companies are doing and why, you understand what will sell, and why. And when I understood that the things my project were measuring and reporting were of little interest to the people who were my market, well...<br /><br /><strong>The not so big business plan</strong><br /><br />I think there are lots of things that will sell, that <em>do</em> sell into this market. When you understand that this is a social problem, when you understand that most information is bad and that the incentives are to value bad information, and for managers to value activities that produce bad information over activities that produce good information, you can make something people <em>will</em> buy.<br /><br />Like books, lectures, methodologies, and video training. If people have a social problem, a social solution is a natural fit.<br /><br />There were interesting possibilities like selling this to BigCo for &#8220;process improvement.&#8221; But whenever I thought about such ideas, I noticed that the software wasn&#8217;t in there. I could have written a book and lectured on these ideas. I could have done a &#8220;search and replace&#8221; of agile for certitude.<br /><br />A good business plan is one that is really specifically about you and your software. If your plan could be executed by someone else, or with a different project, it simply isn&#8217;t the right plan. And all variations of turning this into ConsultingWare were excellent ways of monetizing Reg Braithwaite the brand, but not ways of spreading the adoption of certitude, the product.<br /><br />And so&#8230; and so I looked the <a href="http://en.wikipedia.org/wiki/Sunk_cost" title="Sunk cost - Wikipedia, the free encyclopedia">sunken cost fallacy</a> straight in they eye and said, <strong>no more</strong>. As much as I <a href="http://en.wikipedia.org/wiki/Loss_aversion" title="Loss aversion - Wikipedia, the free encyclopedia">hate to lose</a>, I have folded my project and I am sharing with you the important lessons I learned.<br /><br /><strong>Lessons learned</strong><br /><br />Well, the good one is this: Paul Graham is right. If you phrase your venture as a question, you will walk away with something very valuable. I now know a lot more about project management and the culture of software development than I did when I started the project, and I wasn&#8217;t exactly a Spring Chicken. And  set out to learn about Bayesian Networks and Supervised Classification, but I ended up learning about Unsupervised <a href="http://en.wikipedia.org/wiki/Data_clustering" title="Data clustering - Wikipedia, the free encyclopedia">Clustering</a> and <a href="http://en.wikipedia.org/wiki/Collaborative_filtering" title="Collaborative filtering - Wikipedia, the free encyclopedia">Collaborative Filtering</a>.<br /><br />What a journey.<br /><br />And there is the one I ignored for far too long: Always Be Selling. I can thank friends like <a href="http://www.hyperbio.net/" title="Hyperbio">Leila Boujnane</a>, <a href="http://blog.suthakamal.com/" title="Ambient Thoughts">Sutha Kamal</a>, and Erich Finkelstein for reminding me about this, incessantly. Asking people to &#8220;buy&#8221; your idea forces you to make something people want. That being said, I think there&#8217;s a right amount of &#8220;push.&#8221; You can&#8217;t invent by polling the market. Quickly now, jump in your time machine and go back to 1981 or so. How many people wanted a mouse for their computer? But yet&#8230; Always be selling!<br /><br />(There&rsquo;s a bunch of other stuff that is far more personal, and maybe some of it will appear one day in public, but I wanted to keep this post to essay length, so it&rsquo;s almost entirely about products and markets.)<br /><br />So, here I am. Older, wiser, and ready for life&#8217;s next adventure. It might be more consulting for BigCo. It might be joining a start up and helping someone else&#8217;s dream flower. I don&#8217;t know, but if you have an idea...<br /><br /><blockquote>My brain is open.</blockquote><br /><div style="text-align: right;">&#8212;P&aacute;l Erd&ouml;s</div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html" title="permanent link">6:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, May 22, 2007</div>
			

			<div class="Post"><a name="1195576257542502941">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title="permanent link">The Not So Big Software Design</a></span>
					<div style="clear:both;"></div>A little less than a decade ago, <a href="http://en.wikipedia.org/wiki/Sarah_Susanka" title="Sarah Susanka - Wikipedia, the free encyclopedia">Sarah Susanka</a> wrote a very provocative book, <a href="http://www.amazon.com/gp/product/1561583766?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1561583766">The Not So Big House</a>. I found out about it one evening while watching PBS. I switched to Channel 17, and there was an interview with her in progress. My partner and I were enthralled. We had been struggling to purchase a new home from &#8220;tract&#8221; or &#8220;subdivision&#8221; builders, and we simply couldn&#8217;t find anything that spoke to us. In a few short moments, Sarah articulated exactly why we were so frustrated by the builders.<br /><br />Sarah spoke about a culture of building homes to impress. Of cookie-cutter McMansions, where everything was big, but nothing was warm and inviting. I can give you a very practical example of this syndrome: drive through any subdivision these days. Measure the space <em>between</em> the houses. It&#8217;s pitifully small! The reason is that the builders are building the largest homes the possibly can on each lot.<br /><br /><div class="book"><hr/><a href="http://www.amazon.com/gp/product/1561583766?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1561583766"><img border="0" src="/uploaded_images/not_so_big_house.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1561583766" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/1561583766?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1561583766">The Not So Big House: A Blueprint for the Way We Really Live</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1561583766" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> emphasizes personalization: building a home that fits the way its owners actually live, not just a cookie-cutter idea of what life might be like or what features will be most impressive when company comes to visit.<br /><br />The design conflict described in the book&mdash;the tension between designing for actual use vs. designing for size and visual impact&mdash;is uncannily similar to the tension between Agile (build what you actually use and need) and Buzzwords (build everything you might need using the most impressive technology stack available).<br /><hr/></div>That means that very little light can get into the sides of the houses, and you see this when you look at the floor plans: everything is organized around large picture windows in the front and rear of the house. And no wonder: there is nothing to see to either side except the brick or siding of your neighbour&#8217;s house just a few feet away.<br /><br />Sarah&#8217;s solution to the problems of poorly designed homes is to take a given budget, and instead of buying the largest home for that price, purchase a smaller home but invest in features and details that customize the home for your needs.<br /><br />Applying this &ldquo;not so big&rdquo; thinking to the problem of houses squeezed together in a subdivision, you can try to place a smaller home on the lot and invest the construction savings in windows on three sides instead of having nearly all the windows on just the front and the back.<br /><br />Everything in Sarah&rsquo;s philosophy is driven by the owners&#8217; actual lifestyle, not some imagined lifestyle that never comes to pass. So&#8230; unless you are a competitive dancer, Sarah is not going to design an impressive ballroom for your home. On a more practical note, she spends quite a bit of time discussing the merits of doing away with the formal dining room.<br /><br />Very few people want to have company over for dinner in their kitchen, so Sarah often designs an eating area separated from the kitchen by sliding doors. You have an eat-in for everyday dining and a formal spot when you need to throw a dinner party.<br /><br />This kind of thing is not free: sliding doors are expensive, and that&#8217;s why very few &#8220;tract&#8221; homes have them, even very expensive tract homes. But if you want a home that works, you make the choice to have fewer square feet but make those square feet work for you every day.<br /><br /><strong>Lemons</strong><br /><br />The problem with tract houses can be summed up in a phrase: the builders are selling you <a href="http://www.schneier.com/crypto-gram-0705.html#1" title="A Security Market for Lemons">lemons</a>. I hope Bruce Schneier forgives me quoting wholesale from his excellent article about security problems:<br /><br /><blockquote>In 1970, American economist <a href="http://en.wikipedia.org/wiki/George_Akerlof" title="George Akerlof - Wikipedia, the free encyclopedia">George Akerlof</a> wrote a paper called &#8220;<a href="http://en.wikipedia.org/wiki/The_Market_for_Lemons" title="The Market for Lemons - Wikipedia, the free encyclopedia">The Market for Lemons</a>,&#8221; which established asymmetrical information theory. He eventually won a Nobel Prize for his work, which looks at markets where the seller knows a lot more about the product than the buyer.<br />  <br />  Akerlof illustrated his ideas with a used car market. A used car market includes both good cars and lousy ones (lemons). The seller knows which is which, but the buyer can&#8217;t tell the difference &#8212; at least until he&#8217;s made his purchase. I&#8217;ll spare you the math, but what ends up happening is that the buyer bases his purchase price on the value of a used car of average quality.<br />  <br />  This means that the best cars don&#8217;t get sold; their prices are too high. Which means that the owners of these best cars don&#8217;t put their cars on the market. And then this starts spiraling. The removal of the good cars from the market reduces the average price buyers are willing to pay, and then the very good cars no longer sell, and disappear from the market. And then the good cars, and so on until only the lemons are left.<br />  <br />  In a market where the seller has more information about the product than the buyer, bad products can drive the good ones out of the market.</blockquote><br />Now don&#8217;t think about the house builders as bad people trying to sell you a bad house.<br /><br />In the case of new homes, the bottom line is that if most buyers of homes cannot tell the difference between a home that will suit their lifestyle and one that will not, the builder has very little choice but to offer homes that offer the superficial features (like gross square footage) that will sway people into buying.<br /><br />The entire problem is centered around the fact that the average home buyer is unable to tell the difference between a good house and a bad house, so they settle for superficial distinctions.<br /><br /><strong>Building Better, Not Buzzwordier</strong><br /><br />Does this sound familiar? There are two obvious blog posts here, one about the fact that the average employer cannot tell the difference between good programmers and bad. The other about the average buyer of custom software. Since someone has already noted <a href="http://programming.reddit.com/info/1reqw/comments/c1rl6e" title="Comment on The lemons market: how bad products can drive good ones out of the market">the similarity between used cars and programmers</a>, let&#8217;s look at the similarity between houses and custom software projects.<br /><br />I recently had a chance to review an architecture design for a custom software project. The designer was given a telephone book sized specification written by the client and asked to put together a high-level architecture plan.<br /><br />Now right away, I want to say this is a tough spot to be in: it&#8217;s all well and good to talk about customizing things for clients, but you really need to talk to them if you want a shot at doing a good job. Whether you are a proponent of Agile or of BDUF, I think you will agree that no amount of documentation can replace communication, ever.<br /><br />Any ways, I saw right way that the document was&#8230; What is the phrase?&#8230; Oh yes, as <a href="http://www.amazon.com/gp/product/0393316041?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0393316041" title="Surely You're Joking, Mr. Feynman! (Adventures of a Curious Character)">Richard Feynman</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0393316041" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> would say, <em>it was no damn good</em>. It was a lemon.<br /><br />It is very poor form to criticize this person&#8217;s work after establishing that they had very little chance of doing well. So this is my disclaimer: I am writing to talk about <em>why</em> these circumstances conspire to produce a lemon of an architecture plan. Got it? Good person, bad circumstances.<br /><br />So what was wrong with the design? Quite simply, <em>there was no client in it</em>.<br /><br />There was a technology stack, there were buzzwords, there was a very popular programming language, there even were some quasi-open source components. Lots to like, and difficult to criticize. Think about how such a conversation might go between two lemon sellers: &#8220;Why are you specifying Java, C# is the best language!&#8221; Or perhaps, &#8220;BizTalk?!?! No way, you want <a href="http://shaver.off.net/diary/2007/05/10/the-high-cost-of-some-free-tools/" title="The high cost of some free tools">open standards, not lock-in</a>!&#8221;<br /><br />But there was no client in it. Tract houses are designed for the features that all inexperienced clients want to buy, making owners and tract houses interchangeable.<sup>1</sup><br /><br />And this design articulated the features that inexperienced clients (and inexperienced software designers) like to think about. These kinds of designs and clients are equally interchangeable.<br /><br /><strong>Where is the client?</strong><br /><br />What I saw was a design with such broad strokes (&#8220;Database,&#8221; &#8220;ORM,&#8221; &#8220;Workflow,&#8221; &#8220;Templates&#8221;) that it could have been presented to hundreds of different clients without change. Now obviously, hundreds of clients need databases and what-not. So the design wasn&#8217;t <em>wrong</em> in the sense that none of the decisions it articulated were bad decisions.<br /><br />But let&#8217;s stop for a moment and compare that architecture design to a home design. Imagine you hire an architect. They put together a preliminary design, a kind of sketch, for your consideration. They call you into their office for a presentation. The lights are lowered and the presentation begins.<br /><br />The Consulting Engineer speaks. &#8220;Concrete foundation!&#8221; She says. Next slide. &#8220;Wood frame.&#8221; Next slide. &#8220;Brick exterior.&#8221; You are getting the same treatment as the clients looking at a design that goes into detail about the technology stack (&#8220;Java,&#8221; &#8220;Oracle,&#8221; &#8220;Hibernate,&#8221; &#8220;BizTalk&#8221;).<br /><br />Or maybe the Consulting Engineer sits down and the Junior Architect takes over &#8220;Four bedrooms. Maybe five.&#8221; Next slide. &#8220;En suite bathroom.&#8221; Next slide. These things are all decisions that must be made, but they have little or no connection to the client&#8217;s needs.<br /><br />Isn't it obvious that a well-designed home with vinyl siding is a better choice than a poorly designed home clad in brick? But in the absence of better information, clients are forced to pick the brick over siding instead of choosing whether to have a formal dining room or whether to separate the eat-in from the kitchen with sliding doors.<br /><br />And obviously two parents and three children want at least four bedrooms. But there is no talk of whether the master bedroom is on the main floor, or whether the architect has chosen to place the play room adjacent to the children&#8217;s bedrooms upstairs where the children can play without disturbing the adults or whether to place it downstairs where it can be seen from the kitchen.<br /><br />It&#8217;s easy to see that the exterior of the house and the number of bedrooms are superficialities: To get at the important details, you have to ask a simple question: <em>How is this different than what every other client is getting?</em><br /><br />The really important architectural decisions are the ones that address how each client is unique, not what all clients have in common.<br /><br /><strong>Better Software Architecture</strong><br /><br />Designing software is not easy. And truthfully, our environment makes it difficult, because our clients are not knowledgeable enough to distinguish the not-so-big applications (&#8220;Domain-specific languages,&#8221; &#8220;Agile development&#8221;) from the McMansion applications (&#8220;Industry-standard platform!&#8221; &#8220;Detailed Specifications!!&#8221;)<br /><br />In the context of software developed for clients, good software architecture is, at its heart, architecture that is <strong>specific</strong>, not general. It isn&#8217;t all high-level abstractions that could apply to any client, it&#8217;s specific choices that address specific problems for that specific client.<br /><br />It is easy to say that the cure for the general architecture is to add detail. If the lemon design requires five slides, flesh the design out into fifteen slides. If that isn&rsquo;t specific enough, triple the length again and go to forty-five slides.<br /><br />This would be the equivalent of taking the builder&rsquo;s floor plan of a McMansion and filling in the exact dimensions. Or perhaps selecting the kitchen finishes and whether the shower fixture will be pressure-balanced or not.<br /><br />Adding detail makes a design more specific, but it only makes it specific for a client if the choices expressed address the most important needs of the client. Naturally every new home buyer has a preference with respect to kitchen cabinetry. But does expressing that decision really reflect a deep understanding of the client&rsquo;s lifestyle?<br /><br />When you look at a high-level design for a client, it should be obvious <em>at a glance</em> that the design addresses specific needs. Someone who doesn&#8217;t know the client may need an explanation&mdash;if you looked at a home design with the master bedroom on the ground floor, would you know instantly that the clients have teen-aged children?&mdash;but if you know a little something about the client, you ought to be able to literally <em>see</em> the client in the design.<br /><br />This should be true at each level of detail. It should never be necessary to drill down into the details to understand how the design solves the client&rsquo;s specific problems. If you are looking at a five-slide high-level design, it should convey the one or two most important ways the software will solve the client&rsquo;s most important and pervasive needs.<br /><br />When you drill down to detail requiring forty-five slides, you should see solutions to problems that are a ninth as important as the solutions evident in the five-slide presentation.<br /><br />Like Sarah&rsquo;s approach, this type of design has a cost. When you only have five slides, using one slide to address a client&rsquo;s specific problem means foregoing a slide full of buzzwords that impress the less-knowledgeable client.<br /><br />I wish I could tell you that this will outshine the McMansion presentation from the big consulting firm full of buzzwords and no attention to the client. But it will not: most clients will buy the idea that their needs are not-so-unique, and if what they need doesn&rsquo;t fit the architecture, they must change to adopt &ldquo;best practices.&rdquo;<br /><br />But for the serious practitioner, good design is more important than technology stacks and buzzwords. More important than size and impressiveness. It may be &ldquo;not so big.&rdquo;<br /><br />But it is <em>better</em>.<br /><br /><hr/><br /><ol><li>In all my looking at tract houses, I saw just two departures from the norm: one builder offered a two storey model with a master bedroom on the ground floor so that when they children moved out and the owners aged they wouldn&#8217;t need to go upstairs (bungalows solve that problem as well, but you need a much larger lot). Another style, &#8220;New Urbanism,&#8221; put garages back behind the house where they belong. But <a href="http://raganwald.github.com/2007/04/99-of-programmers-are-law-abiding.html" title="99% of programmers are law-abiding citizens...">99%</a> of them were just variations on the same theme.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title="permanent link">5:18 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, May 09, 2007</div>
			

			<div class="Post"><a name="3249831202425873324">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/05/hard-core-concurrency-considerations.html" title="permanent link">Hard-Core Concurrency Considerations</a></span>
					<div style="clear:both;"></div><a href="http://www.peerbox.com:8668/space/start">Kevin Greer</a> responded to <a href="http://raganwald.github.com/2007/04/haskell-not-just-for-language-weenies.html" title="Don't have a COW, man? What Haskell teaches us about writing Enterprise-scale software">What Haskell teaches us about writing Enterprise-scale software</a> with some insightful emails about the pros and cons of using purely functional data structures for managing concurrency in a multi-processor environment. I&#8217;ve reproduced them (with his permission) below.<br /><br />Now, your first reaction might be, &#8220;Ah, Reg is not nearly as smart as he thinks he is.&#8221;<br /><br />If you feel like giving me some credit, you can keep in mind that I was not writing the definitive essay on designing concurrent software, just pointing out some interesting overlaps between what I consider to be the most academic programming language around and the most practical requirements in business applications.<br /><br />But there&#8217;s something more important to take from this.<br /><br />The original post was a response to someone asking whether there was any value to the stuff you read on <a href="http://programming.reddit.com/" title="reddit.com: programming - what&#39;s new online">programming.reddit.com</a>. His query was whether reading about Haskell was <em>practical</em>. My response was, yes it is, and here are some examples of where functional data structures have an analogue in concurrent data structures. My thesis (that&#8217;s a two dollar word for &#8220;point&#8221;) was that many &#8220;impractical&#8221; things have a lot to teach us about things we will encounter in the pragmatic &#8220;<a href="http://raganwald.github.com/2006/09/business-programming-simply-isnt-that.html">real world</a>.&#8221;<br /><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/0321349601?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321349601"><img border="0" src="/uploaded_images/java_concurrency.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321349601" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0321349601?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321349601">Java Concurrency in Practice</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321349601" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is written by the people who actually designed and implemented the concurrency features in Java 5 and 6. If you are writing Java programs for two, four, eight, or more cores and CPUs (and isn&rsquo;t that practically all server-side Java development?), owning and reading this book should be the very next step in your professional development.</em><hr/><br /><br /></div>Of course, most people read <a href="http://raganwald.github.com/2007/04/haskell-not-just-for-language-weenies.html" title="Don't have a COW, man? What Haskell teaches us about writing Enterprise-scale software">the post</a> and thought, &#8220;Cool, some neat stuff about concurrency.&#8221; Nothing wrong with that. If you value tips on concurrent programming (and <a href="http://raganwald.github.com/2006/09/surfs-up.html" title="raganwald: Surf's Up!">I certainly do</a>), you&#8217;ll find Kevin&#8217;s emails very insightful.<br /><br />And if you are still wondering whether you should look at &#8220;impractical&#8221; and &#8220;academic&#8221; material like Haskell, Erlang, or other things not being promoted by MegloSoft, consider that one of the papers Kevin cites describes a data structure running on a 768 CPU system. Is this in a University lab somewhere? No, it is in a company that promotes itself as an Enterprise-Scale Java company.<br /><br />You simply can&#8217;t assume that everything the industry tells you to learn is everything you need. Or that any one source (Cool! <a href="http://raganwald.github.com/" title="raganwald">Raganwald</a> has a new post on <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="raganwald: Haskell, Ruby and Infinity">Lazy Evaluation</a>) has the definitive answer.<br /><br />You need to commit to <em>life-long learning</em> to be a software developer. Some of that learning is straightforward MSDN Magazine stuff, simple updates to things you already know. And some of that learning is a little further out on the curve.<br /><br />Without further ado, here is one of the most comprehensive technical replies to a post on my blog I&#8217;ve received to date.<br /><br /><strong>Concurrency Considerations</strong><br /><br />Hi Reg,<br /><br />I was just reading your article on concurrent collections and have a few comments:<br /><br /><ol><li>Just because readers do not update the structure doesn’t mean that they don’t need to synchronize.  This belief is a common source of concurrency bugs on multi-processor systems.<br /><br />Unless you synchronize on the root of your data-structure (or declare it as volatile), you can’t be sure that your cache doesn’t have a stale version of the data (which may have been updated by another processor).  You don’t need to synchronize for the entire life of the method, as you would by declaring the method synchronized, but you still need to synchronize on the memory access.  You hold the lock for a shorter period of time, thus allowing for better concurrency, but you still have to sync.<br /><br />If you fail to synchronize your memory (or declare it as volatile), then your code will work correctly on a single CPU machine but will fail when you add more CPU’s (it will work on multi-core machines provided that the cores share the same cache).  If you have a recursive datastructure (like a tree) then you will need to actually synchronize on each level/node, unless of course you use a purely functional data-structure, in which case, you’ll only need to synchronize on the root.<br /><br />Given that you need to make a quick sync anyway, this approach is not much better than just using a ReadWrite-lock (it is slightly better because you can start updating before the readers finish reading (not a big deal for get()’s but potentially a big deal for iterators()), but then again updates are more expensive because of the copying).</li><br /><li>I don’t think that you should be using Haskell as a model of “Enterprise-scale” anything.  “Enterprise-scale software” usually entails “Enterprise-scale hardware” which  means, among other things, multiple-CPU’s.  The problem is that Haskell purely-functional model doesn’t support multiple-CPU’s (it’s true, check the literature (except for specialized pipelined architectures, but not in the general case)).<br /><br />The whole processing “state” is essentially one large purely-functional data-structure.  The problem of synchronizing your data-structure appears to be eliminated, but it has really just been moved up to the top-level “state” structure (monad), where the problem is actually compounded.  This is worse, because not only would you need to lock your structure in order to make an update, but you would in fact need to lock “the whole world”.<br /><br />Some people will advocate launching one process per CPU and then using message passing to communicate between them.  This is just a very inefficient (many orders of magnitude slower) way of pushing the synchronization issue off onto the OS/Network-stack.  (Q: What do multi-core systems mean for the future viability of Haskell?)</li><br /><li>You forgot to mention the common technique of using “striping” to improve concurrency.   Basically,  what you do is create multiple sub-datastructures which each contain only a sub-set of the data.    You can partition the data based on the hash of the key being stored.  You then wrap the whole thing up so that it still has the same interface as the single data-structure.<br /><br />The advantage of this approach is that when you use a ReadWrite lock you only need to lock a small portion of the data-structure, rather than the whole thing.   This allows multiple updates to be performed in parallel.  This is how Java’s concurrent collections work.  See:  <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html" title="ConcurrentHashMap (Java 2 Platform SE 5.0)">ConcurrentHashMap</a>: Java creates 16 sub-structures by default but you can increase the number when even more concurrency is required.</li><br /><li>Have a look at <a href="http://www.azulsystems.com/events/javaone_2007/2007_LockFreeHash.pdf">Azul’s non-blocking HashMap implementation</a>.   They can do 1.2 billion hashMap operations per second (with 1% of 12 million/sec of those being updates) on a 768 cpu machine (the standard Java <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html" title="ConcurrentHashMap (Java 2 Platform SE 5.0)">ConcurrentHashMap</a> still does half a billion ops/sec which isn’t bad either) .  This shows how scalable non-functional methods can be.<br /><br />I’ve never read of any Haskell or other purely-functional implementation being able to scale to anywhere near these numbers.</li></ol><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/193435600X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=193435600X"><img border="0" src="/uploaded_images/programming_erlang.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=193435600X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />There&rsquo;s <strong>another</strong> entire world of concurrency control, the world of independent actors communicating with fault-tolerant protocols. The world of Erlang. You can pre-order the most hotly anticipated book on the subject, <a href="http://www.amazon.com/gp/product/193435600X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=193435600X">Programming Erlang: Software for a Concurrent World</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=193435600X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, the definitive reference from the language's creator, Joe Armstrong.</em><hr/><br /><br /></div>Summary: <em>Using a purely-functional data-structure does make it easier to support multiple readers, but you still need to sync briefly at the “top” of the structure.  Striping has the added advantage of also supporting multiple-writers as well, and in practice, this is a much bigger win.  Haskell is inherently limited to a single CPU, which doesn’t  match modern hardware; especially of the “enterprise” class.  Shared-memory models of concurrency have demonstrated much better performance than purely-functional models.</em>  <br /><br />Best Regards,<br /><br />Kevin Greer<br /><br />p.s. I've actually implemented a b-tree structure for very large data-sets and chose to use a purely-functional data-structure myself.  My reason for doing so was that I have some very long-running read operations (~8 hours) and I obviously can't afford a ReadWrite lock that's going to starve writer threads for that long.<br /><br />Another nice advantage of using purely-functional data-structures is that they make it easy to implement temporal-databases that let you perform time-dependent queries.<br /><br />I just wanted to point out that if all you have is quick-reads then purely-functional is no different than a simple ReadWrite lock and that a super-pure implementation, as with Haskell, doesn't scale to multiple-CPU's or to highly concurrent updates.  However, it can be used to good effect in combination with striping or other techniques.<br /><br />(A tangential note: Java's GC is getting so good in recent releases that P-F data-structures are becoming much more efficient (given that P-F generates more garbage).)<br /><br />p.p.s. One more advantage of functional data-structures (the largest advantage for me actually):<br /><br />They map well to log(or journal)-based storage.  Functional data-structures never update old data, but instead, just create new versions.  If your data-structure uses disk-based storage then this means that you never need to go back and overwrite your file; you only need to append data to the end of the file.  This has two advantages:<br /><br /><ol><li>This works well with the physical characteristics of hard-disks.  They have incredibly high transfer rates (10&#8217;s of Megs/sec) but very slow seek times (~ 200 seeks/sec if 5ms access time).  If you are adding say 1k objects to a data-structure which requires 2 updates on average to a file then you&#8217;re looking at about 100 updates per second.  If on the other-hand you write all of these updates to the end of the file then you&#8217;re looking at say 20,000 updates per second!</li><br /><li>You can&#8217;t corrupt old data with interrupted writes.  The old data is always still there.  The only place that a corruption occur is at the end of the file, in which case you just scan backwards until you find the previous good head of your data-structure.</li></ol><br /><hr/><br /><em>This is fantastic stuff to share, thanks, Kevin!<br /><br />What other tips can readers contribute for people building highly concurrent software (besides the frequent use of JProbe Threadalyzer, of course)? What online resources (papers, articles, books) do readers recommend for the professional developer?</em><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/05/hard-core-concurrency-considerations.html" title="permanent link">2:17 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, April 29, 2007</div>
			

			<div class="Post"><a name="37004754037577415">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html" title="permanent link">Writing programs for people to read</a></span>
					<div style="clear:both;"></div><blockquote>Programs must be written for people to read, and only incidentally for machines to execute.</blockquote><div style="text-align: right;">Abelson &amp; Sussman, <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&amp;linkCode=ur2&amp;camp=1789&amp;creative=9325">Structure and Interpretation of Computer Programs</a><br></div><br /><br />This is about writing programs in a style that favours human comprehension over the convenience of the machine.<sup>1</sup><br /><br />Norbert Winklareth recently raised the question of <a href="http://agilerenaissance.com/2007/04/25/on-semantic-distance-and-computer-languages.aspx" title="On Semantic Distance and Computer Languages">minimizing the <em>semantic distance</em> between the program as written and the solution to the problem as conceived by the programmer</a>.<br /><br />Norbert was talking about comparing the capabilities of programming languages, but the idea of semantic distance is also useful for comparing programs to each other. Although this is not the entirety of writing good programs, let&#8217;s examine this idea in more detail.<br /><br />Indeed, let&#8217;s look at one very simple, very powerful, way of writing programs that are as semantically close to the solution in the mind of the programmer.<br /><br /><strong>Code that resembles its result</strong><br /><br />A template is a blueprint for describing the result you want, where instead of embedding data inside executable code, you turn things inside out and embed executable code inside data.<br /><br />Templates are very popular in programs that generate markup:<br /><br /><pre class="textmate-source sunburst"><span class="text text_xml text_xml_xsl"><br /><span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">HTML</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br />    <span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">HEAD</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br />        <span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">TITLE</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span>Hello World<span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;/</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">TITLE</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br />    <span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;/</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">HEAD</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br /><br />    <span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">BODY</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br />        Hello, Example. Today's date and time is <span class="source source_java source_java_embedded source_java_embedded_xml"><span class="punctuation punctuation_section punctuation_section_embedded punctuation_section_embedded_begin punctuation_section_embedded_begin_xml">&lt;%=</span><span class="storage storage_type storage_type_java">Now</span>()<span class="punctuation punctuation_section punctuation_section_embedded punctuation_section_embedded_end punctuation_section_embedded_end_xml">%&gt;</span></span>.<br />    <span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;/</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">BODY</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br /><span class="meta meta_tag meta_tag_xml"><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&lt;/</span><span class="entity entity_name entity_name_tag entity_name_tag_localname entity_name_tag_localname_xml">HTML</span><span class="punctuation punctuation_definition punctuation_definition_tag punctuation_definition_tag_xml">&gt;</span></span><br /><br /></span></pre><br />It&#8217;s obvious what result you want, much more obvious than if you tried the following:<br /><br /><pre class="textmate-source sunburst"><span class="source source_java"><br />    page = <span class="storage storage_type storage_type_java">Page</span>();<br />    head = <span class="keyword keyword_other keyword_other_class-fns keyword_other_class-fns_java">new</span> <span class="storage storage_type storage_type_java">Head</span>();<br />    title = <span class="keyword keyword_other keyword_other_class-fns keyword_other_class-fns_java">new</span> <span class="storage storage_type storage_type_java">Title</span>();<br />    title.setText(<span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>Hello World<span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span>)<br />    head.add(title);<br />    page.add(head);<br />    body = <span class="keyword keyword_other keyword_other_class-fns keyword_other_class-fns_java">new</span> <span class="storage storage_type storage_type_java">Body</span>();<br />    preamble = <span class="keyword keyword_other keyword_other_class-fns keyword_other_class-fns_java">new</span> <span class="support support_type support_type_built-ins support_type_built-ins_java">StringBuffer</span>();<br />    preamble.append(<span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>Hello, Example. Today's date and time is <span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span>);<br />    preamble.append(<span class="support support_type support_type_built-ins support_type_built-ins_java">Time</span>.now().toString());<br />    preamble.append(<span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>.<span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span>);<br />    body.add(preamble.toString());<br />    page.add(body);<br /><br /></span></pre><br />This code produces its results as a <em>side effect</em> of its execution. The code itself doesn&#8217;t directly describe the result, whereas the first example directly describes the result we wish to generate.<br /><br />Sometimes you need to generate the result as a side effect of the code. You needn&#8217;t write code as opaque as the answer above, instead you can <a href="http://raganwald.github.com/2007/04/rails-style-creators-in-java-or-how-i.html">organize your code so that its form resembles the form of the result you are generating</a>, such as this <a href="http://script.aculo.us/" title="script.aculo.us - web 2.0 javascript">Scriptaculous</a> code:<br /><br /><pre><code>element = Builder.node('div',{id:'ghosttrain'},[<br />   Builder.node('div',{className:'controls',style:'font-size:11px'},[<br />     Builder.node('h1','Ghost Train'),<br />     "testtext", 2, 3, 4,<br />     Builder.node('ul',[<br />       Builder.node('li',{className:'active', onclick:'test()'},'Record')<br />     ]),<br />   ]),<br />]);<br /><br /></code></pre><br />That produces this HTML:<br /><br /><pre><code>&lt;div id="ghosttrain"&gt;<br />    &lt;div class="controls" style="font-size:11px"&gt;<br />        &lt;h1&gt;Ghost Train&lt;/h1&gt;<br />        testtext234<br />        &lt;ul&gt;<br />            &lt;li class="active" onclick="test()"&gt;Record&lt;/li&gt;<br />        &lt;/ul&gt;<br />    &lt;/div&gt;<br />&lt;/div&gt;<br /><br /></code></pre><br />Just like the template example, you don&#8217;t need to run a simulation in your head to try to figure out what the code produces.<br /><br /><strong>Is this just cancer of the semicolon?</strong><br /><br />What&#8217;s the difference between these two code samples?<br /><br /><pre class="textmate-source sunburst"><span class="source source_java"><br />    preamble = <span class="keyword keyword_other keyword_other_class-fns keyword_other_class-fns_java">new</span> <span class="support support_type support_type_built-ins support_type_built-ins_java">StringBuffer</span>();<br />    preamble.append(<span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>Hello, Example. Today's date and time is <span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span>);<br />    preamble.append(<span class="support support_type support_type_built-ins support_type_built-ins_java">Time</span>.now().toString());<br />    preamble.append(<span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>.<span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span>);<br /><br /></span></pre><br />&#8230;and&#8230;<br /><br /><pre class="textmate-source sunburst"><span class="source source_java"><br />    <span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>Hello, Example. Today's date and time is #{Time.now}.<span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span><br /><br /></span></pre><br />Is the second just syntactic sugar for the first? No. It&#8217;s more than <strong>just</strong> syntactic sugar. People have a habit of saying &#8220;syntactic sugar&#8221; in a dismissive way. It&#8217;s another argument that since an underlying language is <a href="http://en.wikipedia.org/wiki/Turing_completeness" title="Turing completeness - Wikipedia, the free encyclopedia">Turing Equivalent</a>, there is no need for a particular language feature.<br /><br />Not all language features are just syntactic sugar. True syntactic sugar features are <em>local</em> features: you can replace the feature with some other equivalent code without having to change a bunch of stuff elsewhere.<br /><br /><a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Lazy evaluation</a> and garbage collected memory management are not syntactic sugar: they require wholesale changes to the underlying model of computation to work. The abbreviated <code>for</code> loop in Java 1.5 <em>is</em> syntactic sugar: you can translate each loop into the equivalent old-style iterator loop without any additional support. For that matter, Java <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/enums.html"><code>enums</code></a> are also syntactic sugar, they&#8217;re a way to write the Type Safe Enum idiom with less boilerplate.<br /><br />Okay, non-local features are not syntactic sugar. When is a local feature &#8220;just&#8221; syntactic sugar and when is it something more than that?<br /><br />Let&#8217;s compare these two language features. Consider this Smalltalk code:<br /><br /><pre class="textmate-source sunburst"><span class="source source_java-props"><br />window<br /><span class="keyword keyword_other keyword_other_java-props">       position</span><span class="punctuation punctuation_separator punctuation_separator_key-value punctuation_separator_key-value_java-props">:</span> 80@80;<br /><span class="keyword keyword_other keyword_other_java-props">       extent</span><span class="punctuation punctuation_separator punctuation_separator_key-value punctuation_separator_key-value_java-props">:</span> 320@90;<br /><span class="keyword keyword_other keyword_other_java-props">       backcolor</span><span class="punctuation punctuation_separator punctuation_separator_key-value punctuation_separator_key-value_java-props">:</span> Color blue;<br /><span class="keyword keyword_other keyword_other_java-props">       caption</span><span class="punctuation punctuation_separator punctuation_separator_key-value punctuation_separator_key-value_java-props">:</span> 'My Blue Test Window'.<br /><br /></span></pre><br />This shows a series of &#8220;cascading messages&#8221; to the same receiver. It saves you having to type the word &#8220;window&#8221; again, and it is a lot easier to read, because it lets you <a href="http://raganwald.github.com/2007/04/rails-style-creators-in-java-or-how-i.html">group messages that obviously belong together</a>.<br /><br />And earlier, we saw:<br /><br /><pre class="textmate-source sunburst"><span class="source source_java"><br />    <span class="string string_quoted string_quoted_double string_quoted_double_java"><span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_begin punctuation_definition_string_begin_java">"</span>Hello, Example. Today's date and time is #{Time.now}.<span class="punctuation punctuation_definition punctuation_definition_string punctuation_definition_string_end punctuation_definition_string_end_java">"</span></span><br /><br /></span></pre><br />This is <em>String Interpolation</em>.<sup>2</sup> It&#8217;s an &#8220;abbreviation&#8221; for a longer sequence of <code>appends</code> onto a <code>StringBuffer</code>.<br /><br />The difference between these two trivial cases is that the first example doesn&#8217;t change your mental model of what&#8217;s going on when you read the code: you&#8217;re simply sending a bunch of messages to the <code>window</code>.<br /><br /><div class="book"><hr/><em><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to dynamic programming techniques just like these.<hr/><br><br></em></div>The second example is different in a very important way: honestly, when you read the second example, do you think &#8220;<em>Aha! Start with a string, get Time.now(), append it to that string, then append a period</em>&#8221;?<br /><br />No way! You think &#8220;<em>A String with Time.now() stuck in it</em>.&#8221;<br /><br />That&#8217;s a huge difference mentally, it&#8217;s not just shorter, it&#8217;s <em>semantically closer</em> to your mental model of the result you&#8217;re trying to achieve.<br /><br /><strong>Wrapping up code that resembles its result</strong><br /><br />In summary, one way to write code that is comprehensible is to make sure that the form of the code matches the data the code generates. This is a very general principle, it can be found in web templates (like PHP and ASP pages), markup builder libraries, and even String or List Interpolation.<br /><br />Features that support this style of writing code are more than simple syntactic sugar, because they alter the reader&#8217;s mental model, lowering the semantic distance between the code and the code&#8217;s result.<br /><br /><em>Bonus! Order now, and we&#8217;ll throw in these free Domain Specific Languages!</em><br /><br />We saw that organizing code so that it resembles the result it generates lowers the semantic distance between the code and the solution. We saw two ways to do this: we can use templates or interpolation (if our language permits interpolation) to produce data, and where templates won&#8217;t work we can structure our code to resemble its result.<br /><br />Well, we needn&#8217;t stop there. <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html" title="An Approach to Composing Domain-Specific Languages in Ruby">Domain-specific languages</a> can provide this exact benefit.<br /><br />The general purpose of a DSL is to write programs, or parts of programs, where the form of the code matches the mental model of domain experts or programmers. And here is one specific use for a DSL: to write code that closely matches the result it generates.<br /><br /><a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html#lcir">List Comprehensions</a> model lists after mathematical notation. <code>list { [x, y, x * y] }.given(:x =&gt; 1..12, :y =&gt; 1..12)</code> directly describes a list of multiplicands and results.<br /><br /><code>(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])</code> is a regular expression that matches dates.<sup>3</sup> Do you think it is hard to read? What would happen if you &#8220;compile&#8221; that expression into procedural code with side effects? Which program would be easier to understand, debug, and modify?<br /><br />There are many valuable uses for DSLs. One of them is to create programs that closely resemble the results achieve, such as the HTML builder we see earlier, list comprehensions, and regular expressions. DSLs can increase human comprehension by representing the desired result directly.<br /><br /><em>And if you call in the next fifteen minutes, you&#8217;ll membership in the Pattern Matching family at no extra cost!</em><br /><br />There&#8217;s another significant opportunity for writing code that increases human comprehension. We saw how to write code where the form of the code resembles its result. You can also write code where the form of the code resembles <em>the data it consumes</em>.<br /><br />In ML, patterns allow us to make our functions resemble the different values they consume:<br /><br /><pre><code>fun factorial 0 = 1<br />    | factorial n = n * factorial (n - 1)<br /><br /></code></pre><br />If you are not familiar with pattern matching, and especially with how languages like ML and Haskell combine patterns with their type checking system, maybe today is the day to spend a little time looking into this powerful idea for making comprehensible programs.<br /><br /><hr /><br /><ol><li>In my personal experience, &#8220;favouring human comprehension&#8221; does not mean favouring readability over writability&#8212;in order to write a program that solves a problem, I have to understand the solution, so comprehensibility applies to the act of composing <em>and</em> of reading programs by humans.<br /><br />Now about machines: In this day and age, &#8220;The convenience of the machine&#8221; is often a way of saying, &#8220;the convenience of the layer of abstraction just below your program.&#8221; In a sense, every layer of abstraction above the silicon is a kind of virtual machine.<br /><br />&#8220;Remember, it&#8217;s all software, it just depends on when you crystallize it.&#8221;&#8212;Alan Kay, <a href="http://www.folklore.org/StoryView.py?project=Macintosh&amp;story=Creative_Think.txt&amp;characters=Alan%20Kay&amp;sortOrder=Sort%20by%20Date">as quoted by Andy Hertzfeld</a></li><br /><li>List Interpolation actually predates String Interpolation, but most people recognize String Interpolation. Lispers have a little thing called a <a href="http://practical-scheme.net/wiliki/schemexref.cgi?quasiquote">quasiquote</a> or <a href="http://cl-cookbook.sourceforge.net/macros.html#LtohTOCentry-2">backquote</a> that builds lists or vectors in a template form.</li><br /><li>Early feedback suggested this is a poor example of a regular expression, because it looks obtuse. I could have selected something much simpler, however I wanted something that really would be <i>incredibly</i> obtuse if you tried to code it procedurally. (Not counting using built-in library functions for parsing dates, of course).<br /><br />The point is that this regex <i>is</i> readable, and you can see out all of the special cases, right where they belong in their place in the pattern. If readers can post some imperative code that does the same thing in a more readable form, that would be a very interesting lesson.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html" title="permanent link">9:57 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, April 04, 2007</div>
			

			<div class="Post"><a name="8511257161778092284">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/04/haskell-not-just-for-language-weenies.html" title="permanent link">Don't have a COW, man? What Haskell teaches us about writing Enterprise-scale software</a></span>
					<div style="clear:both;"></div><a href="http://factorlang-fornovices.blogspot.com/">Berlin Brown</a> asked:<br /><blockquote>I read programming.reddit religiously but I rarely see something that could be used in a non-startup environment.  Am I wrong, or are you considering deploying a haskell enterprise web application?  And if the stuff discussed isn&#8217;t relevant for the next 5 years (i.e. an erlang based webapp) will it ever be relevant?<br /></blockquote><br />Yes, I use what I read on <a href="http://programming.reddit.com/" title="reddit.com: programming - what&#39;s new online">programming.reddit.com</a> in my day job. That&#8217;s one of the reasons I <em>have</em> this day job: it&#8217;s part of what I do to sift through all of the cool stuff and find the things that are practical today.<br /><br />Since you mentioned <a href="http://www.haskell.org/" title="HaskellWiki">Haskell</a>:<br /><br />Consider a multi-threaded application with shared memory, like a really big web server that has some big shared collection of things in memory. From time to time you add things to the big collection, from time to time you remove them.<br /><br /><strong>Pessimism and coarse-grained locking</strong><br /><br />One way to arbitrate multiple threads is to have one copy of the collection with strict locking protocols that apply to its coarse-grained operations like <code>add</code>, <code>remove</code>, and <code>fetch</code>.<br /><br />In a language like Java, you can <code>synchonize</code> those methods and you&#8217;re done. You have just implemented <em>mutex locking</em>: only one thread can use the collection at a time. If one thread is fetching something from the collection, all other threads must wait, even if all they want to do is fetch things as well.<br /><br />That sucks <a href="http://rot13.com?text=tbng%20qvpx">tbng qvpx</a>, especially if you do lots of reading: why should thread <code>546</code> have to wait to fetch something just because thread <code>532</code> is currently fetching something?<sup>1</sup><br /><br /><strong>Read and write locks</strong><br /><br />The next improvement is to have two kinds of locks: <em>read locks</em> and <em>write locks</em>. Two or more threads can lock the collection for reading, but if any thread locks the collection for writing, all of the other threads have to wait until it is done.<br /><br />This works for about 17 clock ticks, and then you fix the bug by adding a new rule: if a thread wants a write lock but one or more threads have read locks, it has to wait, but any other threads that want read locks can&#8217;t have them. Even though the only threads with locks have read locks, they still have to wait.<br /><br />The thread waiting to write gets a kind of pending write lock that blocks all other threads from taking out new locks. And then you fix the next bug by saying that all threads waiting wait in a priority queue so that the read threads aren&#8217;t starved by write threads and the write threads aren&#8217;t starved by read threads.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0521663504?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0521663504"><img border="0" src="http://raganwald.github.com/uploaded_images/purely_functional_data_structures.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521663504" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0521663504?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0521663504">Purely Functional Data Structures</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521663504" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> takes you step by step through the design and implementation of copy on write collections. These collections <em>can</em> be used in purely functional languages, but they are just as useful in multi-paradigm languages like Java, Ruby, or Python handling multiple threads and performance optimization. The author&#8217;s <a href="http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf" title="Purely Functional Data Structures">thesis</a> is available on line for free.<br /><br /></div>You now have a system that is pretty fast a long as you don&#8217;t write things very often. For example, you could build a fairly nice cache using read-write locking provided it is tuned so that you get lots of hits and only rarely have to drop things from the cache or add things to the cache. But if you&#8217;re doing something like maintaining a big index in memory where you have to make lots of updates, the writes will slow everything down.<br /><br />These kinds of locking protocols are called <em>pessimistic</em> protocols: you assume bad things will happen and prevent them from happening up front by blocking threads from executing until it is safe to proceed.<br /><br /><strong>Multi-version concurrency control</strong><br /><br />Another way to arbitrate multiple threads is to make copies of the collection whenever you perform an update.<sup>2</sup> You maintain multiple <em>versions</em> of the collection. When a thread needs the collection, it grabs the latest copy. When it wants to <code>remove</code> or <code>add</code> elements, it writes a new copy without disturbing an existing copy.<br /><br />This works really well in that threads that only want to read are never blocked. They always run at full speed, even if another thread is in the middle of an update. Hand-waving over how you figure out the whole &#8220;latest copy&#8221; thing, this scheme doesn&#8217;t work so well for threads that write.<br /><br />The problem is one of <em>serialization</em>: this word means, if some set of operations takes place on the collection, the result must be the same as if the operations were conducted one at a time on the collection. There is no guarantee of the <em>order</em> of the operations, just that the result is the same as if they had been carried out in some order.<br /><br />Let&#8217;s use an example. Say our collection is a Map. It starts empty:<br /><br /><pre><code>{ }<br /></code></pre><br /><br />Operation <code>A</code> adds an element:<br /><br /><pre><code>{...a: "A"...}<br /></code></pre><br /><br />As does operation <code>B</code>:<br /><br /><pre><code>{...b: "B"...}<br /></code></pre><br /><br />And operation <code>C</code>:<br /><br /><pre><code>{...c: "C"...}<br /></code></pre><br /><br />If we start with an empty hash and perform all three operations, the result should be <code>{ a: "A", b: "B", c: "C" }</code>, exactly the same result as if each operation were performed serially, one after the other. But what happens if each operation is performed by a thread that grabs the initial copy, <code>{}</code> and writes its result back to the collection? Something called a <em>race condition</em>: the result will be <code>{ a: "A" }</code>, <code>{ b: "B" }</code>, or <code>{ c: "C" }</code>, with the &#8220;winner&#8221; being the last one to write its result.<br /><br />We can fix this problem in a couple of ways. One way is to keep the versions so that reading threads work at full speed, but use mutexes for write locks so that only one thread can write at a time. That&rsquo;s simple, and if you can figure out a cheap way to make copies, works pretty well.<br /><br />That&rsquo;s your pessimistic protocol again (threads that write have to wait on other threads that write), but it&rsquo;s a huge win for threads that read.<br /><br />Making this work is tricky. Copying the entire thing is expensive, so you need to do clever tricks where you only copy the things that change and share the things that don&#8217;t change. And you can get a big, big win if you can avoid write conflicts by arbitrating conflict at a finer grain. For example, a <code>HashMap</code> uses a set of linked lists. If two different threads write to different &#8220;buckets,&#8221; you can merge their results rather than rolling one back and starting again.<br /><br /><div class="book"><hr/><br />One of the best books ever written on the subject of implementing fault tolerant concurrency (either on a single system or a distributed network) is <a href="http://www.amazon.com/gp/product/0201107155?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201107155">Concurrency Control and Recovery in Database Systems</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0201107155" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.<br /><br />Don&rsquo;t be fooled by the word &ldquo;database&rdquo;&mdash;the techniques described are just as useful for implementing distributed algorithms like MapReduce, concurrent data structures like high-performance collections, or for building multi-threaded communication systems based on queues.<br /><br />Like all classics, it&rsquo;s also available <a href="http://research.microsoft.com/users/philbe/ccontrol/">online</a> for free.<br /><br /><hr/> <br /></div>There is a lot of extra overhead for this if a thread wants to write while another thread is reading a version, so it is only a big win if writes are fairly rare. Remember, one of the big wins is that reads <em>never</em> wait on writes because they work with immutable versions of the collection.<br /><br />Depending on how many threads you have, what kinds of operations are most likely, and other factors, this kind of system can be orders of magnitude faster than coarse-grained pessimistic locking.<br /><br />Sometimes you want a slightly different protocol. The aforementioned is often called <em>single write, many reads.</em> It requires threads that plan on writing to know in advance they need to write. But for something like a cache, you don&#8217;t know you need to write until you miss the cache. And then it&#8217;s too late to get a write lock.<br /><br /><strong>Optimism and many writes, many reads</strong><br /><br />The easiest way to avoid having to pre-declare whether a thread is a reader or a writer is by letting all of the threads do as they please. They all get the latest version and chug happily along.<br /><br />When they are finished, if they never executed an <code>add</code> or <code>remove</code> we let go of the copy of the collection and we&#8217;re done. If a thread wants to write, it makes a copy as above and writes to its copy. But it doesn&rsquo;t have to grab a lock while it is writing, so writes don&rsquo;t wait on other writes.<br /><br />Now, if a thread <em>has</em> executed a write (an <code>add</code> or <code>remove</code>), when it is done we check the result to see if it violates serializability.<br /><br />For example, we can number our versions. Let&#8217;s say that <code>{}</code> is version <code>0</code>. The first thread to finish, let&#8217;s say it&#8217;s the thread performing operation <code>B</code>, creates its result: <code>{ b: "B" }</code>. Now it checks the collection to see if anyone has updated it since <code>B</code> read the collection. The collection is still at version <code>0</code>, so <code>B</code> can write its result. <code>B</code> writes <code>{ b: "B" }</code> to the collection and calls it version <code>1</code>.<br /><br />Next <code>A</code> finishes and notices that the collection is at version <code>1</code>. This is a problem, because <code>A</code> is working with an updated version <code>0</code>, so it has to throw out its work, fetch version <code>1</code>, and try again. This is exactly the same thing as using a source code control system like <a href="http://subversion.tigris.org/" title="subversion.tigris.org">Subversion</a> to resolve conflicts.<br /><br />This many reads, many writes strategy is called an <em>optimistic protocol</em> because you do work in the hope that nothing will cause you to throw it out and try again. It&rsquo;s a big win if writes do happen at the same time, but they rarely conflict.<br /><br />For example, if you have a good strategy for <em>merging</em> writes, this is huge.<br /><br /><strong>So what?</strong><br /><br />Well, it would be great if you didn&#8217;t have to reinvent the wheel and have to work out all of the implications when you want to make a really fast shared collection in a multi-threaded environment. What you want is someone to share a wealth of experience about how to make really fast copies of things by only changing the little bits that you change instead of the whole thing, and so forth.<br /><br /><blockquote>I like languages which say, &ldquo;No, you don't want to write it the way you&rsquo;re thinking. There&rsquo;s a vastly better way to solve this whole class of problems.&rdquo; Me: <em>brain explodes</em></blockquote><br /><div style="text-align: right">&mdash;<a href="http://www.randomhacks.net/">Eric M. Kidd</a></div><br /><br />Where do you go for that kind of information? How about to people who spend all day thinking about collections that cannot change because their programming languages are purely functional?<br /><br />Yes, what I&#8217;ve just described is <em>exactly</em> how languages like Haskell implement mutable collections like dictionaries and lists. In purely functional languages, collections never change. Adding something to a collection is really creating a new collection with an extra element. This is the exact same implementation that we need for building optimistically locked collections in a multi-threaded environment!<br /><br />Haskell teaches us extremely useful techniques for writing Enterprise-scale software.<br /><br /><em>And more techniques: <a href="http://raganwald.github.com/2007/05/hard-core-concurrency-considerations.html">Hard-core concurrency considerations</a></em><br /><br /><hr /><br /><ol><li>Now, you might be saying, &#8220;what a waste, this is like locking a table in a database when we should be locking <em>rows</em>.&#8221; But if you look at the database closely, it does lock the table when you perform certain actions like deleting a row. Or it does something more complicated, and now that you&rsquo;ve read the entire post, you know what it really does.</li><br /><li>Making Copies on Writes is called <em>copy on write semantics</em>, or COW for short. Chew on that for a while.</ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/04/haskell-not-just-for-language-weenies.html" title="permanent link">10:38 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, March 16, 2007</div>
			

			<div class="Post"><a name="6177546136968725833">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html" title="permanent link">An Approach to Composing Domain-Specific Languages in Ruby</a></span>
					<div style="clear:both;"></div><em>Whoa! This looks like a long post with a lot of code snippets. Am I going to have to do a lot of hard thinking, or can I just relax and enjoy a good rambling essay?</em><br /><br />This is a bit long, probably (like all my posts) 200% longer than necessary. If you just want to see a neat DSL that implements Haskell and Python&rsquo;s List Comprehensions written in Ruby, just <a href="#lcir">scroll to the bottom</a>.<br /><br /><em>If I do bother to read it all, will I learn some neat hacks?</em><br /><br />Yes, but you could learn them just as well by reading the <a href="#dslsource">source code</a> directly.<br /><br /><em>So the benefit of reading the whole thing is...?</em><br /><br />The List Comprehensions DSL is the <strong>what</strong>. The source code is the <strong>how</strong>. But the essay is the <strong>why</strong>.<br /><br />Reading the whole thing will take you through some of the pitfalls of writing DSLs and explain why I chose my particular workarounds.<br /><br />Furthermore, <a href="http://raganwald.github.com/2007/02/why-ruby-is-not-acceptable.html">there are a lot of corners in Ruby where you can easily assume that things work one way, but really they don&rsquo;t</a>. If you actually try the snippets on your computer, you&rsquo;ll have a much better chance of remembering where the pitfalls are. That&rsquo;s why I tried to give a working example for every point, rather than just explaining things in words.<br /><br />Of course, if you have no interest in writing your own Domain Specific Languages in Ruby just yet... this isn&rsquo;t meant as a <em>popular</em> essay, rather it&rsquo;s meant as an experience report for fellow <em>practitioners</em>. And honestly, there&rsquo;s a world market for maybe five tools for writing DSLs in Ruby.<br /><br />But since you&rsquo;re here, the essay starts below!<br /><br /><hr/><br /><strong>An Approach to Composing Domain-Specific Languages in Ruby</strong><br /><br />Ruby is often touted as a good language for writing Domain-Specific Languages (&#8220;DSLs&#8221;). There are a few arguments in favour of writing a DSL as part of an application.<br /><br />The first argument that comes to mind is that if the application&#8217;s domain experts have a specific natural language or jargon of their own, writing a DSL makes it easy for programmers and domain experts to collaborate. While it is rare to find substantial applications entirely written by non-programmers at this time in <em>any</em> language, it is quite feasible for non-programmers to write or validate portions of an application representing its &#8220;business rules&#8221; or domain logic, while programmers maintain its infrastructure.<br /><br /><pre><code>    include StarbucksDSL<br />    order = latte venti, half_caf, non_fat, no_foam, no_whip<br />    print order.prepare<br /></code></pre><p style="text-align: right;">&#8212;<a href="http://obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf">Building Domain Specific Languages in Ruby</a></p><br />Another argument in favour of a DSL is that even when non-programmers are not involved directly in coding an application, the programmers themselves often have a jargon of their own to describe entities, algorithms and data structures in the application. Having portions of the application written in a language closely resembling the programmer&#8217;s own jargon makes it easy for them to read each other&#8217;s work and understand its intent.<br /><br />Successful examples of DSLs embedded within existing languages and frameworks include <a href="http://www.rubyonrails.org/">Ruby on Rails</a>&#8217; ActiveRecord, where statements such as:<br /><br /><pre><code>    has_and_belongs_to_many :Bar<br />    validates_presence_of :blitz<br />    some_bars = Bar.find_by_tavern_license(license_number)<br /></code></pre><br />Are self-documenting to anyone familiar with relational models.<br /><br />The final argument I&#8217;ll repeat here is that a DSL is a very effective way to separate the <em>what</em> from the <em>how</em> of an algorithm. <a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Separation of concerns is a desirable property of good programs</a>, and DSLs provide this separation very clearly. In the ActiveRecord examples above, the exact mechanisms of relating tables, validating records, and performing searches is &#8220;abstracted away&#8221; from the code where the programmer declares how she would like the results used.<br /><br /><strong>Freedom is Slavery</strong><br /><br />DSLs can be hacked together quickly in Ruby (whether they can be made sufficiently robust for your production needs may require considerably more care). Hacking a DSL together with little effort is a benefit, especially when prototyping: sometimes the best way to design a DSL is to try to use it, so you can discover what you need to express.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0672328844"><img border="0" src="http://raganwald.github.com/uploaded_images/the_ruby_way.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to dynamic programming techniques just like these.<br /><br /></div>Some developers have raised the concern that extensive use of &#8220;magic&#8221; features leads to code that cannot be understood or maintained.<sup>1</sup> My own feeling is that DSLs lead to code that is easier to understand, not more difficult to understand. This leaves an argument about maintenance. Some techniques for meta-programming, such as extending core classes like Array, have what you might call &#8220;non-local effects.&#8221;<br /><br />For example, two different pieces of code might try to extend the same core class, interfering with each other. Each works in isolation and passes all of its unit tests. But when plugged into a larger application that uses them together, they break.<br /><br /><blockquote><br />  Lispers are among the best grads of the Sweep-It-Under-Someone-Else&#8217;s-Carpet School of Simulated Simplicity.<br /></blockquote><br /><p style="text-align: right;">&#8212;Larry Wall</p><br />Another problem occurs with extending the <code>Kernel</code> class or creating &#8220;top level&#8221; methods to be used as verbs in a DSL. You end up with name space crowding: you must be very careful that you do not redefine en existing method.<br /><br />To fix this problem, the code that implements the DSL needs to be contained so that it does not interfere with other code. We can still implement verbs as methods, but we must implement those methods in separate objects, classes, or modules.<br /><br /><strong>Zen in the Art of Program Maintenance</strong><br /><br />An established technique for implementing methods in objects is to define the methods and then execute a block of code using <code>instance_eval</code> so that it has access to the object&#8217;s methods.<br /><br /><blockquote><br />  I&#8217;m trying to get the Zen of building DSLs using Ruby. After reading a dozen or so pieces referenced by my favourite search engine, I have a feeling I&#8217;m still not quite getting it.<br /></blockquote><br /><p style="text-align: right;">&#8212;<a href="http://pluralsight.com/blogs/dbox/archive/2006/05/07/22985.aspx">Don Box</a></p><br />You know, code expresses an idea better than words express an idea&#8230; when the idea is about coding. Please try this example in irb. Don&#8217;t just skim the text and nod: there&#8217;s a powerful learning mechanism at work when you physically do things as you&#8217;re learning, even if it&#8217;s just copying, pasting, comparing the result in one window to the text in another, and so on:<br /><br /><pre><code>def bjarne<br />    'Barney'<br />end<br /><br />dsl = Object.new<br />def dsl.phred<br />    'Fred'<br />end<br /><br />plus = ' plus '<br /><br />print dsl.instance_eval {<br />    phred + plus + bjarne<br />}<br />##### "Fred plus Barney"<br /></code></pre><br />What does this show? Well, we have created a way to use a method defined in our <code>dsl</code> object, a local variable <code>plus</code>, and a top-level method <code>bjarne</code>. We can imagine scaling this up to defining a rich DSL in our DSL object and being able to mix verbs from the DSL with instance variables and other methods as we please.<br /><br />Touching back on the subject of containment, we have defined <code>bjarne</code> in <code>Kernel</code>. Now <code>bjarne</code> is essentially global. If we already defined <code>bjarne</code> somewhere else, we just clobbered it. And if we later run a piece of code that defines <code>bjarne</code>, we&#8217;ll clobber our own version. <code>phred</code> is different. It&#8217;s defined inside of an object, and it doesn&#8217;t conflict with any other <code>phred</code> we define elsewhere.<br /><br />Great! So&#8230; Can we cite a few examples of this technique in action (such as <a href="http://weblog.jamisbuck.org/2006/4/20/writing-domain-specific-languages">Jamis&#8217; post</a> where he calls <code>phred</code> and <code>bjarne</code> examples of <em>Sandboxing</em> and <em>Top-level methods</em>) and end the post here?<br /><br />No. The code above looks fine. But there is a hidden problem with this sandboxing technique:<br /><br /><pre><code>MyDsl = Object.new<br /><br />def MyDsl.phred<br />    'Fred'<br />end<br /><br />class ClientCode<br /><br />    def bjarne<br />        'Barney'<br />    end<br /><br />    def friends<br />        plus = ' plus '<br />        MyDsl.instance_eval { phred + plus + bjarne }<br />    end<br /><br />end<br /><br />ClientCode.new.friends<br />##### -:15:in `friends': undefined local variable or method `bjarne' for # (NameError) from -:15:in `friends' from -:20<br /></code></pre><br /><a href="http://worsethanfailure.com">WTF</a>?! This looks just like our top-level example, but we&#8217;ve placed our code inside of a <code>ClientCode</code> method. And <code>bjarne</code> is a method in ClientCode: this way we can continue to separate concerns, keeping <code>phred</code> inside our DSL and <code>bjarne</code> inside of the class where we are using the DSL. But it doesn&#8217;t work.<br /><br /><strong>Why <code>instance_eval</code> breaks (in tedious detail)</strong><br /><br />As you know, everything in Ruby is either a variable or a method (how it figures out the difference is a major irritation). When you invoke a method, you are actually sending a <em>message</em> to a <em>receiver</em>.<sup>2</sup> Sometimes you name the receiver (<code>some_object.a_method</code>), and there is no ambiguity.<br /><br />But when you just name the method (like <code>bjarne</code>), Ruby tries to find the method for itself. It does so by looking to see whether it is an instance method, in which case it behaves like <code>self.bjarne</code>. If not, it looks to see whether <code>bjarne</code> is top-level, in which case it calls that method in the <code>Kernel</code>. See for yourself:<br /><br /><pre><code>def foo<br />  'top level foo'<br />end<br /><br />def bar<br />  'top level bar'<br />end<br /><br />class Test<br />  def bar<br />    'instance method bar'<br />  end<br />  def test<br />    p foo<br />    p bar<br />  end<br />end<br /><br />Test.new.test<br />##### "top level foo" "instance method bar"<br /></code></pre><br />See? It looks for instance methods and then for top-level methods if it can&#8217;t find anything. (Again, we are hand-waving over the pesky problem with instance variables in the case where we don&#8217;t use <code>()</code>). What&#8217;s the problem? Well, I actually mis-described what happens. Here it is again, with more precision:<br /><br />It looks for methods defined in the object <code>self</code>, and then for top-level methods if it can&#8217;t find anything. Of course, <code>self</code> is the current object. Unless it isn&#8217;t: That&#8217;s what <code>instance_eval</code> does: it evaluates a block but it changes <code>self</code> to point to its receiver instead of the object where the code is executing. Everything else stays the same. One more example to show the mechanism:<br /><br /><pre><code>def foo<br />  'top level foo'<br />end<br /><br />def bar<br />  'top level bar'<br />end<br /><br />class Test<br />  def bar<br />    'instance method bar'<br />  end<br />  def blitz<br />    'current object blitz'<br />  end<br />  def test<br />    p foo<br />    p bar<br />    o = Object.new<br />    def o.blitz<br />        'redefined self blitz'<br />    end<br />    p o.instance_eval { blitz }<br />    p o.instance_eval { 'bar within o gives: ' + bar }<br />  end<br />end<br /><br />Test.new.test<br />##### "top level foo" "instance method bar" "redefined self blitz" "bar within o gives: top level bar"<br /></code></pre><br />Now we see: when we use <code>instance_eval</code>, we route around our current object and all of our methods are ignored within the block. Ruby really only has two levels of scope: whatever belongs to self and whatever belongs to Kernel.<br /><br />This state of affairs is unsatisfactory: we would like to introduce a DSL in such a way that we retain access to all of our methods without kludges (like storing the current object in an instance variable).<br /><br /><strong>Nesting Scopes</strong><br /><br /><div class="book"><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://raganwald.github.com/uploaded_images/seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is devoted to the myriad uses of first class functions. This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will be able to compose programs from functions in powerful new ways.<br><br></div>You can think of the current <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29">scope</a> as being nested inside of the top-level scope. <code>instance_eval</code> doesn&#8217;t change the scope for things like local variables, it just points <code>self</code> elsewhere.<br /><br />What we want is a new scope for our DSL nested inside of the current scope. So when we search for a method, we should check the DSL. If we don&#8217;t find it there, check the current object&#8217;s scope. If we don&#8217;t find it there, check the top-level.<br /><br /><blockquote><br />  Those who do not learn from the History of Lisp are doomed to repeat it.<br /></blockquote><br />Oops. <a href="http://www-formal.stanford.edu/jmc/">John McCarthy</a> called from 1960. He wants Lisp&#8217;s <em>dynamic scoping</em> back. Yes, our new feature is almost fifty years old. This is why either a through grounding in CS theory or a hobbyist&#8217;s interest in the history of programming are important for programming: much of what we want to do has already been done before, and sometimes in unexpected contexts. Who would have thought that a technique for helping programmers collaborate with Bond Traders has roots in Lisp 1.5?<br /><br /><a href="http://weblog.raganwald.com/source/dsl_and_let.html">Here&#8217;s an implementation of a nested scope construct</a> that does exactly what we want. You declare a new class that extends <code>DomainSpecificLanguage</code>, and then you can use methods from your DSL, from your current object, and from the top-level (if you so choose). For example:<br /><br /><pre><code>require 'dsl'<br /><br />class MyDSL &lt; DomainSpecificLanguage<br /><br />  def bjarne<br />    'Barney'<br />  end<br /><br />end<br /><br />class TheGreat<br /><br />  def phred<br />    'Fredrick'<br />  end<br /><br />  def test<br />    plus = ' plus '<br />    MyDSL.eval { p phred + plus + bjarne }<br />  end<br /><br />end<br /><br />TheGreat.new.test<br />##### "Fredrick plus Barney"<br /></code></pre><br />This does <em>exactly</em> what we want with methods.<br /><br />There's also a single extension to <code>kernel</code>, the method <code>with</code>. <code>with</code> replaces the <code>eval</code> method so you can also say:<br /><pre><code><br />    with MyDSL do<br />      p phred + plus + bjarne<br />    end<br /></code></pre><br /><br />The <code>eval</code> method creates a new instance of your DSL class, so you can track state within an evaluation. For example:<br /><br /><pre><code>class Censor &lt; DomainSpecificLanguage<br />  attr_reader :ok_on_tv<br /><br />  def initialize (given_binding)<br />    super(given_binding)<br />    @ok_on_tv = true<br />  end<br /><br />  def say something<br />    something.split.each do |word|<br />      @ok_on_tv = false if ['feces', 'urine', 'love', 'pudendum', 'fellator', 'oedipus', 'mammaries'].include?(word)<br />    end<br />  end<br /><br />end<br /><br />class GeorgeCarlin<br />  def test<br />    Censor.eval {<br />      say "People much wiser than I have said, I'd rather have my son watch a film with two people making love than two people trying to kill one other."<br />      say "And I of course agree. I wish I know who said it first, and I agree with that."<br />      ok_on_tv<br />    }<br />  end<br />end<br /><br />p GeorgeCarlin.new.test<br />##### "false"<br /></code></pre><br /><strong>let</strong><br /><br />The first obvious drawback of this approach is that the blocks we pass to <code>eval</code> cannot take parameters. For this reason, rumour has it that a method called <code>instance_exec</code> will be added to Ruby in 1.9. (There are some <a href="http://termos.vemod.net/object-instance_exec">implementations</a> available that work in Ruby 1.8 if you would like to experiment.)<br /><br />The second is that you don&#8217;t get anything like nested local variables, a &#8216;la Pascal, Scheme, or any other language with block structure. Block structure is very powerful: You can use a variable within a particular scope and nowhere else. Here&#8217;s a trivial example:<br /><br /><pre><code>with Let do<br />  let :x =&gt; 0, :y =&gt; 1 do<br />    assert_equal(1, x + y)<br />    let :x =&gt; 2 do<br />      assert_equal(3, x + y) <br />    end<br />    assert_equal(0, x)<br />  end <br />end<br /></code></pre><br />We're using the <code>with</code> syntax. In the <code>Let</code> DSL, there&rsquo;s a new method called <code>let</code>. <code>let</code> creates a new DSL within <code>Let</code>. You can see that re-declaring <code>x</code> does not clobber the value in the outer scope. That is because when <code>let</code> wrote a new DSL, it added <code>x</code> and <code>y</code> as methods.<br /><br />So really, that block of code says &ldquo;Write a new DSL where <code>x</code> and <code>y</code> are methods returning zero and one. Execute some code in that new DSL. That code will create <i>another</i> DSL where <code>x</code> is a method returning two.&rdquo;<br /><br />Because <code>let</code> defines methods and not local variables, bad things happen when you try to override real local variables. It&#8217;s best to use <code>Let</code> for some things and local variables for others, but not mix the two.<br /><br />Like what, you ask?<br /><br /><strong><a name="lcir">List Comprehensions in Ruby</a></strong><br /><br />A <a href="http://en.wikipedia.org/wiki/List_comprehension">List Comprehension</a> is syntactic sugar that lets you build collections using set-like notation. For example, <code>S = [ x | x&lt;-[0..], x^2&gt;3 ]</code> is a list comprehension in Haskell.<br /><br />Here is a <a href="http://weblog.raganwald.com/source/comprehensions.html">List Comprehensions DSL in Ruby</a>. Let&#8217;s say we&#8217;re building up a multiplication table. We want tuples of the form <code>[x, y, x * y]</code> given <code>x</code> is in the range <code>1..12</code> and <code>y</code> is in the range <code>1..12</code>. Let&#8217;s write that:<br /><pre><code><br />require 'comprehension'<br /><br />class MultiplicationTable<br />  def twelve_by_twelve<br />    with Comprehension::DSL do<br />      list { [x, y, x * y] }.given(:x =&gt; 1..12, :y =&gt; 1..12)<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve<br />##### [[1, 1, 1], [1, 2, 2], [2, 1, 2], [1, 3, 3], [2, 2, 4] ...<br /></code></pre><br />(In everyday use, you don&rsquo;t need a class and a method for each comprehension: the important bit is <code>list {</code> <code>[x, y, x * y]</code> <code>}.given(:x =&gt; 1..12,</code> <code>:y =&gt; 1..12)</code>. I just wrote it this way so you could see that comprehensions work fine inside of methods. You can also use more than one comprehension inside of a single <code>with Comprehension::DSL do...</code> <code>end</code> block: see the unit tests for examples.)<br /><br />The expression in the block doesn&#8217;t have to be a tuple:<br /><pre><code><br />class MultiplicationTable<br />  def twelve_by_twelve<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(:x =&gt; 1..12, :y =&gt; 1..12)<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve<br />##### ["1 times 1 is 1", "1 times 2 is 2", "2 times 1 is 2", "1 times 3 is 3", "2 times 2 is 4", ...<br /></code></pre><br />And you can stick a &#8220;where&#8221; block on the end:<br /><pre><code><br />class MultiplicationTable<br />  def twelve_by_twelve_odds<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(:x =&gt; 1..12, :y =&gt; 1..12) { (x % 2 == 1) &amp;&amp; (y % 2 == 1) }<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve_odds<br />##### ... 3 times 5 is 15", "5 times 3 is 15", "7 times 1 is 7", "1 times 9 is 9", ...<br /></code></pre><br /><br />Would you like to nest them? Your expression is the interpreter&rsquo;s command:<br /><pre><code><br />class MultiplicationTable<br />  def odds_times_evens<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(<br />          :x => list { x }.given(:x => 1..12) { x % 2 == 0 } , <br />          :y => list { x }.given(:x => 1..12) { x % 2 == 1 } )<br />    end<br />  end<br />end<br />p MultiplicationTable.new.odds_times_evens<br />##### ... "2 times 11 is 22", "4 times 9 is 36", "6 times 7 is 42", ...<br /></code></pre><br /><strong>List Comprehensions and Let</strong><br /><br />What is the relationship to <code>Let</code>? Well, <code>Let</code> builds the scopes needed for evaluating the where clause and the block defining the elements of the list. Yes, we&#8217;ve built a DSL on top of a DSL on top of a DSL. Does this seem like weird trickery? I don&#8217;t know why. Do you have <em>any idea</em> how many levels of abstraction are responsible for you reading this essay right now?<br /><br />This is what we humans do: we build tools on top of tools. Your browser runs on an OS, possibly in a VM, perhaps in a hypervisor, on top of a BIOS, and on and on. This is the normal state of affairs, not an exception.<br /><br /><strong>Closing Remarks</strong><br /><br />It is possible to build DSLs in Ruby to facilitate cross-functional teamwork and separation of concerns. Care must be taken to avoid polluting the top-level name space, but it is possible to work within sandboxes and still have access to the current object&#8217;s context.<br /><br />Oh yes, and programming is fun as always<br /><br /><strong><a name="dslsource">Source Code</a></strong><br /><br /><em>Update: The copy of <code>dsl.rb</code> has been updated to the latest version. I had committed a rather typical manual synchronization error: I copied the latest file to the wrong directory when I first posted this. Thanks, Justin!</em><br /><br /><ul><li><a href="http://weblog.raganwald.com/source/dsl_and_let.html">DomainSpecificLanguage and Let</a></li><br /><li><a href="http://weblog.raganwald.com/source/comprehensions.html">Comprehension</a></li></ul><br /><br /><strong>How to try it for yourself</strong>: Open <a href="http://weblog.raganwald.com/source/dsl_and_let.html">DomainSpecificLanguage and Let</a>. Save the text only (not the HTML) as <code>dsl.rb</code>. Open <a href="http://weblog.raganwald.com/source/comprehensions.html"><code>Comprehension</code></a></li>. Save the text only as anything you like, as long as it is in the same directory as <code>dsl.rb</code>: I use <code>comprehension.rb</code>. Run <code>comprehension.rb</code>.<br /><hr /><ol><li>I generally call &#8220;<a href="http://en.wikipedia.org/wiki/Bullshit%21">Bullshit</a>!&#8221; on any line of reasoning that sets up a straw man argument just to knock it down. So read on with skepticism!</li><br /><li>Alan Kay has said that he regrets popularizing the notion of &#8220;Object-Oriented&#8221; programming, and that he should have called it &#8220;Message-Oriented&#8221; programming.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html" title="permanent link">12:19 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, March 11, 2007</div>
			

			<div class="Post"><a name="1990194990621630996">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html" title="permanent link">Why Why Functional Programming Matters Matters</a></span>
					<div style="clear:both;"></div>I recently re-read the amazing paper <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a> (&#8220;WhyFP&#8221;). Although I thought that I understood WhyFP when I first read it a few years ago, when I had another look last weekend I suddenly understood that I had missed an important message.<sup>1</sup><br /><br />Now obviously (can you guess from the title?) the paper is about the importance of one particular style of programming, functional programming. And when I first read the paper, I took it at face value: I thought, &#8220;Here are some reasons why functional programming languages matter.&#8221;<br /><br />On re-reading it, I see that the paper contains insights that apply to programming in general. I don&#8217;t know why this surprises me. The fact is, programming language design revolves around program design. A language&#8217;s design reflects the opinions of its creators about the proper design of programs.<br /><br />In a very real sense, the design of a programming language is a strong expression of the opinions of the designer about good programs. When I first read WhyFP, I thought the author was expressing an opinion about the design of good programming languages. Whereas on the second reading, I realized he was expressing an opinion about the design of good programs.<br /><br /><strong>Can we add though subtraction?</strong><br /><br /><blockquote>It is a logical impossibility to make a language more powerful by omitting features, no matter how bad they may be.</blockquote><br />Is this obvious? So how do we explain that one reason Java is considered &#8220;better than C++&#8221; is because it omits manual memory management? And one reason many people consider Java &#8220;better than Ruby&#8221; is because you cannot open base classes like <code>String</code> in Java? So no, it is not obvious. Why not?<br /><br />The key is the word <em>better</em>. It&#8217;s not the same as the phrase <em>more powerful</em>.<sup>2</sup> The removal or deliberate omission of these features is an expression about the idea that programs which do not use these features are better than programs which do. Any feature (or removal of a feature) which makes the programs written in the language better makes the language better. Thus, it <em>is</em> possible to make a language &#8220;better&#8221; by removing features that are considered harmful,<sup>3</sup> if by doing so it makes programs in the language better programs.<br /><br />In the opinion of the designers of Java, programs that do not use <code>malloc</code> and <code>free</code> are safer than those that do. And the opinion of the designers of Java is that programs that do not modify base classes like <code>String</code> are safer than those that do. The Java language design emphasizes a certain kind of safety, and to a Java language designer, safer programs are better programs.<br /><br />&#8220;More powerful&#8221; is a design goal just like &#8220;safer.&#8221; But yet, what does it mean? We understand what a safer language is. It&#8217;s a language where programs written in the language are safer. But what is a &#8220;more powerful&#8221; language? That programs written in the language are more powerful? What does that mean? Fewer symbols (the &#8220;golf&#8221; metric)?<br /><br />WhyFP asserts that you cannot make a language more powerful through the removal of features. To paraphrase an argument from the paper, <em>if removing harmful features was useful by itself, C and C++ programmers would simply have stopped using</em> <code>malloc</code> <em>and</em> <code>free</code> <em>twenty years ago</em>. Improving on C/C++ was not just a matter of removing <code>malloc</code> and <code>free</code>, it was also a matter of adding automatic garbage collection.<br /><br /><blockquote>This space, wherein the essay ought to argue that Java compensates for its closed base classes by providing a more powerful substitute feature, left intentionally blank.</blockquote><br />At the same time, there is room for arguing that some languages are improved by the removal of harmful features. To understand why they may be improved but not more powerful, we need a more objective definition of what it means for a language to be &#8220;more powerful.&#8221; Specifically, what quality does a more powerful programming language permit or encourage in programs?<br /><br />When we understand what makes a program &#8220;better&#8221; in the mind of a language designer, we can understand the choices behind the language.<br /><br /><strong>Factoring</strong><br /><br />Factoring a program is the act of dividing it into units that are composed to produce the working software.<sup>4</sup> Factoring happens as part of the design. (<em>Re</em>-factoring is the act of rearranging an existing program to be factored in a different way). If you want to compare this to factoring in number theory, a well designed program has lots of factors, like the number <code>3,628,800</code> (<code>10!</code>). A <a href="http://www.laputan.org/mud/">Big Ball of Mud</a> is like the number <code>3,628,811</code>, a prime.<br /><br />Composition is the construction of programs from smaller programs. So factoring is to composition as division is to multiplication.<br /><br />Factoring programs isn&#8217;t really like factoring simple divisors. The most important reason is that programs can be factored in orthogonal ways. When you break a program into subprograms (using methods, subroutines, functions, what-have-you), that&#8217;s one axis of factoring. When you break an a modular program up into modules, that&#8217;s another, orthogonal axis of factoring.<br /><br />Programs that are well-factored are more desirable than programs that are poorly factored.<br /><br /><blockquote>In computer science, <strong>separation of concerns</strong> (SoC) is the process of breaking a program into distinct features that overlap in functionality as little as possible. A concern is any piece of interest or focus in a program.<br />  <br />  SoC is a long standing idea that simply means a large problem is easier to manage if it can be broken down into pieces; particularly so if the solutions to the sub-problems can be combined to form a solution to the large problem.<br />  <br />  The term separation of concerns was probably coined by Edsger W. Dijkstra in his paper <a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">On the role of scientific thought</a>.</blockquote><br />&#8212;Excerpts from the Wikipedia entry on <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns</a><br /><br />Programs that separate their concerns are well-factored. There&#8217;s a principle of software development, <a href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=211189&amp;creative=374929&amp;creativeASIN=0201379430" title="Object Design: Roles, Responsibilities, and Collaborations">responsibility-driven design</a>. Each component should have one clear responsibility, and it should have everything it needs to carry out its responsibility.<br /><br />This is the separation of concerns again. Each component of a program having one clearly defined responsibility means each concern is addressed in one clearly defined place.<br /><br /><blockquote>Let’s ask a question about Monopoly (and Enterprise software). Where do the rules live? In a noun-oriented design, the rules are smooshed and smeared across the design, because every single object is responsible for knowing everything about everything that it can ‘do’. All the verbs are glued to the nouns as methods.</blockquote><div>&#8212;<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a></div><br /><br />In a game design where you have important information about a rule smeared all over the object hierarchy, you have very poor separation of concerns. It looks at first like there&#8217;s a clear factoring &#8220;Baltic Avenue has a method called <code>isUpgradableToHotel</code>,&#8221; but when you look more closely you realize that every object representing a property is burdened with knowing almost all of the rules of the game.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256100X"><img border="0" src="http://raganwald.github.com/uploaded_images/seasoned_schemer.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256100X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256100X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is devoted to the myriad uses of first class functions. This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will be able to compose programs from functions in powerful new ways.<br><br></div>The concerns are not clearly separated: there&#8217;s no one place to look and understand the behaviour of the game.<br /><br />Programs that separate their concerns are better programs than those that do not. And languages that facilitate this kind of program design are better than those that hamper it.<br /><br /><strong>Power through features that separate concerns</strong><br /><br />One thing that makes a programming language &#8220;more powerful&#8221; in my opinion is the provision of more ways to factor programs. Or if you prefer, <em>more axes of composition</em>. The more different ways you can compose programs out of subprograms, the more powerful a language is. <br /><br />Do you remember <a href="http://en.wikipedia.org/wiki/Structured_programming">Structured Programming</a>? The gist is, you remove <code>goto</code> and you replace it with well-defined control flow mechanisms: some form of subroutine call and return, some form of selection mechanism like Algol-descendant <code>if</code>, and some form of repetition like Common Lisp&#8217;s <code>loop</code> macro.<br /><br />Dijkstra&#8217;s view on structured programming was that it promoted the separation of concerns. The factoring of programs into blocks with well-defined control flow made it easy to understand blocks and rearrange programs in different ways. Programs with indiscriminate jumps did not factor well (if at all): they were difficult to understand and often could not be rearranged at all.<br /><br />Structured <a href="http://dmoz.org/Computers/Programming/Languages/Assembly/68k/">68k ASM</a> programming is straightforward in theory. You just need a lot of boilerplate, design patterns, and the discipline to stick to your convictions. But of course, lots of 68k ASM programming in practice is only partially structured. Statistically speaking, 68k ASM is not a structured programming language even though structured programming is possible in 68k ASM.<br /><br />Structured Pascal programming is straightforward both in theory and in practice. Pascal facilitates separation of concerns through structured programming. So we say that Pascal &#8220;is more powerful than 68k ASM&#8221; to mean that in practice, programs written in Pascal are more structured than programs written in 68k ASM because Pascal provides facilities for separating concerns that are missing in 68k ASM.<br /><br /><strong>For example: working with lists</strong><br /><br />Consider this snippet of iterative code:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_java"><span class="storage storage_type storage_type_java">int</span> numberOfOldTimers = <span class="constant constant_numeric constant_numeric_java">0</span>;<br /><span class="meta meta_definition meta_definition_constructor meta_definition_constructor_java"><span class="entity entity_name entity_name_function entity_name_function_constructor entity_name_function_constructor_java">for</span> <span class="meta meta_definition meta_definition_param-list meta_definition_param-list_java">(<span class="storage storage_type storage_type_java">Employee</span> emp: employeeList</span>) </span>{<br /><span class="meta meta_definition meta_definition_constructor meta_definition_constructor_java">    <span class="entity entity_name entity_name_function entity_name_function_constructor entity_name_function_constructor_java">for</span> <span class="meta meta_definition meta_definition_param-list meta_definition_param-list_java">(<span class="storage storage_type storage_type_java">Department</span> dept: departmentsInCompany</span>) </span>{<br />        <span class="keyword keyword_control keyword_control_java">if</span> (emp.getDepartmentId() <span class="keyword keyword_operator keyword_operator_comparison keyword_operator_comparison_java">==</span> dept.getId() <span class="keyword keyword_operator keyword_operator_logical keyword_operator_logical_java">&amp;&amp;</span> emp.getYearsOfService() <span class="keyword keyword_operator keyword_operator_comparison keyword_operator_comparison_java">&gt;</span> dept.getAge()) {<br />            <span class="keyword keyword_operator keyword_operator_increment-decrement keyword_operator_increment-decrement_java">++</span>numberOfOldTimers;<br />        }<br />    }<br />}<br /></span><br /></pre><br />This is an improvement on older practices.<sup>5, 6</sup> For one thing, the <code>for</code> loops hide the implementation details of iterating over <code>employeeList</code> and <code>departmentsInCompany</code>. Is this better because you have less to type? Yes. Is it better because you eliminate the fence-post errors associated with loop variables? Of course.<br /><br />But most interestingly, you have the beginnings of a <em>separation of concerns</em>: how to iterate over a single list is separate from what you do in the iteration.<br /><br /><blockquote>Try calling a colleague on the telephone and explaining what we want as succinctly as possible. Do you say &#8220;We want a loop inside a loop and inside of that an if, and&#8230;&#8221;? Or do you say &#8220;We want to count the number of employees that have been with the company longer than their departments have existed.&#8221;</blockquote><br />One problem with the <code>for</code> loop is that it can only handle one loop at a time. We have to nest loops to work with two lists at once. This is patently wrong: there&#8217;s nothing inherently nested about what we&#8217;re trying to do. We can demonstrate this easily: try calling a colleague on the telephone and explaining what we want as succinctly as possible. Do you say &#8220;We want a loop inside a loop and inside of that an if, and&#8230;&#8221;?<br /><br />No, we say, &#8220;We want to count the number of employees that have been with the company longer than their departments have existed.&#8221; There&#8217;s no discussion of nesting.<br /><br />In this case, a limitation of our tool has caused our concerns to intermingle again. The concern of &#8220;How to find the employees that have been with the company longer than their departments have existed&#8221; is intertwined with the concern of &#8220;count them.&#8221; Let&#8217;s try a different notation that separates the details of <em>how to find</em> from the detail of <em>counting what we&#8217;ve found</em>:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_ruby">old_timers = (employees * departments).select <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|emp, dept|<br />  emp.department_id == dept.id &amp;&amp; emp.years_of_service &gt; dept.age<br /><span class="keyword keyword_control keyword_control_ruby">end</span><br />number_of_old_timers = old_timers.size<br /></span><br /></pre><br />Now we have separated the concern of finding from counting. And we have hidden the nesting by using the <code>*</code> operator to create a Cartesian product of the two lists. Now let&#8217;s look at what we used to filter the combined list, <code>select</code>. The difference is more than just semantics, or counting characters, or the alleged pleasure of fooling around with closures.<br /><br /><div class="book"><br>  <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/uploaded_images/haskell_school_of_expression.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br>I’m not a Haskell user (yet), but <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> has received rave reviews and comes with solid recommendations. It’s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you’re feeling generous!<br><br></div><code>*</code> and <code>select</code> facilitates separating the concerns of how to filter things (like iterate over them applying a test) from the concern of what we want to filter. So languages that make this easy are more powerful than languages that do not. In the sense that they facilitate additional axes of factoring.<br /><br /><strong>The Telephone Test</strong><br /><br />Let&#8217;s look back a few paragraphs. We have an example of the &#8220;Telephone Test:&#8221; when code very closely resembles how you would explain your solution over the telephone, we often say it is &#8220;very high level.&#8221; The usual case is that such code expresses a lot more <em>what</em> and a lot less <em>how</em>. The concern of what has been very clearly separated from the concern of how: you can&#8217;t even <em>see</em> the how if you don&#8217;t go looking for it.<br /><br />In general, we think this is a good thing. But it isn&#8217;t free: somewhere else there is a mass of code that supports your brevity. When that extra mass of code is built into the programming language, or is baked into the standard libraries, it is nearly free and obviously a Very Good Thing. A language that doesn&#8217;t just separate the concern of how but does the work for you is very close to &#8220;something for nothing&#8221; in programming.<br /><br />But sometimes you have to write the <em>how</em> as well as the <em>what</em>. It isn&#8217;t always handed to you. In that case, it is still valuable, because the resulting program still separates concerns. It still factors into separate components. The components can be changed.<br /><br />I recently separated the concern of describing &#8220;how to generate sample curves for some data mining&#8221; from the concern of &#8220;managing memory when generating the curves.&#8221; I did so by writing my own lazy evaluation code (Both the <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">story</a> and the <a href="http://weblog.raganwald.com/source/lazy_lists.html">code</a> are on line). Here&#8217;s the key &#8220;what&#8221; code that generates an infinite list of parameters for sample bezi&eacute;r curves:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_ruby"><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">magnitudes</span></span><br />  <span class="support support_class support_class_ruby">LazyList</span>.binary_search(<span class="constant constant_numeric constant_numeric_ruby">0.0</span>, <span class="constant constant_numeric constant_numeric_ruby">1.0</span>)<br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">control_points</span></span><br />  <span class="support support_class support_class_ruby">LazyList</span>.cartesian_product(magnitudes, magnitudes) <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|x, y|<br />    <span class="support support_class support_class_ruby">Dictionary</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>( <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; x, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; y )<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">order_one_flows</span></span> args = {}<br />  height, width = (args[<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>height</span>] || <span class="constant constant_numeric constant_numeric_ruby">100.0</span>), (args[<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>width</span>] || <span class="constant constant_numeric constant_numeric_ruby">100.0</span>)<br />  <span class="support support_class support_class_ruby">LazyList</span>.cartesian_product(<br />      magnitudes, control_points, control_points, magnitudes<br />  ) <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|initial_y, p1, p2, final_y|<br />    <span class="support support_class support_class_ruby">FlowParams</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>(<br />      height, width, initial_y * height,<br />      <span class="support support_class support_class_ruby">CubicBezierParams</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>(<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; width,          <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; final_y * height,<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x1</span> =&gt; p1.x * width,  <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y1</span> =&gt; p1.y * height,<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x2</span> =&gt; p2.x * width,  <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y2</span> =&gt; p2.y * height<br />      )<br />    )<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /></span><br /></pre><br />That&#8217;s it. Just as I might tell you on the phone: &#8220;Magnitudes&#8221; is a list of numbers between zero and one created by repeatedly dividing the intervals in half, like a binary search. &#8220;Control Points&#8221; is a list of the Cartesian product of magnitudes with itself, with one magnitude assigned to <code>x</code> and the other to <code>y</code>. And so forth.<br /><br />I will not say that the sum of this code and the code that actually implements infinite lists is shorter than imperative code that would intermingle loops and control structures, <a href="http://www.amazon.com/gp/product/B000002J27?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000002J27" title="A Trick of the Tail by Genesis, Track 2, Entangled">entangling</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=B000002J27" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <em>what</em> with <em>how</em>. I will say that it separates the concerns of what and how, and it separates them in a different way than <code>select</code> separated the concerns of what and how.<br /><br /><strong>So why does &#8220;Why Functional Programming Matters&#8221; matter again?</strong><br /><br />The great insight is that better programs separate concerns. They are factored more purely, and the factors are naturally along the lines of responsibility (rather than in Jenga piles of <code>abstract</code> <code>virtual</code> <code>base</code> <code>mixin</code> <code>module</code> <code>class</code> <code>proto_</code> <code>extends</code> <code>private</code> <code>implements</code>). Languages that facilitate better separation of concerns are more powerful in practice than those that don&#8217;t.<br /><br />WhyFP illustrates this point beautifully with the same examples I just gave: <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">first-class functions</a> and <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">lazy evaluation</a>, both prominent features of modern functional languages like Haskell.<br /><br />WhyFP&#8217;s value is that it expresses an opinion about what makes programs better. It backs this opinion up with reasons why modern functional programming languages are more powerful than imperative programming languages. But even if you don&#8217;t plan to try functional programming tomorrow, the lessons about better programs are valuable for your work in <em>any</em> language today.<br /><br />That&rsquo;s why <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a> matters.<br /><br /><hr /><ol><li>And now I&#8217;m worried: what am I <em>still</em> missing?</li><br /><li>Please let&#8217;s not have a discussion about <a href="http://en.wikipedia.org/wiki/Turing-complete">Turing Equivalence</a>. Computer Science &#8220;Theory&#8221; tells us &#8220;there&#8217;s no such thing as more powerful.&#8221; Perhaps we share the belief that <em>In theory, there&#8217;s no difference between theory and practice. But in practice, there is</em>.</li><br /><li>I am not making the claim that <em>I</em> consider memory management or unsealed base classes harmful, but I argue that there exists at least one person who does.</li><br /><li>The word &#8220;factor&#8221; has been a little out of vogue in recent times. But thanks to an excellent <a href="http://programming.reddit.com/info/18td4/comments">post on reddit</a>, it could make a comeback.</li><br /><li>So much so that we won&#8217;t even bother to show what loops looked like in the days of <code>for (int i = 0; i &lt; employeeList.size(); ++i)</code>. </li><br /><li>Another organization might merge employees and departments, or have each department &ldquo;own&rdquo; a collection of employees. This makes our example easier, but now the <em>data</em> doesn&rsquo;t factor well. Everything we&rsquo;ve learned from databases in the last forty years tells us that we often need to find new ways to compose our data. The relational model factors well. The network model factors poorly.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html" title="permanent link">10:21 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, February 09, 2007</div>
			

			<div class="Post"><a name="117104072110045314">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/program-in-java-you-must-be-joking.html" title="permanent link">Program in Java? You must be joking!</a></span>
					<div style="clear:both;"></div><blockquote><br />The Y combinator design pattern in Java is easily understood and can be used and maintained by unskilled, entry-level programmers.<br /><br />Cuius rei demonstrationem mirabilem sane detexi. Hanc marginis exiguitas non caperet.<br /></blockquote><br />You know, this kind of joke seems to rile Java apologists to no end. They come out of the woodwork with their web browsers set to <em>flame</em>. Absolutely no criticism of the language that powers everything from the web to space exploration (although there is never any talk of toasters) is allowed.<br /><br />And <em>do not</em> criticize the culture in any way whatsoever. Although it&#8217;s perfectly ok to boast that Java is designed to appeal to the widest possible diversity of skill levels, you <em>may not</em> suggest that Java programmers are stupid. Or else.<br /><br /><div class="book"><style type="text/css">.flickr-photo { border: solid 2px #000000; }.flickr-yourcomment { }.flickr-frame { text-align: left; padding: 3px; }.flickr-caption { font-size: 0.8em; margin-top: 0px; }</style><div class="flickr-frame"> <a href="http://www.flickr.com/photos/thomasb/334531216/" title="silly daddy!"><img height="240" width="168" src="http://farm1.static.flickr.com/138/334531216_31fa1468ac.jpg" class="flickr-photo" alt="" /></a><br /> <span class="flickr-caption"><a href="http://www.flickr.com/photos/thomasb/334531216/">silly daddy!</a>, originally uploaded by <a href="http://www.flickr.com/people/thomasb/">thomas.braithwaite</a>.</span></div>    <p class="flickr-yourcomment"> </p><br /></div>I am trying not to tell anyone what to do, but I have an observation. Have you ever heard a politically incorrect but extremely funny joke about a member of a particular culture? You know you have. And furthermore, the joke was probably told by a member of the group victimized in the joke.<br /><br />The unwritten rule is, if you&#8217;re a member, jokes are <em>fair game</em>. I was once with some, ahh, members of a religion that directly predated and evolved into Christianity. They were telling some jokes about their culture and religion. I had heard a few such jokes, but I wisely refrained from telling any. It&#8217;s not allowed. That&#8217;s the rule: outsiders may not joke.<br /><br />So back to Java. Guess what? I&#8217;m an <em>insider</em>. I write Java code every working day. If you care about hollow appeals to authority, I once wrote a Scheme implementation in Java. I was also the team lead for JProbe Threadalyzer, a tool that analyses multi-threaded Java behaviour. And the development manager for JProbe Server-Side Suite (the aforementioned thread analyser, plus profiling, code coverage, and memory debugging tools). And various J2EE implementations with various degrees of Enterprisy-ness.<br /><br />None of that makes me an expert. Nor does it make me right when I criticize or joke. But it does give me a certain smug <em>right to joke</em>. And don&rsquo;t we all need a laugh from time to time, even if we&rsquo;re laughing at ourselves? Perhaps <em>especially</em> if we're laughing at ourselves?<br /><br />I think it&rsquo;s a sign of good health to be able to laugh at ourselves and criticize our foibles. For all of the talk of Java as a &ldquo;mature platform,&rdquo; don&rsquo;t you agree that &ldquo;not taking criticism well&rdquo; is a little, well, <em>immature</em>? <br /><br />So since it&#8217;s Friday:<br /><br /><blockquote><br />A Muslim, a Vegetarian, and a Java Programmer are traveling by foot, and they stop at a farm house to sleep for the night. The farmer is impressed at the obvious sophistication of the Java Programmer&#8217;s tales of Enterprise wonder, and he invites her into the house. The Muslim he sends to the hayloft, and the Vegetarian can sleep in the barn.<br />  <br />  Well, the farmer is just pouring a night-cap and listening to the Java Programmer describe the time she knocked together a farm workflow application in less than a million lines of XML configuration code when there&#8217;s a knocking on the door.<br /><br />He opens the door and the Vegetarian is standing there. &#8220;I&#8217;m sorry,&#8221; the Vegetarian apologizes, &#8220;But you slaughter animals in the barn, and eating meat is offensive to my beliefs. I cannot sleep in the barn.&#8221; The farmer thinks this is bunkum, but he was raised to be courteous to his guests, so he asks the Vegetarian to swap places with the Muslim.<br />  <br />  The farmer knocks back his drink and turns down the lights. He can hear the Java Programmer setting up a sleeping bag factory to generate down-filled singleton sleeping containers in the living room. His wife is reading in bed, and he&#8217;s looking forward to catching up on the Wall Street Journal.<br /><br />Well, he is just about to climb into bed when there&#8217;s a banging on the door. He opens the door, and the Muslim is standing there. &#8220;I&#8217;m sorry,&#8221; the Muslim apologizes, &#8220;But you keep pigs in the barn, and pigs are profane according to my beliefs. I cannot sleep in the barn.&#8221;<br />  <br />  Muttering, the farmer rouses the Java Programmer off the couch and asks her to switch with the Muslim. He climbs into bed and has just started to read an interesting article on hedging commodity futures with convex derivatives when there&#8217;s a thunderous hammering at the door. His wife tells him to stay put and she goes to answer it. The farmer hears some excited talking, and a moment later his wife is at the bedroom door.<br />  <br />  &#8220;Honey,&#8221; she says, &#8220;it&#8217;s the pigs.&#8221;<br /></blockquote><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/program-in-java-you-must-be-joking.html" title="permanent link">11:59 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, February 06, 2007</div>
			

			<div class="Post"><a name="117073854086425300">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html" title="permanent link">But Y would I want to do a thing like this?</a></span>
					<div style="clear:both;"></div><blockquote><br />  Choose life. Choose a job. Choose a starter home. Choose dental insurance, leisure wear and matching luggage. Choose your future. But <a href="http://en.wikipedia.org/wiki/Y_combinator" title="Y combinator">Y</a> would <a href="http://en.wikipedia.org/wiki/Combinatory_logic#Examples_of_combinators" title="Identity combinator">I</a> want to do a thing like that?<br /></blockquote>Writing about <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">first-class functions</a> and their <a href="http://raganwald.github.com/2007/02/hof-or-oop-yes.html">compatibility with object-oriented programming</a> naturally leads to the <a href="http://en.wikipedia.org/wiki/Y_combinator">Y combinator</a>. And that is the point where eyes glaze over and soft, snoring sounds rise from RSS readers everywhere.<br /><br />But please bear with me, this essay is not really about the Y combinator, it&#8217;s about learning new things and expanding our capacity to think.<br /><br /><strong>Sharpening the saw</strong><br /><br />Years ago I picked up Steven Covey&#8217;s book <a href="http://www.amazon.com/gp/product/0743269519?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0743269519">The 7 Habits of Highly Effective People</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0743269519" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. If the book is a test out of seven, I really wasn&#8217;t doing very well.<br /><br />If you&#8217;ve read the book, you probably remember that he talked about &#8220;Sharpening the Saw,&#8221; investing in your own abilities. That&#8217;s incredibly important, but I don&#8217;t need to tell you that. If you exercise with programming katas, or learn a new programming language once a year, or pick up a book like <a href="http://www.amazon.com/gp/product/0262562146?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262562146">The Reasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262562146" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <em>and actually go through the exercises</em>, then you are already in the top 1% of software developers for personal skills improvement. (Sorry, certifications <em>don&#8217;t count</em>. They are the classic case of doing the wrong thing for the wrong reason!)<br /><br />New ideas&#8212;by which I mean, new to you&#8212;are an important way to sharpen your saw. If for no other reason than this: the brain needs regular exercise to perform at or near its potential. Learning new things keeps you sharp, even if you don&#8217;t directly use the things you learned.<br /><br />Others have suggested that learning Lisp is beneficial to your programming skills in its own right. That&rsquo;s one good way to sharpen your saw. But I add to that an important caveat: to obtain the deepest benefit from learning a new language, you must learn to think in the new language, not just learn to translate your favourite programming language syntax and idioms into it.<br /><br /><strong>Think different</strong><br /><br />The interesting thing about that is that almost by definition, if you see something in, say, Lisp that solves a problem you already have, you won&#8217;t learn much from the Lisp code. It is tempting to think that Lisp (or any other language) will somehow do what you&#8217;re already doing in some wonderfully magic way that is obviously better. But no, that isn&#8217;t how it really works.<br /><br />For your problems are tuned to your existing tools. You simply can&#8217;t imagine problems that your tools can&#8217;t solve well, much less can&#8217;t solve at all. That&#8217;s why there are so few continuation-based web servers. Who&#8217;s going to invent one unless they have a programming paradigm with continuations?<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422"><img border="0" src="http://raganwald.github.com/uploaded_images/to_mock_a_mockingbird-785706"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: The most enjoyable text on the subject of combinatory logic ever written. What other textbook features starlings, kestrels, and other songbirds?<br /></div>And worse, when a new tool is applied to a problem you think you know well, you will probably dismiss the things the new tool does well. Look at how many people dismiss brevity of code. Note that all of the people ignore the statistics about the constant ratio between bugs and lines of code use verbose languages. Look at how many people dismiss continuation-based servers as a design approach. Note that all of them use programming languages bereft of control flow abstractions.<br /><br />Thus, to truly learn a new tool, you must not just learn the new tool, you must <em>apply it to new kinds of problems</em>. It&#8217;s no good learning to replace simple iteration with first-class functions: all you&#8217;ve learned is syntax. To really learn first-class functions, you must seek out problems that aren&#8217;t easily solved with iteration.<br /><br /><strong>The Why of Y</strong><br /><br />Which leads me back to fixed point combinators. They appear to have no practical (as in making money) use. And that&#8217;s why I&#8217;m suggesting to you that you figure out how to make one in your language of choice. The very fact that the problem is far outside of your realm of &#8220;practicality&#8221; guarantees that you will learn something. You won&#8217;t be simply applying your same-old, same-old techniques and patterns to a slightly new problem.<br /><br />Start your research with Richard P. Gabriel&#8217;s <a href="http://www.dreamsongs.com/NewFiles/WhyOfY.pdf">The Why of Y</a>. Try porting his examples directly to your favourite programming language. If what you want to use is too brain-damaged to support closures, you may need to do a little greenspunning and build a little <a href="http://en.wikipedia.org/wiki/Function_object">functor</a> infrastructure.<br /><br />Don&#8217;t be dissuaded if you have to follow the functor route: you are learning far more about your language and about programming in general than the shmoes that settle for learning five new buzzwords related to the latest WS-* interoperability with XPath 3.x.<br /><br />If you prefer a <a href="http://raganwald.github.com/2007/02/its-monday-its-snowing-and-im-actually.html">fun</a> approach to learning, you can do not better than Raymond Smullyan&#8217;s <a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: an enjoyable romp through the world of combinatory logic. After reading this book, you will have mastered the S, K, I, Y, and other combinators. Added bonuses include a safe that can only be opened by applying G&ouml;del&#8217;s Incompleteness Theorem to its combination. How can you read this book and <em>not</em> learn?<br /><br /><strong>Eating my own dog food</strong><br /><br />I thought of a few things to say along these lines last week and then I abruptly realizing I was asking you to &#8220;Do as I say, not as I do.&#8221; What good is recycling problems I first encountered in University textbooks two decades ago? I put this post aside and set to work on a problem of my own.<br /><br />I set out to write a function for making recursive functions&#8212;a function <a href="http://en.wikipedia.org/wiki/Extensional_equality">extensionally equal</a> to the Y combinator&#8212;in Ruby. The ultimate goal is to take something like:<br /><br /><pre><code>lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) } }<br /></code></pre><br /><br />And be able to have it call itself recursively. In this case, to compute the <code>factorial</code> function.<br /><br />This is trivial, given that Ruby supports named recursion, but if you want to write a fixed-point combinator you want to write a function that makes recursive functions <em>without using the host language&rsquo;s support for named recursive calls</em>. In other words, you are bootstrapping named recursion out of anonymous first-class functions.<sup>1</sup><br /><br />There are important theoretical implications of being able to do this, but the killer reason to try it is to learn.<br /><br />I started my quest for a function for making recursive functions with a rather trivial observation based on OO programming and the Curry function:<br /><br /><pre><code>require 'test/unit'<br /><br />class ExempliGratia &lt; Test::Unit::TestCase<br /><br />  CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br /><br />  def test_recursive_curry<br />    maker = lambda { |func_with_me|<br />      CURRY.call(func_with_me, func_with_me)<br />    }<br />    assert_equal(120, maker.call(lambda { |me, n| n.zero? &amp;&amp; 1 or n * me.call(me, n-1) }).call(5))<br />  end<br /><br />end<br /></code></pre><br /><br />In OO some language implementations, <code>this</code> (or <code>self</code>) is a hidden parameter passed to each method. Thus, there&#8217;s a parameter&#8212;<code>me</code> in the example code&#8212;that is added for handling recursion. If you write a recursive function&#8212;like the venerable <code>factorial</code>&#8212;with the extra <code>me</code> parameter, a trivial currying operation evaluates it recursively without any need for names.<br /><br />This is obviously deficient. As noted above, we want to write <code>factorial</code> like so:<br /><br /><pre><code>lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) }<br /></code></pre><br /><br />We&#8217;ll need an <code>f</code> from somewhere, and just as our Scheme colleagues do, we&#8217;ll bind one as a parameter in an enclosing lambda. So we want to write:<br /><br /><pre><code>lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) } }<br /></code></pre><br /><br />And somehow this should be transformed into a working <code>factorial</code> function. For the test-driven crowd, we want to write:<br /><br /><pre><code>def test_clean_up_loose_ends<br />  maker = ...<br /><br />  factorial = maker.call(<br />    lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />  )<br />  assert_equal(120, factorial.call(5))<br /><br />  iterative_factorial = maker.call(<br />    lambda { |f| lambda { |n, acc| n.zero? &amp;&amp; acc or f.call(n - 1, n * acc) } }<br />  )<br />  tail_factorial = lambda { |n| iterative_factorial.call(n, 1) }<br />  assert_equal(120, tail_factorial.call(5))<br />end<br /></code></pre><br /><br />Of course, we need some code for <code>maker</code>. And the <code>iterative_factorial</code> case shows that <code>maker</code> works for functions with more than one parameter. The solution I came up with is:<br /><br /><pre><code>CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br />maker = lambda { |f|<br />       lambda { |func_with_me| CURRY.call(func_with_me, func_with_me) }.call(<br />            CURRY.call(lambda { |inner_func, me, *args|<br />                        inner_func.call(CURRY.call(me, me)).call(*args) }, f)) }<br /></code></pre><br /><br />The source code with each transformation from beginning to end is <a href="http://weblog.raganwald.com/source/curry_combinator.html">here</a> (I strongly suspect that this &#8220;curry combinator&#8221; is actually the Y combinator with a huge amount of cruft hanging off it).<br /><br />Unique or derivative, crap or craft, the process of getting it to work has enriched my mind by forcing me outside of my usual problem space. I still can&rsquo;t think of a practical application for what I&rsquo;ve just written. But I know I&rsquo;ve stretched myself.<br /><br />And now back to you: perhaps you&rsquo;re rushing off to try to implement a fixed-point combinator from first principles. Perhaps your plan is to code the canonical examples in your usual language. Those are both good paths. But whether you follow them today or not, remember the underlying principle exemplified by the fixed-point combinator:<br /><br /><em>Do not dismiss impractical or weird problems. While you may not have an immediate application for the code you write to solve such problems, you are maximizing your learning when you venture outside of your usual problem space.</em><br /><br /><hr/><br /><ol><li>Named recursion is stuff like <code>foo = lambda { |...| foo.call(:bar) }</code>. It takes advantage of the host language&rsquo;s variable binding to recurse. If you want anonymous recursion, you should be able to assign the same <code>lambda</code> to another name and have it work just as well, as in: <code>fufu = lambda { |...| foo.call(:bar) }</code>. That won&rsquo;t work if you are relying on Ruby&rsquo;s name for <code>foo</code>.</li></ol><br />p.s. Don&rsquo;t miss <a href="http://raganwald.github.com/2007/02/guest-blogger-tom-moertel-derives-y.html">Tom Moertel&rsquo;s derivation of the Y combinator in Ruby</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html" title="permanent link">12:06 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, January 31, 2007</div>
			

			<div class="Post"><a name="117030666664178098">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html" title="permanent link">Closures and Higher-Order Functions</a></span>
					<div style="clear:both;"></div>There has been a great deal of interest in <em><a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html">closures</a></em> lately, driven in great part by the fact that there is talk of adding some form of anonymous functions to the Java. Most of the time, people talk about “adding closures” to Java, and that prompts a flurry of questions of the form “what is a closure and why should I care?”<br /><br />The discussion around closures tends to go on and on about the “closing over” of free variables and only lightly touch on the biggest change to Java: functions as first-class objects with a lightweight syntax for creating them. Making it easy to do something basic like define a new function is more than just a little syntactic sugar: it makes it easy to do new things with functions that were impractical when you needed a lot of boilerplate to make anything work.<br /><br /><blockquote>Without understanding functional programming, you can’t invent MapReduce, the algorithm that makes Google so massively scalable.<br /></blockquote><div style="text-align: right;">—Joel Spolsky, <a href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">The Perils of JavaSchools</a><br /></div><br />I’m going to try to explain first class functions using Ruby (it <em>is</em> possible to write code that does exactly the same thing using the current Java feature set, however the result is so wordy that it obscures the basic idea being presented: call it accidental complexity, or perhaps <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html">yellow code</a>.)<br /><br /><a href="http://www.ruby-lang.org/">Ruby</a> is a good language for demonstrating features that ought to be in Java. Like Java, Ruby uses squiggly brace syntax. Like Java, everything in Ruby is an object&mdash;whoops, Java has primitives. Okay, like Java, functions are represented as objects.<br /><br />In Java you write:<br /><br /><pre><code>interface IFromIAndI {<br />   Integer call(Integer a, Integer b);<br />}<br /><br />IFromIAndI add_two_integers = new IFromIAndI() {<br />   public Integer call(final Integer a, final Integer b) {<br />      return a + b;<br />   }<br />};<br /></code></pre><br />(The Java convention is to name things in <a href="http://en.wikipedia.org/wiki/CamelCase">lowerCamelCase</a>, but we’ll ignore that. If you need to print this essay on a dot-matrix printer you may want to make some changes first.)<br /><br />In Ruby you write the function as:<br /><br /><pre><code>add_two_integers = lambda { |a,b| a + b }<br /></code></pre><br />Later on, when you want to call your function in Java, you write:<br /><br /><pre><code>add_two_integers.call(35, 42);<br /></code></pre><br />And if you like semicolons, you write the <em>exact same thing</em> in Ruby:<br /><br /><pre><code>add_two_integers.call(35, 42);<br /></code></pre><br />You can do the same thing with multiplication:<br /><br /><pre><code>multiply_two_integers = lambda { |a,b| a * b }<br /></code></pre><br /><strong>First Class Functions</strong><br /><br />In the examples above, functions look a little like methods. The Java version is obviously implemented as a method. But what we did in both cases was assign the resulting function to a variable. In Java, assigning a method to a variable is not particularly easy (it is possible using reflection).<br /><br />Anything that can be assigned to a variable is a <em>value</em>. If it can also be passed as a parameter or returned from a method (or function), we say it is a <em>first class value</em>. Functions as first class values, or first class functions, are very interesting. For example, what can we do passing a function as a parameter to another function?<br /><br />Hmmm. Well, I am breaking a cardinal rule of selling something. We’re talking about shiny new toys without identifying a problem to be solved. Let’s talk about my favourite problem: writing the same thing more than once, violating the <acronym title="Don't Repeat Yourself">DRY</acronym> principle.<br /><br />Here are two pieces of similar Ruby code:<br /><br /><pre><code>adder_wth_acc = lambda { |acc, list|<br />   if list.empty?<br />      acc<br />   else<br />      adder_wth_acc.call(acc + list.first, list[1..-1]) # [1..-1] returns a copy of the list without the first element<br />   end<br />}<br />adder = lambda { |list|<br />   adder_wth_acc.call(0, list)<br />}<br />adder.call([1, 2, 3, 4, 5])<br /></code></pre><br />And:<br /><br /><pre><code>multiplier_with_acc = lambda { |acc, list|<br />   if list.empty?<br />      acc<br />   else<br />      multiplier_with_acc.call(acc * list.first, list[1..-1]) # [1..-1] returns a copy of the list without the first element<br />   end<br />   }<br />   multiplier = lambda { |list|<br />   multiplier_with_acc.call(1, list)<br />}<br />multiplier.call([1, 2, 3, 4, 5])<br /></code></pre><br />What do they both do? Pretty much the same thing: they accumulate the result of some binary operation over a list of values. <code>adder</code> accumulates addition, and <code>multiplier</code> accumulates multiplication. You could call this a “Design Pattern.” If you did that, you would use the exact chunk of code everywhere. I would call that retrograde. Didn’t our predecessors invent the subroutine so we could eliminate writing the exact same piece of code over and over again?<br /><br />Why can’t we do the same thing? Well, we can. A subroutine does the same thing over and over again, but it takes different parameters as it goes. What is different between adder and multiplier? Ah yes, the adding and multiplying. Functions. What we want is a function that takes a function as a parameter.<br /><br />Well, we said that with first-class functions, functions are values and can be passed as parameters. Let’s try it:<br /><br /><pre><code>folder = lambda { |default_value, binary_function, list|<br />   fold_with_acc = lambda { |acc, list|<br />      if list.empty?<br />          acc<br />      else<br />          fold_with_acc.call(binary_function.call(acc, list.first), list[1..-1])<br />      end<br />   }<br />   fold_with_acc.call(default_value, list)<br />}<br /></code></pre><br />Now we can use our function that takes functions as a parameter:<br /><br /><pre><code>folder.call(0, add_two_integers, [1, 2, 3, 4, 5])<br />folder.call(1, multiply_two_integers, [1, 2, 3, 4, 5])<br /></code></pre><br />This is <strong>much</strong> better. When functions can take functions as parameters, we can build abstractions like <code>folder</code> and save ourselves a lot of code. Note that this would be a lot harder to read if we had to surround all of our functions with Object boilerplate in Java. That’s one of the key reasons why ‘syntactic sugar’—making it brief—is a big win.<br /><br />And you know what? Functions are values, not just variables that happen to hold functions. These work just as well:<br /><br /><pre><code>folder.call(0, lambda { |a, b| a + b }, [1, 2, 3, 4, 5])<br />folder.call(1, lambda { |a, b| a * b }, [1, 2, 3, 4, 5])<br /></code></pre><br />There’s just one problem (actually two, but I’m saving one for later): everywhere you use our new <code>folder</code> function, you need to remember that <code>add_two_integers</code> needs a default value of zero, but <code>multiply_two_integers</code> needs a default value of one. That’s bad. Sooner or later you will get this wrong.<br /><br />What we need is a way to call <code>folder</code> without having to always remember the correct initial value. Should we extend our understanding of a function to include a default initial value for folding? If we’re thinking in Java, maybe our <code>IFromIAndI</code> interface needs a <code>getDefaultFoldValue</code>? I think not. Why should a function know anything about how it’s used? And besides, as we build other abstractions out of functions we’ll need more stuff.<br /><br />If we aren’t careful, we’ll end up implementing the <code>Visitor</code> pattern on functions, and all of our brevity will go out the window. No, what we want is this: in one place we define that folding addition starts with a default value of zero and in another place we say we want to fold, say, <code>[1, 2, 3, 4, 5]</code> with addition. Then when we want to fold something else with addition, like <code>[2, 4, 6, 8, 10]</code>, we shouldn’t have to say anything about zero again.<br /><br /><strong>Adding Curry</strong><br /><br />What we need is a function that folds addition. Didn’t we say that functions are values that can be returned from functions? How about a function that makes a folding function? We should pass it our initial value and our binary function, and it should return a function that performs the fold without needing an initial value as a parameter:<br /><br /><pre><code>fold_coder = lambda { |default_value, binary_function|<br />   fold_with_acc = lambda { |acc, list|<br />      if list.empty?<br />          acc<br />      else<br />          fold_with_acc.call(binary_function.call(acc, list.first), list[1..-1])<br />      end<br />   }<br />   lambda { |list|<br />      fold_with_acc.call(default_value, list)<br />   }<br />}<br /></code></pre><br />Now we can do the following:<br /><br /><pre><code>adder = fold_coder.call(0, lambda { |a, b| a + b })<br />adder.call([1, 2, 3, 4, 5])<br />adder.call([2, 4, 6, 8, 10])<br /></code></pre><br />No more remembering that addition starts with a default of zero.<br /><br /><blockquote>Actually, there’s a far simpler way to avoid having to remember the default value when you want to fold over addition. But let’s just play along so that we don’t have to come up with an entirely new set of examples to demonstrate the value of functions as first-class values.<br /></blockquote>Functional programmers (as opposed to the rest of us <em>dysfunctional</em> programmers) will recognize this as <a href="http://en.wikipedia.org/wiki/Currying">currying</a> our <code>folder</code> function. Currying is when a function takes more than one parameter and you combine one of the parameters and the function to produce a function that takes fewer parameters.<br /><br />Here’s a currying function in Ruby:<br /><br /><pre><code>curry = lambda { |fn,*a|<br />   lambda { |*b|<br />     fn.call(*(a + b))<br />   }<br />}<br /></code></pre><br />(<em>This is an improvement on an earlier version, thanks to Justin's <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html#117037273013059827">comment</a>.</em>)<br /><br />So you can use our new function to create an increment function out of our adder and a treble function out of our multiplier:<br /><br /><pre><code>plus_one = curry.call(add_two_integers, 1)<br />times_three = curry.call(multiply_two_integers, 3)<br /></code></pre><br /><br />If you are ever asked, “what good is currying?,” I hope I’ve given you an example you can use to explain why currying matters, and why people do it all the time (possibly without explicitly naming it). Although it doesn’t look like much when looking at trivial examples like functions that multiply by three, it’s much more useful when creating folders and mappers where you want some of the parameters to remain constant.<br /><br /><strong>Composition</strong><br /><br />Our examples combined functions and non-functions to create new functions. Here’s an example from a recent post, <a href="http://raganwald.github.com/2007/01/dont-overthink-fizzbuzz.html">Don’t Overthink FizzBuzz</a>, where I give a method for <em>composing</em> two functions. The idea is that if you have multiple functions that each take one argument, you can combine them using <code>compose</code>. I also have a method that generates functions, <code>carbnation</code>:<br /><br /><pre><code># fizzbuzz.rb<br /><br />def compose *lambdas<br />  if lambdas.empty?<br />    lambda { nil }<br />  elsif lambdas.size == 1<br />    lambdas.first<br />  else<br />    lambda do |n|<br />      lambdas.first.call(compose(*lambdas[1..-1]).call(n))<br />    end<br />  end<br />end<br /><br />def carbonation(modulus, printable_form)<br />  i = 0<br />  lambda do |n|<br />    (i = (i + 1) % modulus) == 0 && printable_form || n<br />  end<br />end<br /><br />print(((1..100).map   &compose(     carbonation(15, 'FizzBuzz'), carbonation(5, 'Buzz'), carbonation(3, 'Fizz'))).join(' '))<br /><br /></code></pre><br />The simple explanation of how it works is that <code>carbonation</code> generates functions that replace every so many elements of a list with a printable string. <code>Compose</code> composes any two or more methods together. So if you want to print out 100 numbers, but replace every third number with “Fizz,” every fifth with “Buzz,” and all those that are third <strong>and</strong> fifth with “FizzBuzz,” you generate a function for each replacement, compose them together with compose, and then map the numbers from one to one hundred to the resulting überfunction.<br /><br />When you look at this today, it seems weird and unreadable by Java standards. I wonder if adding first-class functions with simple syntax to Java will lead the Java community to a place where code like this will not appear out of place?<br /><br /><strong>Just one more thing</strong><br /><br />So we started by saying that people are getting hung up on what makes a closure a closure, and there has been less emphasis on the benefits of using functions as first-class values. Did you notice that our <code>folder</code> function actually includes a non-trivial closure?<br /><br />If you look at the <code>fold_with_acc</code> function, it makes use of <code>binary_function</code>, a variable from its enclosing lexical scope. This is not possible with the current version of Java: if you translate this to Java, when you make <code>fold_with_acc</code> and anonymous inner class, you will have to copy <code>binary_function</code> into a final member to use it. It simply won’t compile if you try an idiom-for-idiom translation, even adding explicit types.<br /><br />And then if you look at the anonymous function it returns, <code>lambda { |list| fold_with_acc.call(default_value, list) }</code>, that anonymous function uses <code>default_value</code>,another variable from the enclosing lexical scope. Once again you will have to fool around with final variables to make this work, or perhaps declare full-fledged object with constructors.<br /><br />(If you try writing this simple example out in Java, you quickly find yourself inventing a lot of classes or interfaces. And they have some complicated types, like a function taking an integer and a function taking two integers, returning a function taking a list of integers and returning an integer.<br /><br />After twenty minutes of that, you understand why the <a href="http://www.ml.com/">ML</a> and <a href="http://planet.haskell.org/">Haskell</a> communities use <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: If the types are that complicated, it&rsquo;s incredibly helpful to have the compiler check them for you. Yet if the types are that verbose, it&rsquo;s incredibly painful to write them out by hand. Even if your IDE were to write them for you, they take up half the code, obscuring the meaning.<br /><br />You also get why the Ruby on Rails community doesn&rsquo;t care about type checking: types for CRUD applications are way less complicated than types for first-class functional programs.)<br /><br /><strong>That’s Interesting</strong><br /><br />Part of the interest in closures is in simplifying the syntax around functions, and part of the interest is in the way that access to enclosing scope would simplify a lot of code. There’s a whole debate around the value of simplification in a world where all serious languages are <a href="http://scienceblogs.com/goodmath/2007/01/turing_equivalent_vs_turing_co.php#more">Turing Equivalent</a>.<br /><blockquote><br />I hope you’re convinced, by now, that programming languages with first-class functions let you find more opportunities for abstraction, which means your code is smaller, tighter, more reusable, and more scalable.<br /></blockquote><div style="text-align: right;">—Joel Spolsky, <a href="http://www.joelonsoftware.com/items/2006/08/01.html">Can Your Programming Language Do This?</a><br /></div><br />For me, simpler is just nicer until something reaches a certain tipping point: when it becomes so simple that the accidental complexity of using it goes away, I will start using it without thinking about it. Tail optimization is like that: as long as recursion is slower than iteration and sometimes breaks, I have to think about it too much. But when I’m not burdened with “except…” and “when performance is not a factor…” it becomes natural.<br /><br />And then something interesting happens. It changes the way I look at problems, and one day I see a whole new way to do something that I never saw before. Functions as first class values are definitely one of those things that change everything.<br /><br /><span style="font-weight: bold;">Further Reading<span style="font-weight: bold;"><br /><br /></span></span>If this has whet your appetite for more, <a href="http://www.amazon.com/gp/product/0262011530?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&camp=211189&amp;creative=373489&creativeASIN=0262011530">Structure and Interpretation of Computer Programs</a> is <span style="font-style: italic;">the</span> book on higher-order functions and how they can be used as building blocks to create more elaborate abstractions such as object-oriented programming.<br /><br /><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a> devotes an entire book to the uses of functions. Although the examples are in Scheme, the language is dead simple to learn and the techniques in the book can be applied to Ruby and Java (or at least to a future version of Java where you do not need functors).<br /><br />The second edition of <a href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&camp=211189&amp;creative=373489&creativeASIN=0974514055">Programming Ruby</a> is an indispensable guide. Even if you will not be using Ruby immediately, pick it up and discover why so many people are lauding the language's simple, clean design and powerful Lisp-like underpinnings.<br /><br />As the author says, &ldquo;<a href="http://www.amazon.com/gp/product/1558607013?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1558607013">Higher-Order Perl: Transforming Programs with Programs</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1558607013" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is about functional programming techniques in Perl. It&rsquo;s about how to write functions that can modify and manufacture other functions.<br /><br />&ldquo;Why would you want to do that? Because that way your code is more flexible and more reusable. Instead of writing ten similar functions, you write a general pattern or framework that can generate the functions you want; then you generate just the functions you need according to the pattern. The program doesn&rsquo;t need to know in advance which functions are necessary; it can generate them as needed. Instead of writing the complete program yourself, you get the computer to write it for you.&rdquo;<br /><br />It&rsquo;s worth reading even if you have no intention of using Perl: the ideas span languages, just as SICP is worth reading even if you don&rsquo;t use Scheme at work. And be sure to read <a href="http://interglacial.com/hoj/">Higher-Order JavaScript</a> and <a href="http://blog.grayproductions.net/articles/category/higher-order-ruby/">Higher-Order Ruby</a>. They translate HOJ&rsquo;s ideas to other languages.<br /><br /><i>Notable Follow-ups:</i><br /><br /><a href="http://www.randomhacks.net/articles/2007/02/01/some-useful-closures-in-ruby">Some useful closures, in Ruby</a>: &ldquo;The <a href="http://en.wikipedia.org/wiki/Dylan_programming_language">Dylan programming language</a> included four very useful functions for working with closures: <strong>complement</strong>, <strong>conjoin</strong>, <strong>disjoin</strong> and <strong>compose</strong>.  The names are a bit obscure, but they can each be written in a few lines of Ruby.&rdquo;<br /><br /><a href="http://www.wuenschenswert.net/wunschdenken/archives/117">From Functional to Object-Oriented Programming</a>: &ldquo;OO allows a traceable connection between the conceptual design level and the implementation level. Concepts have names, so you can talk about them, between programmers and architects.&rdquo;<br /><br /><a href="http://raganwald.github.com/2007/02/hof-or-oop-yes.html">HOF or OOP? Yes!</a>: &ldquo;First-class functions are a natural fit with OO, as evidenced by their presence in OO languages that aren’t glorified PDP-11 assemblers with some OO stuff bolted on the side.&rdquo;<br /><br /><a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>: &ldquo;To truly learn a new tool, you must not just learn the new tool, you must apply it to new kinds of problems. It’s no good learning to replace simple iteration with first-class functions: all you’ve learned is syntax. To really learn first-class functions, you must seek out problems that aren’t easily solved with iteration.&rdquo;<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html" title="permanent link">11:55 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, January 18, 2007</div>
			

			<div class="Post"><a name="116914365603826794">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/business-programming-standards-have.html" title="permanent link">Business programming standards have become higher in 2007. Learn to love it.</a></span>
					<div style="clear:both;"></div>From time to time people suggest that fundamental computer science familiarity is irrelevant to the work of a business programmer. I am talking about a knowledge of <a href="http://blogs.msdn.com/ericlippert/archive/2004/05/19/135392.aspx" title="How not to teach recursion">recursion</a>, operations on data structures, code generation, and other topics that are often derided as being &#8220;unnecessary&#8221; in a business programming context.<br /><br />Hmmm.<br /><br />I think this is wrong in 2007. It may not have been wrong in <a href="http://raganwald.github.com/2007/01/where-were-you-on-saturday-november-9.html" title="Where were you on Saturday, November 9th, 2002?">2002</a>, perhaps such knowledge was a bonus but not a basic requirement. But today, I think you need to have it. And I don&#8217;t mean, you need to have it on your resum&eacute;. I mean, you will use it on your job from time to time.<br /><br />Now, I know that some readers are shaking their heads, <strong>no</strong>. And some are nodding their heads, <strong>yes</strong>. It&#8217;s easy to think this is all about culture, and some kind of weird hacker fraternity, or whatever. It&rsquo;s especially easy to dismiss stuff you never use: if you never needed it before, why would you need it now?<br /><br />That&rsquo;s the <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a> talking. Your toolbox is good enough because you've never needed anything else to do a job... <em>up to now</em>.<br /><br />No matter what you think of Lisp, Google-style interviews (do you remember when they were &ldquo;Microsoft-style interviews&rdquo;?), or optimizing code, please put that aside and try to read this post as objectively as possible. I&#8217;ll lay out my thinking for you.<br /><br />When you say &#8220;these things are not relevant for the job,&#8221; how do you know? Ok, you have twenty years of experience. And you&#8217;ve never used recursion or you&#8217;ve <a href="http://discuss.joelonsoftware.com/default.asp?joel.3.426416.61" title="Joel on Software discussion about recursion">only used it once or twice</a>. So you won&#8217;t need it now, you&#8217;ll find a way to use iteration. And who cares what a <a href="http://en.wikipedia.org/wiki/Suffix_array">suffix array</a> is, you&#8217;ll look it up in wikipedia if you need to implement one.<br /><br />That&#8217;s what people have done for quite a while: wire existing frameworks together. What programmers need to know is how to Google stuff, and what a programmer need on her desktop is an IDE that auto-completes stuff so she&#8217;ll know what the methods are called. And of course, static typing to make sure she gets the method parameters right. Good to go.<br /><br /><blockquote>There are jobs out there like that. Last year&#8217;s jobs.</blockquote><br />Well, there <em>are</em> jobs out there like that. Last year&#8217;s jobs. But how do you know the one I&#8217;m filling in 2007 is one of those? Because I told you that for this position we are working with one of the world&#8217;s largest financial institutions on a public-facing J2EE application that has been in service for more than five years?<br /><br />Now, I agree that you have figured out 98% of what we do. Most of the time, we mess with XSLT, message queues, JDBC through a DAL, and other buzzword compliant tasks. The keys to success for those items is less about programming brilliance than around discipline, process, requirements management, and the other stuff the &#8220;no hard CS&#8221; folks want to talk about in the interview.<br /><br />And of course, we <strong>care</strong> about skills in those areas. We have to, we can&#8217;t hire someone who can distribute data sets across a grid but is unable to negotiate requirements effectively with a business analyst. But let&#8217;s talk about the other 2%.<br /><br /><strong>The top two percent</strong><br /><br />From time to time we get some challenges. Here are some recent examples:<br /><br />As part of a refactoring effort last year, we wrote some Java that used Reflection and Dynamic Proxies to replace an entire layer of the application that used to include extensive hand-coding of stuff that was repetitive and error-prone. This saves us 80-90% of the code in that layer when we add new stuff to the application. A testing utility the year before used Reflection to automatically write a certain JUnit suite.<br /><br /><blockquote>You know how bit-twiddling in Java is irrelevant because you&#8217;re waiting for the database any ways? Well, we can&#8217;t afford to wait for this particular function, it&#8217;s one of those AJAX-y things that happens in real time. We can&#8217;t wait to go back to the database.</blockquote><br />We&#8217;re working on something right now that is highly performant. We have a seven-figure user base, and peak loads are intense. You know how bit-twiddling in Java is irrelevant because you&#8217;re waiting for the database any ways? Well, we can&#8217;t afford to wait for this particular function, it&#8217;s one of those AJAX-y things that happens <strong>in real time</strong>. We can&#8217;t wait to go back to the database. So we have to load something into memory on the server, build a compact data structure, and traverse it quickly. And oh yes, we can&#8217;t have a lot of layers of crap, we need to get a response back to the browser with every key press.<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262561158"><img border="0" src="http://raganwald.github.com/uploaded_images/a_little_java-777624.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262561158" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><em><br /><br /><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of The Little Schemer and The Little MLer bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em></div>For another client, we had to build a task dispatching system. It was like building a piece of a very lightweight fault-tolerant operating system. That operated across data centres in three different cities, moving jobs around from centre to centre. If you were in an interview and someone posed one of those hypothetical &#8220;how would you design a &#8230;&#8221; problems, would you think they stole the problem from some Amazon programmer&#8217;s weblog? Would you think &#8220;you don&#8217;t need that for business programming?&#8221; Well, we built that. For an ordinary, brick and mortar business that makes physical stuff.<br /><br />That 2% figure? That was in 2006. In 2007, it will be way more. Standards are rising. We&#8217;re doing more and more work that steps outside of the usual <acronym title="Create-Read-Update-Delete">CRUD</acronym> development. <br /><br />Here&#8217;s the big reason why. Have you read people grousing about interviews where they&#8217;re asked about how to implement a search? And about what a waste it is because 99% of the time the database does it, and the rest of the time they stick it in a hash table? Well, in 2007 <strong>search matters</strong>. The database is a big part of that, but it&#8217;s not as easy as <code>SELECT foo.* FROM bar WHERE ...</code> any more.<br /><br /><strong>The Google Effect</strong><br /><br />Google has become the &#8220;start page of the internet.&#8221; As a result, everyone now thinks that the way to find stuff is to do a full text search. Everyone thinks that relevant results should be first. And I mean everyone, not just your &#8220;early adopter&#8221; users, you now have Joe Average calling your customer support hotline and complaining that the search page on your application&#8212;the one with a different field for each column in each table&#8212;is too hard and why can&#8217;t he just type something and get an answer?<br /><br /><blockquote>This stuff isn&#8217;t rocket science. And you don&#8217;t need Common Lisp or Haskell to pull it off. You can do it in Java or C#.</blockquote><br />Just how do you plan to implement full text search? Buy it from Google or Oracle? And do you think you can do the &#8220;Google Suggest&#8221; thing with the drop down? In real time?<br /><br />Users now love having a single search box. They don&#8217;t want to have one box for searching on product SKU and a drop-down for searching on supplier name. One box. And if you want to make searching for supplier name easy, give them an auto-complete. Users don&#8217;t like to be given an application that basically has the implementation protruding into the interface.<br /><br />They don&#8217;t care that you store first name and last name in separate columns, they want to search for &#8220;Reg Braithwaite&#8221; and find him, even if &#8220;Reginald&#8221; is what&#8217;s stored in the first name column and there are 3,215 Braithwaites in the table. You figure it out, possibly by word stemming, possibly by statistical analysis. Or maybe you&#8217;re just doing some untrained bayesian classification to cluster the &#8220;Reginald Braithwaite&#8221; record with some other things the user is looking at right now so you put that record at the top of the list you returned.<br /><br />Hmmm, we&#8217;re not in Kansas any more. It isn&#8217;t all about <code>has_one</code>, <code>has_many</code>, or <code>has_and_belongs_to_many</code>, and you don&#8217;t have to be a <a href="http://www.powerset.com">high-profile start up</a> to care. Jane Average uses stuff like this when she reads her mail and books her vacation. But does her office HR support application work half as well? Why not?<br /><br />This stuff isn&#8217;t rocket science. And you don&#8217;t need Common Lisp or Haskell to pull it off. You can do it in Java or C#: we do it and there are thousands of places just like ours where people just like us are doing it every day.<br /><br />But in 2007, you do need to let go of the idea that all we&#8217;re doing with &#8220;business programming&#8221; is building web applications that are replacing the client-server applications of the eighties and nineties that themselves replaced the green screen terminal applications of the seventies and eighties.<br /><br />The &#8220;leading edge&#8221; interface and ideas employed by Google, Amazon, eBay, and Yahoo! are suffusing our culture to become the standard user interface of web applications. And programming the standard user interface is a basic job requirement. Learn to love it.<br /><br /><hr /><br /><em>Do you love applications like Google Mail? Would you like to write stuff like this, even if it&#8217;s less than 100% of the time? But are you looking for a stable company working on stuff you can explain to your neighbors? <a href="mailto:apply@devtopia.com">Michael Lucas</a> is hiring intermediate and senior developers for positions in Toronto, Canada. To be considered for a position, please send Michael an email with your answer to the following question:</em><br /><br /><blockquote>Name three features from public web &#8216;sites&#8217; like Google, Amazon, and YouTube (you can pick any site or sites you like) that will make the jump to business applications in 2007.</blockquote><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/business-programming-standards-have.html" title="permanent link">12:59 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, January 15, 2007</div>
			

			<div class="Post"><a name="116889503774201560">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="permanent link">What I've Learned from Sales, Part II: Wanna Bet?</a></span>
					<div style="clear:both;"></div>In Part I of &#8220;What I&#8217;ve Learned from Sales,&#8221; <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">Don&#8217;t Feed the Trolls</a>, we looked at why resistance to a new idea is expressed as a never-ending series of objections. We looked at one powerful way to avoid objections, by identifying a real, urgent problem that needs to be solved. The next installment, Part III, <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html">How to use a blunt instrument to sharpen your saw</a>, describes the mind-set that there are opportunities for improvement to be found everywhere.<br /><br />In this part, we&#8217;re going to disregard my advice to avoid objections and talk about one way to respond to many of the objections raised against new ideas.<br /><hr /><br /><strong>Can we overcome objections?</strong><br /><br />Right off the top, I want to say that I don&#8217;t believe you can &#8220;overcome&#8221; an objection by frontal assault. And furthermore, you shouldn&rsquo;t try. You cannot persuade someone to consider an idea by debating them into submission.<br /><br />My belief is that you must <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">discover and address their true problem</a>. The first reason to do so is that if they do not have a problem your idea can solve, there is no reason for them to &ldquo;change for change&rsquo;s sake.&rdquo; The second reason is that if you are not solving a real, genuine problem for them you will get caught defending an idea against an endless series of objections.<br /><br />That being said, there are some circumstances where it is important to respond directly to objections. Even if we have carefully qualified someone&#8217;s problem and explained how a new idea will solve their problem, a prudent person will analyse the idea carefully, looking for fatal defects that could prevent it from solving their problem.<br /><br />Another common circumstance is when there are several parties involved in presenting, discussing, and analysing an idea. Although one of the parties may be bringing up irrelevant objections to resist the idea, you may need to persuade another of the parties that these irrelevant objections do not have merit.<br /><br />For example, you may be suggesting that <a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html" title="Dear Agile Metaprogrammer">agile meta-programming</a> will solve a company&#8217;s problems to the CEO. You may have carefully qualified the CEO&#8217;s priorities. But the company&#8217;s IT department will raise objections because your proposals do not address their personal and departmental problems. So you <em>will</em> need to respond to some of their objections as part of a campaign to neutralize their influence.<br /><br /><strong>What is overcoming an objection?</strong><br /><br />Overcoming an objection is, to borrow a phrase from law, &ldquo;A sword, not a shield.&rdquo; When you overcome an objection, you point out that the reason for not considering your new idea is fallacious, or does not apply in this case.<br /><br />However, overcoming the objection does not actually provide a reason to change: it merely removes a reason <em>not</em> to change. This is why <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">Part I</a> goes on and on about discovering an immediate problem your idea can fix. If you overcome an objection but have not presented a compelling reason to change, nothing will happen.<br /><br />In other words, if someone says &ldquo;I like your idea, however...&rdquo; you should attempt to overcome the objection. If someone says &ldquo;Your idea stinks because...&rdquo; you really need to gidentify a problem to solve.<br /><br /><strong>One model for responding to common objections</strong><br /><br /><blockquote><br />  A gotcha objection is a proposition that your idea is false based on a premise that is true infrequently or only true for some small number of cases.<br /></blockquote><br /><br />Let&#8217;s assume you are going to respond to an objection, and you have good reason for doing so. Here&#8217;s one common form of objection, and a method for responding to the objection. In essence, I am going to share a pattern with you.<br /><br />First, let&#8217;s look at one of the most common kinds of objections. Here are some examples. They all have something in common:<br /><br /><ul><li>&#8220;Sometimes you <em>are</em> gonna need it, so you&#8217;re wasting time if you don&#8217;t build it in from the beginning. Therefore, we should build what we know we&#8217;ll need.&#8221;  </li><br /><li>&#8220;Some bugs simply can&#8217;t be found through automated unit tests, sorry. This is why we have to use a programming language with static typing.&#8221;  </li></ul><br />What these objections all have in common is what I call the &#8220;gotcha!&#8221; <a href="http://www.infidels.org/library/modern/mathew/logic.html" title="Logic and Fallacies">fallacy</a>. The underlying assumption is that if your idea does not work 100% of the time, on 100% of the cases, it is no damn good. And thus I call an objection based on the gotcha fallacy a <strong>Gotcha Objection</strong>. A gotcha objection is a proposition that your idea is false based on a premise that is true infrequently or only true for some small number of cases.<br /><br /><strong>P is for Pharmaceutical</strong><br /><br />Think about therapies in medicine. None of them are deterministic! Every pill, every technique, every therapy is described in probabilistic terms: <em>When compared to the control group who drank a glass of red wine daily but did little exercise, 36.7% of those who combined daily exercise with a glass of red wine had an average improvement of 22.1% in their combined evaluation scores for cardiovascular health</em>.<br /><br />Try this the next time you&#8217;re at the doctor&#8217;s office: point out to your physician that you have heard that some people who exercise <a href="http://en.wikipedia.org/wiki/Jim_Fixx" title="Jim Fixx">drop dead right after their daily run</a>. Use this as an excuse not to exercise.<br /><br />Now, software development is not the same thing as medicine, and I am not suggesting you respond to criticism by saying that since some drugs do not work for some patients that your ideas have merit regardless of evidence or suggestions to the contrary. But I will walk you through the reasoning that leads to the same conclusion.<br /><br /><strong>How to respond to gotcha objections</strong><br /><br />Our pattern for responding to these gotcha objections is to establish that software development is <em>probabilistic</em> in practice. Once we establish this premise, we then turn the debate from whether there are cases where a particular practice does not appear to be optimal to whether the overall results of applying that practice is better than not applying that practice.<br /><br />That&#8217;s it, and if you&#8217;re in a hurry you can stop right here: everything else is an elaboration of this idea.<br /><br /><strong>Exempli gratia: the technique in action</strong><br /><br /><strong>Objection</strong>: &#8220;Sometimes you <em>are</em> gonna need it, so you&#8217;re wasting time if you don&#8217;t build it in from the beginning. Therefore, we should build what we know we&#8217;ll need.&#8221;  <br /><br /><strong>Response</strong>: Well, sometimes you need it, sometimes you don&#8217;t. And when you don&#8217;t need it, you save the code you would have written as well as all the other design that becomes coupled to the code you end up throwing out. Of course, sometimes you end up throwing out some stub code, but think about the possibility that you will wind up getting more features done, earlier in the cycle where we can get feedback and reduce risk. Why don&#8217;t we look at whether, in aggregate, more projects will succeed using YAGNI than will succeed using &#8220;Build everything we might need&#8221;?<br /><br /><strong>Objection</strong>: &#8220;Some bugs simply can&#8217;t be found through automated unit tests, sorry. This is why we have to use a programming language with static typing.&#8221;  <br /><br /><strong>Response</strong>: Sure enough, some can&#8217;t be detected with automated unit tests. But our choice of a dynamic language provides us with many other benefits, most especially in the areas of metaprogramming and code reduction. By writing less code, we may even have fewer bugs overall. Shouldn&#8217;t we try to compare similar projects written in a static language against those written in a dynamic language, and see whether the projects in the dynamic language had fewer bugs and whether the projects written in the dynamic language were more likely to be successful?<br /><br />Now that you have seen the <em>results</em> of applying the technique, we will patiently examine the reasoning in detail.<br /><br /><strong>Theory D and Theory P in Software Development</strong><br /><br /><blockquote><br />  Theory P states that the time and effort required to measure all of the variables influencing a software development project precisely enough to predict the outcome with certainty and in advance exceeds the time and effort required develop the software.<br /></blockquote><br /><br />There are two schools of thought about the <em>practice</em> of managing software development (the theory of managing software development is of little use to us because &#8220;the gap between theory and practice is larger in theory than it is in practice&#8221;).<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536"><img border="0" src="http://raganwald.github.com/uploaded_images/critical_chain-794734.jpg"  width="140" height = "208" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0884271536" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br/><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536">Critical Chain</a> explains project management from the ground up in probabilistic terms. It's a significant improvement over the classical approach for managing risk and uncertainty in software development.<br/></div>One school is that everything is fully deterministic in practice (&#8220;Theory D&#8221;). If development appears, from the outside, to be probabilistic, it is only because we haven&#8217;t discovered the &#8220;hidden variables&#8221; that fully determine the outcome of software development projects. And, since we are talking about development in practice, it is <em>practical</em> to measure the variables that determine the outcome such that we can predict that outcome in advance.<br /><br />The other school of thought is that development is fully probabilistic in practice (&#8220;Theory P&#8221;), that there are no hidden variables that could be used to predict with certainty the outcome of a software development project. Theory P states that the time and effort required to measure all of the variables influencing a software development project precisely enough to predict the outcome with certainty and in advance exceeds the time and effort required develop the software.<br /><br />Theory P does not mean that software development cannot be managed in such a way that the desired outcome is nearly certain: the flight of an airplane is fully probabilistic as it encounters atmospheric conditions, yet we have a huge industry built around the idea that airplanes arrive at their destinations and land on the runway as planned.<br /><br />Which theory fits the evidence collected in sixty years of software development? To date, Theory P is the clear winner on the evidence, and it&#8217;s not even close. Like any reasonable theory, it explains what we have observed to date and makes predictions that are tested empirically every day.<br /><br />(Sidebar: do not confuse Computer Science&#8212;the study of the properties of computing machines&#8212;with Software Development, the employment of humans to build computing machines. The relationship between Computer Science and Software Development parallels the relationship between Engineering, the hard science of the behaviour of constructions, and Project Management, the employment of humans to construct engineered artefacts.)<br /><br /><strong>The first response to the gotcha objection</strong><br /><br /><blockquote><br />  The race may not always be to the swift nor the victory to the strong, but that&#8217;s how you bet<br />  &#8212;Damon Runyan<br /></blockquote><br /><br />Before we can go anywhere with gotcha objections, there is something you absolutely, positively must do when you respond. And it must be the very <em>first thing you do</em>. You must establish the fact that the premise of the objection is not universal and not predictable, it is probabilistic.<br /><br />The objection is of the form that &#8220;since your idea works out badly some of the time, your whole idea is bad.&#8221; You must respond by establishing that some of the time the idea doesn&#8217;t appear to work out, and some of the time it does appear to work out. It isn&#8217;t universally bad or universally good.<br /><br />If you are in a face to face discussion, you can solicit agreement from the objecting party. For example:<br /><br /><ul><li>&#8220;Well, sometimes you need it, sometimes you don&#8217;t, sometimes you&#8217;re wasting time, sometimes you aren&#8217;t. Is that right?&#8221;  </li><br /><li>&#8220;So there are <em>some</em> bugs that can&#8217;t be found with automated unit tests and some that can&#8212;am I understanding you correctly?&#8221;</li></ul><br />In a less interactive environment like a running language flame war on Usenet, you can start by simply stating that the premise is not universal.<br /><br />Having established that the premise is not universal you must then establish that the cases where the premise applies are not easily distinguished from the cases where the premise does not apply. Establish that nobody knows whether the premise will apply or not until after it has happened.<br /><br />We simply can&#8217;t tell in advance whether the bugs that would be caught by a static type system will end up being significant to the outcome of a project. We can&#8217;t tell in advance which constructs will end up being a waste of time. And we can&#8217;t tell in advance which people will fail when they try to pair program. (The last point is absolutely true if the people involved are not doing the arguing about whether pair programming will work. If the programmers involved do not believe it will work, they may have a point.)<br /><br />This is the other aspect of establishing that the premise is probabilistic: not only does it only apply some of the time, but we don&#8217;t have a good way of knowing in advance when it applies and when it doesn&#8217;t.<br /><br />Okay, we&#8217;ve gone through all of this dry pseudo-academic talk of theories and probabilistic development. Time for a vacation to Las Vegas.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://flickr.com/photos/markhardie/269236151/"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/casino_royale-725195.jpg" border="0" alt="Casino Royale, follow link for rights information." title="Casino Royale, follow link for rights information." /></a><br /><strong>How do casinos make money?</strong><br /><br /><blockquote><br />  The casino&#8217;s strategy is so secure, there is just one danger to its profits: if the casino plays very few games for very high stakes relative to their capitalization, they could lose their capital.<br /></blockquote><br /><br />Casinos make money by wagering money on the outcome of games with gamblers. (If the gambling industry offends you, I apologize. We could choose to look at how insurance companies make money, it is entirely the same thing.) The games are arranged in such a way they the casino holds a small mathematical edge on each play. Over the long run, with many gamblers playing the games many, many times, the casino inexorably makes money. The casino may lose games here and there, and some gamblers may enjoy temporary winning streaks, but overall, the casino wins more than it loses.<br /><br />The very briefest exploration of statistics reveals the following facts about the casino&#8217;s strategy for making money:<br /><br /><ol><li>The casino must have an edge on each play;</li><br /><li>The more games played, the more likely that the casino will profit overall;</li><br /><li>Runs of good luck for some gamblers are offset by runs of bad luck for other gamblers.</li></ol><br /><div class="book"><a href="http://www.amazon.com/gp/product/0521540364?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0521540364"><img style="cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/understanding_probability-706271.jpg" border="0" alt="" /></a><br/>Henk Tijms&rsquo;s <a href="http://www.amazon.com/gp/product/0521540364?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0521540364">Understanding probability</a> explains probability in simple terms requiring very little mathematics. Examples drawn from everyday life include analyzing investment returns, lotteries, and gambling. The book continues to build on the basics, worthing through Bayes' theorem up to multivariate and conditional distributions. A must-read for those working with data or seeking to understand risk analysis.<br/></div>In fact, the casino&#8217;s strategy is so secure, there is just one danger to its profits (besides the obvious fear of losing their license to print money): if the casino plays very few games for very high stakes relative to their capitalization, they could lose their capital. One celebrated &#8220;whale,&#8221; <a href="http://en.wikipedia.org/wiki/Akio_Kashiwagi">Akio Kashiwagi</a>, won more than $19 million in one casino and on another occasion won $6 million in a siangle session playing baccarat for $200,000 a hand.<br /><br />Therefore, the casino&#8217;s prime safeguard is to <em>avoid risking large amounts of capital on games played very few times</em>.<br /><br />To summarize, the casino&#8217;s strategy is to:<br /><br /><ol><li>Arrange a small advantage on each game played;</li><br /><li>Play a very large amount of games;</li><br /><li>Ignore good and bad runs, they will offset each other;</li><br /><li>Do not risk large amounts of capital on games played very few times.</li></ol><br />Now that we know the casino&#8217;s strategy, let&#8217;s consider how they evaluate games. Imagine them sitting around a conference table, and someone suggests, &#8220;Let&#8217;s create a new game, Alaska Freeze.&#8221; What do they use to evaluate whether to add this new game to their casino?<br /><br />Space in a casino is at a premium. If Alaska Freeze goes in, something else comes out. So there has to be an Incremental Value calculation: do they make more money with Alaska Freeze in and something else out? Or less? This calculation has two simple components: does Alaska Freeze have a larger or smaller mathematical edge than whatever it replaces, and will Alaska Freeze be played more or less often than whatever it replaces?<br /><br />Ok, let&#8217;s return to handling gotcha objections. I&#8217;m sure you knew all of this, I was just presenting it in a palatable morsel so you can feed it to someone objecting to your idea.<br /><br /><strong>From casinos back to objections</strong><br /><br /><blockquote><br />  The process of developing software is just like the business of running a casino.<br /></blockquote><br /><br />You are handling an objection and you have established that its premise is neither universal nor predictable, it is probabilistic. Well, if it has an uncertain outcome, it is <em>just like a casino game</em>. And the process of developing software is just like the business of running a casino.<br /><br />So the question is not whether a new practice ever has a case where it appears to &#8220;lose,&#8221; for the same reason that evaluating a new game for a casino does not involve worrying about whether gamblers will ever win.<br /><br />The way to evaluate the idea is to examine it and see whether it fits the casino model:<br /><br /><ol><li>Does it offer a probable advantage each time it is employed?</li><br /><li>Can it be employed many times?</li><br /><li>Do streaks of &#8220;losses&#8221; and &#8220;wins&#8221; offset each other?</li><br /><li>Can we avoid risking the entire outcome of the project infrequent events?</li></ol><br />And if it does, to identify what idea or practice it replaces to determine whether it is a net win or a net loss overall:<br /><br /><ul><li>Does it offer a larger or smaller mathematical edge over the practice it replaces? In other words, does it lose less often?</li><br /><li>Can it be applied more or less often than the idea it replaces? In other words, how much benefit can we obtain from it?</li></ul><br />Now, I am not going to say that XP, YAGNI, or dynamically typed programming languages <em>necessarily</em> fit the casino model and are necessarily better than the practices they replace (Classical Project Management, BDUF, and static typing). But what I will say is that there is a huge difference between saying &#8220;some of the time, for some of the people, that idea loses&#8221; and saying &#8220;overall, when applied to an entire project, the project does worse than whatever idea it replaced.&#8221;<br /><br />So to handle a gotcha objection, we establish that it is probabilistic in nature, then we analyse it as we would analyse any other probabilistic practice: we look at the overall effect of the practice on the entire project, comparing it to whatever practice it would replace. And I have some easy-to-remember phrases for doing that.<br /><br /><strong>The second response to the gotcha objection</strong><br /><br />The next step is rather obvious. You have to state the payoff those times that your idea or practice &#8220;wins.&#8221; And to be fair, you also have to agree to the cost of your idea or practice when it &#8220;loses.&#8221;<br /><br /><ul><li>&#8220;When teams are disciplined about not writing code that won&#8217;t be needed in the current iteration, we get more of the features developed earlier, where we can analyse and learn from them. This lowers our technical and requirements risk. Of course, sometimes this means that they have to throw stub or temporary scaffolding code out later, so there is some wasted code.&#8221;</li><br /><li>&#8220;When projects are written using dynamic languages, they can use techniques like meta-programming to write less code and to concentrate the <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html" title="Economizing can be penny-wise and pound foolish">green code</a> in one place. Of course, we do not have the compiler telling us about certain types of errors.&#8221;</li></ul><br />Needless to say, if you are in a face to face meeting you should solicit agreement to this second response as well. If you can&#8217;t establish that there are <em>any</em> benefits to your suggested practice, you have a great deal more work to do to handle this objection.<br /><br /><strong>The third, and final response to the gotcha objection</strong><br /><br />The final step is the clincher. Having established that the objection&#8217;s premise is probabilistic, and that for those times the idea or practice &#8220;wins&#8221; there is a positive payoff, it&#8217;s time to compare the overall benefit of the idea or practice to whatever it replaces. You want to shift the debate from debating the premise to debating the overall benefit.<br /><br />And in fact, there are two different forms of the clincher. You can use either, or preferably both:<br /><br /><ol><li>Ask whether you can balance the benefits of using the practice when it wins against the cost of using the practice when it loses, and evaluate the overall benefit <em>in comparison to</em> the benefits and costs of the alternative and see whether you would get more of a benefit <em>over one entire project</em>, or;</li><br /><li>Ask whether you can compare the success rate of teams using the practice to the success rate of teams using the alternative <em>in aggregate</em>, or;</li><br /><li>Both.</li></ol><br />And here are the example responses again, demonstrating the three forms of clincher:<br /><br /><strong>Objection</strong>: &#8220;Sometimes you <em>are</em> gonna need it, so you&#8217;re wasting time if you don&#8217;t build it in from the beginning. Therefore, we should build what we know we&#8217;ll need.&#8221;  <br /><br /><strong>Response</strong>: Well, sometimes you need it, sometimes you don&#8217;t. And when you don&#8217;t need it, you save the code you would have written as well as all the other design that becomes coupled to the code you end up throwing out. Of course, sometimes you end up throwing out some stub code, but think about the possibility that you will wind up getting more features done, earlier in the cycle where we can get feedback and reduce risk. Why don&#8217;t we look at whether, in aggregate, more projects will succeed using YAGNI than will succeed using &#8220;Build everything we might need&#8221;?<br /><br /><strong>Objection</strong>: &#8220;Some bugs simply can&#8217;t be found through automated unit tests, sorry. This is why we have to use a programming language with static typing.&#8221;  <br /><br /><strong>Response</strong>: Sure enough, some can&#8217;t be detected with automated unit tests. But our choice of a dynamic language provides us with many other benefits, most especially in the areas of metaprogramming and code reduction. By writing less code, we may even have fewer bugs overall. Shouldn&#8217;t we try to compare similar projects written in a static language against those written in a dynamic language, and see whether the projects in the dynamic language had fewer bugs and whether the projects written in the dynamic language were more likely to be successful?<br /><br />Good luck handling objections. What is your experience: do you have another technique you can recommend?<br /><br /><strong>A Personal Note</strong><br /><br />As Mike pointed out in the first comment, this post explains how to handle this one type of objection, the gotcha objection, by moving the debate away from the exception case and towards the overall case. But it does not follow up by presenting hard data to justify the example ideas presented.<br /><br />First, I want to say that even with hard data you will not foster change with numbers: you need to show how your idea addresses an urgent priority. That should have happened <em>before</em> you got to this point. If you have addressed the problem correctly, it really is sufficient to point out the fallacy in the objection and allow your original argument to stand.<br /><br />Second, there is a dearth of hard data about anything to do with software development. Repeat after me: &ldquo;the plural of anecdote is not data.&rdquo; If you have a source of hard data about any practice, be it programming languages, practices, or even interviewing techniques, I would very much like to read and learn from it.<br /><br />Does this mean that we should never change, that since there&rsquo;s no <strong>proof</strong> that new ideas are an improvement over old ones?<br /><br />If you are happy with your current situation, maybe not. If you are unhappy with your current situation, if you want things to be better, you may want to change something. It&rsquo;s your call.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="permanent link">5:16 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, January 14, 2007</div>
			

			<div class="Post"><a name="116866063058399558">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="permanent link">What I've Learned From Sales, Part I: Don't Feed the Trolls</a></span>
					<div style="clear:both;"></div>This is the first part of “What I’ve Learned From Sales.” In this part, “Don’t Feed the Trolls,” I present my explanation for why people act like “trolls,” raising objection after objection to new ideas, and I suggest how to side-step this behaviour and deal directly with their concerns.<br /><br />(Part II, <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">Wanna Bet?</a>, describes how to handle one very common form of objection. Part III, <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html">How to use a blunt instrument to sharpen your saw</a>, describes the mind-set that there are opportunities for improvement to be found everywhere.)<br /><hr /><br />“Oh no,” you must be thinking, “another <a href="http://garage.com" title="Garage Ventures">Guy Kawasaki</a> wanna-be trying to tell me how to sell things.” Well, <em>yes</em> to the wanna-be accusation, but <em>no</em> to the proposition that this is a general-purpose article about sales. I am not going to pretend to tell you how to promote your business, turn your product idea into a money-maker, or even how to sell yourself to an employer.<br /><br />What I am going to share with you is some experience I have had with sales that strongly parallels my experience discussing new ideas with people. (I know, reasoning by analogy is often faulty. But it’s what we humans do, we’re pattern-matching machines.) If you find that people seem unreasonably resistant to good ideas like <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="Are we Blub programmers?">more powerful programming languages</a>, <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="Wasabi cannot cure rotten fish">putting people before process</a>, or <a href="http://raganwald.github.com/2005/06/working-code-attracts-people-who-want.html" title="Working code attracts people who want to code">valuing working code above documents</a>, you may find this helpful.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0673461750?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0673461750"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/the_macintosh_way-791759.gif" alt="" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;o=1&a=0673461750" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br />Guy Kawasaki’s <a href="http://www.amazon.com/gp/product/0673461750?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0673461750">The Macintosh Way</a> explains how to create and evangelize great ideas, whether they are products for sale or world-changing movements.<br /></div>Our model here is that the mental process of considering a new idea is the same as the mental process behind buying something. If you are discussing a new idea with someone—even if you aren’t actively trying to “sell” it to them—they are still going through the buying process. And if they have trouble accepting the idea, they will resist, or in sales jargon, they will “raise objections.”<br /><br />Do you think this is specific to sales? No, when we see new ideas like the Ruby programming language, we encounter objection after objection. Some are ironic: Some Java enthusiast objects to Ruby on performance grounds: perhaps they are too young to remember when the C/C++ folks objected to Java on performance grounds? Or perhaps it will be the IDE support objection, or the Not Invented By Microsoft (a/k/a Not a Corporate Standard) objection, or any of a million others that are not completely unreasonable, but are also usually irrelevant.<br /><br /><span style="font-weight: bold;">What is an objection?</span><br /><br />On the face of it, an objection is an expression of a discrepancy between your idea and what someone wants. So if they say “Lisp has too many parentheses,” you might think that they are saying “I would use Lisp if it didn’t have so many parentheses.”<br /><br />The great secret we can learn from sales is that <em>this is not true</em>. As we will see below, people say what they think other people want them to say. So someone might be thinking “Lisp is too hard for me, all this talk of <code>let</code> and <code>lambda</code> and <a href="http://raganwald.github.com/2005/11/repost-closures-in-ruby.html" title="Closures in Ruby">closures</a> and <a href="http://raganwald.github.com/2006/09/scientists-announce-empirical-evidence.html" title="Scientists Announce Empirical Evidence for Greenspun's Tenth Rule">tail recursion</a> is confusing.” But they are embarrassed to admit this, so they seize on something that sounds more reasonable, like “the syntax is weird.”<br /><br />We need to understand this, because <em>the absolute worst thing you can do with an objection is answer it directly</em>. If someone is really thinking “Lisp is too hard,” what good does it do to try to persuade them that parentheses are their friends? They don’t really care. Worse, if you trot out the benefits of homiconicity and its applications to macros and introspection and <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="The significance of the meta-circular interpreter">meta-circularity</a>, you’re actually making Lisp sound <em>harder</em>, not easier.<br /><br /><blockquote><br /> At one time I was a Macintosh salesperson. I used to sell Mac SEs and Mac IIs in “The Dark Times” after Steve Jobs was expelled from Apple by the vile and treacherous Prince John…<br /></blockquote><br /><br />Let me give you an example from my own experience in sales. At one time I was a Macintosh salesperson. I used to sell <a href="http://en.wikipedia.org/wiki/Macintosh_SE">Mac SEs</a> and <a href="http://en.wikipedia.org/wiki/Macintosh_II">Mac IIs</a> in “The Dark Times” after Steve Jobs was expelled from Apple by the vile and treacherous <a href="http://en.wikipedia.org/wiki/John_Sculley" title="John Sculley">Prince John</a>… <em>but I digress</em>. I was a Macintosh salesperson at a time much like this time: nineteen out of twenty computer sales were PCs.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0596007191?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0596007191"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/revolution_in_the_valley-742074.jpg" alt="" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;o=1&a=0596007191" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br /><a href="http://www.amazon.com/gp/product/0596007191?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0596007191">Revolution in the Valley</a> tells the incredible story of the creation of the Macintosh—from the perspectives of the people who were actually there. It’s packed with behind-the-scenes anecdotes and little-known secrets. Much of the material is available on line <a href="http://folklore.org">for free</a>.<br /></div>You would think that selling Macintoshes would be a lonely existence. But no, the phone would ring regularly and customers would visit the office on a daily basis, always with the same question, <em>Why should I buy a Macintosh instead of a PC?</em> And at first, I would answer this question. Macintoshes were superior to PCs in every way. (Actually, this was technically very true at that time. Why, you could run as many as six monitors on a Macintosh II! But I am digressing from my digression.)<br /><br />I learned a funny thing about answering people’s questions. I would answer their questions, and they would <em>argue</em> with me. I would say that you could run multiple monitors on a Macintosh II, making yourself more productive. And they would say “but I don’t need to be <em>that</em> productive, so that doesn’t count.” Or I would say that the mouse and windowing interface is easier to use, you can learn to use more programs. And they would say “but all I need is a word processor and a spreadsheet, so I don’t need to learn new programs.”<br /><br />(Why would they do that? It was so that if someone asked them, “did you shop around and make an intelligent decision?,” they could reply, “why yes, I shopped around, I checked out Macs and PCs, I did a lot of research, and surprise surprise, I ended up with the <em>exact same thing that my neighbour Bob has</em>, except mine is running at 12Mhz and poor Bob is stuck with 10Mhz.” It may sound to you like they are doing an awful lot of work just to be able to say that one thing with a straight face, but I can tell you that there is this multi-billion dollar automobile industry that works on this principle: people want to be a little better than their neighbour, but not so much better that they are <em>different</em> than their neighbour.)<br /><br />I can give you many more examples, but the interesting thing is not whether people wanted this stuff or not, but no matter how convincingly I answered their question, they would just ask another one. Their questions had nothing to do with how they were making up their mind.<br /><br /><blockquote><br /> What people think often bears no relationship to how they behave<br /></blockquote><br /><br />I learned very quickly that what people think often bears no relationship to how they behave. People usually say the things that they think other people expect them to say, but they go ahead and do whatever it is they always wanted to do. In the case of buying computers, my observation is that most people want to buy whatever it is that most people are buying. They want to <em>belong</em>, to <em>fit in</em>. So they are going to buy a PC. Or an iPod.<br /><br />So what was <em>really</em> on their mind was fitting in, even though they argued about the Macintosh’s technical merits.<br /><br />The lesson I learned is that before we can introduce a new idea to someone, we first need to understand what is really on their mind.<br /><br />Salespeople call this “uncovering the hidden objection”. They have all these elaborate techniques for figuring out what’s really on a prospect’s mind when they encounter resistance to the sales pitch. I’m not going to suggest we do that. Instead, I’m going to suggest we avoid the objections in the first place by “qualifying.”<br /><br /><blockquote><br /> The most important principle of effective selling is that qualifying the customer is more important than overcoming objections.<br /></blockquote><br /><br /><span style="font-weight: bold;">What is “qualifying” and why is it the most important step in the sales process?</span><br /><br />Many people say the most important step is “closing,” the art of getting the prospect to hand over the money, the end of the sale. If you judge by the behaviour of people selling time shares, fitness club memberships, and automobiles, this is the only thing salespeople work on: haranguing prospects and ‘overcoming objections’ by arguing.<br /><br />Experienced and successful salespeople follow a different path. Experienced salespeople believe that the most important step is <em>qualifying</em>, the art of discovering whether a prospect has an actual need for the product, the <em>beginning</em> of the sale. Salespeople who are strong qualifiers spend almost no effort on closing because they are always working with prospects who want to buy.<br /><br />On the other hand, if you do not discover their real problem, you extol virtues that have no attraction for them and neglect to address any perceived issues in their mind. The principle at work is that if you know what someone really needs, you address their needs from the very beginning. When you arrive at the conclusion, you have already addressed any questions they may have.<br /><br />This is true for sales. It is also true for new ideas. If someone fears that an idea like learning Lisp (or meta-programming, or designing a program in the technical interview) would be too difficult for them, you will only be successful if you first explain how <a href="http://raganwald.github.com/2006/12/giles-bowkett-turns-language-elitism.html" title="Giles Bowkett Turns language Elitism Upside Down">easily they will learn the new idea</a>, and only then explain how wonderful the idea is.<br /><br /><blockquote><br /> If someone doesn’t have a headache, you cannot establish the value of an aspirin for them… Don’t focus on how you think your new idea can help them be better. Instead, focus on whether they have an urgent problem that your new idea can fix.<br /></blockquote><br /><br />Although there are various models for understanding people’s motivations—such as <a href="http://en.wikipedia.org/wiki/Maslow%27s_Hierarchy_of_Needs">Maslow’s Hierarchy of Needs</a>, or the Greed-Belonging-Exclusivity-Fear Quartet—for development tools and methodologies my experience is that the simplest model fits best: people are motivated to <strong>solve their problems</strong>: if you can identify a problem they think they have, you can show them how to solve it.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0805074562?ie=UTF8&amp;tag=raganwald001-20&link_code=as3&amp;amp;camp=211189&creative=373489&amp;creativeASIN=0805074562" title="On Intelligence by Jeff Hawkins"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/on_intelligence-797528.jpg" alt="" border="0" /></a><br />In <a href="http://www.amazon.com/gp/product/0805074562?ie=UTF8&amp;tag=raganwald001-20&link_code=as3&amp;amp;camp=211189&creative=373489&amp;creativeASIN=0805074562" title="On Intelligence by Jeff Hawkins">On Intelligence</a>, Jeff Hawkins explains how the human neocortex matches visual, audible, and kinaesthetic patterns—and replays them to form the basis of prediction. He makes a convincing case that the neocortex is the single most important distinction between humans and other species… and therein explains what makes humans human.<br /></div>People without problems are not good prospects for lightweight development methodologies, new development tools, programming languages, or any other “change for the better.” Just the other day I was lunching with Dmitri from <a href="http://www.opalis.com">Opalis</a>. We were talking about a development tool I am trying to build, and Dmitri was suggesting that it was a <a href="http://disruptivethoughts.com/2007/01/08/aspirin-vs-vitamins/" title="Aspirin vs. Vitamins">“vitamin” and not an “aspirin”</a>.<br /><br />I was taken aback. Isn’t improving software development important for everyone? Then I remembered my sales training and asked him about how things were going at Opalis. Dmitri admitted that his team was performing well and that he had built a lot of trust with his organization. So he didn’t have a problem. Quite simply, if someone doesn’t have a headache, you cannot establish the value of an aspirin for them.<br /><br />Now, even Dmitri’s team has room for improvement, so it is not correct to say that there is no value in improved methodologies, tools, languages, or anything else for him. However, such things may not be a <em>priority</em> right now. This is exactly the same case as trying to sell a Macintosh to Bob’s neighbour: I believed that absolutely everyone could have benefited from owning a Macintosh. However, Bob’s neighbour didn’t think he had a usability problem, he thought he had an urgent “keeping up with Bob” problem.<br /><br />And there’s the key: Don’t focus on how <em>you</em> think your new idea can help them be better. Instead, focus on whether they have an urgent problem that your new idea can fix.<br /><br />Discovering their priorities shouldn’t difficult. Why don’t we simply ask them? Well, there’s a trick to asking someone about their priorities. Remember, they will tell you what they think other people want to hear, not what they are thinking. Here’s an example concerning agile development:<br /><br /><strong>Agilist</strong>: “What’re your priorities for the development team in the next 60-90 days?” <br /><br /><strong>Manager Says</strong>: “I have a total commitment to process improvement and faster response to business initiatives,” …<strong>but thinks</strong>… <em>CMM Level Four—or, God willing, Level Five—will get me a higher profile and a shot at the CIO position. I need some consultants in here to start imposing some bondage and discipline over our development processes.</em> <br /><br />The trick is to <em>get specific and objective</em>. Never take objections as evidence of their real needs, and never accept vague feel-good values at face value. Top salespeople don’t. Try calling a busy estate agent and saying you’d like to buy a house. I guarantee that the agent will ask you, “when do you need to buy a new house?” And so it is with new ideas:<br /><br />You cannot position lightweight development, tools, languages, or any other type of change without being able to fit them into the specific and objective problems someone is trying to solve. You need to relentlessly pursue the immediate, urgent priority:<br /><br /><strong>Startup Founder</strong>: “I’ve heard that Agile stuff is crap—it only works for star programmers who would be good no matter how you manage them.” <br /><br /><strong>Agilist</strong>: “Well, there’re a lot of opinions out there. Tell me, what would you say is the most pressing issue facing your development team right now?” <br /><br /><strong>Startup Founder</strong>: “Well, we have hacked together some great stuff, but we need to scale, and to scale without imploding we’ll need some discipline, some real management of the development team. That’s why we need a <em>real</em> methodology.” <br /><br /><strong>Agilist</strong>: “I can understand the importance of scaling up. So, have you set some specific objectives for scaling up over the next month or two?”<br /><br /><strong>Startup Founder</strong>: “For the next couple of months? Oh, it’s all about recruiting, definitely recruiting. I need another two or three top people to work on a new project that could be worth millions. We’ve identified some good candidates, but it’s very difficult to get them to accept an offer from a start up.” <br /><br /><strong>Agilist</strong>: “You know, we really ought to consider whether using Agile might help you recruit—have you considered the possibility that some star candidates might be looking for an environment that is more Agile than the one they are leaving?” <br /><br /><strong>Startup Founder</strong>: “Hmmm…” <br /><br />As you can tell, once you have a specific problem with specific dates attached to when the problem needs to be resolved, you can discuss a specific solution. You’ve side-stepped the useless “objections.” One more time: do not accept vague objectives, get specific objectives with near-term dates attached to them.<br /><br />If someone really doesn’t have any applicable near-term objective, you will not be able to introduce a new idea to them. So don’t be surprised if they express very little interest. But when you have an immediate, specific objective in hand, you can position the idea as a solution to their problem.<br /><br />And that works for almost any idea. Say you had a new programming language designed for set-top boxes. But it turns out nobody has a “programming set top boxes” problem. So they raise objections about the speed of your virtual machine, or the fact that programmers cannot manage memory in your language, so they cannot squeeze programs into very small spaces.<br /><br />Should you keep pounding away at that? Or go looking for an immediate problem people have, like building web applications?<br /><br />If you side-step their objections—like memory management—and get to the root of their immediate needs, you might be able to introduce a new popular programming language. Good luck!<br /><br /><span style="font-style: italic;">Part II, <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">Wanna Bet?</a>, describes how to handle one very common form of objection. If you liked this post, you might also like a related post, </span><a href="http://raganwald.github.com/2007/01/false-dichotomy-of-choosing-between.html" title="permanent link"><span style="font-style: italic;">The false dichotomy of choosing between your values and expediency</span></a><span style="font-style: italic;">.</span><span class="PostTitle"></span><a href="http://raganwald.github.com/2007/01/false-dichotomy-of-choosing-between.html" title="permanent link"><br /></a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="permanent link">12:47 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, December 16, 2006</div>
			

			<div class="Post"><a name="116628208495215893">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/12/lisp-is-not-last-word.html" title="permanent link">Lisp is not the last word</a></span>
					<div style="clear:both;"></div><a href="http://www.tilton-technology.com/">Ken Tilton</a> <a href="http://groups-beta.google.com/group/comp.lang.lisp/msg/c03b6b011661c011" title="comp.lang.lisp posting">asked</a>: <em>What is up the power continuum from Lisp?</em><br /><br />I don’t have a ready answer. However, just because I don’t have an answer doesn’t mean I don’t believe there’s an answer. It could be that Lisp is a little like Democracy. It could be the least powerful programming language possible, excepting all of the others invented so far. But you know what? I have faith <em>we can do better</em>.<br /><br />Ken doesn’t say there isn’t a language up the power continuum. And I won’t say we have already invented one: like Ken, I’ll pose a question: <em>what law of computer science places a limit on the power continuum at Lisp?</em><br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/1400077974?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=1400077974"><img style="" src="http://raganwald.github.com/uploaded_images/meta_math-757398.png" alt="" border="0" /></a><em><br /><br />G.J. Chaitin explains his proofs of Kurt Godel’s incompleteness theorem and Alan Turing’s “halting problem” in computation. Chaitin’s creative use of Lisp in mathematics and fervent belief that no theorem is proof against new analysis are welcome shots of espresso.</em></div>Human history is chock-a-block full of inventions and practices that were considered for decades or even centuries to be the final word, the ultimate expression and implementation of ideas. And then someone came along and demolished everything. Geocentricity. Heliocentricity. Newtonian celestial mechanics. Light as a wave. Light as a particle. Three dimensions. Uniform space. Euclidian geometry.<br /><br />Some of these new ideas took years to take root while the establishment derided them as “not even wrong.” Others were so obviously right they immediately displaced what had come before. We might now have invented a more powerful language. Or we might have invented one but not realize it yet. But who can say that we haven’t invented a more powerful language and will never do so?<br /><br />If you believe there <span style="font-style: italic;">is</span> a power continuum, if you are not so obsessed with Turing Completeness and theoretical equivalence, what is the argument that it has any limit whatsoever, let alone that its limit is Lisp?<br /><br />I believe that the only language that is affixed to the top of the power continuum is <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a>. For everyone whose imagination soars above the ceiling of their laboratory, Lisp is not the last word.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/12/lisp-is-not-last-word.html" title="permanent link">9:56 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, November 22, 2006</div>
			

			<div class="Post"><a name="116423826413955025">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="permanent link">The significance of the meta-circular interpreter</a></span>
					<div style="clear:both;"></div>A <a href="http://en.wikipedia.org/wiki/Self-interpreter">self-interpreter</a> is a &#8220;programming language interpreter written in the language it interprets.&#8221; A <a href="http://en.wikipedia.org/wiki/Metacircular_Interpreter">meta-circular interpreter</a> is a special case of a self-interpreter that applies only to programs where the primary representation of the program is a primitive data type in the language itself (this property is called homoiconicity). Lisp is such a language because Lisp programs are lists of symbols and other lists. XSLT is such a language because XSLT programs are written in XML.<br /><br />(If you have ever written an XSLT that transforms other XSLTs, then you immediately grasp the advantage of a meta-circular interpreter over an &#8216;ordinary&#8217; self-interpreter: it is not just possible, but it is <em>easy</em> to write programs that write programs, because you don't have to fiddle with transforming each program into an abstract data structure (typically a tree) that can be manipulated by your program.)<br /><br />This is interesting to both language theoreticians and hobbyists. But does it matter to those of us trying to get things done? What is the significance of meta-circular interpreters and self-interpreters?<br /><br />The short answer is that if you are working on meta-programming, a self-interpreter makes all things not just possible, but practical. The lack of such an interpreter places a limit on how much you can accomplish using your implementation language.<br /><br /><h4 id="meta-programming">Meta-programming</h4>Let&#8217;s start our examination of the significance of self-interpreters with a review of meta-programming, or bottom-up programming. This is the practice of constructing a programming language tailored to your problem space. You get your language&#8217;s basics working by building it on top of a base, or <em>implementation language</em>, and then you build your solution in your <em>solution language</em>.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://raganwald.github.com/uploaded_images/men_with_tools-706630.jpg"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/men_with_tools-798729.jpg" border="0" alt="" /></a>While meta-programming, you are working on two tiers either simultaneously or alternately: you work on expressing your solution in your solution language, and you work on the implementation (whether that be fun stuff like making it expressive or plumbing stuff like making it fast enough to be practical) in your implementation language.<br /><br />An important and popular sub-domain of meta-programming is the practice of writing <a href="http://en.wikipedia.org/wiki/Domain-specific_programming_language">Domain-Specific Languages</a> or DSLs. DSLs are solution languages tailored to resemble as closely as possible the human jargon of &#8220;domain experts.&#8221;<br /><br />(<a href="http://www.jroller.com/page/obie">Obie Fernandez</a> has an excellent <a href="http://obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf" title="Building Domain Specific Languages in Ruby">presentation</a> on the rationale for and construction of DSLs.)<br /><br />DSLs are commonly cited as useful in areas where programmers who are not domain experts collaborate with domain experts who are not programmer. In my own experience, DSLs are also valuable even when the programmers are themselves the domain experts. My rule of thumb for whether a DSL would be worthy of consideration is to ask how two programmers discussing the solution to a problem over an IM client would talk. If their language would closely resemble the natural constructs and idioms of their chosen implementation language, there is no need for a DSL.<br /><br />This is not always the case. A very classic example is that of SQL. SQL is a DSL designed for programmers to express relational algebra rather than the imperative steps for performing queries and updates. Although complex cases are impenetrable to the journeyman, its general form closely follows the way even a non-technical person would express their thoughts about data that is stored in tables.<br /><br />Another example of a successful DSL for programmers is the regular expression engine present in almost every language (whether baked in or as a commonly available library). Programmers do not discuss searching for text patterns in terms of backtracking and lookup tables and loops unless they are implementing a search library themselves.<br /><br />Programmers talk about <em>matching the string &#8216;Nokia&#8217; followed by four digits, a forward slash, and two numbers separated by a period</em> in the User-Agent Header. Regular expressions, while imperfect, match the way programmers think and talk about text matching much more closely than writing out the most efficient steps using <code>strstr</code> and <code>for</code> loops.<br /><br /><h4 id="what_about_the_meta_circular_interpreter">What about the meta-circular interpreter?</h4>Meta-circular interpreters are nothing new. Lisp is most famous for its <a href="http://raganwald.github.com/2005/03/page-thirteen.html">meta-circular interpreter</a>. But do you know that one of the world&#8217;s most popular programming languages has the next best thing, a self-interpreter? The C programming language&#8217;s compiler is written in C. That&#8217;s interesting. But why is it significant?<br /><br />Well, instead of heading up the &#8216;power continuum&#8217; and talking about Lisp, let&#8217;s stay with C for a moment. If you&#8217;re a C programmer and you become very, very interested in building a better programming language, you have in your hands the tool to make changes as you see fit.<br /><br />You might, for example, start with a pre-processor and implement the first version of your C++ language by mechanically translating a C++ program to C. Or you might bootstrap your C++ language by writing a compiler for C++ in C. Because you have in your hands all of the tools for going from source to running program, you can enhance and change its behaviour exactly as you please.<br /><br />When a language is not implemented in itself, you have limitations on your ability to create new forms. One might argue that Lisp&#8217;s macros make it possible to build any other language paradigm on top of Lisp. This is partially correct, however macros alone are not a complete answer. Macros act to rewrite local sections of programs.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0521545668/104-5191901-1508708?ie=UTF8&tag=raganwald-store-20&linkCode=xm2&creativeASIN=0521545668"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/lisp-768094.jpg" border="0" alt="" /></a>You cannot&#8212;to my knowledge&#8212;take a dialect of Lisp that does not support tail recursion and use macros to execute tail calls in constant space without rewriting every function using your macro. A similar argument holds for using <a href="http://library.readscheme.org/page6.html">macros to implement continuations</a>. You must manually rewrite every function using your macros if you want to change the global behaviour of your program.<br /><br />Manually <em>blank</em> every <em>blank</em>. This sounds an awful lot like something we can automate. Automatically transforming entire programs is the province of interpreters and compilers, isn&#8217;t it?  If you wish to perform transformations that are global in scope, you want a custom interpreter. Of course, you can write one from scratch in your implementation language.<br /><br />But&#8230; This sounds like we are headed towards the <a href="http://raganwald.github.com/2004/10/beware-of-turing-tar-pit.html">Turing Tar Pit</a>. Isn&#8217;t it much easier to use the interpreter that&#8217;s built in? Implementation languages that provide an interpreter or compiler for themselves provide an industrial-strength, debugged platform for the construction of solution languages.<br /><br />This is the other half of the power of Lisp: if you want to change deeper fundamental language features like whether you have a Lisp-1 or a Lisp-n, or whether all evaluation is lazy, or&#8230;, or&#8230;, or&#8230; you can, because Lisp interprets Lisp and Lisp compiles Lisp.<br /><br />It is this reason that languages like Ruby, which is implemented mainly in C, provide less maximum power than languages like <a href="http://www.squeak.org/" title="Squeak">Smalltalk</a>, which is <a href="http://users.ipa.net/~dwighth/squeak/oopsla_squeak.html">implemented mainly in&#8230; Smalltalk</a>. For example, there is talk&#8212;at this time&#8212;that continuations will be <acronym title="like the Income Tax is temporary?">temporarily</acronym> dropped from Ruby 1.9. If you have an application making heavy use of continuations, what is your upgrade path?<br /><br />Of course, not everyone <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="Are we Blub programmers?">thinks they need</a> all of a more powerful meta-programming implementation. You will have to decide for yourself whether a language without a meta-circular evaluator or self-interpreter offers other benefits that outweigh this significant feature.<br /><br /><h4 id="serving the self-interpreter to your canine companion">Serving the self-interpreter to your canine companion</h4>As Simen pointed out in a <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html#116429036918590040">comment</a>,  Ruby does have a third-party project to interpret Ruby in Ruby called <a href="http://blog.fallingsnow.net/rubinius/">Rubinus</a>. Assuming it graduates from its current status as an experimental work-in-progress, how is this different from having a self-interpreter baked into the language?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://raganwald.github.com/uploaded_images/climbers_dog-765949.jpg"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/climbers_dog-763491.jpg" border="0" alt="" /></a>When a language is built on top of a self-interpreter, the language designers are forced to <a href="http://en.wikipedia.org/wiki/Dogfooding">eat their own dog food</a>.<br /><br />Now it is not correct to say that Matz does not use Ruby. He does, and so he does eat his own dog food. And for the domains where he uses Ruby, he has optimized Ruby to be a useful tool. But since he <em>doesn&#8217;t use Ruby to build Ruby</em>, he does not have the same incentive to tune Ruby for the purpose of building languages.<br /><br />An obvious example is Ruby&#8217;s performance. It is perfectly fine for <a href="http://rubyonrails.org">building CRUD applications</a>. However, it lacks really high performance when working with complex data structures in memory. This is the kind of thing that an interpreter or compiler has to do when parsing code or managing <a href="http://ce.sharif.edu/~dic-ads/d.php?ref=1&origin=stack&r=cactusstack.7.">cactus stacks</a>.<br /><br />Imagine what would have happened had Matz become impatient waiting for Ruby to interpret itself when he was first building the language? I suggest that the implementation and language would both be tweaked to bring performance up an order of magnitude or more. Programmers are notoriously impatient with slow tools.<br /><br />The implementation is not the only thing that improves when a language designer eats her own dog food by baking a self-interpreter into the language. The design of the language itself changes. Larry Wall has said that &#8220;Languages differ not so much in what they make possible, but in what they make easy.&#8221; When a designer builds their new language in itself, the language invariably makes building languages easy.<br /><br />So I suggest that the presence of a self-interpreter <em>baked right into the language, not bolted on as an after-thought</em> forces a language to be useful for building solution languages.<br /><br />(<em>This is not a broad criticism of Ruby, or a suggestion that Ruby is not an excellent tool for building a wide variety of useful solution languages. I&#8217;m just trying to point out the salient distinction between baking a self-interpreter into a language from the beginning and bolting one on the side.</em>)<br /><br /><h4 id="but_i8217m_a_tool_maven_not_a_language_maven">But I&#8217;m a tool maven, not a language maven</h4>Of course <a href="http://www.zwitserloot.com/">you</a> are. So tell me, how does <a href="http://www.eclipse.org/">Eclipse</a> do all of its magic with <a href="http://www.java.com/">Java</a>, a language lacking a self-interpreter?<br /><br />The answer is <a href="http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html">here</a>. The Eclipse team based Eclipse on VisualAge for Smalltalk. They were more than familiar with the benefits of having a self-interpreter, so they wrote most of one in themselves, in Java. Self-interpreters are also the basis for building advanced tools.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="permanent link">6:23 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, November 17, 2006</div>
			

			<div class="Post"><a name="116378772384103978">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/11/first-seven-books-i-would-buy-if-my_17.html" title="permanent link">The first seven books I would buy if my shelves were bare</a></span>
					<div style="clear:both;"></div><a href="http://www.rufy.com/">Lucas Carlson</a> won a $100 gift certificate on <a href="http://www.amazon.com">Amazon.com</a> for his 2nd place entry at <a href="http://www.railsday2006.com/">Rails Day</a> (in collaboration with John Butler). Congratulations, Lucas!<br /><br />Lucas asked for suggestions on spending the money. I tried suggesting a new <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FApple-iPod-Nano-Black-Generation%2Fdp%2FB000EPHP4U%2Fsr%3D8-10%2Fqid%3D1163787219%3Fie%3DUTF8%26s%3Delectronics&amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">iPod Nano</a> loaded up with the SICP lectures in <a href="http://feeds.feedburner.com/SICP">video podcast form</a>. But as you would expect for someone working in a music-related venture, he has plenty of toys already.<br /><br />So… here are the first seven books I would buy if my shelves were bare (in no particular order):<br /><ol><li><a href="http://www.amazon.com/gp/product/0262011530?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262011530">Structure and Interpretation of Computer Programs</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262011530" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. You can read it for free <a href="http://mitpress.mit.edu/sicp/">on line</a>, but it’s even better as a physical book. One for the ages, it’s the kind of thing that ought to be bound in rich leather (if you go for that sort of thing) and kept in the library you build for your luxury castle.</li><br /><li><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. It seems you can’t raise micro-capital these days without understanding <a href="http://en.wikipedia.org/wiki/Y_combinator">fixed point combinators</a>. Here’s the most enjoyable text on the subject of combinatory logic ever written. What other textbook features starlings, kestrels, and other songbirds?</li><br /><li><a href="http://www.amazon.com/gp/product/0140097015?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0140097015">The Media Lab: Inventing the Future at M. I. T.</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0140097015" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. Stewart Brand’s book captures the legendary think tank’s culture and ideas. Compare and contrast their view of broadcatch with today’s RSS feeds, or narrowcasting with today’s 500 channel television.</li><br /><li><a href="http://www.amazon.com/gp/product/0805074562?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0805074562">On Intelligence</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0805074562" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> A book that shook my views about how my brain works. To pick one nugget out of many, neurons are so slow that in the time it takes for us to react suddenly—say to duck a flying object—there is only time for a chain of at most 100 steps to complete. 100 steps do not permit us to perform <em>any</em> complex reasoning or look-up. Jeff explains how the neocortex can accomplish complex tasks using layers of parallel switches.</li><br /><li><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FPhilip-Alexs-Guide-Web-Publishing%2Fdp%2F1558605347%2Fsr%3D1-1%2Fqid%3D1163785428%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">Philip and Alex’s Guide to Web Publishing</a>. While the technologies suggested (TCL, AOLServer) are unlikely to float your boat, this is the most beautiful technical book on my shelves. Philip’s advice on how to build software for web publishing and approach is still relevant several generations of web developers later. (Also available <a href="http://philip.greenspun.com/panda/">on line</a> for free.)</li><br /><li><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FRecursive-Universe-Complexity-Scientific-Knowledge%2Fdp%2F0809252023%2Fsr%3D1-1%2Fqid%3D1163786265%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">The Recursive Universe: Cosmic Complexity and the Limits of Scientific Knowledge</a>. Although it seems to be out of print, hunt down a copy for yourself. A thrilling journey into the ideas of the great John Horton Conway and computation’s building blocks. Best of all, it’s explained beautifully using the legendary <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>. Who knew that <a href="http://en.wikipedia.org/wiki/Puffer_train_%28CA%29">puffer trains</a> and <a href="http://en.wikipedia.org/wiki/Spaceship_%28CA%29">spaceships</a> are Turing Complete?</li><br /><li><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FQED-Strange-Princeton-Science-Library%2Fdp%2F0691125759%2Fsr%3D1-1%2Fqid%3D1164028852%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&amp;amp;amp;linkCode=ur2&camp=1789&amp;creative=9325">QED: The Strange Theory of Light and Matter</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=ur2&amp;o=1" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" />. Yes, the full <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FFeynman-Lectures-Physics-Definitive-Extended%2Fdp%2F0805390456%2Fsr%3D1-1%2Fqid%3D1163786913%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">Feynman Lectures</a> are incomparable, and for further thrills you can listen to him give the lectures on <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FFeynman-Lectures-Physics-Richard-Phillips%2Fdp%2F0738209287%2Fsr%3D1-10%2Fqid%3D1163786913%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">audiobook</a>. But in QED, Feynman does this one magical thing: he explains how a mirror reflects light. And in the process of explaining how light actually reflects off a mirror, Feynman deconstructs classical physics and rebuilds our understanding with Quantum Electrodynamics. For a moment, you can understand how little we really know about how the universe works.</li></ol><br />Is there a book you would <a href="http://www.blogger.com/comment.g?blogID=7618424&amp;postID=116378772384103978">recommend</a>? What’re <a href="http://www.blogger.com/comment.g?blogID=7618424&amp;postID=116378772384103978">your feelings</a> about the books I’ve suggested?<br /><br />p.s. Shane Sherman’s <a href="http://www.turnofthecrank.com/2006/12/01/the-5-books-that-every-programmer-should-read/">The 5 Books that Every Programmer Should Read</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/11/first-seven-books-i-would-buy-if-my_17.html" title="permanent link">12:31 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, November 08, 2006</div>
			

			<div class="Post"><a name="116302520925270414">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html" title="permanent link">Take control of your interview</a></span>
					<div style="clear:both;"></div>I’m helping some colleagues interview programmers, and for once I’d like to offer some suggestions to the interviewees and not the interviewers. This post is about using the interview to maximize <em>your</em> chance of landing the right job.<br /><h4 id="have_an_objective">have an objective</h4>First, you need to walk in with an objective. No, not “<span style="font-style: italic;">to secure a strategically progressive position leveraging your forward-going architectural vision and hands-on experience to advance the division’s mission</span>,” but a simple, tactical objective for the interview.<br /><br />Here’s what I suggest. Think of <strong>three things you want the interviewer to know about you that you think they are unlikely to find out if they ask all the questions</strong>.<br /><br />The important ideas are that (a) you want the interviewer to know about each of the three things, and that (b) the interviewer is unlikely to ask about all three if you don’t exercise some control over the interview.<br /><br />Let’s start by ruling a few things out. First, don’t bother with how many years of technical experience you have with the company’s tools and platforms. If they are using in-house Common Lisp macros compiled to C and then distributed on a grid with MapReduce, I guarantee that they will ask whether you have any Lisp or distributed programming experience all by themselves. (You can still take advantage of your experience, I’ll show you how below.)<br /><br />Second, rule out anything that doesn’t really help sell them on you. Yeah, yeah, hockey is competitive and it takes a special kind of focus to be a goalie. I get that, but it really only sells when the interviewer is also a hockey player. My suggestion is put that kind of thing at the bottom of your resumé and let them ask about it if they care.<br /><h4 id="the_three_things">the three things</h4>The three things you want to take into the interview should be stuff that matters to them but is hard for them to ask about. Stuff that doesn’t pop out of your resumé. I don’t have a pat formula for generating these items that I can share, but here are a couple of ideas to get you started.<br /><br />Remember the technology buzz-phrases we rejected (“five years of JEE” “Common Lisp”)? Think about the difference between yourself, presumably an expert in these areas, and someone who has only worked on one project with the same technology. You both touched all the same tools and code, but there’s something special about <em>you</em>, your extra experience means something. What is it?<br /><br /><a href="http://www.joelonsoftware.com/articles/lordpalmerston.html" title="Lord Palmerston on Programming">Joel Spolsky</a> and <a href="http://www.norvig.com/21-days.html" title="Teach Yourself Programming in Ten Years">Peter Norvig</a> both suggest that you cannot pick up a new programming language or platform and become proficient overnight. That being said, if you tell me that you have five years of experience, I have no idea whether you have five years of experience or whether you simply did the same thing over and over again. What is it that you learned that makes you special? What secrets to you possess that can’t be listed on your resumé?<br /><br />For each person, there will be different answers. One person might say that their “secret sauce” is that they have learned the ins and outs of the platform, they know what works and what doesn’t, they know how to work around the shortcomings. Another might emphasize the non-technical skills. I would personally be impressed with anyone who said that what makes them special is that they are very, very accurate when they estimate tasks and projects.<br /><br />This leads naturally to another area I would mine for nuggets: <em>Soft or non-technical skills</em>.<br /><br />99% of the <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html" title="My favourite interview question">dreck</a> you read about interviewing programmers is about finding out whether they can <a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html" title="Hiring a Juggler">actually</a> write programs. Rightly or wrongly, most interviewers focus on the hard skills. But if they never get around to discovering your ability to juggle priorities, or write effective technical documentation, or analyze requirements, how will they know that you are far and away superior to the other five people they will interview this week?<br /><br /><strong>You have to tell them</strong>, that’s how they’ll find out.<br /><h4 id="tell_them_about_it">tell them about it</h4>Walk into the interview with your three things. Now, the interview is a game. Presuming you don’t get thrown out or you don’t walk out before it ends, <em>you win the game if the interviewer discovered all three of your things</em>. If you like games as a metaphor, call them <strong>goals</strong>.<br /><br />If the interviewer asks you about one of your things, that’s an easy goal. Take it.<br /><br />If the interviewer asks you if there’s anything you’d like to mention about yourself, that’s an easy goal. Talk about one of your things.<br /><br />If the interviewer asks you about something related to one of your things, answer the interviewer’s question and then ‘coat tail’ your thing onto the end. For example:<br /><br /><strong>Interviewer</strong>: <em>It says here you worked on JProbe, that’s a Java tool, right?</em><br /><br /><strong>Interviewee</strong>: Absolutely. JProbe is a suite of tools for JEE Server-Side development (answers the interviewer’s question). Under my management, we released three consecutive versions on schedule. I’m really hoping that there’s an opportunity to apply my focus on hitting plan to this team (adds on).<br /><br />Watch politicians “staying on message.” Now matter what question they are asked, they spit out their own pat statements. You don’t want to be that plastic, but you have to take responsibility for a a successful interview. And you know what? If the interview ends with your best features undisclosed, the company loses as well.<br /><br />One more time with the coat tail:<br /><br /><strong>Interviewer</strong>: What’s your experience with Ruby?<br /><br /><strong>Interviewee</strong>: Well, I was the lead developer on the Certitude project. We built that with Rails and we included a fairly heavy dose of Ruby idioms, including a domain-specific language for pattern-matching and lots of dynamic meta-programming (answers the interviewer’s question). One of the things I discovered on that project was the importance of a bomb-proof <em>quality control process</em> when you have such a powerful language. I customized our continuous integration server to track changed files, tests, bugs in a unified report interface so we could monitor the most troublesome modules. It really saved our bacon late in the project when we had to really tighten up our risk management to ship on time (the add on, emphasizing the process).<br /><h4 id="if_all_else_fails">if all else fails</h4>Perhaps you didn’t get a good opportunity to mention your three things and the interview is winding down to a close. Don’t try a desperation coat tail where you try to stick two completely unrelated things together. Instead, try using a question to introduce one of your things indirectly.<br /><br />Some examples:<br /><ul><li>“Could you describe the product management process for me?” leads to an oportunity to talk about your product management experience or your experience working with product managers.<br /></li><li>“What tools do you use for source code management, builds, and bug tracking?” is a great opportunity to talk about your experience with the full software development life cycle, not just the coding.<br /></li><li>“How do you plan and track ship dates?” turns the conversation towards how well you estimate dates, manage priorities, and your track record of shipping code on time.<br /></li><br /></ul>Opportunities to ask questions should not be wasted on trivia like the company’s dental plan or whether they prefer cubicles to private offices (actually, neither are trivial, but they are not important until you have given the interviewer every reason to hire you).<br /><br />My suggestion is to only ask questions about areas where you have something positive to contribute if the question leads to a spirited discussion. And the best way to make that happen is to <em>plan in advance</em>.<br /><br />You have three things you want to say, and you should walk into the interview with three questions you can ask that will turn the conversation towards your agenda.<br /><h4 id="back_to_square_one">back to square one</h4>So here’s how to get started.<br /><ol><li>List your three things you want the interviewer to know about you that you think they are unlikely to find out if they ask all the questions;</li><li>Write a one-paragraph description of for each thing that you could use to ‘coat tail’ onto another question;</li><li>Think of a question you could ask for each thing that would naturally lead to a discussion.</li><br /></ol>Good luck.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html" title="permanent link">5:11 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, October 16, 2006</div>
			

			<div class="Post"><a name="116105348803572321">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/irony.html" title="permanent link">Irony</a></span>
					<div style="clear:both;"></div><blockquote>Programs must be written for people to read, and only incidentally for machines to execute.</blockquote><div style="text-align: right;">Abelson &amp; Sussman, <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&linkCode=ur2&camp=1789&creative=9325">Structure and Interpretation of Computer Programs</a><br /></div><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&linkCode=ur2&camp=1789&creative=9325"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://raganwald.github.com/uploaded_images/sicp-786043.jpg" alt="" border="0" /></a>From time to time people quote this as a justification for staying <em>away</em> from high-level languages like Lisp, Scheme, <a href="http://www.planetpython.org/">Python</a>, and <a href="http://poignantguide.net/ruby/" title="Why's (Poignant) Guide to Ruby">Ruby</a>, and not only sticking to popular languages but also staying within the lowest-common denominator when choosing idioms within those popular languages.<br /><br />Isn’t it interesting that the quote is from a book explaining concepts such as recursion and metalinguistic abstraction? In Scheme?<br /><br />The <a href="http://mitpress.mit.edu/sicp/">full text</a> is on line. If you have yet to read it, I recommend you give it a try.<br /><br /><i>update: if you enjoyed reading <acronym title="Structure and Interpretation of Computer Programs">SICP</acronym>, you may find my list of <a href="http://raganwald.github.com/2006/11/first-seven-books-i-would-buy-if-my_17.html">the first seven books I would buy if my shelves were bare</a> interesting.</i><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/irony.html" title="permanent link">10:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 12, 2006</div>
			

			<div class="Post"><a name="116068720976582522">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="permanent link">Are we Blub programmers?</a></span>
					<div style="clear:both;"></div>From time to time I open my email and find someone asking a question:<br /><br /><blockquote>What the hell is Blub? I take from context that it may be a pejorative generalist term for programming languages that encourage writing pablum instead of programs. Or maybe it really is a new language out there that has a huge following I'm unaware of. </blockquote><div style="text-align: right;"><a href="http://chalain.livejournal.com/">Chalain</a>, the "<span style="font-style: italic;">if you're not having fun, you're doing</span><span style="font-style: italic;"> it wrong</span>" guy<br /></div><br /><a style="margin: 0pt 0pt 10px 10px; float: right;" href="http://www.flickr.com/photos/raganwald/15824364/" title="Preparing to climb Lollipop Kids"><img src="http://static.flickr.com/10/15824364_16defaae5e_m.jpg" alt="Preparing to climb Lollipop Kids" border="0" height="240" width="180" /></a>Actually, Blub is a hypothetical programming language Paul Graham invented when describing something very interesting: the <span style="font-style: italic;">Blub Paradox</span>:<br /><br /><blockquote>Blub falls right in the middle of the abstractness continuum... As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages... Blub is good enough for him, because he thinks in Blub.</blockquote><div style="text-align: right;">Paul Graham, <a href="http://www.paulgraham.com/avg.html">Beating the Averages</a><br /></div><br />The interesting things about this paradox is that almost <span style="font-style: italic;">any</span> language could be Blub. The pre-requisites for a language being Blub are (a) there is at least one language less powerful than Blub, (b) there is at least one language <span style="font-style: italic;">more</span> powerful than Blub, and (c) that there be at least one programmer using Blub who accepts (a) but refutes (b) because he or she cannot see how the more powerful language is more powerful. She does not think in the <a href="http://www.braithwaite-lee.com/weblog/2006/01/finding-signal-to-noise-ratio-in-never.html">idioms</a> that the more powerful language affords.<br /><br /><div style="margin: 0pt 10px 10px 0pt; width: 240px; float: left; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/little_mler-705423.jpg" alt="" border="0" height="180" width="180" /></a><em><br /><br />The Little MLer introduces ML (and Ocaml) through a series of entertaining and straightforward exercises leading up to the construction of the Y Combinator.<br /><br />ML and OCaml introduce powerful strong typing and type inference. Both are great languages to learn: you will stretch your understanding of defining types and writing correct programs.<br /></em></div>When <span style="font-style: italic;">I</span> use the term, I am thinking of the language and also the programmers around it. Could Java be Blub? Sometimes, possibly often, but only when I'm thinking about Java programmers who dismiss Ruby's features as unnecessary. <a href="http://t-a-w.blogspot.com/2006/08/programming-in-blub.html">Could Ruby be Blub</a>? Sometimes, but only when I'm thinking about Ruby programmers who dismiss macros as unimportant.<br /><br /><a href="http://raganwald.github.com/2006/12/lisp-is-not-last-word.html">Could Lisp be Blub?</a> I suspect that Erlang and Haskell programmers might say that it is, provided we can find a Lisp programmer who feels that all progress in programming languages stopped when Common Lisp was standardized.<br /><br />At the same time, Java is not Blub when I am thinking of programmers <a href="http://raganwald.github.com/2006/10/in-praise-of-informed-choices.html">who are perfectly aware of its shortcomings and deliberately Greenspun around them for pragmatic reasons</a>. The same goes for any other language: it is sometimes Blub, and sometimes not Blub.<br /><br />So... I use the term "Blub" to refer to a programming language in the context of intransigent programmers who feel that their chosen tool is the best tool possible.<br /><br /><blockquote>Programming consists of overcoming two things: accidental difficulties, things which are difficult because you happen to be using inadequate programming tools, and things which are <em>actually difficult</em>, which no programming tool or language is going to solve. </blockquote><div style="text-align: right;"><a href="http://www.joelonsoftware.com/items/2006/10/12.html">Joel Spolsky reviewing Beyond Java<br /></a></div><br />This provokes a very obvious question: <span style="font-style: italic;">How do we know which things are accidentally difficult and which are actually difficult</span>? Is it only because we haven't discovered the right tool yet?<br /><br />It's easy to find a Java programmer who believes that all of the Design Patterns in the GoF's book are necessary. She believes that the difficulties of applying those patterns are actual difficulties of programming systems. It is only when she learns a different language that she realizes how the patterns were strongly driven by limitations in Java's object model.<br /><br />At that point she has an epiphany and understands that what she thought were actual difficulties were merely accidental difficulties. And the line between "accidental" and "actual" moves for her.<br /><br />No matter how much each us us thinks we know right now, are we nevertheless like this Java programmer, unable to see the difference between accidental and actual differences because we simply haven't discovered a more powerful tool?<br /><br />Are we Blub programmers?<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">update</span>: <a href="http://raganwald.github.com/2006/10/in-praise-of-informed-choices.html">In praise of informed choices</a> and </span><a href="http://raganwald.github.com/2006/12/lisp-is-not-last-word.html">Lisp is not the last word</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="permanent link">4:40 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, October 08, 2006</div>
			

			<div class="Post"><a name="116033648506034653">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?</a></span>
					<div style="clear:both;"></div><a href="http://en.wikipedia.org/wiki/ML_programming_language">ML</a> is a programming language featuring <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: you don’t have to encumber your code with type declarations, the compiler can figure them out for you. So… are type inference languages like ML for Sneetches <a href="http://steve-yegge.blogspot.com/2006/10/egomania-itself.html">with or without stars</a>? Or another kind of Sneetch entirely?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/Sneetches-Other-Stories-Classic-Seuss/dp/0394800893/s?ref=raganwald001-20"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/sneetches-711589.jpg" border="0" alt="" /></a><blockquote style="font-style: italic;">Now, the Star-Belly Sneetches had bellies with stars.<br />The Plain-Belly Sneetches had none upon thars.<br />Those stars weren’t so big. They were really so small<br />You might think such a thing wouldn’t matter at all.</blockquote><span style="font-style: italic;font-size:85%;" >Update</span><span style="font-size:85%;">: More than a few people have <a href="http://empathybox.com/archives/7">written</a> that Steve Yegge's association of static typing with neatness and dynamic typing with slovenliness runs opposite to their impressions of the kinds of people who strongly prefer one or the other. I used Steve's terms in the original post, partly because I thought people would get the same joke I thought Steve was making. It looks like they don't, nobody wrote to say "LOL." I have changed the terms to something that represents what I think of the cultural divide between programmers who like Java and programmers who like Ruby.</span><br /><br />Let’s review. Sneetches with stars like to use a colour-coded label maker to label the drawers, boxes, and files in their office. Once glance at everything and you know what it holds. Sneetches with stars add extra labels even when you don’t need them. For example, if a box is labeled ‘tax receipts’, each piece of paper inside has a post-it note saying tax receipt’, even if it’s obviously a tax receipt and lives inside the tax receipts box.<h4 id="what_is_stariness">What is Stariness?</h4>Sneetches with stars like these languages we say are <em>statically typed</em>. What do we mean by the word static? We mean <em>it can be resolved at compile time</em>. Other words for this idea are <em>invariant</em> or <em>constant</em>. Sneetches with stars like languages where the type of each entity can be resolved at compile time.<br /><blockquote>Some people are always critical of vague statements. I tend rather to be critical of precise statements; they are the only ones which can correctly be labelled "wrong."</blockquote><div style="text-align: right;">Raymond Smullyan<br /></div><br />Let’s dive into this a little deeper. (My apologies to my readers who were actually paying attention to the stuff in first year computer science that isn’t a requirement for <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">getting a job at BigCo</a>.) What does it mean when we say “something can be resolved at compile time”? That expression is laden with implementation details like assuming we’re using a compiler. But it’s a convenient short-hand for saying <em>something about the program that is true every time you run the program</em>.<br /><br />Consider the <code>final</code> declaration in Java. If you write:<br /><pre><code>final String snafu = "situation normal...";<br /></code></pre>We know that the variable <code>snafu</code> always holds a reference to the constant string <code>"situation normal..."</code>. No matter what data you feed to your program and how you mangle it, <code>snafu</code> will always be <code>"situation normal..."</code>. Do you agree? (Joe Campbell, put your hand down. Yes, there is a back door way you can change the contents of a <code>String</code> in Java.)<br /><br />Java can take advantage of this to perform <em>constant propagation</em>. Everywhere you write <code>snafu</code>, Java can substitute <code>"situation normal..."</code> and throw away the variable lookup. To get away from arguing about back doors in the <code>String</code> class, let’s consider one of the primitive types, a <code>boolean</code>. If you write:<br /><pre><code>final boolean foo = true;<br />    // code without assignments to foo<br />    if (foo) {<br />        // do something<br />    }<br />    else {<br />        // do something else<br />    }<br /></code></pre>Wouldn’t you agree that the compiler can get rid of the variable lookup and the <code>if</code> statement? The path through the code is always through the <code>// do something</code> path every time you run the program.<br /><br />Now back to the word <em>stariness</em>. We really mean <em>the amount of stuff about the program that can be resolved at compile time</em>, or if you prefer, <em>the amount of stuff that is true every time you run the program</em>.<br /><br />In the example above, the compiler can figure out which branch the program will follow at compile time, because that variable is true every time you run the program.<br /><br />Stuff that is always true is useful. For most programs, we have an idea in our head about “correctness.” What we mean when we talk about a program being correct is that it produces desirable results every time you run the program.<br /><blockquote>A formalist is one who cannot understand a theory unless it is meaningless.</blockquote>Stariness is thus similar to correctness. And that’s why a lot of people, the Sneetches with stars, are obsessed with it. Being able to “prove” something about their program (“the method call <code>foo.bar(5)</code> never throws a <code>MethodNotImplemented</code> exception”) feels a lot like being able to prove that their program is correct.<br /><br />It feels a lot like it, but it isn’t the same thing. The reason it isn’t the same thing is that while its true that a program throwing <code>MethodNotImplemented</code> exceptions is probably not correct, it’s not true that a program that doesn’t throw such exceptions <em>is</em> correct. It just feels, somehow, more likely to be correct because we’ve thrown out one of the infinite ways it can be incorrect.<br /><br />Now that we’ve dispatched that logically, let’s be clear about something: just because stariness does not enforce correctness, it doesn’t mean that stariness isn’t <strong>useful</strong>. Stariness is useful. Period, no debate.<h4 id="back_to_inferences">Back to inferences</h4>Type inference is also for Sneetches with stars.  A language with type inference resolves the type of each entity at compile time by inspecting the program and figuring the types out through inspection. It’s a lot like the way a compiler can look at the Java code above and figure out that you always <code>// do something</code> and you never <code>// do something else</code>. The code looks sorta like you could go either way, but the compiler knows better.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald-store-20&linkCode=ur2&camp=1789&creative=9325"><img style="float:left; margin:0 10px 10px 0;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/little_mler-705423.jpg" border="0" alt="" /></a>Languages with type inference look like variables can have any type, but the compiler knows better. Remember the labels that the verbose declaration Sneetches with stars love? Type inference languages still have labels, but the labels are hidden inside of the files and boxes where you can’t see them.<br /><br />Remember when manufacturers used to put their labels <em>inside</em> clothes instead of right across the front? Same thing. The rules for what goes where are strictly enforced, it’s just that if you can figure out what goes where with a bit of common sense, you don’t need a label or a post-it note.<br /><br />Compare these two snippets of Java:<br /><pre><code>final String[] words = { "foo", "bar", "blitz" };<br />final int word_length = words.length;<br />final String[] anagrams = new String[word_length];<br /></code></pre>…and…<br /><pre><code>final words = { "foo", "bar", "blitz" };<br />final word_length = words.length;<br />final anagrams = new String[word_length];<br /></code></pre>Hey, if a variable is final, we can figure out its type in Java through simple inspection. Making that work in the compiler is something an intern ought to be able to do over a Summer work term!<br /><br /><span style="font-size:85%;">(Frank Atanassow pointed out that techniques exist for inferring the types of nearly all Java variables through inspection of programs. But this simple case is enough for our purposes.)</span><br /><br />So if we take a valid Java program and simply erased type declarations whenever we could logically deduce the type of the variables (using our simple scheme), but left them in whenever we were not sure of the final type of the variables, we would have exactly the same program. Nothing about it has changed except it has fewer symbols. It’s just as starry, it is just as static, it is no more or less correct than it was before we erased some symbols.<br /><br />And you over there itching to say something about IDE refactorings and auto-completions: None of those go away either. You can rename things and move things and press command-tab to get an object’s methods whenever you like. So… would you agree that type inference of this sort doesn’t change a starry program into a starless program? This isn’t about stariness versus starlessness, it’s about the obsessive-compulsive desire to label everything.<br /><br />The bottom line: <em>type inference does not change a statically typed language into a dynamically typed language</em>. It’s still starry.<h4 id="so_why_can8217t_the_Sneetches without stars_use_type_inference">So why can’t the Sneetches without stars use type inference?</h4>Think of types as being like values and objects like variables. A statically typed language is one where there are no type re-assignments. Some languages enforce this. But if you write a program in a static way, you can still reason about it. This is why lots of people think that we can “neaten up” languages like Ruby by adding type inference to the compiler: they're thinking about programs that are neat to begin with, but we happen to have written them in a language for Sneetches without stars.<br /><br />And whenever someone talks about a refactoring IDE or an auto-completing IDE for a dynamic language, they’re talking about performing some type inference on Ruby programs that are written in a static way. So… what’s the holdup? We said we could add type inference to Java in a Summer. Where’s the intern to add it to Ruby?<br /><blockquote>Programmed. In me somewhere, he thought, there is a matrix fitted in place, a grid screen that cuts me off from certain thoughts, certain actions. And forces me into others. I am not free. I never was, but now I know that; that makes it different.</blockquote><div style="text-align: right;">Philip K. Dick, "The Electric Ant"<br /></div><br />The problem is that the set of all programs that are "starry" is a subset of the set of all programs that parse correctly. So either not all starless programs are neat, or not all portions of a starless program are neat, or both.<br /><br />Let’s compare back to our Java snippet. Remember:<br /><pre><code>final boolean foo = true;<br />// code without assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>The compiler could infer that we always follow the first branch because it knows that final variables are not reassigned. They’re <em>immutable</em>. What happens if we erase the <code>final</code> keyword as well:<br /><pre><code>boolean foo = true;<br />// code that might have assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>Now the job is much harder. We have to examine all the code in between the declaration and the use of foo. If there are any assignments involving things we can't know until runtime, we can't know the value of foo until runtime.<br /><br />For a very large class of programs, we cannot infer the contents of a variable with less runtime complexity than running the program for every possible input. This is why compilers have limitations on the optimizations they can perform, and humans still need to do some thinking about writing fast programs.<br /><br />This exact same thing happens with types. In statically typed languages, types are never re-assigned. Whether explicitly declared or inferred, they're immutable. But in languages like Ruby where methods can be added and removed dynamically, where messages can be forwarded dynamically, where we can even send messages dynamically, the types of objects are fully mutable.<br /><br />In starless languges, there is no <code>final</code> keyword on the types of objects. We can no longer infer the type of a variable in any but the simplest, degenerate cases.<br /><br />The type inference problem in dynamically typed languages is exactly the same as the inferring the possible contents of a variable problem. The inferring the contents of a variable problem is doable for a restricted set of programs. And the way we tell the compiler that a variable is a member of this restricted set is with the <code>final</code> keyword.<br /><br />Likewise, the way we tell a compiler that the type of a variable is also restricted is that we use a language where the type of every variable is final. It’s the same thing: we don’t reassign final variables and we don’t change types on the fly.<br /><br />Starlessness is not about writing programs without labels. Starlessness is when you write dynamic programs. Dynamic doesn’t mean ‘unlabeled’. As I showed above, if the <code>final</code> keyword is there, the label is mostly optional. But if you don’t have <code>final</code>, you’re writing dynamic programs.<br /><br />Truly starless programs have dynamic types: <em>types that change at run time</em>. they are not always one thing or another. For example, what if you write an Object-Relational Mapper (“ORM”) that reflects on the database structure at run time. That is, you can change columns in a database table and you get new getters and setter methods in your program. <em>Without recompiling</em>.<br /><br />In a fully static language (with or without type inference), you can’t do that. Think of Java’s JDBC: you have to fool around with methods that get values and pass a column name as a parameter. Or maybe you create a hash. And C# is getting this capability, but of you look closely you still have to define the “type” of a query through the LINQ syntax.<h4 id="are_neat_freaks_ever_starless">Are Sneetches with stars ever starless?</h4>A dynamically typed language lets us define an object holding a database row with methods for each column. But we can’t know at compile time whether our program will throw a <code>MethodNotImplemented</code> exception because we don’t know whether someone will monkey with the database structure. That sounds bad.<br /><br />But what happens if you write the same thing in a neat program? Aha! a <code>SQLException</code>! it seems that there are dynamic things that must be dynamic no matter what you do.<br /><br />This is a specific case of Greenspunning. There are some facilities of dynamic languages that you are going to need. If you don’t have them built into your static language, you will build them yourself or use a framework that has already built them for you. Other examples I have seen in Java programs include:<br /><br />Spring and Hibernate;<br />Any use of <code>Class.forName(...)</code>;<br />Any use of dynamic proxies;<br /><br />In essence, you’re being a Sneetch without a star but twisting your starry language to permit starlessness. And for those portions of the program that are no longer nice, starry bundles that can be examined at compile time for invariant behaviour, you are indeed in dynamic territory and have to live with the risks.<br /><br />In my experience, all non-trivial starry programs contain this kind of starlessness. To my admittedly inexperienced eyes, starlessness is the hallmark of expert programming in starry languages ("expert" does not necessarily mean "more desirable," especially in the minds of those who believe that programs should be written and maintained by mediocre developers).<h4 id="eating_cake">Eating cake</h4>So… can we say that since you can write starless programs in neat languages, you can have the useful benefits of stariness when you need it and the flexibility of starlessness when you need that too? Isn’t that better?<br /><br />Yes, you <em>can</em> say that. And you may be right, for you. The <a href="http://boo.codehaus.org/Language+Guide">Boo</a> people believe that: their language has a <code>duck</code> keyword for when you feel like a Sneetch without a star. Be aware that at this moment in history, languages designed for Sneetches without stars seem to have much better features for writing starless programs than languages for Sneetches with stars. So my observation is this:<br /><br /><em>If you dislike the verbosity of starry languages like Java but like the feeling of safety, try a type inference language. Don’t go to a starless language if you don’t intend to actually write dynamically typed programs.</em><br /><br />My experience is that if you are frustrated by the amount of work you have to do to express the algorithms in your head, you should look at a language that removes your frustration. If you're using Java and don't like the verbosity, find a language that celebrates brevity while preserving static typing. But if you're using Java and find yourself pushing more and more logic out of java because its type system is too static or too inflexible, you should consider a language with a different approach to typing.<br /><blockquote>Computer languages differ not so much in what they make possible, but in what they make easy. </blockquote><div style="text-align: right;">Larry Wall<br /></div><h4 id="why_would_the_Sneetches without stars_use_starless_languages">Why would the Sneetches without stars use starless languages?</h4><em>Writing starless programs on top of neat languages is exactly the same thing as writing automatic memory management routines on top of a manually managed programming language or writing functional programs on top of a noun-centric object-oriented language.</em><br /><br />You can take that statement as an argument in favour of specialized languages for Sneetches without stars or as an argument against them. My guess is that the above statement is true and a Rorschach Inkblot: You will interpret it as confirmation of your existing prejudices.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">3:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, October 04, 2006</div>
			

			<div class="Post"><a name="116001645840262686">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html" title="permanent link">Why are local variables bad?</a></span>
					<div style="clear:both;"></div>Steve Yegge wrote a terrific post about <a href="http://www.refactoring.com/">refactoring</a>, "<a href="http://www.oreillynet.com/ruby/blog/2006/03/transformation.html">Transformation</a>," in March of 2006. My two cent review is that the most valuable part is his discussion of how the <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a> community has become so enamored of push-button refactoring at the line of code level that they have lost sight of what refactoring is supposed to accomplish at the design level.<br /><br />Many Blub programmers won't even <span style="font-style: italic;">try</span> a language that doesn't have so-called refactoring support in their IDE. Given <a href="http://beust.com/weblog/archives/000414.html">the choice between dynamic metaprogramming and refactoring</a>, they choose refactoring without even knowing exactly what <a href="http://raganwald.github.com/2006/08/dynamic-is-opposite-of-static-not-of.html">dynamic metaprogramming</a> is.<br /><br />And they are blissfully unaware that the 'refactorings' in their editors are just a few of the <a href="http://www.refactoring.com/catalog/index.html">refactorings suggested</a> in Martin Fowler's seminal book on the topic. Furthermore, there is more than one way to accomplish the goal of well-designed software, and some languages, (especially folding languages), provide much more powerful tools for clean software design than micro-refactoring.<br /><br />All that leads me to a question posed on <a href="http://programming.reddit.com">programming.reddit.com</a>:<br /><br /><span style="font-style: italic;">Why are local variables considered bad?</span><br /><br />I'll simplify things. <span style="font-style: italic;">Mutable</span> local variables are bad. And here's why:<br /><br />Mutable local variables mean that within a method execution you have changes of state. That makes it very difficult to change anything without breaking things.<br /><span class="g"><blockquote>Those are my principles, and if you don't like them... well, I have others.</blockquote></span><div style="text-align: right;"><span class="g">Groucho Marx</span><br /><span class="g"></span></div><br />For Eclipse fans, consider what happens if you take a random chunk in the middle of a method with mutable local variables and try to use the automatic refactoring to make a new private method.<br /><br />If you have lots of immutable local variables, they have to be passed to your new method as parameters. That's not so bad. But if you have mutable local variables, you have to do some back flips and sit ups to ensure that any changes to those variables are propagated to the rest of your method.<br /><br />This is a tip-off that the mutable local variables have introduced a lot of complexity to the structure of the method. Unless they make it dramatically shorter than a variable-free version of the same method, they should be removed.<br /><br />(Update): What kind of complexity are we talking about? We are talking about lots and lots of dependencies between the lines of code in the method. Those dependencies are what make the code brittle: if you try to move something or change it, you break some other code that is depending on its side effects. The extra dependencies have introduced <span style="font-style: italic;">coupling</span>, which is a code smell.<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0201485672?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201485672" title="Refactoring: Improving the Design of Existing Code"><img style="" src="http://raganwald.github.com/uploaded_images/refactoring-720867.jpg" alt="Refactoring: Improving the Design of Existing Code" border="0" /></a><em><br /><br />The book that touched off a revolution in software design. Incredibly, most programmers think that refactoring is just about the dozen or so menu items in their IDE. This book discusses over a hundred refactorings, organized into themes. It goes beyond mere transformations to explain what makes good code and how to recover from bad decisions.</em></div>The extra coupling manifests itself in many ways, not just in the difficulty of moving code around. You also have problems changing lines of code. This manifests itself in regressions: every time you fix a problem or add some functionality, do you find yourself having to fix a bunch of bugs created by your change?<br /><br />Let's be clear: we don't say mutable local variables are bad because it's hard to refactor methods with mutable local variables. We say mutable local variables are bad because they intrduce complex dependencies and coupling between the lines of code in a method.<br /><br /><span style="font-style: italic;">Immutable</span> local variables, such as the local variables you use to cache certain results, are  <span style="font-style: italic;">not</span> bad. (I should say, "in my opinion," but this is my blog. Note the words "my" and "blog," establishing that we're talking about <span style="font-style: italic;">me</span> and <span style="font-style: italic;">opinions,</span> not everyone and especially not widely accepted irrefutable facts).<br /><br />As a matter of fact, I can <span style="font-style: italic;">prove</span> that they are not bad. Okay, "proof" is an ambitious word given that there is no widely accepted <a href="http://scienceblogs.com/goodmath/2006/06/extreme_math_1_1_2.php">proof that 1+1=2</a>. I'll demonstrate. Here's some code with an immutable local variable:<br /><pre><code><br />my_var = SomeModelClass.find :all<br />if my_var.empty?<br />  :empty<br />else<br />  my_var<br />end<br /></code></pre><br />Let's transform that code into:<br /><pre><code><br />(lambda do |my_var|<br />  if my_var.empty?<br />     :empty<br />  else<br />     my_var<br />  end).call(SomeModelClass.find :all)<br /></code></pre><br />We've transformed the immutable local variable into a parameter for a lambda (or closure, or anonymous proc object, whichever name you prefer). Parameters are not harmful. And since this transformation can be automatically performed for <span style="font-style: italic;">any</span> immutable local variable, I claim that immutable local variables are also not harmful.<br /><br />Cool discovery, hunh? I should be famous. Oh wait, someone on the phone from the 1970s. The Lisp people want their <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">macro</span> back. And they're right. People having been using <span style="font-weight: bold;">let</span> for more than thirty years to write concise code without the side effects and state changes associated with mutable local variables. Consider instead:<br /><pre><code><br />(let ((my_var (find SomeModelClass 'all)))<br />     (if<br />        (empty? my_var)<br />        'empty<br />        my_var))<br /></code></pre><br />That's simpler structurally than using one of Ruby's procs. So what do we conclude?<br /><br />First, refactoring is cool, but it's a tool, not an objective. The important thing is the objective,  well-designed software. Second, read the book. Really read it, cover to cover.<br /><br /><span style="font-size:85%;">Update: This is exactly why languages with more powerful abstractions are more important than adding push-button variable renaming to less powerful languages. Where's the button that refactors a method with lots of mutable variables into one with no mutable variables? No button? Okay, until you invent one, don't you want a language that makes it easy to write methods and functions without mutable local variables? (Attention Java programmers: <span style="font-style: italic;">Yes you do</span>, and I have proof. Do you like the new <span style="font-weight: bold;">for</span> syntactic sugar in Java 1.5? Its biggest benefit is that it makes loops that used to have a mutable variable look just like an iterator block with an immutable parameter in Ruby or Smalltalk. Think about it.)</span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html" title="permanent link">10:13 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, September 30, 2006</div>
			

			<div class="Post"><a name="115961926939112412">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="permanent link">Wasabi cannot cure rotten fish</a></span>
					<div style="clear:both;"></div>There is only one problem with development methodologies. Just one. It affects <span style="font-style: italic;">all</span> methodologies, agile and otherwise: No methodology can 'fix' projects that are staffed with underperforming people. People are more important than process, period.<br /><br />This is the underlying issue with the language 'wars' as well. No magical combination of JSON, static typing, design patterns, IDE whizzies, and frameworks will somehow help a million monkeys produce any of Shakespeare's works.<br /><br /><span class="body"><blockquote>If you want to build a ship, don't drum up people to collect wood and don't assign them tasks and work, but rather teach them to long for the endless immensity of the sea.</blockquote></span><div style="text-align: right;"><a href="http://www.brainyquote.com/quotes/authors/a/antoine_de_saintexupery.html">Antoine de Saint-Exupery</a><br /></div><br />Steve Yegge has <a href="http://steve-yegge.blogspot.com/2006/09/good-agile-bad-agile_27.html">suggested</a> that if 90% of the projects adopting a methodology fail, you have to stop blaming the people. You have to stop saying "you're not doing it right." You have to say <span style="font-style: italic;">there's something wrong with the methodology itself if 90% of the projects fail to use it properly</span>.<br /><span style="font-style: italic;"><br /></span>Sounds reasonable. But why would this be true for methodologies but not true for programming languages?<br /><br />99.999% of the software written in almost any language (including Lisp, Python, and Ruby) is buggy. Yet we readily say that the problem is the programmer. We think that some languages are better than others, that some languages help eliminate certain classes of bugs, but we take as a given that good tools are not sufficient unto themselvesfor good results. We know that the quality of the result is almost entirely driven by the quality of the programmer.<br /><br /><blockquote>I have the uncomfortable feeling that others are making a religion out of it, as if the conceptual problems of programming could be solved by a single trick, by a simple form of coding discipline!</blockquote><div style="text-align: right;">Edsger Dijkstra<br /></div><br />Home Depot might suggest that buying a new table saw will cause beautiful woodwork to appear in your home. Yet just because a duffer with a table saw cannot make built-in closets all by himself, we don't abandon table saws outright. We assume that good woodworking is <span style="font-style: italic;">better</span> with good tools. And if we are blessed with the skill to make a built-in closet with a hand saw, we know that we can also make the closet with a table saw, and <span style="font-style: italic;">we judge the table saw on whether and how it can improve the results we could have obtained with another tool</span>.<br /><br />This is my criteria for judging a methodology. Can it improve a team that is already fundamentally qualified to write software?<br /><br />If you want to stop reading here, my statement is that you can only judge a methodology on the basis of the results it delivers for a team that has already proven it can ship software. You judge it on the basis of <span style="font-style: italic;">incremental value</span>. You don't compare its results to the results some other team gets, or to your fantasy of what results the team 'ought' to get.<br /><span style="font-style: italic;"><br /></span><span style="font-weight: bold;">The mythical marginal</span><span style="font-style: italic;"><br /></span><br />What I've written seems obvious. Yet, billions of dollars are paid every year to people who are selling a different perspective. What is it that causes companies to buy silver bullet after silver bullet? Why do companies lurch from consultant to methodology to programming language like infomercial junkies looking for something that will flatten their tummies without sweaty exercise or unpleasant diets?<br /><br />I bifurcate teams into those that are fundamentally qualified and those that aren't. And I believe that to fix an unqualified team, you start with the people, not the process or the tools. So what could the rest of the IT industry possibly believe?<br /><br />I have observed a belief in a marginal team. A team that is somehow straddling the fence between incompetence and competence. They can ship software, but only with help from their process and tools. If 'marginal' is too perjorative a term, you could think of them as having <span style="font-style: italic;">unactualized potential</span>.<br /><br />In truth, I have worked with several such teams, so I believe they exist. However, I believe that such teams are quite rare, while proponents of silver bullets make a living convincing customers that marginal teams are commonplace.<br /><br />The primary example I have observed of a marginal team is a team composed of individuals who are not working together well, yet they have achieved success on other teams in prior roles. Something like the Los Angeles Lakers before Phil Jackson arrived. There is a lot of latent championship potential in the individuals, but the team isn't performing.<br /><blockquote>Shipping software is not an emergant property of competent programming, nor is it a consequence of management technique.</blockquote>Why does the IT industry believe that perhaps most teams that fail are marginal teams? They have to believe this, otherwise they wouldn't waste time and money trying new silver bullets ("everything should be a stored procedure," "tests are the only documentation that matter").<br /><br /><span style="font-weight: bold;">It always comes back to hiring</span><br /><br />My broken-record assertion is that the industry as a whole embraces the above model of a marginal team: latent potential in the individuals. The difference between the industry and I is that I have an objective measure of latent potential: <span style="font-style: italic;">has the individual demonstrated success shipping software in the past</span>.<br /><span class="body"></span><blockquote><span class="body">True happiness comes from the joy of deeds well done, the zest of creating things new.</span> </blockquote><div style="text-align: right;"><a href="http://www.brainyquote.com/quotes/authors/a/antoine_de_saintexupery.html">Antoine de Saint-Exupery</a><br /></div><br />The industry doesn't apply this test rigorously, if at all. A typical interview with a developer focuses on patterns and archiecture, on talking about past achievements. Developer's don't <a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html">juggle</a>. Developer's don't <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">design software</a>. And especially, managers don't hire developers with super-strong references from strong employees that have worked with the candidate in the past.<br /><br />Basically, managers ask developers if they can ship software and then take the candidate's word for it. If you take only one thing from this blog post, take this: <span style="font-style: italic;">shipping software is not an emergant property of competent programming, nor is it a consequence of management technique</span>. Someone can demonstrate the ability to write software but lack the ability to actually ship software.<br /><br /><span style="font-style: italic;">(Update</span>: nothing in this post should be construed to suggest that people cannot become better developers through study, mentorships, or training. However, training is to hiring as tools are to skill. And they are not mutually exclusive, any more than good programmers and good tools are mutually exclusive.)<br /><br />I believe that the reason why the IT industry believes that most failing teams are marginal rather than outright incompetent is that they believe that these teams are composed of individuals who can write software and managers who can direct work. All they need are the right tools to write software "better" and better software will emerge. All they need is a methodology to manage software development better and software will ship.<br /><br />If you have a marginal team, a team composed of individuals with proven ability to ship working software, you might have something there. But if a team isn't even marginal, no methodology will help. And that's why a useful methodology can still fail to help 90% of the teams that try it.<br /><br />For the same reason that Wasabi makes Sushi divine.<br /><br /><span style="font-size:85%;">Follow-up: <a style="font-style: italic;" href="http://raganwald.github.com/2006/10/three-questions-and-three-answers.html">Three questions and three answers about Wasabi and Rotten Fish</a></span><br /><br /><span style="font-size:85%;">Postscript: <span style="font-style: italic;">The difference between Sashimi and Nigiri</span></span><br /><br /><span style="font-size:85%;">If we're judging success or failure of a development methodology, we have to judge the results on whether the development itself was successful. We can't judge whether the software made money, or whether the company's stock soared. Such things can be studied, however those are <span style="font-style: italic;">product management<span style="font-style: italic;"> </span></span>problems, not <span style="font-style: italic;">software development problems.<br /><br /></span>People have criticised Google, saying that althought it has a track record for shipping products, only one, AdWords, is financially successful. If you want to compare product management methodologies, that's fine, but you aren't talking about software development. You have to compare similar kinds of projects, for example you can't compare an in-house IT project with a known ROI (reduce the time spent entering a new Blort Ticket by 50%, saving $47.32 per week per Fizbang team member) to speculative product development like a new Web 2.0 calendar.<br /><br />Who else is trying to create new products? Apple? Microsoft? Dan Bricklin? Compare <span style="font-style: italic;">them</span> to Google, and if they are doing a better job of making money with their projects, post a critique of Google's product management on your blog.<br /><br />-r.b.<br /></span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="permanent link">8:13 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, September 05, 2006</div>
			

			<div class="Post"><a name="115749758551074651">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/09/business-programming-simply-isnt-that.html" title="permanent link">Business programming simply isn't that hard</a></span>
					<div style="clear:both;"></div>Business programming simply isn't that hard, right?<br /><br />Seriously, how hard can it be to wire  a SQL database to some basic business rules ("<span style="font-style: italic;">employee HAS-A manager, employee.manager_id != employee.id</span>") and add some AJAXy goodness on top like <span style="font-style: italic;">edit_in_place</span>? Business applications are a simple pyramid with the frameworks doing the heavy lifting at the bottom and the AJAXy goodness on the top providing the sizzle that makes users say "wow." Right?<br /><br /><a href="http://www.flickr.com/photos/raganwald/193444521/" title="The Ultimate Pyramid"><img src="http://static.flickr.com/74/193444521_e7f11ede88_o.jpg" alt="The Ultimate Pyramid" border="0" height="545" width="487" /></a><br /><br />And needless to say, business applications are borrrring! Nothing about the programming is stimulating. It's all a question of managing requirements, priorities, and figuring out how to cram ninety hours worth of work into a seventy hour week to stave off the outsourcing.<br /><br />But... Could there be <a href="http://raganwald.github.com/2006/05/how-to-make-programming-hard-for.html">interesting problems to seek out</a> in business? Try a couple of these on for size:<br /><br /><span style="font-weight: bold;">Real time risk management</span><br /><br />You have an online banking application. Your goal is to produce a system that can alert a customer service rep when <a href="http://en.wikipedia.org/wiki/Bank_fraud">suspicious activity</a> is detected so that they can telephone the customer before the customer has left the web site. How can you detect suspicious activities in real time?<br /><br />For an example of how this works, consider credit cards. I often make very large computer purchases, and they never bat an eyelash. But when I purchase <a href="http://www.tiffany.com/">jewelry</a> for my wife, I get a call. A friend swears she gets the same pattern, but they called her when she purchased an <a href="http://www.apple.com/ca/ipod/">iPod</a> because she doesn't usually purchase electronics.<br /><br />Your system will notice weird patterns, like a customer who never banks internationally suddenly trying to transfer money to Russia. But take heed: you don't want to be bothering the fur importer who regularly does business in the "Wild Wild East." You need to look for <span style="font-style: italic;">suspicious</span> patterns. And you need to explain it simply enough that a customer service rep knows how to verify the transaction with the customer.<br /><br />Did I meantion <span style="font-style: italic;">in real time</span>? Visa normally calls me within a few hours. Your goal is to make the call <span style="font-style: italic;">while the customer is still on line</span>.<br /><br /><span style="font-weight: bold;">Let's get our hands dirty</span><br /><br /><a href="http://en.wikipedia.org/wiki/Concrete">Concrete</a> is funny stuff. From the moment you start mixing it, you have a limited amount of time it can sit in the mixer truck before it has to get poured. Construction sites need so much an hour, no more and no less. A cement company can't send a customer one hundred trucks simultaneously and have them idling on site, they have to arrive just as they're needed.<br /><br />In major cities, <span style="font-style: italic;">traffic</span> is a problem. So build a system that can dispatch and direct the trucks in real time. Your input will be demand from customers plus real time traffic and road construction reports, which your system will use to update a graph representation of the road network. Naturally, it will <a href="http://en.wikipedia.org/wiki/Shortest_path">search the network in real time for apropriate paths</a> for the trucks. They're outfitted with GPS units, so you will have real time locations for your trucks.<br /><br />Don't forget to manage the return of the empty trucks to your site. Concrete is a low margin business, so operational efficiency is a <span style="font-style: italic;">competitive advantage</span>. Do a great job, and your company could become the dominant supplier.<br /><br /><span style="font-weight: bold; font-style: italic;">update</span>:<span style="font-style: italic;"> This isn't just finding the fastest way to get trucks to their destinations. That is not a simple problem, but you must also solve the flow problem: </span><span style="font-weight: bold; font-style: italic;">when do the trucks have to leave your yard in order to arrive at each customer's site on schedule</span><span style="font-style: italic;">? If a customer is ninety minutes away and traffic is building towards ruch hour, you have to leave earlier. How much earlier? Do you send two trucks by different paths at certain times and reroute one of the trucks if the other arrives ahead of schedule? When an accident suddenly clogs the freeway, is your system able to predict how long the freeway will be closed and what the effects will be on alternate routes?<br /><br />To do this job well, you're going to have to have a really good model of traffic in the city you serve. Don't forget to build the <a href="http://bluejays.mlb.com/">baseball</a>, <a href="http://www.argonauts.on.ca/">football</a>, <a href="http://www.torontomapleleafs.com/">hockey</a>, and <a href="http://www.nba.com/raptors/">basketball</a> schedules into your system, along with big ticket concerts :-)<br /></span><br /><span style="font-weight: bold;">...his lips are moving, that's how</span><br /><br />Consider any large organization that makes big-ticket sales to walk-in prospects. Let's choose car sales. Some prospects will walk in and buy right away, others will never buy. Some will buy, but only if you follow up with a call after they've been in for a test drive.<br /><br />When's the right time to call them back? If salespeople call too soon, they waste time, make the prospects feel pressured, and their quote ends up being fodder for the competition to beat and steal the business. But of they call too late, the prospect will have bought from someone else.<br /><br />Build a system that learns over time when to call each prospect. For starters, you'll have access to a survey team that will call a sample of prospects that didn't buy. They will fill out a form about the prospect (age, gender, household income, zip code, car they owned, car they bought, anything else you can gather), along with when they bought.<br /><br />This becomes your training corpus. Now build a system that the salespeople use to manage callbacks. Your system must suggest when to call the prospect in order to have the best chance of closing the deal.<br /><br />Yes, your system must be able to train itself. Yes, your system must do "meta-training": if the zip code isn't significant but the age of their existing car is significant, your system must recommend dropping the former from the survey and promoting the latter to the top of the form. And you ought to add new questions from time to time and test them for relevance.<br /><br />Oh yes, you'll have to infer distributions like the <a href="http://en.wikipedia.org/wiki/Erlang_distribution">Erlang</a>, <a href="http://en.wikipedia.org/wiki/Normal_distribution">Normal</a>, or <a href="http://en.wikipedia.org/wiki/Binomial_distribution">Binomial</a> for purchase times: it should figure out the most appropriate model for lag between test drive and purchase.<br /><br />Did I mention the scale? This system should be rolled out to every dealer in North America, and every salesperson on duty will be using it. How many dealers are there? I think you answered that question in your job interview, didn't you?<br /><br /><span style="font-weight: bold;">Well?</span><br /><br />Does business programming have to <a href="http://raganwald.github.com/2006/09/just-in-time-for-labour-day.html">suck</a>?<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/09/business-programming-simply-isnt-that.html" title="permanent link">4:13 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, August 11, 2006</div>
			

			<div class="Post"><a name="115530532347740461">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html" title="permanent link">Dear Agile Metaprogrammer</a></span>
					<div style="clear:both;"></div>I read and enjoy your weblog. You are fairly witty and your stories about attending Woodstock-like <a href="http://ll2.ai.mit.edu/">love-in</a>s are always amusing. And although I have no intention of even trying <a href="http://www.rubycentral.com/book/lib_standard.html">Ruby</a> on <a href="http://www.loudthinking.com/">Rails</a>, <a href="http://planet.lisp.org/">Lisp</a>, <a href="http://spyced.blogspot.com/">Python</a>, <a href="http://lambda-the-ultimate.org/">Haskell, Lua, or whatever else you are fawning over</a> at the moment, there are some snippets of interesting technical knowledge to be gleaned from your experiences.<br /><br /><a href="http://www.flickr.com/photos/raganwald/212610290/" title="(c) 2005 Darrin Weissinger"><img src="http://static.flickr.com/62/212610290_37a4d863f5.jpg" alt="(c) 2005 Darrin Weissinger" border="0" height="412" width="500" /></a><br /><br />For example, just the other week I realized that with fewer than 500 lines of intricate code and a few pages of boilerplate interfaces (I was going to have to define all those Java types and methods anyway, so it's free, right?), I could use an <a href="http://java.sun.com/j2se/1.3/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a> to remove some duplication from my code. I would never have thought of that if I hadn't read about how Ruby lets you make delegates with one line of code.<br /><br /><a href="http://philip.greenspun.com/research/">Philip</a> would be proud of me. But let's get to why I'm writing, ok?<br /><br /><span style="font-weight: bold;">Your posts are getting tiresome</span>.<br /><br /><a href="http://mark-watson.blogspot.com/2006/06/incredible-what-few-lines-of-ruby-code.html">Blah, blah, blah</a> <span style="font-style: italic;">the indexing takes about 20 lines of code and took less than 10 minutes to get working</span>. <a href="http://magicmodels.rubyforge.org/">Blah, blah, blah</a> <span style="font-style: italic;">magic models</span>. <a href="http://tinyurl.com/loxac">Blah, blah, blah</a> <span style="font-style: italic;">rewrite reddit in Lisp in one hundred lines and twenty minutes</span>. Worst of all, <a href="http://www.jroller.com/page/obie?entry=productivity_arbitrage">blah, blah, blah</a> $<span style="font-style: italic;">800,000 contract</span>. That's real money!<br /><br />I don't mind fanboys, <a href="http://en.wikipedia.org/wiki/Luser">luser</a>s that brag about these 'metaprogramming' languages but never actually do any work with them.<br /><br />But how irritating to hear yet another Rubyist, Pythonista, or Lisper brag about getting actual work done in half the time, with half the effort, then taking the rest of the day off to enjoy the <a href="http://flickr.com/photos/raganwald/16406258/">Real World</a>.<br /><br />Some of us are busy doing <a href="http://duckdown.blogspot.com/2006/03/large-enterprises-and-why-they-dont.html">Enterprise</a> work, you know, and we're man enough to put in seventy hour weeks debugging our XML parsers, <a href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/FrontController.html">Front Controllers</a>, and verbosely typed languages (<a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html">VTL</a>s). We don't want to hear about your Euro-style three hour lunch breaks and incremental delivery schedules.<br /><br />We do the heavy lifting and <a href="http://news.com.com/Vista+debut+hits+a+delay/2100-1016_3-6052270.html">we have the GANTT charts to prove it</a>.<br /><br />So just cut it out, ok?<br /><br />p.s. <em>I'm sorry I'm so testy, but I've been up all night trying to talk to our QA team located in Bangalore. It's bad enough that I don't speak any of their five mother tongues, but it looks like their QA plan is based on a different version of the specs than we got in our supposedly locked down briefing package from the <a href="http://www.kuro5hin.org/story/2005/9/27/95759/4240">consultants</a> that were hired to gather requirements.</em><br /><br />p.p.s. <em><a href="http://raganwald.github.com/2006/08/and-another-thing-you-software-as.html"> And another thing, you Software As A Service gadfly...</a></em><br /><span style="font-size:78%;"></span><p></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html" title="permanent link">9:46 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, July 02, 2006</div>
			

			<div class="Post"><a name="115186402509398821">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html" title="permanent link">Hiring a Juggler</a></span>
					<div style="clear:both;"></div>Circus Manager: How long have you been juggling?<br />Candidate: <span style="font-style: italic;">Oh, about six years.</span><br /><br />Manager: Can you handle three balls, four balls, and five balls?<br />Candidate: <span style="font-style: italic;">Yes, yes, and yes.</span><br /><br /><style type="text/css">.flickr-photo { border: solid 2px #000000; }.flickr-yourcomment { }.flickr-frame { text-align: left; padding: 3px; }.flickr-caption { font-size: 0.8em; margin-top: 0px; }</style><div class="flickr-frame"> <a href="http://www.flickr.com/photos/x180/32055405/" title="photo sharing"><img src="http://static.flickr.com/21/32055405_5d5fbb5e4f.jpg" class="flickr-photo" alt="" /></a><br /><span class="flickr-caption"><a style="font-style: italic;" href="http://www.flickr.com/photos/x180/32055405/">OSCon 2005: Juggler</a><span style="font-style: italic;">, originally uploaded by </span><a style="font-style: italic;" href="http://www.flickr.com/people/x180/">x180</a><span style="font-style: italic;"> Courtesy James Duncan Davidson/O&#8217;Reilly Media.</span><br /></span></div>    <p class="flickr-yourcomment"> Manager: Do you work with flaming objects?<br />Candidate: <span style="font-style: italic;">Sure.</span><br /><br />Manager: &#8230;knives, axes, open cigar boxes, floppy hats?<br />Candidate: <span style="font-style: italic;">I can juggle anything.</span><br /><br />Manager: Do you have a line in funny patter that goes with your juggling?<br />Candidate: <span style="font-style: italic;">It&#8217;s hilarious.</span><br /><br />Manager: Well that sounds fine. I guess you&#8217;re hired.<br />Candidate: <span style="font-style: italic;">Umm&#8230; Don&#8217;t you want to see me juggle?</span><br /><br />Manager: Gee, I never thought of that.<br /><br />&#8220;It would be ludicrous to think of hiring a juggler without first seeing him perform. That&#8217;s just common sense. Yet when you set out to hire an engineer or a designer or a programmer or a group manager, the rules of common sense are often suspended. You don&#8217;t ask to see a design or a program or anything. In fact, the interview is just talk.&#8221;<br /><br />(HIRING A JUGGLER, Chapter 15 of <a href="http://www.amazon.com/gp/product/0932633439?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0932633439">Peopleware: Productive Projects and Teams</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0932633439" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> by Tom DeMarco and Timothy Lister.)<br /><br /><strong>Update: Some relevant links</strong><br /><br /><blockquote>Of course, some interviewers are just looking for an excuse to talk about technical issues and will not prejudge you in any way. Speaking for myself, I would laugh if you wrote something like this out. But then again, I once worked for someone who had won the second International Obfuscated C Contest.<br /><div style="text-align: right;"><em><a href="http://raganwald.github.com/2007/01/dont-overthink-fizzbuzz.html">Don&#8217;t Overthink Fizzbuzz</a></em></div></blockquote><br /><br /><blockquote>What I&#8217;m about to say will be blindingly obvious to the Enterprise crowd (sorry, not you over there with the <a href="http://greasemonkey.mozdev.org/">Greasemonkey </a>script that translates your web email to Klingon). <span style="font-style: italic;">The rules must be considered as carefully as the entities</span>. Enterprise developers have known this for years: that&#8217;s why you see rules engines, table-driven designs, and visual workflow editors in many Enterprise applications.<br /><div style="text-align: right;"><em><a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a></em></div></blockquote><<br /><br /><blockquote>In case you didn’t know this, about 1/3 of all technical interview questions worldwide are variants of “How do you fit 10 pounds of crap in a five-pound bag?” Examples: how do you reverse a string in place, how do you sort a billion numbers, how do you write a decent compiler backend for an architecture with only four frigging registers, how do you handle fair scheduling when someone just forked off 1000 copies of some Towers of Hanoi simulation, etc.<br /><div style="text-align: right;"><em><a href="http://www.oreillynet.com/ruby/blog/2006/03/interviewing_ruby_programmers.html">Interviewing Ruby programmers</a></em></div></blockquote><br /><br /><blockquote>I&#8217;m exaggerating a lot, but the point is, when you select 1 out of 200 applicants, the other 199 don&#8217;t give up and go into plumbing (although I wish they would&#8230; plumbers are impossible to find). They apply again somewhere else, and contribute to some <em>other</em> employer&#8217;s self-delusions about how selective they are.<br /><div style="text-align: right;"><em><a href="http://www.joelonsoftware.com/items/2005/01/27.html">Joel on Hiring</a></em></div></blockquote><br /><br /><blockquote><em></em>And then there is the issue of why would someone care if I knew how to write a file copy function, ahead of what the difference between an interface and an abstract class was. Or when would I use encapsulation? Or in my design, how would I choose between polymorphism or inheritance? Or what pattern would I recommend for dealing with a general or specific problem?<br /><div style="text-align: right;"><em><a href="http://blogs.msdn.com/davidlem/archive/2006/05/16/598696.aspx">What&#8217;s with the programming test!?</a></em></div></blockquote><br /><br /><blockquote><em></em>I know lots and <em>lots</em> of interviewers, at many companies, who&#8217;ve decided that they can fully evaluate you based on whether you can solve some particular convex optimization problem (or graph-search problem, or logic problem, or whatever their pet Elephant Question is), and they ask every candidate this question regardless of their background or experience. In fact, I&#8217;d estimate that some 10% of all technical interviewers ask the same questions, year after year, and they could care less about your experience.<br /><div style="text-align: right;"><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html"><em>The Truth About Interviewing</em></a></div></blockquote><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html" title="permanent link">2:09 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, June 12, 2006</div>
			

			<div class="Post"><a name="115012606053917465">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html" title="permanent link">My favourite interview question</a></span>
					<div style="clear:both;"></div>Some years back, I was interviewed by an interesting start-up in Palo Alto. I was really tempted to take their offer, mostly because:<br /><ol><li>One of the interviewers was an avid Ultimate player;</li><li>Stanford. In walking distance. (And the regular Stanford Friz-ball variant game);</li><li>They asked me a question which has become my favourite interview question to ask and to answer.</li></ol>The question they asked was:<br /><br /><div style="text-align: center;"><span style="font-weight: bold;">How might you design a program that lets people play <a href="http://en.wikipedia.org/wiki/Monopoly_%28game%29">Monopoly</a> with each other over the internet? </span><br /></div><br /><br />Of course there&#8217;s a lot to be learned on both sides when an interviewee is asked to design something and explain their design. Both parties learn a lot about each other&#8217;s communication styles and approach.<br /><br />It works both ways: for example, if I were sketching out a design and the interviewers repeatedly interrupted me to discuss my UML notation, I could infer certain things about their culture.<br /><br />Those kinds of issues apply to any reasonably sized design problem. Anything larger than, say, &#8220;write a procedure that reverses a string in place.&#8221; But let&#8217;s look at three of the characteristics of the game of Monopoly that I find attractive for this exercise:<br /><ul><li>Monopoly is poorly defined;</li><li>Monopoly requires more than simplistic object design, and;</li><li>Monopoly is too big to be designed in one session.<br /></li></ul>First, <span style="font-weight: bold;">Monopoly is poorly defined</span>. Chess, for example, is rigorous. The <a href="http://richard_wilding.tripod.com/monorules.htm">official rules of Monopoly</a> are silent on some critical questions and vague on others. A tournament-playing aficionado will realize this immediately, but it&#8217;s easy to guide a candidate to this realization by asking some of the well-known <a href="http://www.google.ca/search?q=monopoly+faq">FAQ questions</a>.<br /><br />This &#8216;problem&#8217; makes it a great interview question. It drives a lot of valuable interaction between the candidate and the interviewers. You have to ask questions, make assumptions, and know when to stop gathering requirements and start driving the design.<br /><br /><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FMonopoly-Game-70th-Anniversary-Edition%2Fdp%2FB00061I4YM%2Fsr%3D8-2%2Fqid%3D1165601433%3Fie%3DUTF8%26s%3Dtoys-and-games&amp;tag=raganwald-store-20&amp;linkCode=ur2&amp;camp=1789&amp;creative=9325"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/monopoly-773348.jpg" border="0" alt="" /></a>There have been some blog posts pointing out that <a href="http://exold.com/article/stupid-interview-questions">even trivial requirements can have many hidden implications</a>. A determined and finicky developer can drive questions for the length of the interview. I think Monopoly&#8217;s missing requirements actually improve its suitability as an interview question.<br /><br />If the candidate uses up all of the interview time trying to obtain perfect requirements, we have a problem. In the software development I do, the requirements are never perfect. I don&#8217;t demand that a candidate try to create an agile, iterative process on the spot, but I look for someone who knows when to say &#8220;close enough, let&#8217;s move forward.&#8221;<br /><br />Another good way to move forward for both interviewer and candidate is to say, &#8220;ok, we&#8217;ve covered the most important requirements. Let&#8217;s make a bunch of assumptions and document them. In a real-world situation we could obtain feedback on the assumptions after presenting an initial approach.&#8221;<br /><br />After all, who&#8217;s to say that a programmer, designer, or architect is always 100% beholden to others for requirements?<br /><br />The second reason I like this problem is that <span style="font-weight: bold;">Monopoly requires more than just a simplistic object design</span>. What I&#8217;m about to say will be blindingly obvious to the Enterprise crowd (sorry, not you over there with the <a href="http://greasemonkey.mozdev.org/">Greasemonkey </a>script that translates your web email to Klingon). <span style="font-style: italic;">The rules must be considered as carefully as the entities</span>. Enterprise developers have known this for years: that&#8217;s why you see rules engines, table-driven designs, and visual workflow editors in many Enterprise applications.<br /><br />Now let&#8217;s talk about &#8216;object-oriented programming&#8217; for a second. 99% of the stuff you read discusses modeling real-world physical objects. Things. Nouns. It is a <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Kingdom of Nouns</a>. Most candidates start every design by dutifully listing all of the nouns they can think of and then they spend the rest of the time available thinking about piling them into phyla, hierarchies of &#8220;IS-A&#8221; and &#8220;A-KIND-OF.&#8221;<br /><br />This approach, which I will call &#8220;noun and verb,&#8221; is so limited I&#8217;ll dare to call it <a href="http://www.folklore.org/StoryView.py?project=Macintosh&amp;story=A_Mac_For_Mick.txt">brain damaged</a>. In fun. But seriously, competent software developers spend much more time on relationships, responsibilities, and constraints than they do on trying to <a href="http://www.petefreitag.com/item/509.cfm">prematurely optimize</a> reuse through inheritance.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201379430"><img border="0" width="128" height="160" src="http://raganwald.github.com/uploaded_images/object_design-719894.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201379430">Object Design: Roles, Responsibilities, and Collaborations</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> focuses on the practice of designing objects as integral members of a community where each object has specific roles and responsibilities. The authors present the latest practices and techniques of Responsibility-Driven Design and show how you can apply them as you develop modern object-based applications.  <br /><br /></div>Now let&#8217;s ask a question about Monopoly (and Enterprise software). <span style="font-style: italic;">Where do the rules live?</span> In a noun-oriented design, the rules are smooshed and smeared across the design, because every single object is responsible for knowing everything about everything that it can &#8216;do&#8217;. All the verbs are glued to the nouns as methods.<br /><br />Let&#8217;s take a look at a simple rules question. <span style="font-style: italic;">If a player owns Baltic Avenue, can she add a house to it?</span><br /><br />Well, there&#8217;s a bunch of stuff about whether she can afford it and whether there is a house available in the bank. Where does that live? In the bank object? And there is a bunch of stuff about whether it is either the player&#8217;s turn or between turns. Where does that live?<br /><br />And there is a bunch of stuff about whether the property already has four houses. Where does that live? Somewhere in the property hierarchy? Sounds reasonable. Now what about mortgaged property? If Baltic is mortgaged, the answer is <span style="font-weight: bold;">no</span>. That&#8217;s easy. But what if Mediterranean Avenue is mortgaged? And what if, for example, Baltic has one house but Mediterranean has none? Where does that logic live? Both of these last two questions involve knowing something about the other properties of a colour group.<br /><br />Now you can debate which verbs belong to which nouns, but here is an opportunity to step back a bit and consider the larger implications of maintaining such a &#8216;classical&#8217; OO design.<br /><br />Consider a &#8216;noun and verb&#8217; design. First, an easy question. <span style="font-style: italic;">How well does the design document the actual game of Monopoly?</span> If someone were to read the source code, do you think they could learn how to play the actual game?<br /><br />Is this a <a href="http://www.quotationspage.com/quote/27543.html">stupid question</a>? I think it strikes at the root of sustainable software development. In real world applications, software lives for a long time and teams change over that time. Programmers are often asked to maintain software with insufficient training in its intended use.<br /><br />OO programs can be brilliant communicators in some designs (&#8220;here&#8217;s everything I need to know about a Money Transfer&#8221;) and terrible in others. I think this is part of the appeal and effectiveness) of the <a href="http://jamis.jamisbuck.org/articles/2006/04/20/writing-domain-specific-languages">Domain Specific Language</a> approach. It does a better job of communicating its intentions than a simple OO design.<br /><br />I&#8217;m not saying that a DSL is right for Monopoly. Or wrong. Just that it&#8217;s valuable to consider this issue when discussing an approach. There is a lot of opportunity for a candidate and the interviewers to learn about each other&#8217;s thinking that goes way beyond coding if you spend a few moments discussing the importance (or irrelevance) of a design that communicates its intentions. And I think that makes Monopoly a good design subject.<br /><br />Another issue about the rules. In software development, requirements often change. <span style="font-style: italic;">What kinds of requirements changes are easy with the design? What kinds are difficult?</span><br /><br />I suspect it&#8217;s easy to change the prices and names of properties, but very difficult to change the fundamental rules. Well, it&#8217;s probably easy to introduce the popular &#8216;lottery&#8217; variation where fines are paid into a pool and anyone landing on Free Parking&#8217; scoops  it up.  But some of the more esoteric variations would require making lots of changes to many different classes.<br /><br />The &#8216;noun and verb&#8217; design is tightly coupled, and distributes the rules across the design. If you really want a mess, consider that popular computer versions of Monopoly allow you to pick and choose rules variations for each game.<br /><br />The key to making this easy is to find another way to represent the rules. I generally provide hints along these lines by asking the candidate how they plan to implement the Chance and Community Chest cards. What is the relationship between the cards, special squares like &#8220;Luxury Tax,&#8221; and introducing variant rules?<br /><br /><blockquote style="font-style: italic;">(You can probably save yourself a lot of interview time. Instead of all this hoopla, ask the candidate to describe when they have actually used the <a href="http://c2.com/cgi/wiki?StrategyPattern">Strategy</a>, <a href="http://c2.com/cgi/wiki?VisitorPattern">Visitor</a>, and <a href="http://c2.com/cgi/wiki?CommandPattern">Command</a> patterns outside of a framework.)</blockquote>The bottom line is that designing a Monopoly game requires giving a lot of thought to representing the rules. There are a lot of ways to do that. I&#8217;ve hinted at two, and you I&#8217;ve heard of a lot of other interesting approaches. It&#8217;s a great chance to really go beyond OOP 101.<br /><br />Now to close as rapidly as possible with what I consider an essential characteristic of a good design problem, and one that applies here. <span style="font-weight: bold;">Monopoly is too large to solve in one interview</span>. This is related to the vague requirements characteristic I mentioned above.<br /><br />The reason this is important is that it forces the designer to pick and choose what elements of the design to solve in limited time. Some candidates will fail outright because their problem solving style is to consider all of the implications before starting. It&#8217;s easy to spend hours on a problem like Monopoly. But will you get up and apply the marker to the white board?<br /><br />>Does a candidate start with the trivia? Who cares how to represent the colour of a property? CSS? A getter in each object? Yawn. I&#8217;ll prod him to move along.<br /><br />Perhaps a candidate spends all of her time working in an area of the problem she knows well. Some candidates can spend forever engineering a Monopoly Online site up to <a href="http://joedrumgoole.com/blog/2006/05/29/web-20-vs-web-10/">Web 1.0</a> scale. Or building <a href="http://novator.com/">FTD.com</a>-like <a href="http://www.37signals.com/svn/archives2/dont_scale_99999_uptime_is_for_walmart.php">reliability</a>. Whatever.<br /><br />I&#8217;m not saying that&#8217;s bad. Or good. But I will say that given a problem too large to solve in the time allotted, there&#8217;s fantastic value in evaluating what&#8217;s important. And that cuts both ways. If you think that some of the OO design choices are critical but the interviewers hand wave it and want to see how you plan to handle 10,000 requests per minute, that&#8217;s revealing.<br /><br /><span style="font-weight: bold;">Summary</span><br /><br />I like asking (and being asked) about Monopoly because it provides fertile ground for discussing issues that are critical to judging both competence and cultural fit, like:<br /><ul><li>Communication style and skills;</li><li>Deep OO design philosophy;</li><li>Prioritization and time management, and;</li><li>Handling ambiguity.</li></ul>And now, if you have a moment, I&#8217;d like to ask for your feedback. Is there a better design question to ask? What is your perspective as an interviewee? What other issues about a design should be discussed during an interview?<br /><br />I&#8217;m looking forward to hearing from you. Thanks in advance!<br /><br /><strong><a name="caution">Update: A cautionary note</a></strong><br /><br />Some people have objected to this question because it may be a trivia challenge: how well does the candidate know the game of Monopoly? In the comments I mentioned that the question really only applies to candidates that already know the game.<br /><br />Others have suggested it may be a form of &#8220;guess the design I&#8217;m thinking of&#8221; where there is exactly one right answer, the design the interviewer has already come up with. I think this is a legitimate concern.<br /><br />It really applies to <span style="font-weight: bold;">any </span>interview question. For example: &#8220;name your three strengths&#8221; or &#8220;tell me about a challenge you faced in your last position and how you overcame the obstacles.&#8221; If an interviewer is looking for something specific, they can and will twist any interview question into a variation of &#8220;guess the answer I&#8217;m thinking of.&#8221;<br /><br />I won&#8217;t say that Monopoly is somehow better than other questions in this regard, nor is it worse. If you have an interview based on reviewing a candidate&#8217;s past accomplishments, don&#8217;t you think there are some interviewers that will discount those that don&#8217;t fit their personal criteria for merit?<br /><br /><blockquote>I once had an interview where the interviewer spent forty minutes talking to me about my education, and something like fifteen talking about my fifteen years (at that time) of actual career experience. Bias in an interviewer is orthogonal to the choice of interviewing technique.<br /></blockquote><br /><br />What do these two cautions have in common? Only that the most important thing for a successful interview is that the interviewer be genuinely seeking out a view of the candidate&#8217;s strengths and weaknesses. All I can really say about this question is that if (and it&#8217;s a big if) the interviewer is sincerely attempting to evaluate a candidate&#8217;s technical ability, and if the candidate has some familiarity with the game, then the session can be very productive.<br /><br /><strong>Update: Some relevant links</strong><br /><br /><blockquote>It would be ludicrous to think of hiring a juggler without first seeing him perform. That&#8217;s just common sense. Yet when you set out to hire an engineer or a designer or a programmer or a group manager, the rules of common sense are often suspended. You don&#8217;t ask to see a design or a program or anything. In fact, the interview is just talk.<br /></blockquote><br /><br /><div style="text-align: right;"><em><a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html">Hiring a Juggler</a></em></div><br /><br /><blockquote>The bottom line in my interviewing technique is that smart people can generally tell if they’re talking to other smart people by having a conversation with them on a difficult or highly technical subject, and the interview question is really just a pretext to have a conversation on a difficult subject so that the interviewer’s judgement can form an opinion on whether this is a smart person or not.<br /></blockquote><br /><br /><div style="text-align: right;"><a href="http://www.joelonsoftware.com/articles/ThePhoneScreen.html"><em>The Phone Screen</em></a></div><br /><br /><blockquote>Think of three things you want the interviewer to know about you that you think they are unlikely to find out if they ask all the questions. The important ideas are that (a) you want the interviewer to know about each of the three things, and that (b) the interviewer is unlikely to ask about all three if you don’t exercise some control over the interview.<br /></blockquote><br /><div style="text-align: right;"><a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html"><em>Take control of your interview</em></a></div><br /><br /><blockquote>In case you didn’t know this, about 1/3 of all technical interview questions worldwide are variants of “How do you fit 10 pounds of crap in a five-pound bag?” Examples: how do you reverse a string in place, how do you sort a billion numbers, how do you write a decent compiler back end for an architecture with only four frigging registers, how do you handle fair scheduling when someone just forked off 1000 copies of some Towers of Hanoi simulation, etc.<br /></blockquote><br /><div style="text-align: right;"><em><a href="http://www.oreillynet.com/ruby/blog/2006/03/interviewing_ruby_programmers.html">Interviewing Ruby programmers</a></em></div><br /><br /><blockquote>I&#8217;m exaggerating a lot, but the point is, when you select 1 out of 200 applicants, the other 199 don&#8217;t give up and go into plumbing (although I wish they would&#8230; plumbers are impossible to find). They apply again somewhere else, and contribute to some <em>other</em> employer&#8217;s self-delusions about how selective they are.<br /></blockquote><br /><br /><div style="text-align: right;"><em><a href="http://www.joelonsoftware.com/items/2005/01/27.html">Joel on Hiring</a><br /></em></div><br /><br /><blockquote>And then there is the issue of why would someone care if I knew how to write a file copy function, ahead of what the difference between an interface and an abstract class was. Or when would I use encapsulation? Or in my design, how would I choose between polymorphism or inheritance? Or what pattern would I recommend for dealing with a general or specific problem?<br /></blockquote><br /><br /><div style="text-align: right;"><em><a href="http://blogs.msdn.com/davidlem/archive/2006/05/16/598696.aspx">What&#8217;s with the programming test!?</a></em></div><br /><br /><blockquote>I know lots and <em>lots</em> of interviewers, at many companies, who&#8217;ve decided that they can fully evaluate you based on whether you can solve some particular convex optimization problem (or graph-search problem, or logic problem, or whatever their pet Elephant Question is), and they ask every candidate this question regardless of their background or experience. In fact, I&#8217;d estimate that some 10% of all technical interviewers ask the same questions, year after year, and they could care less about your experience.<br /></blockquote><br /><div style="text-align: right;"><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html"><em>The Truth About Interviewing</em></a></div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html" title="permanent link">10:45 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, May 25, 2006</div>
			

			<div class="Post"><a name="114856931325471522">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/05/ready-aim-final.html" title="permanent link">Ready, Aim, Final</a></span>
					<div style="clear:both;"></div>There're <a href="http://www.sphericalimprovement.com/blogs/mbowler/exit.php?url_id=1042&entry_id=352">some</a> <a href="http://cafe.elharo.com/java/final-good/">interesting</a> <a href="http://www.cincomsmalltalk.com/blog/blogView?showComments=true&amp;entry=3325941352">rants</a> going on about Java's <span style="font-weight: bold;">final</span> keyword. And Mike Bowler does a decent job of <a href="http://www.sphericalimprovement.com/blogs/mbowler/archives/352-Weighing-in-on-final.html">explaining what final </a><a href="http://www.sphericalimprovement.com/blogs/mbowler/archives/352-Weighing-in-on-final.html">does</a>. As Mike points out, all of the ranting is about whether you should declare classes and methods final.<br /><br />The arguments against declaring classes and methods final are persuasive. It makes it really hard to unit test anything. You are putting future programmers in a straightjacket (that's actually part of the spirit of bondage and discipline languages like Java, but that doesn't mean it's a good idea). And some refactoring becomes impossible.<br /><br />When I look at these arguments, I see evidence of a deeper malaise. The problem isn't the final keyword. The problem is <span style="font-style: italic;">the lack of separation between interfaces and implementations</span>.<br /><br />Take <span style="font-weight: bold;">java.lang.String</span>. This class is final, and that is a royal PITA. If you want to extend String to do neat things like keep track of SQL injection safety you are SOL. Now if there was a String <span style="font-style: italic;">interface</span>, and everyone declared their instance variables with the interface instead of the implementation, there would be no problem with a final String class.<br /><br />Do you need a flag for whether the String is SQL-safe? Use delegation instead of inheritence. No problem. Do you need pluggable storage behaviours for handling special character sets? Use aggregation and a Strategy pattern.<br /><br />Separating the String interface from the String implementation solves our problems nicely.<br /><br />I'm 100% ok with the final keyword in implementations. I think it's ok to make a class and say, this is the FizbangImplementationClass. For example, if you were making a sort class for some reason, it would be a little weird to override the actual sort algorithm. If you do, maybe it isn't really a-kind-of FizbangImplementationClass, so it shouldn't extend that base class. It ought to <span style="font-style: italic;">conform to the same interface but be implemented as something else</span>.<br /><br />At no time in the near future will I be proposing JSR666, "How to fix the Java language so that you can write elegant, object-oriented code." But if I do, my suggestion will be to <span style="font-style: italic;">make every class an interface automatically</span>. (This is not an original idea.)<br /><br />Here's how it would work. We keep all of the existing syntax exactly as we have it. But the first addition is that you can have class A implement class B. Note that class B is a class, not an interface. This means class A acquires the public members of class B but not their implementations. Now you can 'override' to your heart's content. The final keywords do not affect this, because you are actually implementing an interface.<br /><br />Is this bad? I don't think so. Framework authors that declare methods final are usually trying to ensure some consistency within a class. If you are implementing the class instead of extending it, you can build it from the ground up. If you need some of the class's behaviour you can use delegation and the orginal class will retain its original behaviour.<br /><br />The second addition is that when you declare a variable to be of a certain class, you are naturally declaring it to be the interface of the class. So anything declared as a String is actually declared as the String interface, not the String class.<br /><br />(There are other, subtle changes that are needed. Should String.class refer to the class and String.interface refer to the interface separately? Order plenty of espresso and let the committee thrash this kind of question out).<br /><br />This could be all accomplished within the current language if everyone was disciplined about declaring interfaces. However, Gosling and Steele set the tone for the Java language when the original libraries contained precious few interfaces and tons of classes. I think it's too late to get everyone to change. So some language change is needed to handle the zillions of lines of existing code.<br /><br />Or, you could take another approach and eschew languages that deliberately restrict your expressiveness. It's a big world out here, and it would be a shame if you don't get out from behind your desk and travel once in a while :-)<br /><br /><span style="font-style: italic;">Updates: Elliote Rusty Harold <a href="http://cafe.elharo.com/java/eliminating-final/">triple-underscored his support for the final keyword, while suggesting that interfaces are mostly bad</a>, and <a href="http://raganwald.github.com/2006/05/reg-suffering-from-high-altitude.html">I responded with respect for our differences</a>.<br /><br />Then Rusty provided some <a href="http://cafe.elharo.com/java/the-three-reasons-for-data-encapsulation/">excellent reasons for locking interfaces down</a> in his designs, and I explained why I believe there're <a href="http://raganwald.github.com/2006/06/trade-off-between-power-and-ease-of.html">legitimate reasons to choose Rusty's approach for some programmers and more flexibility for others</a>.<br /></span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/05/ready-aim-final.html" title="permanent link">10:28 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, April 24, 2006</div>
			

			<div class="Post"><a name="114588769746536855">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/04/why-do-we-resist-idea-that-programming.html" title="permanent link">Why do we resist the idea that programming might be hard?</a></span>
					<div style="clear:both;"></div><blockquote>Don’t blame me for the fact that competent programming, as I view it as an intellectual possibility, will be too difficult for ‘the average programmer’, you must not fall into the trap of rejecting a surgical technique because it is beyond the capabilities of the barber in his shop around the corner.</blockquote><div style="text-align: right;">—<a href="http://en.wikipedia.org/wiki/Edsger_Dijkstra"><span style="font-style: italic;">Edsger Dijkstra</span></a><br /></div><blockquote>Programming something even half decent requires considerable intellectual ability. That’s not all there is to it, but if you’re not smart, it will be much harder for you to be a decent programmer. We’re mostly in denial about this and would like to believe that programming can be done by anyone or can be made somehow unnecessary. It’s the opposite view we take to managerial or executive ability, where we pay through the node for talent. Yet it’s been known since we started building software that some programmers are much better than others. Maybe all disciplines are like this, but it is very obvious in programming. Naturally this intelligence makes people who don't have it uncomfortable, particularly if that person is supposed to lead or organize very smart people to do something that they don't fully understand, even though that person is probably better paid, more socially equipped and has nothing to worry about.<br /><br />As with meat-markets this is not something we like to talk about a lot. It’s not egalitarian and intelligence is something we’re sensitive about culturally. But consider that it’s not controversial to say being a good musician or athlete requires a level of ability, some of which is innate. Or that our educational systems are based around being ranked smarter than the next person anyway. So we should get over ourselves a bit and accept the fact the good software requires more than stringent process; it requires well-above average intelligence to create it.</blockquote><div style="text-align: right;">—<a style="font-style: italic;" href="http://www.dehora.net/journal/2004/04/better_is_better_improving_productivity_through_programming_languages.html">Bill de hÓra</a></div><br /><blockquote>The statements that make people mad are the ones they worry might be believed. I suspect the statements that make people maddest are those they worry might be true.</blockquote><div style="text-align: right;">—Paul Graham, <a style="font-style: italic;" href="http://paulgraham.com/say.html">What You Can't Say</a></div><br /><span style="font-weight: bold;">Addendum</span>:<br /><br /><span style="font-style: italic;">I have recieved a few emails and comments suggesting that anyone can become a good programmer with sweat and dedication. Here're my personal feelings:</span><br /><br />I don't believe that <span style="font-style: italic;">anyone </span>can become a good programmer with dedication, practice, and experience. In case you haven't guessed from the third quote above, my interest is not in whether there is an innate talent involved with programming, but in people's state of denial.<br /><br />Let's look at what it means to improve and to be good.<br /><br />I suppose there's some room for argument about whether almost any infant or toddler, if exposed to the right stimuli, can become a good programmer. Our knowledge of genetics and early brain development is primitive.<br /><br />However, by the time people reach their teen years, I believe that much of their potential has been established.<br /><br />With dedication and practice, people can improve almost anything, however in most fields this improvement shows diminishing returns. It may be aymptotic, so in theory they may eventually become a good programmer or a chess master, but in practice this may take longer than the number of productive years available.<br /><br />With respect to everyone who has emailed to say that anyone can be a great programmer, how many of you play Bridge or Chess? These are fields where no serious practitioner believes that round the clock study and fanatic devotion will take you to the top: winning requires both potential and the will to fulfill that potential.<br /><br />Likewise, how many of you who write or email play a musical instrument and especially compose music? Many people have fanatic devotion to practice, yet every generation yields remarkably few geniuses that will stand the test of time.<br /><br />Why do people consider fields like Bridge, Chess, Athletics, and Music different from programming?<br /><br />I think the salient distinction is that we habitually consider games like Bridge, Chess and Athletics very competetive. And if you're paying close attention, we consider Classical Music and Jazz equally competitive, if not more so (where do you think we got the word "Diva"?).<br /><br />When something is competitive, it's irrelevant how good you can become through practice. If someone else can become <span style="font-style: italic;">even better</span> with the same amount of practice, you will be unable to surpass them.<br /><br />Of course, you can still surpass those that don't study, practice, or <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">learn from their mistakes</a>. That's important. But if the field is desirable enough that there are a significant number of innately talented people willing to study, practice, and learn, then only those with innate talent will occupy the top spots.<br /><br />I believe that if programming jobs were more demanding and that if the industry were more competitive, we would rapidly lose all pretensions to egalitarianism.<br /><br />But what do I know?<br /><br /><span style="font-style: italic;">If you found this interesting, you may want to read </span><span class="PostTitle">  <a href="http://raganwald.github.com/2006/05/how-to-make-programming-hard-for.html">How to make programming hard for yourself</a>.</span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/04/why-do-we-resist-idea-that-programming.html" title="permanent link">9:45 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, March 24, 2006</div>
			

			<div class="Post"><a name="114322745914091238">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html" title="permanent link">I'll take Static Typing for $800, Alex.</a></span>
					<div style="clear:both;"></div>There’s an argument that static typing prevents errors by detecting them at compile and/or edit time. In a trivial sense, this is absolutely true. You can, for example, write a Java program with such an error and watch Eclipse highlight the offence.<br /><br />The interesting thing I’ve noticed is that many of the people in favour of static typing are arguing from a position of “Do what I say, not as I do.”<br /><br />I don’t mean that they program in Python. I mean that when I ask them whether they would have typing troubles in a dynamic language, their answer is often “<em>well, I wouldn’t, but every business needs hordes of monkey/offshore/intern/new graduate programmers who do make these errors</em>.”<br /><br /><blockquote>“People shouldn’t be able to open my classes.” “They need compile time type checking so the app doesn’t blow up.” “Extending system libraries is bad.”<br /><br />Concerns like these all seem to boil down to one major theme: The people I work with are stupid.</blockquote><div style="text-align: right;">—<a href="http://evang.eli.st/blog/2007/1/22/java-people-must-be-stupid">Java People Must Be Stupid</a>, Pat Maddox<br /></div><br /><blockquote>It’s not really stupid people, it’s people who’ve accepted a stupid idea. Java’s design is based on the idea that a language can prevent misuse by making bad things hard to do. It’s defensive thinking.<br /></blockquote><div style="text-align: right;">—<a href="http://gilesbowkett.blogspot.com/2007/01/favor.html">A Favour</a>, Giles Bowkett<br /></div><br />Let’s stop worrying about errors we don’t actually make. Let’s stop worrying about errors some hypothetical junior, error-prone programmer might make.<br /><br />Here’s an interesting question: what sorts of typing errors do experienced, intelligent programmers actually make? And what sorts of typing errors sneak through unit tests and even QA and into production? And most especially, what sorts of typing errors have catastrophic consequences in production?<br /><br />Now those are interesting errors. Those are worth worrying about. I’ll go further: those are worth static typing.<br /><br />Here’s one from my actual, hands on experience. Distinguishing escaped from unescaped strings. I don’t know if I’m using the right words here: I’m thinking of a typical XML or XHTML application where some of the time a string is just a string, but some of the time it has a bunch of its characters replaced or escaped with special entities.<br /><br /><blockquote>Another case of escaped and unescaped strings concerns safely composing SQL queries and updates (another <a href="http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem">solved problem</a> in other languages). The argument is always in favour of using library functions that do the conversion for you, like <code>PreparedStaement</code>. If you think about it, that’s no damn good. What that does is treat everything like an unsafe String and only convert it at the very last second.<br /><br />If you’re going to do any fancy SQL composition, you can only do it with stuff that isn’t a user value, so you have to keep track of escaped and unescaped strings <strong>anyways</strong>. And finally, your libraries still have all the unsafe APIs that don’t perform the conversion for you, so you are relying on your iron will and self-discipline to prevent errors, rather than having the compiler perform what is really a rather trivial check.<br /><br />I have no problem with relying on iron will and self-discipline to eliminate errors. But if your argument is that iron will is appropriate for preventing SQL injection attacks, why isn’t iron will appropriate for preventing trivial type errors that would result in a <code>MethodNotImplemented</code> exception? </blockquote>I’m not alone in considering this a problem. Web applications that screw this up are vulnerable to cross site scripting (XSS) attacks. This is very bad, and if static typing could help I’d eagerly embrace it.<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0262561158"><img src="http://raganwald.github.com/uploaded_images/a_little_java-777624.jpg" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&o=1&amp;a=0262561158" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><em><br /><br /><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&amp;creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of The Little Schemer and The Little MLer bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em></div>How could static typing help? Well, imagine if you designate some strings as escaped and some as unescaped. So our type hierarchy is that there is String, <code>UnescapedString extends String</code>, and <code>EscapedString extends String</code>. (Actually, I’d prefer interfaces if I were designing a Java-like language, but that’s by the by).<br /><br />Now there are certain critical places where we would need to harden our application. The first is everywhere we get strings from users. These strings, just like <code>tainted</code> or <code>unsafe</code> variables in scripting languages like PHP, need to be <code>UnescapedStrings</code>. We would type our methods accordingly (in Java, this could be accomplished with annotations). For example, anything snarfed from the <code>HttpRequest</code> object is an <code>UnescapedString</code>.<br /><br />Then when we present strings, we type the methods as taking <code>EscapedStrings</code> only. If we try to pass a POS (Plain Old String) or <code>UnescapedString</code> to a method parameterized by an <code>EscapedString</code>, we get a compile time error.<br /><br />To get around the errors, we need to escape our strings. We do that by writing a conversion method somewhere that, you guessed it, takes an <code>UnescapedString</code> as a parameter and returns an <code>EscapedString</code>.<br /><br />Naturally our application would be full of bookkeeping annotations as we keep track of which strings are escaped and which aren’t. But my gut feeling is that catching this kind of error at compile time would be worth it.<br /><br />Here’s another error that I think is worth the effort of static typing. The bane of my existence when maintaining legacy Java code: <code>NullPointerExceptions</code>.<br /><br />This is actually a solved problem in languages like Haskell. Static typing can easily distinguish between methods that might return a null (like getting a column from a database row) and variables that must not contain a null. The compiler can and should force you to write code that handles the null case.<br /><br /><div style="margin: 0pt 10px 10px 0pt; width: 240px; float: left; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/little_mler-705423.jpg" alt="" border="0" height="180" width="180" /></a><em><br /><br /><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">The Little MLer</a> introduces ML (and Ocaml) through a series of entertaining and straightforward exercises leading up to the construction of the Y Combinator.<br /><br />With ML and Ocaml you can design rich types that fit the domain model and all types are checked at compile time through type inference.</em></div>Here’s my question to my fellow Java programmers: why do we tolerate a compiler that forces us to type some things as <code>BigDecimals</code> and some things as <code>Integers</code>, but we don’t insist that the compiler catch places where we aren’t checking for <code>null</code>?<br /><br />These are just two places where static typing could help experienced programmers solve problems that plague real, production code. I’m all for static typing, if it can help me with the errors I actually encounter.<br /><br />That being said, there is a lot of work being done in this area, although obviously not by Sun or Microsoft (to be specific, not by their <a href="http://msdn.microsoft.com/vcsharp/">C#</a> team). As mentioned, Haskell and several other languages provide static typing that is sophisticated enough to prevent errors like this.<br /><br />I’m not even close to being the first person to notice the problem:<br /><ul><br /><li><a href="http://www.joelonsoftware.com/">Joel Spolsky</a> described using naming conventions to highlight errors like this. It’s interesting that <a href="http://en.wikipedia.org/wiki/Hungarian_notation">Hungarian Notation</a> was invented for this kind of thing, but somehow a Cargo Cult has arisen around Systems Hungarian where programmers use it for things like marking integers, a fact that the compiler and IDE already know, but don’t use it for domain-specific things like whether a string is safe.</li><br /><li>Tim Sweeney of <a href="http://www.epicgames.com/">Epic Games</a> wrote an incredibly lucid wish list for <a href="http://lambda-the-ultimate.org/node/1277">The Next Mainstream Programming Language</a>, where he discusses in detail the exact issues his team has faced building and maintaining Unreal. His presentation is available in PowerPoint and PDF formats. He has given a lot of thought to how static typing could help build and maintain huge, complex, commercial applications.</li><br /></ul>Okay, back to Earth. What can we do about this?<br /><br />Here are my specific suggestions:<br /><ol><br /><li>Stop worrying about the theoretical errors we don’t actually make. We unit test, we review our code. We’re not concerned with obvious, superficial problems.</li><br /><li>Agitate for language features that can help us solve these important problems. If the next version of javac can do escape analysis, it can identify potential null pointer exceptions, possibly through inference so we don’t even have to type more code.</li><br /><li>Educate ourselves about the bleeding edge of language development. No, that isn’t C# 3.0, Common Lisp, or Ruby 2.0. It’s <a href="http://www.ml.com/">ML</a>, <a href="http://www.haskell.org/">Haskell</a>, <a href="http://www.erlang.org/">Erlang</a>, and a bunch of other things I need to learn. We may not be able to use Haskell to build Yet Another Boring Web Commerce Application, but we might learn enough to use a new naming convention or possible to write a string container that enforces escaped safety.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html" title="permanent link">2:10 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, March 14, 2006</div>
			

			<div class="Post"><a name="114237514897947609">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/03/fair-and-balanced-look-at-static-vs.html" title="permanent link">A "fair and balanced" look at the static vs. dynamic typing schism</a></span>
					<div style="clear:both;"></div>A long time ago in an industry far, far away, everyone programmed in C.<br /><blockquote>Like <a href="www.joelonsoftware.com/articles/APIWar.html" title="How Microsoft Lost the API War">Joel says</a>, this is a broad stroke observation. I happened to use Pascal an awful lot at the time, so I realize that "everyone" doesn't mean "every last one of us." But it does mean "so many people that no other language mattered to the industry as a whole."</blockquote>C has many delightful advantages. It also has two, umm, features that programmers routinely screwed up. The first, as everyone knows, is the lack of memory management. Programmers had to do everything themselves and do it properly. If you made a mistake, your program would suffer from dangling pointers, or have a memory leak.<br /><br />The second was the almost complete lack of type safety. That's a big hand wave. I realize that if you're very careful you can make a C compiler, especially an <a href="http://en.wikipedia.org/wiki/C_programming_language">ANSI C</a> compiler, do a little static type checking for you. That's the theory. But in practice, it had this one little thing that made type safety moot: the unconditional type cast.<br /><br />How many readers know what I'm talking about? Put your hand up... Good! Talk amongst yourselves for the next paragraph while I explain this to the readers who are under the age of forty.<br /><span style="font-weight: bold;"></span><blockquote><span style="font-weight: bold;">Why C casts are dangerous</span><br />With an unconditional type cast, the C compiler would let you treat an address of something in memory as whatever you want. You could treat a byte as the start of a string. Or you could treat a long word as the address of a function. Or you could treat it as an array of pointers to functions. So if you had a pointer to the address of an array of pointers to functions and you mistakenly cast it to the address of an array of pointers to functions, and then you tried to call one of those functions, bad things would happen.</blockquote>Okay, everyone back? This was phenomenally bad, especially because we do this Von Neumann thing and have bytes of memory that are sometimes code to be executed and sometimes data to be shuffled around. If you have a pointer that is pointing to the wrong thing, the program would sometimes crash right away, or it would sometimes chug along for a while silently corrupting memory until everything failed. There's an entire industry of malicious people taking advantage of this possibility to craft <a href="http://en.wikipedia.org/wiki/Buffer_overflow">buffer overflow</a> attacks.<br /><br />This problem was so bad that it was one of the things C++ tried to fix with its <a href="http://en.wikipedia.org/wiki/Cast_%28computer_science%29#C.2B.2B-style_casting">casting constructs</a>. One of them, the dynamic cast, specifically checks the situation at run time to make sure that the cast is safe. The only trouble was, C++ let you keep the dangerous C cast and then threw in a variation called static cast that was nicer looking but still unsafe some of the time.<br /><br />I want to underline the consequences of bad casts here. When discussing risks, you always have to thing along two axes: the <span style="font-weight: bold;">likelihood</span> of disaster and the <span style="font-weight: bold;">magnitude</span> of the consequences. C programs with bad casts have extremely bad consequences. The might crash. They might corrupt all of their data. They could cause other things to crash. These are all terrible.<br /><br />When we discuss "type safety" we have to think along the same two axes of risk: there is safety that protects us from something going wrong, and there is safety that limits the consequences when something does go wrong.<br /><br />Well, one day Java came along. You may deride it as "Cobol Lite," but it did two things an awful lot better than C++, and if you look back at history it succeeded by converting people away from C++. The first thing it did better was to make automatic memory management mandatory.<br /><br />The second was to throw out all of the dangerous casts and replace them with a single casting operation that always checks types at run time and throws a nice exception right away if you get it wrong. Java, in effect, provides two kinds of type safety: its static type checking reduces the likelihood of a typing error, and its runtime cast checking sharply limits the consequences of a bad cast.<br /><br />Before we argue about static vs. dynamic type checking, let's remember where this fanaticism for so-called strong typing came from: it came from an entire industry that had been burned by having a trap door that led to having <span style="font-weight: bold;">no</span> typing. Back when it was C/C++ vs. Java, the debate was between having no type checking at run time vs. type checking at run time.<br /><br />(Attention pedants: I'm very aware of how much static type checking ANSI C and C++ can do. I'm judging these languages by the bad news edge case bugs, not by the billions of perfectly fine lines of code that eschewed unsafe casts.)<br /><br />For the most part, today we see people arguing about static vs. dynamic typing. They argue about the effort involved in telling the compiler what to check, and whether having the compiler find some errors for them does or doesn't make up for the extra code.<br /><br />The static folks say "hell, yeah, you're headed for big trouble if a type checking bug slips through the compiler into production." Okay, let's look at the history. Back in the day when Reg was young and user interface design consisted of colouring the punch cards, a type error slipping into a C program represented a real risk of a catastrophic problem. True.<br /><br />But let's say you want to use one of these "new-fangled" dynamic languages. Are you exposed to the same risk? The answer is <span style="font-weight: bold;">no</span>. The reason is that these dynamic languages have types and check them for you, just like Java's checked type casts. The consequences of a type error are trivial compared to C/C++ errors.<br /><blockquote><span style="font-weight: bold;">How trivial can a type error be?</span><br />Consider a web application. If a type error takes place, users will get a server error 500 response. The server will not crash, the database will not be infested with corrupt data, and users will not find themselves charging their purchases to someone else's credit cards. The consequences of a type error are relatively mild when the language checks types at run time.</blockquote>Let's consider sending a message to an object (not all dynamic languages have objects, but whatever). How would this happen in C? Well, you'd have a pointer or a handle to an object, and it would have a pointer to an array of pointers to functions representing its methods. (It could be more complex if there's inheritance or aggregation).<br /><br />So you might try dereferencing the handle twice, looking up the offset of the pointer to the array, then looking up the offset of the function you want, dereference that pointer, and call the function. If any of this is wrong, boom. Actually, it's worse than boom. You might not find out it was wrong for a very long time. Silent but deadly!<br /><br />In a dynamic language, you try sending a message to the object and if the object doesn't handle that message, there's a very explicit behaviour for managing the error. It calls a special missing method method. Or it throws a specific exception. Dynamic languages address the issue just like C++ did with dynamic casts and Java does all the time with its casts.<br /><br />Dynamic language advocates argue for more automated unit tests instead of compiler checking. Well, I'm in favour of more testing whenever you can get it.  But to my eye, that isn't the point. The point to me is that the potential for catastrophe with both Java and dynamic languages is so much smaller than the potential for catastrophe with C/C++ that the debate about type safety is almost moot.<br /><br />I really don't want to get into a shrill "do so! do not!!" debate. But if you're reading this and you're still planted 100% in the strong, static type checking camp, let me ask you one question:<br /><br /><span style="font-style: italic;">Have you actually worked on a project where casting errors caused the failure of the project? I mean the product failed in the marketplace, or you spent so much time trying to find and squash critical bugs that the project was cancelled?</span><br /><br />I have a funny feeling that most or all of the people who answer "yes" were working with C/C++ and unconditional casts. I have a feeling that as an industry we're so scarred with those problems that we don't realize that moving to run time type checking solves 75% of our problems and makes the errors 99% less dangerous.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/03/fair-and-balanced-look-at-static-vs.html" title="permanent link">4:18 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, January 03, 2006</div>
			

			<div class="Post"><a name="113630985287415026">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html" title="permanent link">Finding the Signal-to-Noise Ratio in the Never-Ending Language Debate</a></span>
					<div style="clear:both;"></div>Once again the web is buzzing with one of the most boring debates ever, namely "what's the best programming language?" I will not rehash the arguments. I'll try to restrain myself to stating my position, giving my reasons, and then toss in speculation on why a certain web framework is growing like wildfire.<br /><br />My position is simple: <span style="font-weight: bold;">the language operating at the highest level of abstraction while not suffering from project-killing defects is the one I want to use</span>. My algorithm is simple: throw away languages that will scuttle my project, and pick the highest level language out of those that remain. (I'm not going to discuss defects. They are a matter of taste and lead us down an unhappy path.)<br /><br />I believe that programming is an idiomatic activity. We learn idioms and then apply a kind of pattern-matching to recognise problems that can be solved with an idiom we already know. Some idioms are easier to express than others in each programming language. (Does the Weak <a href="http://en.wikipedia.org/wiki/Sapir-Whorf_Hypothesis">Sapir-Whorf Hypothesis</a> apply to programming?)<br /><br />Sure, all languages are Turing Complete and therefore equivalent in theory, but in practice you might find that the only way to express an idiom from Language A in Language B is to write a A->B compiler or interpreter in B.<br /><blockquote>  Greenspun's Tenth Rule of Programming: "Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp."</blockquote>Does that sound too academic? Consider this: how would you write a <a href="http://en.wikipedia.org/wiki/Continuation">continuation</a>-based framework (like <a href="http://seaside.st/">Seaside</a>) in <a href="http://rifers.org/wiki/display/RIFE/Web+continuations">Java</a>?<br /><br />This, incidentally, is why the language debate will never end. Programmers naturally learn and know the idioms <a href="http://en.wikipedia.org/wiki/Affordance">afforded</a> by their language. So when you say "In my language I can very easily do X and Y," the programmers using other languages always say "But nobody needs X or Y. We're busy doing Z."<br /><br />So let's talk about idioms instead of so-called features like syntax. What does it mean for one language to be "higher level" than another? To have a "higher level of abstraction"? My own interpretation is simple:<br /><br />One language is higher-level than another if it expresses more idioms in fewer bits than the other language. Or fewer lines of code. Or fewer symbols. There's a really simple language idiom for this: Programs in a higher-level language have a high <a href="http://catb.org/%7Eesr/jargon/html/S/signal-to-noise-ratio.html">signal to noise ratio</a>.<br /><br />For example, there are these "design patterns" that all of the COBOL^H^H^H^H^H Java programmers like to use. One of these is called <a href="http://128.42.6.89/JavaResources/DesignPatterns/VisitorPattern.htm">Visitor</a>: "<span style="font-style: italic;">One key advantage of using the Visitor Pattern is        that adding new operations to perform upon your data structure is very        easy. All you have to do is create a new Visitor and define the operation        there.  This is the result of the very distinct separation of variant        and invariant behavior in the    Visitor pattern.   The invariant behaviors are represented by the data  structure elements and    the abstract Visitor.   The variant behaviors are encapsulated in the concrete Visitors.</span>"<br /><br />Got that? How many lines of code do you need in Java? Here's how you express the Java idiom of the Visitor pattern in Ruby:<br /><br /><span style="font-family:courier new;">concrete.each { |thingy| visitor.visit thingy }</span><br /><br />Do you think I'm making this thing about brevity up?<br /><br />Here's something I found this morning. This fellow is explaining why interviewees can use any language they like to solve a problem, provided it's black:<br /><blockquote>When I interview someone, I usually let them use the language of their choice with between C, C++, C# and Java... It's not that I have something against Ruby or other fourth generation languages, but I found that these languages work at a level of abstraction that is a little too high to give me a meaningful insight on the candidate for a forty-five minute interview.  There are plenty of very interesting problems that are hard to solve even in Ruby or Python (and actually, it's quite likely this is the kind of problem that the candidate will be struggling with if she gets hired), but formulating the question and writing the solution would take several hours.<br /><div style="text-align: right;"><a href="http://beust.com/weblog/archives/000352.html">The Language of Interviews</a><br /></div></blockquote>Let me see if I can condense this: there is a class of problems that are non-trivial to solve in C# and Java but are trivial in Ruby and Python. Hot <a href="http://www.randsinrepose.com/archives/2006/01/01/swear_a_bit.html">damn</a>, I could have skipped writing this whole thing and simply posted the quote.<br /><br />(By the way, do you buy that something non-trivial to solve in Ruby must necessarily require hours to explain and to write out? Neither do I. I am not bashing the post here. That point is really a very small aside. But I don't have any trouble thinking of Ruby, Python, or Lisp problems that would require only a few minutes to explain and would be appropriate for an interview.)<br /><br />Now, there's some idea that you can build your own idioms in any programming language. We have various names for the technique (like procedures, subroutines, objects, modules, and macros), but the argument is that you can build up a library or framework of idioms and then you can ultimately express yourself with startling brevity.<br /><br />So some state that all languages are equal because if something is difficult to express you build your new idioms into the language and presto, you have a high signal-to-noise ratio in your programs.<br /><br />This argument has a major, glaring, flaw: <span style="font-style: italic;">the mechanism for building idioms in each language is an idiom itself, and it tends to be the most rigidly limiting idiom on the language</span>. C++ is a language for defining abstract data types that look just like built in types. In SmallTalk everything is an object that belongs to a class. And so on. Let's call this the language's "meta-idiom."<br /><br />The argument about idioms applies to meta-idioms. So if you want to build new idioms in a language, you need to use its meta-idioms. Some languages provide higher signal-to-noise on meta-idioms than others. Some languages make it easier to construct your own idioms than others. So even though all languages may provide some mechanism for raising the signal-to-noise ratio, not all are equal when it comes to using their mechanisms.<br /><br />So, I've written that I believe that not all languages are equal. I've written that I believe that an important metric for comparing languages is the signal-to-noise ratio, as measured by the brevity of expressing idioms. Now I will conclude by revisiting the affordances argument.<br /><br />Some languages make it easier to express some idioms than others. How? See the paragraph above about signal-to-noise ratio. Given that some things are easier than others in each language, wouldn't you expect that <span style="font-weight: bold;">there will be a very few languages that can express an order of magnitude more idioms in an order of magnitude less code than the 'average' language</span>?<br /><br />(If you don't think so, why not? Doesn't practically everything you've ever seen operate on a power law distribution? Why should programming languages be different?)<br /><br />So, I expect that some languages will do a better job of expressing a larger set of idioms than others. Now, here's the key question: does the number of idioms that a language affords <span style="font-style: italic;">matter</span>?<br /><br />I diverge from the wise men who write <a href="http://paulgraham.com/articles.html">essays </a>on this topic. I think it matters to me, but it is unlikely to sway anyone's decision. My simple observation is that programmers develop and use idioms that are easy to express in their language. They 'cut with the grain.'<br /><br />When considering one language over another, my first consideration, naturally, is with the idioms I already know. Does the new language help? This consideration is exactly like almost any other "upgrade" consideration. When considering an upgrade, the first thing you want to do is solve an existing problem.<br /><blockquote>When I purchased an iMac for my home, I had no need for playing DVD's. So I was very close to buying the 17" model. Luckily, I purchased the 20" model so I would have more desktop for programming. I already had a 17" monitor on my development box, and it was starting to feel cramped. Now that I have the 20" iMac, I love watching DVD's on it and I'm very happy I didn't settle for the model that seemed to suit what I thought I would need.<br /></blockquote>Once you're satisfied that the upgrade meets your needs and solves a problem, you go ahead. Later on, you'll discover a whole new world of features. These grow on you, until one day you ask yourself how you ever lived without them.<br /><br />And so it is with programming languages. I can write about meta-programming in Ruby and Scheme for six more posts, but if you aren't meta-programming now, my guess is that you won't switch. You simply don't think in terms of that idiom, so you perceive it to be a "nice to have," but not essential.<br /><br />What will get you to move up the ladder is when someone shows you how to solve an existing problem in fewer bits. This, you can recognise. Did I say signal-to-noise? Imagine your favourite music on AM radio in your grandparents' car. Now imagine you hear it on a beautiful stereo. More signal! Less noise!<br /><br />But you aren't going to switch because someone says "if you think listening to music is fantastic, just wait until you hook up a keyboard and use GarageBand to compose music..." That simply doesn't mean anything to you until you've already bought your new iMac.<br /><br />So although I fervently believe that a better language will allow you to express more idioms than you are currently using, I know that you are unlikely to switch for that reason. So I'm not going to write about how cool it is that someone could add "acts_as_versioned" to the Rails framework. You probably only care about whether "acts_as_versioned" saves you a ton of boilerplate versioning data in your application.<br /><br />Speaking of Rails, I'm going to conclude with my take on one reason why <a href="http://rubyonrails.org/">Rails</a> is taking off and Seaside is not. Rails allows programmers to express the idioms they already know (relational databases, web-backed MVC, stateless event handling plus a global session store) in fewer bits.<br /><br />Seaside provides a whole new idiom, continuations, that IMO is more powerful. I think you end up with an even higher signal-to-noise ratio with a Seaside app than with a Rails app. Why? Because continuations afford you a much higher degree of controller reuse.<br /><br />Now, here's the catch: if you try to imagine your current application running on both Rails and on Seaside, you probably won't see much difference between the two (although they'll both be an order of magnitude better than ASP.NET). They will look the same because you designed your application with idioms that both Rails and Seaside support.<br /><br />To get a big win, you'd have to rethink your application's flow and logic. You'd have to "think in Seaside." And you're not going to do that. So you pick Rails, like so many others have picked it, because it looks just like your ASP app, only all the noise has gone away. It's all signal, baby.<br /><br />Now, do you see the thing here? Ruby has been around for a while, but nobody switched. Why? Because they couldn't see how its new idioms would help them. Every time a programmer considered switching from <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a> to Ruby, she was presented with all these new idioms, like dynamic types. None of this meant anything to her, because they didn't appear to make the idioms she already knew more compact. No win.<br /><br />But now she looks and she sees her existing web idioms, and she sees them expressed with way fewer bits, and she is suddenly prepared to learn this Ruby thing if it will let her say:<br /><br /><pre>class Language &lt; ActiveRecord::Base<br />has_and_belongs_to_many :idioms<br />end<br /></pre><br />Happy New Year!<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html" title="permanent link">12:24 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, October 26, 2005</div>
			

			<div class="Post"><a name="113034661235758648">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/10/im-not-young-enough-to-know-everything.html" title="permanent link">I'm not young enough to know everything</a></span>
					<div style="clear:both;"></div>Paul Graham has alluded to the difficulty of doing a startup when you're, well, not young. He puts the upper bound at thirty-eight:<br /><blockquote>So who should start a startup? Someone who is a good hacker, between about 23 and 38... I don't think many people have the physical stamina much past that age. I used to work till 2:00 or 3:00 AM every night, seven days a week. I don't know if I could do that now. Also, startups are a big risk financially. If you try something that blows up and leaves you broke at 26, big deal; a lot of 26 year olds are broke. By 38 you can't take so many risks-- especially if you have kids.<br /><div style="text-align: right;">Paul Graham, <a href="http://www.paulgraham.com/start.html">How to Start a Startup</a></div> </blockquote>While what he says is true, lately I've become aware of an even bigger threat to starting a startup. <span style="font-style: italic;">Experience can be a handicap</span>.<br /><br />Let's start with a digression. What makes weblog posts popular? Most people say things like "insightful" posts become popular. Or "well-written" posts become popular. Adjectives like that are tautological: if someone likes a piece of writing, they generally will find nice adjectives to apply to it.<br /><br />One model for popular writing is that it <span style="font-style: italic;">panders to the reader's prejudices</span>. Plain and simple. People like writing that validates them and especially their ideas. I'm no different, and as a result I tend to focus my research on things that I already think I know.<br /><br />When you're twenty-two this isn't much of a problem because you know you don't know. You're "consciously incompetent." So you're far more likely to find something unfamiliar and try to understand it, to change your way of thinking to match what you learn rather than applying a "bozo filter" to it in advance.<br /><br />But at forty-two (or three!), it's easy to think you know things. You're at incredible risk of thinking you know things when you've achieved some measure of success, no matter how modest. You become "unconsciously incompetent." You don't know, but you don't know you don't know.<br /><br />I was personally reminded of this at <a href="http://startupschool.org/">startup school</a>. As Chris Sacca pointed out:<br /><blockquote>The glow of screens (from a refreshingly Powerbook-dominated audience) revealed an array of real-time collaborative note-taking for a virtually assembling the room's minds in a concurrent recording and discussion of the event.<br /><div style="text-align: right;">Chris Sacca, <a href="http://www.whatisleft.org/lookie_here/2005/10/startup_school_.html">Startup School - An Inspiring Room Full of Hackers</a></div> </blockquote><a href="http://www.whatisleft.org/lookie_here/2005/10/startup_school_.html"></a> <h3 class="entry-header"></h3> Sitting in that room, I was hyper-aware that I was no longer in Kansas. It struck me that if I didn't want the next generation of hackers to wipe me out like a Tsunami, I needed to stop paddling, climb on my surfboard, and accept the risk of being dashed on the rocks.<br /><br />I immediately made a commitment to myself to let go of things I used to think I knew.<br /><br /><span style="font-weight: bold;">Matz,  Jonathan Ives, and A Narrow Road to a Far Province</span><br /><br />One commitment was to try <a href="http://rubyonrails.com/">Ruby on Rails</a> instead of Lisp. Every time I've looked at Ruby, I've thought "nice, but it doesn't do anything I couldn't do in SmallTalk back in 1980."<br /><br />I've been the most pompous hypocrite. I mean, I often poke my Windows apologist friends and tell them that efficiency and user interface is not measured with check boxes ("mouse? check. icons? check. well, they must do the same thing.") I've extolled the virtues of <span style="font-style: italic;">design</span>, of the interaction between the parts, of the frictionless user experience of a <a href="http://www.braithwaite-lee.com/weblog/2004/09/returning-to-macintosh.html">Macintosh</a>.<br /><span style="font-family:georgia,bookman old style,palatino linotype,book antiqua,palatino,trebuchet ms,helvetica,garamond,sans-serif,arial,verdana,avante garde,century gothic,comic sans ms,times,times new roman,serif;"><blockquote> Do not seek to follow in the footsteps of the wise.  Seek what they sought.<br />  <div style="text-align: right;">Matsuo Basho</div> <div style="text-align: right;"></div> </blockquote></span>Ok, Ruby's blocks and classes and closures are the same things that Lisp has given us since 1959 and SmallTalk has given us since 1980. But maybe... Maybe... Maybe Ruby on Rails is <span style="font-style: italic;">easier to use</span> than Lisp in the very same sense that OS X is easier to use than Windows.<br /><br />As for the Rails thing, it's awfully popular and I have been uneasy about anything so hype-ridden. But how is that different from any of a thousand funny quotes deriding the new new thing? I'm tempted to say that <a href="http://research.microsoft.com/acm97/gb/tsld010.htm">there's a world market for maybe five Rails applications</a>. But maybe there's more to it.<br /><br />Maybe I should find out.<br /><br /><span style="font-weight: bold;">Thomas Bayes, Joel Spolsky, and Richard Feynman</span><br /><br />Joel Spolsky dropped an incredibly provocative anecdote into one of his well-written and insightful posts:<br /><blockquote>A very senior Microsoft developer who moved to Google told me that Google works and thinks at a higher level of abstraction than Microsoft. "Google uses <a href="http://en.wikipedia.org/wiki/Bayesian_filtering">Bayesian filtering</a> the way Microsoft uses the if statement," he said. That's true. Google also uses full-text-search-of-the-entire-Internet the way Microsoft uses little tables that list what error IDs correspond to which help text. Look at how Google does spell checking: it's not based on dictionaries; it's based on word usage statistics of the entire Internet, which is why Google knows how to correct my name, misspelled, and Microsoft Word doesn't.<br /><br />If Microsoft doesn't shed this habit of "thinking in if statements" they're only going to fall further behind.<br /><div style="text-align: right;"><a href="http://www.joelonsoftware.com/items/2005/10/17.html">Joel Spolsky</a><br /></div> </blockquote>I have an entire career built on top of experience building applications that manage ontologies, that are built out of objects and classes and tables and relations and all sorts of things that boil down to if statements. Or at least, they boil down to classifying things <span style="font-weight: bold;">in advance</span> rather than building systems that learn over time.<br /><br />I've known about Bayesian classification for years. And I've always thought of it as a specialized tool. It's incredibly disruptive to think of it as an every-day tool, as a general-purpose tool, as something that can replace the if statement.<br /><blockquote>"Your old-fashioned ideas are no damn good!"<br /><div style="text-align: right;">Richard Feynman</div> </blockquote> Yet when I step out of my comfort zone, I realize that<span style="font-style: italic;"> I've seen this before</span> (experience can be handy at times). Many of you young-uns have never known a programming world where there was no polymorphism (although judging by some of the code that has caused me to say "<a href="http://thedailywtf.com/">WTF</a>?", not as many as I would like). Before messages, virtual functions, and method calls there were the switches, cases, and if statements.<br /><br />There was an "aha!" moment for me when I suddenly grokked polymorphism. When I understood that switch statements were junk. Maybe <a href="http://en.wikipedia.org/wiki/Bayesian_inference">Bayesian inferences</a> can change programming the same way that polymorphism changed programming.<br /><br />I need to find out.<br /><br />And now I'd like to quote the other Steve, the one who isn't a hacker and wasn't presenting at startup school (Psst! Steve! Do you want to sell coloured MP3 players for the rest of your life or do you want to change the world again?)<br /><br /><span style="font-weight: bold;">One more thing</span><br /><br />For a very long time I've been carrying a conjecture around. Paul Graham supplied me with the framework for thinking about the conjecture:<br /><div style="text-align: right;"> <div style="text-align: left;"></div> <blockquote>   <div style="text-align: left;">Treating a startup idea as a question changes what you're looking for. If an idea is a blueprint, it has to be right. But if it's a question, it can be wrong, so long as it's wrong in a way that leads to more ideas.<br /></div> Paul Graham, <a href="http://www.paulgraham.com/ideas.html">Ideas for Startups</a></blockquote><a href="http://www.paulgraham.com/ideas.html"></a></div> The "Graham Question" is: <span style="font-style: italic;">Can we predict the future of a software development project with  objective observation?<br /><br /></span>Let's take a simple example, one that ran through my head this morning. I've worked for several companies that used issue tracking systems. These systems have had a little widget/enumeration for declaring the priority of an issue. I've also worked with Scrum-like teams that maintained priority with a master list or backlog.<br /><br />You want to know which issues will be fixed/implemented/done by a certain date. What is the significance of the priority?<br /><br />Well, this is management 101. Start with the number of hours available for development, then take the highest priority issues and estimate how much time is required to do them. Your prediction is that the team will do as many as possible of the highest priority items in the time available.<br /><br />All well and good, but in reality "Spolsky" isn't in the dictionary and neither is "Braithwaite." For that matter, neither is "p.s.", and why should I have to click "add to dictionary" after the program has <span style="font-style: italic;">watched me type this thing and not correct it hundreds of times?</span><br /><br />And lo, if we watch an actual software project we see that over time priorities change and new issues are added to the mix and sometimes low priority items are done first for some reason, and humans just can't seem to follow the damn plan, but software emerges from the other end anyways.<br /><br />It's easy to say, "your old-fashioned priority is no damn good." But maybe we are not young enough to know everything. Maybe we should ask a question: "<span style="font-style: italic;">what good is the priority if you can't construct a nice if statement around it?</span>"<br /><br />Maybe this is like Spolsky and Braithwaite and Error IDs and Help Text. Maybe there is no formula up front but we can <span style="font-weight: bold;">watch what people do hundreds of times</span>.<br /><br />Maybe Thomas Bayes knows the significance of the priority.<br /><span style="font-style: italic;"></span><p></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/10/im-not-young-enough-to-know-everything.html" title="permanent link">1:08 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, July 08, 2005</div>
			

			<div class="Post"><a name="112085123623686754">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html" title="permanent link">Why You Need a Degree to Work For BigCo</a></span>
					<div style="clear:both;"></div>Hello applicant:<br /><br />I&#8217;m very sorry, but I don&#8217;t have good news about the job opening here at BigCo. We really liked meeting you, but the bottom line is that you don&#8217;t have a degree from the right kind of University.<br /><br />——What&#8217;s that you say? You have learned an awful lot about writing software during the four years that you weren&#8217;t carting textbooks around the campus? My dear applicant, thanks for pointing out the <a href="http://www.everything2.com/index.pl?node=obvious">obvious</a>.<br /><br />I can read, you know. I was impressed by the list of projects you have completed. I even took an extra thirty seconds to Google your name and enjoyed the screen shots and links on your home page.<br /><br />But nevertheless, University teaches you things above and beyond how to write code. And that&#8217;s what we need here at BigCo.<br /><br />——I beg your pardon? You think that you have learned just as much about communication, teamwork, and project management from shipping software in small teams as you would have learned completing coursework?<br /><br />Please don&#8217;t take this personally, but I need a moment to chuckle. Ok, I&#8217;m done. University isn&#8217;t about communication, teamwork, or project management. If you happen to learn those things, that&#8217;s a bonus. I was thinking of something else.<br /><br />——Look, I admire your enthusiasm, but if you&#8217;d let me do a little of the talking I could tell you what we need. But since you bring it up, no I wasn&#8217;t thinking of any of that Computer Science stuff.<br /><br />Just in case you&#8217;re thinking of referring any of your friends to BigCo, please let them know that if they learned why <a href="http://en.wikipedia.org/wiki/SKI_combinator_calculus">S, K, I</a>, and <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y</a> are the most important letters in the alphabet, they need not apply. Ever.<br /><br />To paraphrase Eric Beck, &#8220;At either end of the educational spectrum there lies a hacker class.&#8221; And we are not interested in hackers, even <a href="http://www.paulgraham.com/gh.html">great hackers</a>. We need those middle of the spectrum folks who are going to live in the suburbs, commute to our offices, and do a decent job for a fair wage week after week, year after year.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://cagle.msnbc.com/working/060424/lester.gif"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://raganwald.github.com/uploaded_images/lester-779828.gif" alt="" border="0" /></a><br /><br />Quite honestly, the very fact that you passed on University tells us something disturbing about you. Quite obviously you aren&#8217;t stupid. And you knew that people like us would have a problem with your lack of education. But you believed in your heart of hearts that you could make up for this with excellence.<br /><br />But you know what? That same attitude might have you think &#8220;It&#8217;ll look bad if I quit this job in less than five years, but I&#8217;ll make up for it.&#8221; That kind of attitude makes you a little <em>fearless</em>. And while we try our best to build a decent working environment, we like our people to be just a little afraid of leaving the nice security blanket we give them.<br /><br />This may come as a surprise to you, but we&#8217;re looking for people who are looking for us. Of course we know that the educational component of University is a waste. We wouldn&#8217;t have it any other way.<br /><br />Like hazing rituals and wearing dark suits to work in August, attending a certain kind of University is a statement that you want to belong, that you know there is no practical purpose to the exercise but that you are prepared to make the sacrifice just to fit in. And you, dear applicant, would not fit in.<br /><br />Let me stress this point about what kind of University. We aren&#8217;t talking about some aerie faerie place where you <a href="http://www.media.mit.edu/cogmac/">build robots</a> or spend your free time <a href="http://www.google.com/corporate/history.html">writing business plans</a>. Those places exist to skim the cream off the top so we can hire a plain glass of 1% milk.<br /><br />As a matter of fact, the kind of University we like discourages you from dreaming about the future and keeps your feet firmly planted in the ground. For example, our favourite institutes of higher learning send you to work for companies like ours on work terms. This provides us with cheap labour and has the pleasant side-effect of discouraging the more creative undergraduates from wasting everybody&#8217;s time by coming to work for us.<br /><br />——Look, I really have to go, and I don&#8217;t want this call to end on a down note. There are lots of happy people in this world, and most have never even heard of BigCo, much less come to work here. So please consider this a redirection instead of a rejection. I know that&#8217;s trite, but it&#8217;s no less true just because it has a memorable rhyming form.<br /><br /><a href="http://www.seinfeldscripts.com/TheLipReader.htm">It&#8217;s not you, it&#8217;s us</a>. The plain fact is, you wouldn&#8217;t be happy here. So buck up, look around, and see if you can get yourself into something a little more early stage. Consider starting your own company.<br /><br />Because <a href="http://paulgraham.com/hiring.html">quite honestly</a>? I&#8217;d read your business plan any day. Your r&eacute;sum&eacute; would look better on top of a funding proposal than under a cover letter.<br /><br />Good luck out there.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html" title="permanent link">4:30 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, June 15, 2005</div>
			

			<div class="Post"><a name="111884505690316553">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/06/working-code-attracts-people-who-want.html" title="permanent link">Working code attracts people who want to code</a></span>
					<div style="clear:both;"></div>Charles Miller made a profound observation:<i><br /></i> <blockquote><i>Working code attracts people who want to code. Design documents attract people who want to talk about coding</i>.<br /></blockquote><div style="text-align: right;"><a href="http://fishbowl.pastiche.org/2005/05/08/finding_discord_in_harmony">Finding Discord in Harmony</a><br /></div><br />He happened to be talking about a new open source initiative, but I couldn&#8217;t help but relate this simple principle to my experience with agile methodologies.<br /><br />I have found that Big Design Up Front environments attract people who want to talk about software development, while iterative environments attract people who want to develop software. Is it any surpise that in companies where BDUF is predominant, nobody wants to stoop to coding? Everyone wants to be an &#8220;architect&#8221; or a &#8220;Business Analyst&#8221; or a &#8220;Product Manager.&#8221;<br /><br />Recently I met a very bright fellow who is implementing a big new framework initiative. Developing within the framework seems to be quite frustrating and time consuming. Of course, there are many buzzword-compliant benefits promised from the framework. But there&#8217;s a certain &#8220;smell&#8221; to the project.<br /><br />After some reflection, I realized that the problem with the framework is that the &#8220;architects&#8221; behind it have little or no interest in software development. Unlike <a href="http://www.rubyonrails.org/">today&#8217;s flavour-of-the-moment open source framework</a>,* the developers of the framework do not actually use the framework. They&#8217;re architects, they don&#8217;t actually code applications. They don&#8217;t eat their own dogfood.<br /><br />Their framework was developed for people who like design documents, buzzwords, and PowerPoint slides. And for that reason, there is lots of documentation and white papers. But there is precious little in the way of working example applications.<br /><br />I suspect&#8212;although I don&#8217;t actually know&#8212;that the framework began with a white paper, and its destiny was forged then and there by that simple act.<br /><br />Turning back toward the light, I think there&#8217;s a powerful lesson. Begin each project as Scrum begins, with the simplest chunk of code that delivers a benefit. If you&#8217;re building a framework, start with an example application in mind. Don&#8217;t make it &#8220;hello, framework.&#8221; Begin with something you can use and make sure your framework actually makes your life easier.<br /><br />I&#8217;ll close with a joke:<br /><blockquote>A programmer is someone who is so irritated by small inconveniences that they will spend weeks writing a script, so they can spend days debugging same script, so they can save five minutes of their time, which they will waste <strike>reading slashdot</strike> on <a href="http://programming.reddit.com">reddit</a>.</blockquote> Just remember that if your work actually saves you some time you&#8217;ve created something of value. And the best way to make that happen is to <span style="font-weight: bold;">start with working code</span>.<br /><br /><span style="font-style: italic;">* Ruby on Rails (link above), is the foundation of </span><a style="font-style: italic;" href="http://www.basecamphq.com/">Basecamp</a><span style="font-style: italic;">, a software service for distributed project management.</span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/06/working-code-attracts-people-who-want.html" title="permanent link">10:17 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, March 21, 2005</div>
			

			<div class="Post"><a name="111142607489783454">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/03/are-you-thinking-of-working-for-start.html" title="permanent link">Are you thinking of working for a start up?</a></span>
					<div style="clear:both;"></div>Let’s say you want to work for a start up. You aren’t one of the founders: you’re coming in after the company has raised some money: it looks like it’s serious about success.<br /><br />You know that the start up route is a work hard, work harder environment. You’re going to push yourself to the end of your rope and then push yourself harder. You know the deal: work 60, 70, 80, or even 100+ hours a week in exchange for working with great people on something you believe in.<br /><br />If the personal rewards matter more than any monetary consideration, you can stop reading right here. I wish you well, and nothing would please me more than to hear that the years you spent in a start up were the most thrilling years of your life to date. Go for it!<br /><br />But <span style="font-style: italic;">what if you want a little more than the vibe</span>? Everyone’s heard about the riches available to employees with stock options when their company goes public or gets bought for big money. Should you consider the working for a venture backed company to make money? Is it worth it?<br /><br />I’m going to give you my perspective, based on widely disseminated anecdotes about working for start up companies in the technology sector. After you’ve read this post, you should be able to come up with a basic figure of how much money you need to make on your options to justify the long hours, hard work, and lower pay of a start up company.<br /><blockquote>Let’s say you’re a senior kind of person and you’re offered options worth 1% of the company. Not so fast! As the company grows, it takes in more investment. With every round of investment, the existing stock holders get diluted. You need to figure out how much of the company you’ll have when the company is worth M$100.</blockquote>First, a disclaimer: <em>I absolutely positively cannot value your stock options</em>. Even if your employer is wildly successful, your ability to cash in depends entirely on the whims of your Board of Directors. If they want to screw you out of your option money, they can and will do so. If you’re an employee, the only reasons to let you cash in are to keep you from quitting and to hold you up as an example so they can motivate other people to work for them.<br /><br />(Some of the time, those two reasons are good enough. This is especially true if the company has been backed by a reputable VC firm. The VC business depends on “deal flow”: a steady stream of entrepreneurs walking into the offices and offering the VCs new businesses to own. It hurts their deal flow when word gets around that they don’t share the wealth.)<br /><br />So how much will you get? And is it worth the work? As I said, I don’t know how much you’ll get. I can give you a few tools for making a Wild Assed Guess.<br /><br /><span style="font-weight: bold;">Raganwald’s Scientific Wild-Assed Guesstimation Methodology</span><br /><br />First, you have to convert options into your interest in the company. Don’t waste your time figuring out “if the company goes public at $100 a share, and each option has a strike price of $1, I get $99 per option, times 10,000 options is…” That doesn’t work. The thing to do is to figure out <em>how much of the company you have a right to buy</em>.<br /><br />Let’s say you’re a senior kind of person and you’re offered options worth 1% of the company. That sounds like a lot. If your company is purchased for M$100, your options are worth a million dollars give or take. (Just so you know, lots of software companies are sold for between one and four times revenues. So unless your company is really, really hot, your company isn’t going to be worth M$100 unless you get revenues up to M$25 at the very, very least.)<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%; font-style: italic;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0140257314?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0140257314"><img style="" src="http://raganwald.github.com/uploaded_images/startup-791634.jpg" alt="" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&o=1&amp;a=0140257314" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br /><br /><span style="color: rgb(255, 255, 255);">(</span>Ad: One of the most exciting business stories I’ve ever read: Jerry Kaplan put together an all-star team of engineers backed by the best VCs in the Valley, then he tried to revolutionalize computing by building a useful tablet computer. Then Bill Gates heard about it...<span style="color: rgb(255, 255, 255);">)</span></div>Okay, 1% is worth a million dollars. Not so fast! As the company grows, it takes in more investment. With every round of investment, the existing stock holders get diluted. That means the 1% you have now (I’m being generous: you typically have the right to buy 1% provided you don’t quit or get fired over the next four years) will actually be worth less than 1% of the company when you cash in.<br /><br />So you ask the President about the dilution, and she laughs and says “yes, but that means we’ll be on track and on our way to riches, so it’s worth it.” Okay, but you can’t have it both ways: you can’t say 1% of M$100 is worth a million dollars: you need to figure out how much of the company you’ll have when the company is worth M$100.<br /><br />Here’s an easy way to figure out what your 1% is worth: pretend you’re a VC. They just invested in the company, right? So… what was the post-money valuation? If the company shares this with you, they’re telling you how much the VCs thought the company was worth when they made their investment.<br /><br />Let’s say you get a rough estimate of the post-money valuation. I’m going to take a really early stage company, a company that just raised M$4 on a post-money valuation of M$12. In other words, the investors just paid M$4 in exchange for 33% of the company.<br /><br />Guess what? Some people with a reasonable idea of what start up companies are worth just said that 100% of the company is worth exactly M$12. So what do you think 1% of the company is worth? That’s right, 1% of M$12 is worth $120,000. No more, no less.<br /><br /><span style="font-weight: bold;">Another SWAG</span><br /><br />Is that worth it to you? Maybe you want a second opinion. Or maybe you aren’t told the post money valuation. Okay, here’s the other way to calculate what your options are worth. For this, you need to figure out your share after all the dilution. Basically, you need to estimate how many times the company will raise more money and how much stock they’ll give investors to do it.<br /><br />You’re going to have to do some research on comparables to get a good estimate. I’ll take the example I’ve used above and hypothesize a company that’s just raised M$4 on a post money of M$12. This is their second round: the founders started with credit cards and sweat, then management and an “angel” investor put another M$1 to really get things going.<br /><br />I would expect a company like this to raise at least two more rounds of capital if they’re going to do something big. They’ll probably give away another 50% of the company to do so. So the 1% you have today is going to be worth .5% when the company scores a big win. What’s that worth?<br /><blockquote>A VC is having a good year when one in five investments hits a home run. If you honestly can do a better job of picking winners, drop your day job and go into venture capital. You’ll make way more money investing in start ups than working for them!</blockquote>Well, you can always say “.5% of M$100 is half a million dollars.” And that sounds great, much better than $120,000. Where did the $380,000 come from? Well, the first calculation measured what investors think of the company. That takes risk into account. The second calculation doesn’t take risk into account. What’s the chance that the company will be a big success?<br /><br /><span style="font-weight: bold;">Making book</span><br /><br />I know, I know. <em>It’s a sure thing</em>. If you didn’t think so, you wouldn’t go to work there. And the President is awfully confident. She ought to be, she’s put her career and possibly her retirement savings on the line. But don’t forget, everyone is that confident, and most VC investments tank. By most, I don’t mean 51%. I mean <em>80% or more go right down the toilet</em>.<br /><br />The bottom line is, you ought to ignore your gut and the pedigree of the management team. The VCs take that into account when they invest, and the best they can do is about 20%. Yup, a VC is having a good year when one in five investments hits a home run.<br /><br />If you honestly can do a better job of picking winners, drop your day job and go into venture capital. You’ll make way more money investing in start ups than working for them!<br /><br />So back to 20%. That’s the number I’d pick when figuring out the odds of a spectacular success. Oh, I don’t mean that there’s an 80% chance of mass layoffs and/or bankruptcy. Many VC backed start ups eke out a living and make a little money. But the option are worthless unless the company does really, really well and can go public or get bought for major money. And that only seems to happen about 20% of the time.<br /><br />So… What does that do to the $500,000 we get if the company is sold for M$100? You guessed it, that means that the value of those options is really only about $100,000. Not $120,000 by this calculation, but close enough. And it should be: the investors use pretty much the same reasoning when they decide on the post money valuation.<br /><br /><span style="font-weight: bold;">So is that a lot of money or not?</span><br /><br />Okay, final calculation: what’s $120,000 worth to you? I mean, is $120,000 a good return on your investment?<br /><br />To figure that out, you need to know how much you’re investing by working for this company. You need to calculate your opportunity cost, the money you could have made elsewhere. Let’s start with your salary: if you could make more money somewhere else, calculate how much salary you forgo.<br /><br />For example, let’s say you can get another $5,000 a year working somewhere else with little or no risk. Over the four years your options need to vest, that’s $20,000 you’ve just invested to get $120,000 when everything works out. Okay, not bad.<br /><br />But wait: how hard will you work? If the other job is only 45 hours a week and the start up is 60 hours a week, you’re investing 15 hours a week. What’s that worth? You can take the other job and work out the hourly rate, but I prefer to calculate what I could make by the hour consulting. If you can work 60 or more hours in a start up, you can work a night job programming for other people.<br /><br />Let’s say it’s $30 an hour. $30 by 15 hours is obviously $450 a week. You’re probably going to work 200 weeks over four years, so you’re investing another $90,000 over four years. Add that to the $20,000 and you’ve just put $110,000 into the company to get $120,000 out.<br /><br />For me, that’s breaking even. It’s not terrible, but it’s no short cut to riches. If you can get a substantially better stake in the company, you’re on track to do much better. But if you’re such a hot shot, you can probably do very well seeking out a job or contract that pays well. So you probably end up in the same place.<br /><br /><span style="font-weight: bold;">Coda</span><br /><br />Of course, there are other ways to get rich in a start up. <span style="font-style: italic;">The best is to be one of the founders rather than an employee</span>. In this capitalistic world of ours, entrepreneurs are higher on the food chain than employees. Below investors, but higher than employees.<br /><br />p.s. Here's <a href="http://www.paulgraham.com/start.html">Paul Graham's take on starting a company</a>. Jerry Colonna has some reasons why you should be <a href="http://www.inc.com/resources/finance/articles/20040801/noVC.html">self-funding</a>. And the Anti-Venture Capital web site gives an excellent example of why you'll <a href="http://www.antiventurecapital.com/venturecapital.html">make less money</a> using venture capital to grow than you would staying small and profitable.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/03/are-you-thinking-of-working-for-start.html" title="permanent link">12:11 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, October 12, 2004</div>
			

			<div class="Post"><a name="109761396577799346">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/10/beware-of-turing-tar-pit.html" title="permanent link">Beware of the Turing Tar-Pit</a></span>
					<div style="clear:both;"></div><p><blockquote>&#8230;<em>in which everything is possible but nothing of interest is easy.<br /></em><div style="text-align: right;"><a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Alan J. Perlis</a></div><div style="text-align: right;"></div></blockquote><p><br />What is the Turing tar-pit? It&#8217;s the place where a program has become so powerful, so general, that the effort to configure it to solve a specific problem matches or exceeds the effort to start over and write a program that solves the specific problem. </p><p>I suffer from a tendancy to go swimming in tar. I start out trying to solve a specific problem. I become frustrated with the obvious deficiencies of the tools, and before I know it I&#8217;m sketching out ideas for platforms, frameworks, and architectures to solve a whole class of similar problems.</p><p>(This is especially dangerous for programming language designers. There&#8217;s an irresistable urge to reduce a language to the smallest, most elegant core of axioms.)</p><blockquote><em>I think a programming language should be mostly defined in itself. A language spec should be divided into two parts, a small core of operators that play the role of axioms, and the rest of the language, which, like theorems, are defined in terms of the axioms.<br /></em>   <div style="text-align: right;"><a href="http://www.paulgraham.com/ilc03.html">Paul Graham</a></div> </blockquote><p align="left">The danger of the tar-pit is that instead of developing a solution to a problem, you develop a tool for solving problems. And invariably, the wider the class of problems the tool can solve, the less useful it is for solving any one problem.</p><p align="left">In my own case, I often find myself engaging in &#8220;<a href="http://www.paulgraham.com/progbot.html">bottom-up programming</a>,&#8221; trying to invent the perfect programming language for expressing the program I&#8217;m trying to write. When I find myself working on language syntaxes, I realize I&#8217;m mired in tar and I need to reset.</p><p align="left">The Turing tar-pit&#8217;s lure is that it is situated right in the centre of some of the most attractive real-estate in your imagination. Tools that solve whole classes of problems in generic ways offer the potential for vast improvements is productivity. Consider <a href="http://www.bricklin.com/visicalc.htm">VisiCalc</a>: this application actually turned its users into programmers!</p><blockquote><em>In programming, everything we do is a special case of something more general&#8212;and often we know it too quickly.<br /></em>   <div style="text-align: right;"><a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Alan J. Perlis</a></div> </blockquote><p align="left">The very exercise of trying to understand the relationship between the problem you&#8217;re trying to solve and the general class of problems can help you understand your problem in more detail. And you can get some wonderful Aha! moments.</p><p align="left">So I believe that to do really great work, you must be prepared to skirt very close to the edge of the tar-pit. Hopefully you have an iron will and can avoid disaster with ease.</p><p align="left">In my own case, I have little will and I&#8217;m further hampered by an enormous curiosity. Out of self defence, I&#8217;ve developed some heuristics for exploring the edges of the tar-pit and mining generalization for insights:</p><ol><li><strong>Keep</strong> <a href="http://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a>&#8217;s <strong>words in mind</strong>: &#8220;<em>We aim to make simple things simple and complex things possible</em>.&#8221; When solving the general problem makes complex things possible, that&#8217;s good. But it shouldn&#8217;t be at the expense of making simple things simple.</li><li><strong>Mentally retrace your steps to the safe safe ground of the problem domain on a frequent basis</strong>. In my own case, I work with fairly disposable user stories. The important thing I do is return to them every once in a while and ask &#8220;how will this marvellous widget make any of these things easy?&#8221;</li><li><strong>Eat your own dog food/go round trip on an infrequent basis</strong>. Okay, you&#8217;re convinced you need to run your application inside a special purpose virtual machine. Fine. Pick one small operation and make it work. Program for your virtual machine, end to end. Don&#8217;t skip any of the steps. It&#8217;s better to go thin (few functions) and deep (use the entire stack) than to go wide and shallow. If your VM is a pain in the rump, you&#8217;ve discovered something. (This is a cornerstone of Ken Schwaber&#8217;s <a href="http://www.controlchaos.com/">Scrum</a> methodology).</li><li><strong>Don&#8217;t beat yourself up if you get mired</strong>. If you never produce anything more than an esoteric programming language or tool, you&#8217;ll still have gone where strong minds fear to tread. Okay, your started out trying to solve problem A and you found yourself solving a general class of problems C that doesn&#8217;t even include A. Once again, Alan Kay: &#8220;<em>A successful technology creates problems that only it can solve</em>.&#8221; Don&#8217;t be so sure you haven&#8217;t created something really important. Finish it up, you won&#8217;t know what you have until you start using it.</li></ol><blockquote><p align="left"><em>Are you quite sure that all those bells and whistles, all those wonderful facilities of your so called powerful programming languages, belong to the solution set rather than the problem set?</em></p><p align="right"><a href="http://www.cs.utexas.edu/users/EWD/"> Edsger Dijkstra</a></p></blockquote><p>Amen.</p></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/10/beware-of-turing-tar-pit.html" title="permanent link">6:11 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, July 26, 2004</div>
			

			<div class="Post"><a name="109086199736458365">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/selling-agile-difference-between-sales.html" title="permanent link">Selling Agile: The Difference Between Sales and Marketing </a></span>
					<div style="clear:both;"></div>There's an interesting Yahoo! Group centered around "selling" agile: convincing stakeholders and developers to adopt Agile Methods to improve their software development. 
<br />
<br /><a href="http://finance.groups.yahoo.com/group/SellingAgile/">http://finance.groups.yahoo.com/group/SellingAgile/</a> 
<br />
<br />I spent a few years as a salesman, with decent results. I recall one thing from my sales career that seems quite relevant to the 'problem' of selling organizations on changing their development culture: 
<br />
<br /><strong>Know the difference between Sales and Marketing</strong> 
<br />
<br />Sales is persuading a prospect that now is the time to act and that you are the best choice. Everything else is marketing. 
<br />
<br />What's the difference? Fundamentally, marketing lowers the cost of getting your message to prospects by&nbsp;publishing a fairly generic message in bulk. Sales increases the effectiveness by arranging for a sales person to engage a prospect interactively. 
<br />
<br />Effective sales companies use lower-cost marketing to educate customers about their products or services so that customers understand whether or not they have a problem and at the very least know that the company should be on the short list for choosing a solution when the customer is ready to act. 
<br />
<br />Then, effective sales companies use medium-cost prospecting (like direct mail and tele-sales) to locate customers that may make a decision in the near future. Those 'leads' are turned over to salespeople for closing. 
<br />
<br />The high-cost sales-people then have just two jobs: urge the customer to act now and urge the customer to buy from the company. If the customer needs to be convinced that there is a problem worth solving, the salesperson shouldn't be talking to the customer. 
<br />
<br />That's why salespeople spend so much time <strong>qualifying</strong>. Talk to a top salesperson. They'll tell you that there are only two skills that pay the mortgage: qualifying and closing. Everything else is secondary. 
<br />
<br />Why do we Agilists care? Because most companies don't think they have problem. Or if they think they have a problem, they think they have a personnel problem, or an estimation problem, or a discipline problem. They don't think their methodology is fundamentally broken. 
<br />
<br />By my reckoning, this is a marketing problem, not a sales problem. If you talk to these companies about Agile, you need to get them to understand that their process is broken. That's an expensive conversation. It's far, far better to market Agile to those companies. That means write books, publish weblogs, speak at seminars... All low-ish cost ways of getting the message out. 
<br />
<br />There's one big problem with this. Some Agilists take full-time jobs with non-Agile organizations and want to "sell" internally. That's a problem, because they have failed to perform the crucial first step in Sales: they failed to qualify the customer. If you want to practice Agile, you need to restrict your job search to companies that practice Agile, or at the very least companies that are hiring you because what they're currently doing doesn't work. 
<br />
<br />If your boss thinks that what you're currently doing is "not bad" or "good enough," then there's no sale to be made. You need to market, not sell. And that's a long, drawn-out proposition.
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/selling-agile-difference-between-sales.html" title="permanent link">12:54 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://reginald.braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://weblog.raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://weblog.raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://weblog.raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://raganwald.github.com/uploaded_images/coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://raganwald.github.com/uploaded_images/coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>