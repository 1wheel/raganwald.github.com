<html> 
<head>
        
        <title><script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>raganwald</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
<link rel="me" href="http://www.blogger.com/profile/13132345822387028437" />
</head>

<body>

	<div id="leftcontent">
			<img src="http://minus.com/loSY4FTZKVCwz"
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Friday, June 29, 2007</div>
			

			<div class="Post"><a name="454947708026296695">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="permanent link">Which theory fits the evidence?</a></span>
					<div style="clear:both;"></div>There are two schools of thought about the practice of managing software development (the <em>theory</em> of managing software development is of little use to us because &ldquo;the gap between theory and practice is narrower in theory than it is in practice&rdquo;).<br /><br />One school is that everything is fully deterministic in practice (&ldquo;Theory D&rdquo;). If development appears, from the outside, to be probabilistic, it is only because we haven’t discovered the &ldquo;hidden variables&rdquo; that fully determine the outcome of software development projects. And, since we are talking about development in practice, it is practical to measure the variables that determine the outcome such that we can predict that outcome in advance.<br /><br />The other school of thought is that development is fully probabilistic in practice (&ldquo;Theory P&rdquo;), that there are no hidden variables that could be used to predict with certainty the outcome of a software development project. Theory P states that the time and effort required to measure all of the variables influencing a software development project precisely enough to predict the outcome with certainty and in advance exceeds the time and effort required develop the software.<br /><br />Theory P does not mean that software development cannot be managed in such a way that the desired outcome is nearly certain: the flight of an airplane is fully probabilistic as it encounters atmospheric conditions, yet we have a huge industry built around the idea that airplanes arrive at their destinations and land on the runway as planned.<br /><br /><strong>why do theory p and theory d matter?</strong><br /><br />Understanding whether software development follows the Theory D (fully deterministic) model or the Theory P (probabilistic) model helps us set our expectation for the relationship between what we plan and what transpires.<br /><br />If we believe Theory D, we believe that it is possible and practical to plan software development entirely in advance. Therefore, when things do not go as planned, our first reaction is to either blame the planners for faulty planning or to blame the implementers for failing to carry out a reasonable plan. Believing in Theory D, we believe that we ought to have a <em>plan</em> that can be carried out to perfection.<br /><br /><blockquote>Programming is not complicated because computers are complicated&mdash;it&rsquo;s complicated because your requirements are complicated (even if you don&rsquo;t know it yet).</blockquote><div style="text-align: right;">&mdash;<a href="http://blogs.msdn.com/cashto/">Chris Ashton</a></div><br />If we believe Theory P, we believe that it is only possible and practical to plan some part of software development in advance. Therefore, when things do not go as planned, our first reaction is to embrace the new information and update our expectations. Believing in Theory P, we believe we ought to have a <em>process</em> for continually updating a plan that asymptotically approaches a description of reality as the project nears its conclusion.<br /><br /><strong>belief drives behaviour</strong><br /><br />Our belief about which theory is true drives the way we manage software development projects in almost every way. Here are three examples: the way we manage <em>software design</em>, the way we manage <em>time estimates</em>, and the way we manage <em>selecting people</em>.<br /><br /><blockquote>If extra time is required, people on Theory D projects work nights or weekends, or they cut testing time. They do this because their belief is that if a task takes too long, the fault lies with the estimate or with the worker carrying out the task, and by working overtime they can &#8220;make up for their fault.&#8221;</blockquote><br />Theory D adherents believe you can design software in advance. They believe it is possible to collect all of the information needed about software&#8217;s requirements and the technical elements of its construction, such that you can fully specify how to build it before you start. In short, Theory D adherents believe in Big Design Up Front.<br /><br />Theory P adherents believe that software can only partially be designed in advance. They believe that requirements suffer from observation, that the act of building software causes the requirements to change. Theory P adherents also believe that technical factors cannot be perfectly understood, that only the act of trying to build something with specific components will reveal all of the gotchas and who-knews associated with a chosen technology strategy. They believe that software design is an iterative process, starting with a best guess that is continually refined with experience.<br /><br />Theory D adherents believe it is possible to estimate the amount of time required to develop software (in both the large and the small) with precision. This is partly a consequence of their belief that you can know the requirements and design in advance, and therefore you can plan the activities required without uncertainty. Theory D adherents do not plan to miss milestones. Theory D adherents do not, in fact, have a process around re-estimating tasks; instead, they have a mechanism for raising exceptions when something goes wrong.<br /><br />Theory D adherents believe that the <em>normal case</em> for software projects is that tasks are completed within the time estimated. (If extra time is required, people on Theory D projects work nights or weekends, or they cut testing time. They do this because their belief is that if a task takes too long, the fault lies with the estimate or with the worker carrying out the task, and by working overtime they can &#8220;make up for their fault.&#8221; Theory D managers often &#8220;game&#8221; their workers by &#8220;negotiating&#8221; estimates downward in a cruel game of &#8220;guess the estimate I&#8217;m think of.&#8221;)<br /><br /><div class="book"><em></em><hr><em><a name="evtst|a|0884271536" href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0884271536"><img src="http://raganwald.github.com/uploaded_images/critical_chain.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271536" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0884271536" href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0884271536">Critical Chain</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271536" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is an amazing book. The narrative form—a novella detailing a technical project team and their search for a way to manage an uncertain process—is a big win, it highlights the important ways that Critical Chain Project Management handles risks and uncertainty and makes it visible where everyone can manage it.<br><br>The section on estimating tasks alone is priceless. If you can’t afford a copy and your library doesn’t stock it, borrow mine. You <strong>must</strong> read this book if you participate in software development teams.<br></em><hr></div>Theory P adherents believe that there are lies, damned lies, and software development estimates. This is partly a consequence of their lack of faith that the requirements are truly fixed and that the technology is fully understood. If you don&#8217;t know what you&#8217;re doing and how you&#8217;ll do it with precision, how can you know when it will be done? Theory P adherents build processes around re-estimating estimates, such as <a href="http://www.controlchaos.com/about/burndown.php" title="about scrum - work burn-down">burndown charts</a> and time-boxed iterations.<br /><br />Theory P adherents are always fussing with an updated view of how long things will take. They talk about &#8220;velocity&#8221; or &#8220;effective vs. actual programmer-hours.&#8221; Theory P adherents believe that the normal case for software projects is that tasks are rarely completed exactly as estimated, but that as a project progresses, the aggregate variance from estimates falls.<br /><br />Theory D adherents believe that the most important element of successful software development is <em>planning</em>. If a plan is properly constructed for the design and development of a software project, the actual implementation is virtually guaranteed. Theory D adherents invest most of their human capital in &#8220;architects&#8221; and &#8220;managers,&#8221; leaving little for &#8220;programmers.&#8221; They often have architects, senior developers, and other &#8220;valuable resources&#8221; involved in the early stages of projects and then moved to the early stage of other projects, leaving the team to implement  their &#8220;vision.&#8221; They likewise believe that you can &#8220;parachute&#8221; rescuers into a troubled project. Since the plan is perfect, it is easy to jump in and be productive.<br /><br />Theory D adherents believe in &#8220;architecture by proxy,&#8221; the belief that using frameworks, components, programming languages, libraries, or other golden bullets makes it possible to employ lesser talents to perform the implementation of software, since the difficult decisions have been made by the creators of the pre-packaged software. Theory D adherents also believe in &#8220;success by proxy,&#8221; the belief that using methodologies, practices, SDLCs, or other buzzwords makes it possible to employ lesser talents to perform the management of software development, since the difficult project management decisions have been made by the &#8220;thought leaders&#8221; who coined the buzzwords.<br /><br />Theory P adherents believe that the most important element of successful software development is <em>learning</em>. They invest their human capital more evenly between implementers and architects, often blurring the lines to create a flatter technical structure and a more egalitarian decision-making environment. This is a consequence of the belief that learning is important: if you invest heavily in a few &ldquo;smart&rdquo; people, you have a very small learning surface exposed: there is only so much even very bright people can learn at one time. Whereas when the entire team meets a certain standard for competence, there is a very large learning surface exposed and the team is able to absorb more information.<br /><br /><blockquote>Theory P adherents believe that there are lies, damned lies, and software development estimates.</blockquote><br />They strongly prefer to have the same team work a single project from start to finish, believing that when a member moves on to another project, crucial knowledge moves on with them. They likewise abhor bringing new members onto a team late in a project, believing that the new people will need experience with the project to &#8220;get up to speed.&#8221;<br /><br />Theory P adherents use frameworks (especially testing frameworks), but are skeptical of claims that the framework eliminates technical risk or the need for talented contributors. Theory P adherents, even Agilists, are skeptical of methodology claims as well. They do not believe that a deck of slides and a nicely bound book can capture the work required to learn how to develop software for a particular user community in a particular environment.<br /><br />Theory D and Theory P adherents are easy to distinguish by their behaviour.<br /><br /><strong>so which theory fits the evidence?</strong><br /><br />Which theory fits the evidence collected in sixty years of software development?<br /><br />To date, Theory P is the clear winner on the evidence, and it&rsquo;s not even close. Like any reasonable theory, it explains what we have observed to date and makes predictions that are tested empirically every day.<br /><br />Theory D, on the other hand, is the overwhelming winner in the marketplace, and again it&rsquo;s not even close. The vast majority of software development projects are managed according to Theory D, with large, heavyweight investments in design and planning in advance, very little tolerance for deviation from the plan, and a belief that good planning can make up for poor execution by contributors.<br /><br />Does Theory D reflect reality? From the perspective of effective software development, I do not believe so. However, from the perspective of organizational culture, theory D <em>is</em> reality, and you ignore it at your peril.<br /><br /><em>Do not confuse Computer Science—the study of the properties of computing machines—with Software Development, the employment of humans to build computing machines. The relationship between Computer Science and Software Development parallels the relationship between Engineering, the hard science of the behaviour of constructions, and Project Management, the employment of humans to construct engineered artefacts.</em><br /><hr/><br />(A portion of this essay originally appeared in <a HREF="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">What I&rsquo;ve Learned from Sales, Part II: Wanna Bet?</a>.<br /><br /><em>Update</em>: <a href="http://raganwald.github.com/2007/10/d-is-for-doh-we-should-have-gone-with-p.html">D is for &ldquo;D&rsquo;oh! We should have gone with P!&rdquo;</a> and <a href="http://www.thisisby.us/index.php/content/the_myth_of_project_management">The Myth of Project Management</a>, a SFW retelling of <a href="http://angryaussie.wordpress.com/2007/07/25/project-management-is-bollocks/">Project Management is Bollocks!</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html" title="permanent link">11:38 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, June 08, 2007</div>
			

			<div class="Post"><a name="7807584909754823107">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html" title="permanent link">Still failing, still learning</a></span>
					<div style="clear:both;"></div><strong>The good new</strong>s: I&#8217;m still learning. <br /><strong>The bad news</strong>: &#8230;<em>from <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html" title="raganwald: What I've learned from failure">failure</a></em>.<br /><br />This post officially announces that my side project (originally named <em>cause &amp; effect</em> and later named <em>certitude</em>) is over.<br /><br /><strong>What I wanted to achieve</strong><br /><br />For those of you who weren&#8217;t subjected to one of my enthusiastic rants, here was my <a href="http://raganwald.github.com/2005/10/im-not-young-enough-to-know-everything.html" title="raganwald: I'm not young enough to know everything">Graham Question</a>: Can we predict the outcome of a software development project with objective observation?<br /><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/0071460829?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0071460829"><img border="0" src="http://raganwald.github.com/uploaded_images/marketing_warfare.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0071460829" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />Although most businesspeople would soil their khakis if they had to ride a tank into action, Reis and Trout are right on when they compare the four major strategies of War&mdash;Offense, Defense, Flanking, and Guerrilla&mdash;to businesses, especially start ups. I rate this even higher than <a href="http://www.amazon.com/gp/product/0060517123?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0060517123">Crossing the Chasm</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0060517123" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> for its ability to succinctly explain what growing companies have to do and how to do it to succeed.<br /><br />After you&rsquo;ve read what I have to say here about my failure, I invite you to read what <a href="http://www.amazon.com/gp/product/0071460829?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0071460829">Marketing Warfare</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0071460829" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> has to say about Guerrilla Warfare (just three tactics to pursue!) and see if I'm a case in point.<br /></em><hr/></div>I have always believed that the answer is <em>Yes</em>. And I manage projects that way. But I also strongly believe that the only way to prove that we have an objective understanding of an algorithm is to mechanize it, to write a piece of software that executes your algorithm. <br /><br />So I set out to write a piece of software that, pure and simple, would look at a software development project and show you a traffic light: a green light would mean that the project looks like it&#8217;s on track, a yellow light would mean that the project needed help, and a red light would mean that there is no hope.<br /><br />I won&#8217;t go into a lot more detail, mostly because this isn&#8217;t a story about teeming hordes of customers and me not being able to finish by deadline. It&#8217;s a story of inventing a great solution to a problem nobody cares about. But if you absolutely must visualize the application, think of something that gobbles up your MS project files, your bug tracking data, even your burn down spreadsheets, and belches out that traffic light when it&#8217;s done. That&#8217;s it.<br /><br />So how and why did I fail?<br /><br /><strong>Project management software is social software</strong><br /><br />Reason zero, just as Paul Graham warned, my age. Really. I remember how much code I could crank at age 22, and now that I am double the age, I write an order or magnitude less. I&#8217;d like to say that my code is that much better that it makes up for the lack of volume. That might be true if I start a project with a specific end in mind, but the act of experimenting, tinkering, and exploring benefits from being able to turn large amounts of code around in short amounts of time.<br /><br />This is reason zero because I wanted to get it out of the way before explaining why I think I still would have failed if I were 22. But it&#8217;s still important to understand, because I might have known that I was going to fail two years ago, instead of today.<br /><br />Reason one that I failed&#8212;and this is the most important reason I failed&#8212;is that I was trying to tackle a social problem with technology. This can work&#8212;ask any dating site zillionaire&#8212;but it is a very high-risk strategy for software. Not just for making money, but for what really matters, adoption.<br /><br /><blockquote>Project management is a <em>social problem</em>.</blockquote><br />Project management is a <em>social problem</em>. It is 99.5% about getting everyone who knows something about the state of the project to share what they know with everyone else. Getting all the relevant information is 99.5% of the problem, analyzing the information is 0.5% of the problem.<br /><br />Joel likes to brag about how much trouble FogBugz goes to to make it easy to enter bugs, about how certain kinds of reports are not available to discourage punitive social behaviours like punishing developers who generate too many bugs. This is a strong hint that getting good information is all about managing people&#8217;s perception of the likelihood of punishment for telling the truth.<br /><br />Sitting here typing this, I think the company who can do the best job of predicting the outcome of software development projects is <a href="http://inklingmarkets.com/" title="Inkling Markets">Inkling Markets</a>. That&#8217;s because their entire business is about finding a way for people to communicate what they really think of something, not just what they think other people want them to say about something. I think <a href="http://news.com.com/Tech+lessons+learned+from+the+wisdom+of+crowds/2100-1014_3-6143896.html?tag=st.num" title="Tech lessons learned from the wisdom of crowds | CNET News.com">Todd Proebsting would agree</a>.<br /><br />This problem isn&#8217;t limited to dysfunctional environments where people cower in fear of saying anything except &#8220;Sir, Yes Sir&#8221; when told to <a href="http://tuxdeluxe.org/node/213" title="&quot;Ye cannae change the laws of physics!&quot; | Tux Deluxe">change the laws of physics</a>.<br /><br /><strong>Lemons, damned lemons, it&#8217;s always lemons</strong><br /><br />Project management suffers from a real lemon problem. I <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title="raganwald: The Not So Big Software Design">quoted Bruce Schneier at length</a> about this already, so this time I&#8217;ll explain things directly:<br /><br />Most managers, especially those with limited experience shipping software on a predictable schedule, do not know how to correlate what they&#8217;re told about the project with the likelihood that the project will succeed.<br /><br />Some information is valuable, some is junk. The problem is, managers &#8220;buy&#8221; information. They trade favours like letting you keep your job for information about how well you are doing your job. So there is a market for information just like a market for cars.<br /><br />They also &#8220;sell&#8221; information, literally: they have to make a report or a presentation to their superiors, or to stake holders, or to their fellow founders at the <a href="http://ycombinator.com/" title="Y Combinator">YCombinator</a> dinner.<br /><br />When a manager cannot tell the difference between information that is useful for predicting the outcome of a project and information that is not useful for predicting the outcome of a project, she thinks about the next best thing: the &#8220;resale value&#8221; of the information with people one step removed from the project, like her own manager. So she values things like pretty PowerPoints about the architecture higher than finished pieces of functionality.<br /><br />(This is why I have always sweated my heart out to give good presentations. My teams have depended on me being able to take good information and sell it upstream just as if it were CMM Level Five Buzzword-Compliant Junk).<br /><br />Do managers further removed from a project always value pretty junk more than good, solid information? Not always, but often. And that&#8217;s enough for people to be pressured to give the bad information that sells to their manager, while hiding the good information that doesn&#8217;t sell. Exactly like the owners of good cars taking their treasures off the market.<br /><br /><strong>Lemon and bay leaf cr&egrave;me br&ucirc;l&eacute;e</strong><br /><br />Why does junk information outsell good information? Nice PowerPoint isn&rsquo;t a good explanation by itself: there are nice PowerPoints explaining Agile, but managers still prefer waterfall.<br /><br />Consider a <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html" title=" The Not So Big Software Design">not so big design</a>. Let&rsquo;s call completing that design good information: we&rsquo;ve done a good job finding out what&rsquo;s really important for the project and making a design that emphasizes the way this project is unique, not the technology stack.<br /><br />Now consider a typical technology design, emphasizing frameworks and technologies. Fully buzzword-compliant.<br /><br />Which one sells better? The <em>technology stack does</em>. Why? Well, for starters, managers have been exposed to seventeen billion dollars worth of advertising talking about the benefits of technology stacks. Nobody is advertising the specific ways the not so big design helps the project. How could they? Those are <em>specific to the project</em>, that&rsquo;s the whole point.<br /><br />And managers are like anyone else, they compare what you are doing to successful projects they have seen in the past. Once again, the not so big design doesn&rsquo;t have anything in common with other projects, but the technology stack does. (There are lots of failed projects with technology stacks, of course. But who cites those when bugging the team about whether they will use Hibernate as their ORM?)<br /><br />How did this happen? How did things that have no correlation to the success of a project become more attractive than things that do?<br /><br /><div class="book"><em><hr/><a href="http://www.amazon.com/gp/product/1580630081?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1580630081"><img border="0" src="http://raganwald.github.com/uploaded_images/creme_brulee.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1580630081" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br />Mmmmmm... <a href="http://www.amazon.com/gp/product/1580630081?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1580630081">Elegantly Easy Cr&egrave;me Br&ucirc;l&eacute;e</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1580630081" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />... The title doesn&rsquo;t lie, the recipes are easy: even I was able to make tasty desserts! For motivating a team or thanking your family for putting up with your devotion to your start up, dessert is always a good choice :-)<br /><hr/></em></div>Quite simply, people have an incentive to look successful. So they imitate the outward appearances of successful projects. We have a really simple way of completing successful software projects: <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="Wasabi cannot cure rotten fish">we put successful people on them</a>. But we have a broken way of thinking about it: we don&rsquo;t like to think of the people as being special, we think that what the people do is successful.<br /><br />And by that logic, we can take <em>anyone</em>, have them do the same things as successful people, and our projects will succeed.<br /><br />In a manager&rsquo;s mind, the measure of whether information is good or not is, <em>Does it measure whether people are doing the same things that successful people have done on projects I&rsquo;ve been told were successful</em>?<br /><br />This is not the same thing as measuring whether the project is on its way to success at all. This measures the outward appearance of a project. Things that can be measured easily are rarely the most significant things. Behaviours that can be &ldquo;gamed,&rdquo; like how many hours a team is working, will be gamed.<br /><br />And as above, even if a manger knows better, does her manager know better? If not, good information will be difficult to sell and she will be under a lot of pressure to serve Lemon Pie.<br /><br /><strong>Off balance sheet transactions</strong><br /><br />There&#8217;s another important reason that projects have bad information: the best information is <em>off balance sheet</em>. That&#8217;s an expression meaning something a businessperson sweeps under the rug. Try Googling <a href="http://www.google.ca/search?q=Off+Balance+Sheet+Transaction" title="Off Balance Sheet Transaction - Google Search">Off Balance Sheet Transaction</a>. It&#8217;s never pretty.<br /><br />In essence, project plans and reports never include the most important information about the likelihood of project success. Never. (I mean never in the same sense that Joel Spolsky means &#8220;nobody,&#8221; as in &#8220;<a href="http://www.joelonsoftware.com/articles/APIWar.html" title="How Microsoft Lost the API War - Joel on Software">fewer than 10,000,000 project plans</a>&#8221;).<br /><br />Let me give you a recent example. I was discussing a project with a certain manager in a client organization, and there was a rather linear series of releases. Her question was, <em>Can&#8217;t we shorten the plan by looking at the dependencies and starting some releases in parallel with others</em>?<br /><br />Of course we could, but in doing so, we increased the project risk. Just as a single developer has a problem keeping multiple tasks in one brain, a team has the same problem: when working on several unrelated pieces of software at the same time, the individual developers may only work on one thing at a time, but the managers and the testers and especially the stake holders who are thinking about functionality and exercising change control are overloaded, so they will make poorer decisions.<br /><br />And worse, although you might <em>think</em> that there are no dependencies, you only think that at the outset of a project because of assumptions you are making <em>now</em>, before you fully understand what you are getting into. All in all, there&#8217;s a reason Agile projects have a practice of working on iterations with single themes, and the reason is to reduce risk.<br /><br />Does this mean that manager wasn&#8217;t making a reasonable trade off between risk and time? Maybe she was making a very reasonable choice. But let me ask you this: where on the plan would you see the risk component of the decision? If you were comparing Plan &#8220;A,&#8221; with the linear releases that finish in August, and Plan &#8220;B&#8221; with some parallel releases finishing in July, how do you decide which plan is better?<br /><br />Right, you can&rsquo;t see anything except the difference in dates, so you choose Plan B. The risk component of the plan is off balance sheet. Enjoy your lemon.<br /><br />(And it is very hard for a manager&rsquo;s people to explain, for the twentieth time, that <em>it is a mistake to try to optimize a project by having everybody working at once, because that crystallizes certain architecture decisions too early, and haven&#8217;t you read any Eliyau Goldratt, whose novel <a href="http://www.amazon.com/gp/product/0884271781?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0884271781">The Goal</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0884271781" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> explains what&#8217;s wrong with optimizing resource engagement when you should be managing project risk</em>? The incentive is for them keep their own counsel and put their <a href="http://braythwayt.com/RegBraithwaiteDevJune2007_en_US.pdf" title="Reginald Braithwaite">résumés</a> up on the web. Such is life.)<br /><br />A more striking example comes from another project where, for various reasons, there was nearly 100% turnover of the senior staff, and finally an outside firm was brought in to clean it up. Do you think there was a notation on the plan for staff turnover? That has to have a huge risk implication, but the plan where you use the same team from start to finish looks exactly like the plan where new people are brought in for each phase or iteration.<br /><br />Why is risk off balance sheet? I think it&#8217;s because people have a blind spot for risk in projects. After the fact of a project, you can always do a postmortem and say, &#8220;if we had done this, and this, and if we didn&#8217;t do that, we would have succeeded.&#8221; So you blame yourself for poor execution.<br /><br />There&#8217;s a culture of <em>Boolean thinking</em> about projects and plans. They worked or they didn&#8217;t. We&#8217;ll be done in July or August. Not &#8220;With Plan A, we&#8217;re 90% August, 8% September&#8221; and &#8220;With Plan B, we&#8217;re 12% July, 56% August, but 23% September and 7% October!&#8221;<br /><br />Decisions that add risk to a project, such as excessive parallelization, or the use of unproved people, or the use of team who have never worked together in the past, or of forcing decisions prematurely, all of these things are not reflected in the plan.<br /><br />(This is another reason there is pressure downwards on developer competence in many organizations. Consider two managers: the first staffs up quickly by selecting available developers, who may not be particularly good. In fact, they are less good then the existing team average. The second moves more cautiously, only adding to the team when the addition improves the average competency of the team. Do you think the second manager will keep their job long enough to finish a project? No, because the ticking time bomb of hiring certain types of developers is off balance sheet, but being understaffed is out there for everyone to criticize.)<br /><br />I had this hope that through a kind of collaborative filtering I could have a piece of software notice that linear plans or plans involving hiring too quickly or whatever had less variance than parallel plans, and adjust the traffic light accordingly. Regardless of what people would say, it would shrug its shoulders and remorselessly remark on the actual historical averages.<br /><br />Nice idea? No, it&#8217;s a dud. (Or at least, my execution was a dud!)<br /><br /><strong>Somebody set up us the bomb</strong><br /><br />The second major reason I bombed is that I couldn&#8217;t find any buyers. Quite simply, the people who understand these principles are running successful projects. I know lots of people who agree that there is a problem and agree this would help, but <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="raganwald: What I've Learned From Sales, Part I: Don't Feed the Trolls">they don&#8217;t think they need help</a>.<br /><br />I couldn&#8217;t find anyone holding their head in their hands, saying, &#8220;If only I could get the <em>truth</em> about our projects, I could open my budget and shower you with gold.&#8221; The people who were aware of the problems with project information were busy using decidedly low tech tools&#8212;like hiring good people and having daily meetings and estimating tasks in spreadsheets&#8212;to solve their problems.<br /><br />And the people who could use some help quantifying the consequences of their choices&#8212;like managers who insist on calcifying decisions very early in a telephone book design document so that they can demonstrate progress in the form of an architecture&#8212;they don&#8217;t think there&#8217;s anything wrong with their approach.<br /><br />Why is that? My conjecture is that people want help with things that fit their model of what&rsquo;s important. Someone who uses skilled practitioners and XP thinks that limiting risk is important: that&rsquo;s why they use two week iterations and merciless refactoring rather than up-front design.<br /><br />Someone using a classical BDUF management approach thinks maximizing resource allocation and managing task dependencies is important, that&rsquo;s why they spend all of their time looking at GANNT and PERT charts. When you try to sell either of them something, they want to know how it will fit the model they have in their head about how to succeed with software development, not why they should consider a new model.<br /><br />And I&rsquo;m not sure they&rsquo;re wrong about what&rsquo;s important to them, personally.<br /><br />If one of those <acronym title="Big Design Up Front">BDUF</acronym> projects fails due to the architecture being a poor fit for what the team discovers is really important about the projects, or from poor decisions being made in haste at the beginning of the project, well&#8230; managers will say that the problem was with the people making poor decisions. Such managers are not shopping for tools to help them understand the trade-offs, because they do not believe they are making trade-offs.<br /><br /><div class="book"><em><hr/><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536"><img border="0" src="http://raganwald.github.com/uploaded_images/critical_chain.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0884271536" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536">Critical Chain</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0884271536" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is an amazing book. The narrative form&mdash;a novella detailing a technical project team and their search for a way to manage an uncertain process&mdash;is a big win, it highlights the important ways that Critical Chain Project Management handles risks and uncertainty and makes it visible where everyone can manage it.<br /><br />The section on estimating tasks alone is priceless. If you can&rsquo;t afford a copy and your library doesn&rsquo;t stock it, borrow mine. You <strong>must</strong> read this book if you participate in software development teams.<br /><hr/></em></div><!--One manager I know told me that Project Management is about managing risks, as if knowing you have only a 5% chance of succeeding means you can always find a way. Given that perspective, how do you sell him a tool that tells him the difference between &#8220;With Plan A, we&#8217;re 90% August, 8% September&#8221; and &#8220;With Plan B, we&#8217;re 12% July, 56% August, but 23% September and 7% October&#8221;? I also believe project Management is about managing risks, and the way I do that is by avoiding them.<br /><br />Can such managers be sold? Of course, eventually. -->Something I learned from selling Macintoshes back in the day is this: <em>only make one sale</em>. Convincing someone they have a problem is one sale. Convincing them you have the solution is another. And convincing them that today is the day to act is a third. If you have to do all three at the same time, you are doomed.<br /><br />This is why experienced companies distinguish <a href="http://raganwald.github.com/2004/07/selling-agile-difference-between-sales.html" title="raganwald: Selling Agile: The Difference Between Sales and Marketing">sales from marketing</a>. The first two steps are marketing, the third is selling. When you are a new company, you don&#8217;t have the resources to market and sell. You have to work with an established pain point (eliminating the first hurdle), then use PR and limited marketing funds to get the word out that you have solved the problem (the second hurdle). You only have time and energy for the third sale, separating customers from their money.<br /><br />But trying to convince managers that they&#8217;re doing it wrong (tactfully), then convince them that they want your product rather than some big rigid waterfall thing or three by five cards and XP, and then convince them that they should write a cheque today&#8230;<br /><br />Bad idea. I should know, I discovered that I was trying to do exactly that.<br /><br />Now you understand why I have used so much of this post to rant about the state of project management in software development. When you understand what most companies are doing and why, you understand what will sell, and why. And when I understood that the things my project were measuring and reporting were of little interest to the people who were my market, well...<br /><br /><strong>The not so big business plan</strong><br /><br />I think there are lots of things that will sell, that <em>do</em> sell into this market. When you understand that this is a social problem, when you understand that most information is bad and that the incentives are to value bad information, and for managers to value activities that produce bad information over activities that produce good information, you can make something people <em>will</em> buy.<br /><br />Like books, lectures, methodologies, and video training. If people have a social problem, a social solution is a natural fit.<br /><br />There were interesting possibilities like selling this to BigCo for &#8220;process improvement.&#8221; But whenever I thought about such ideas, I noticed that the software wasn&#8217;t in there. I could have written a book and lectured on these ideas. I could have done a &#8220;search and replace&#8221; of agile for certitude.<br /><br />A good business plan is one that is really specifically about you and your software. If your plan could be executed by someone else, or with a different project, it simply isn&#8217;t the right plan. And all variations of turning this into ConsultingWare were excellent ways of monetizing Reg Braithwaite the brand, but not ways of spreading the adoption of certitude, the product.<br /><br />And so&#8230; and so I looked the <a href="http://en.wikipedia.org/wiki/Sunk_cost" title="Sunk cost - Wikipedia, the free encyclopedia">sunken cost fallacy</a> straight in they eye and said, <strong>no more</strong>. As much as I <a href="http://en.wikipedia.org/wiki/Loss_aversion" title="Loss aversion - Wikipedia, the free encyclopedia">hate to lose</a>, I have folded my project and I am sharing with you the important lessons I learned.<br /><br /><strong>Lessons learned</strong><br /><br />Well, the good one is this: Paul Graham is right. If you phrase your venture as a question, you will walk away with something very valuable. I now know a lot more about project management and the culture of software development than I did when I started the project, and I wasn&#8217;t exactly a Spring Chicken. And  set out to learn about Bayesian Networks and Supervised Classification, but I ended up learning about Unsupervised <a href="http://en.wikipedia.org/wiki/Data_clustering" title="Data clustering - Wikipedia, the free encyclopedia">Clustering</a> and <a href="http://en.wikipedia.org/wiki/Collaborative_filtering" title="Collaborative filtering - Wikipedia, the free encyclopedia">Collaborative Filtering</a>.<br /><br />What a journey.<br /><br />And there is the one I ignored for far too long: Always Be Selling. I can thank friends like <a href="http://www.hyperbio.net/" title="Hyperbio">Leila Boujnane</a>, <a href="http://blog.suthakamal.com/" title="Ambient Thoughts">Sutha Kamal</a>, and Erich Finkelstein for reminding me about this, incessantly. Asking people to &#8220;buy&#8221; your idea forces you to make something people want. That being said, I think there&#8217;s a right amount of &#8220;push.&#8221; You can&#8217;t invent by polling the market. Quickly now, jump in your time machine and go back to 1981 or so. How many people wanted a mouse for their computer? But yet&#8230; Always be selling!<br /><br />(There&rsquo;s a bunch of other stuff that is far more personal, and maybe some of it will appear one day in public, but I wanted to keep this post to essay length, so it&rsquo;s almost entirely about products and markets.)<br /><br />So, here I am. Older, wiser, and ready for life&#8217;s next adventure. It might be more consulting for BigCo. It might be joining a start up and helping someone else&#8217;s dream flower. I don&#8217;t know, but if you have an idea...<br /><br /><blockquote>My brain is open.</blockquote><br /><div style="text-align: right;">&#8212;P&aacute;l Erd&ouml;s</div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html" title="permanent link">6:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, January 18, 2007</div>
			

			<div class="Post"><a name="116914365603826794">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/business-programming-standards-have.html" title="permanent link">Business programming standards have become higher in 2007. Learn to love it.</a></span>
					<div style="clear:both;"></div>From time to time people suggest that fundamental computer science familiarity is irrelevant to the work of a business programmer. I am talking about a knowledge of <a href="http://blogs.msdn.com/ericlippert/archive/2004/05/19/135392.aspx" title="How not to teach recursion">recursion</a>, operations on data structures, code generation, and other topics that are often derided as being &#8220;unnecessary&#8221; in a business programming context.<br /><br />Hmmm.<br /><br />I think this is wrong in 2007. It may not have been wrong in <a href="http://raganwald.github.com/2007/01/where-were-you-on-saturday-november-9.html" title="Where were you on Saturday, November 9th, 2002?">2002</a>, perhaps such knowledge was a bonus but not a basic requirement. But today, I think you need to have it. And I don&#8217;t mean, you need to have it on your resum&eacute;. I mean, you will use it on your job from time to time.<br /><br />Now, I know that some readers are shaking their heads, <strong>no</strong>. And some are nodding their heads, <strong>yes</strong>. It&#8217;s easy to think this is all about culture, and some kind of weird hacker fraternity, or whatever. It&rsquo;s especially easy to dismiss stuff you never use: if you never needed it before, why would you need it now?<br /><br />That&rsquo;s the <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Blub</a> talking. Your toolbox is good enough because you've never needed anything else to do a job... <em>up to now</em>.<br /><br />No matter what you think of Lisp, Google-style interviews (do you remember when they were &ldquo;Microsoft-style interviews&rdquo;?), or optimizing code, please put that aside and try to read this post as objectively as possible. I&#8217;ll lay out my thinking for you.<br /><br />When you say &#8220;these things are not relevant for the job,&#8221; how do you know? Ok, you have twenty years of experience. And you&#8217;ve never used recursion or you&#8217;ve <a href="http://discuss.joelonsoftware.com/default.asp?joel.3.426416.61" title="Joel on Software discussion about recursion">only used it once or twice</a>. So you won&#8217;t need it now, you&#8217;ll find a way to use iteration. And who cares what a <a href="http://en.wikipedia.org/wiki/Suffix_array">suffix array</a> is, you&#8217;ll look it up in wikipedia if you need to implement one.<br /><br />That&#8217;s what people have done for quite a while: wire existing frameworks together. What programmers need to know is how to Google stuff, and what a programmer need on her desktop is an IDE that auto-completes stuff so she&#8217;ll know what the methods are called. And of course, static typing to make sure she gets the method parameters right. Good to go.<br /><br /><blockquote>There are jobs out there like that. Last year&#8217;s jobs.</blockquote><br />Well, there <em>are</em> jobs out there like that. Last year&#8217;s jobs. But how do you know the one I&#8217;m filling in 2007 is one of those? Because I told you that for this position we are working with one of the world&#8217;s largest financial institutions on a public-facing J2EE application that has been in service for more than five years?<br /><br />Now, I agree that you have figured out 98% of what we do. Most of the time, we mess with XSLT, message queues, JDBC through a DAL, and other buzzword compliant tasks. The keys to success for those items is less about programming brilliance than around discipline, process, requirements management, and the other stuff the &#8220;no hard CS&#8221; folks want to talk about in the interview.<br /><br />And of course, we <strong>care</strong> about skills in those areas. We have to, we can&#8217;t hire someone who can distribute data sets across a grid but is unable to negotiate requirements effectively with a business analyst. But let&#8217;s talk about the other 2%.<br /><br /><strong>The top two percent</strong><br /><br />From time to time we get some challenges. Here are some recent examples:<br /><br />As part of a refactoring effort last year, we wrote some Java that used Reflection and Dynamic Proxies to replace an entire layer of the application that used to include extensive hand-coding of stuff that was repetitive and error-prone. This saves us 80-90% of the code in that layer when we add new stuff to the application. A testing utility the year before used Reflection to automatically write a certain JUnit suite.<br /><br /><blockquote>You know how bit-twiddling in Java is irrelevant because you&#8217;re waiting for the database any ways? Well, we can&#8217;t afford to wait for this particular function, it&#8217;s one of those AJAX-y things that happens in real time. We can&#8217;t wait to go back to the database.</blockquote><br />We&#8217;re working on something right now that is highly performant. We have a seven-figure user base, and peak loads are intense. You know how bit-twiddling in Java is irrelevant because you&#8217;re waiting for the database any ways? Well, we can&#8217;t afford to wait for this particular function, it&#8217;s one of those AJAX-y things that happens <strong>in real time</strong>. We can&#8217;t wait to go back to the database. So we have to load something into memory on the server, build a compact data structure, and traverse it quickly. And oh yes, we can&#8217;t have a lot of layers of crap, we need to get a response back to the browser with every key press.<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262561158"><img border="0" src="http://raganwald.github.com/uploaded_images/a_little_java-777624.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262561158" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><em><br /><br /><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of The Little Schemer and The Little MLer bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em></div>For another client, we had to build a task dispatching system. It was like building a piece of a very lightweight fault-tolerant operating system. That operated across data centres in three different cities, moving jobs around from centre to centre. If you were in an interview and someone posed one of those hypothetical &#8220;how would you design a &#8230;&#8221; problems, would you think they stole the problem from some Amazon programmer&#8217;s weblog? Would you think &#8220;you don&#8217;t need that for business programming?&#8221; Well, we built that. For an ordinary, brick and mortar business that makes physical stuff.<br /><br />That 2% figure? That was in 2006. In 2007, it will be way more. Standards are rising. We&#8217;re doing more and more work that steps outside of the usual <acronym title="Create-Read-Update-Delete">CRUD</acronym> development. <br /><br />Here&#8217;s the big reason why. Have you read people grousing about interviews where they&#8217;re asked about how to implement a search? And about what a waste it is because 99% of the time the database does it, and the rest of the time they stick it in a hash table? Well, in 2007 <strong>search matters</strong>. The database is a big part of that, but it&#8217;s not as easy as <code>SELECT foo.* FROM bar WHERE ...</code> any more.<br /><br /><strong>The Google Effect</strong><br /><br />Google has become the &#8220;start page of the internet.&#8221; As a result, everyone now thinks that the way to find stuff is to do a full text search. Everyone thinks that relevant results should be first. And I mean everyone, not just your &#8220;early adopter&#8221; users, you now have Joe Average calling your customer support hotline and complaining that the search page on your application&#8212;the one with a different field for each column in each table&#8212;is too hard and why can&#8217;t he just type something and get an answer?<br /><br /><blockquote>This stuff isn&#8217;t rocket science. And you don&#8217;t need Common Lisp or Haskell to pull it off. You can do it in Java or C#.</blockquote><br />Just how do you plan to implement full text search? Buy it from Google or Oracle? And do you think you can do the &#8220;Google Suggest&#8221; thing with the drop down? In real time?<br /><br />Users now love having a single search box. They don&#8217;t want to have one box for searching on product SKU and a drop-down for searching on supplier name. One box. And if you want to make searching for supplier name easy, give them an auto-complete. Users don&#8217;t like to be given an application that basically has the implementation protruding into the interface.<br /><br />They don&#8217;t care that you store first name and last name in separate columns, they want to search for &#8220;Reg Braithwaite&#8221; and find him, even if &#8220;Reginald&#8221; is what&#8217;s stored in the first name column and there are 3,215 Braithwaites in the table. You figure it out, possibly by word stemming, possibly by statistical analysis. Or maybe you&#8217;re just doing some untrained bayesian classification to cluster the &#8220;Reginald Braithwaite&#8221; record with some other things the user is looking at right now so you put that record at the top of the list you returned.<br /><br />Hmmm, we&#8217;re not in Kansas any more. It isn&#8217;t all about <code>has_one</code>, <code>has_many</code>, or <code>has_and_belongs_to_many</code>, and you don&#8217;t have to be a <a href="http://www.powerset.com">high-profile start up</a> to care. Jane Average uses stuff like this when she reads her mail and books her vacation. But does her office HR support application work half as well? Why not?<br /><br />This stuff isn&#8217;t rocket science. And you don&#8217;t need Common Lisp or Haskell to pull it off. You can do it in Java or C#: we do it and there are thousands of places just like ours where people just like us are doing it every day.<br /><br />But in 2007, you do need to let go of the idea that all we&#8217;re doing with &#8220;business programming&#8221; is building web applications that are replacing the client-server applications of the eighties and nineties that themselves replaced the green screen terminal applications of the seventies and eighties.<br /><br />The &#8220;leading edge&#8221; interface and ideas employed by Google, Amazon, eBay, and Yahoo! are suffusing our culture to become the standard user interface of web applications. And programming the standard user interface is a basic job requirement. Learn to love it.<br /><br /><hr /><br /><em>Do you love applications like Google Mail? Would you like to write stuff like this, even if it&#8217;s less than 100% of the time? But are you looking for a stable company working on stuff you can explain to your neighbors? <a href="mailto:apply@devtopia.com">Michael Lucas</a> is hiring intermediate and senior developers for positions in Toronto, Canada. To be considered for a position, please send Michael an email with your answer to the following question:</em><br /><br /><blockquote>Name three features from public web &#8216;sites&#8217; like Google, Amazon, and YouTube (you can pick any site or sites you like) that will make the jump to business applications in 2007.</blockquote><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/business-programming-standards-have.html" title="permanent link">12:59 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, January 15, 2007</div>
			

			<div class="Post"><a name="116889503774201560">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="permanent link">What I've Learned from Sales, Part II: Wanna Bet?</a></span>
					<div style="clear:both;"></div>In Part I of &#8220;What I&#8217;ve Learned from Sales,&#8221; <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">Don&#8217;t Feed the Trolls</a>, we looked at why resistance to a new idea is expressed as a never-ending series of objections. We looked at one powerful way to avoid objections, by identifying a real, urgent problem that needs to be solved. The next installment, Part III, <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html">How to use a blunt instrument to sharpen your saw</a>, describes the mind-set that there are opportunities for improvement to be found everywhere.<br /><br />In this part, we&#8217;re going to disregard my advice to avoid objections and talk about one way to respond to many of the objections raised against new ideas.<br /><hr /><br /><strong>Can we overcome objections?</strong><br /><br />Right off the top, I want to say that I don&#8217;t believe you can &#8220;overcome&#8221; an objection by frontal assault. And furthermore, you shouldn&rsquo;t try. You cannot persuade someone to consider an idea by debating them into submission.<br /><br />My belief is that you must <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">discover and address their true problem</a>. The first reason to do so is that if they do not have a problem your idea can solve, there is no reason for them to &ldquo;change for change&rsquo;s sake.&rdquo; The second reason is that if you are not solving a real, genuine problem for them you will get caught defending an idea against an endless series of objections.<br /><br />That being said, there are some circumstances where it is important to respond directly to objections. Even if we have carefully qualified someone&#8217;s problem and explained how a new idea will solve their problem, a prudent person will analyse the idea carefully, looking for fatal defects that could prevent it from solving their problem.<br /><br />Another common circumstance is when there are several parties involved in presenting, discussing, and analysing an idea. Although one of the parties may be bringing up irrelevant objections to resist the idea, you may need to persuade another of the parties that these irrelevant objections do not have merit.<br /><br />For example, you may be suggesting that <a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html" title="Dear Agile Metaprogrammer">agile meta-programming</a> will solve a company&#8217;s problems to the CEO. You may have carefully qualified the CEO&#8217;s priorities. But the company&#8217;s IT department will raise objections because your proposals do not address their personal and departmental problems. So you <em>will</em> need to respond to some of their objections as part of a campaign to neutralize their influence.<br /><br /><strong>What is overcoming an objection?</strong><br /><br />Overcoming an objection is, to borrow a phrase from law, &ldquo;A sword, not a shield.&rdquo; When you overcome an objection, you point out that the reason for not considering your new idea is fallacious, or does not apply in this case.<br /><br />However, overcoming the objection does not actually provide a reason to change: it merely removes a reason <em>not</em> to change. This is why <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">Part I</a> goes on and on about discovering an immediate problem your idea can fix. If you overcome an objection but have not presented a compelling reason to change, nothing will happen.<br /><br />In other words, if someone says &ldquo;I like your idea, however...&rdquo; you should attempt to overcome the objection. If someone says &ldquo;Your idea stinks because...&rdquo; you really need to gidentify a problem to solve.<br /><br /><strong>One model for responding to common objections</strong><br /><br /><blockquote><br />  A gotcha objection is a proposition that your idea is false based on a premise that is true infrequently or only true for some small number of cases.<br /></blockquote><br /><br />Let&#8217;s assume you are going to respond to an objection, and you have good reason for doing so. Here&#8217;s one common form of objection, and a method for responding to the objection. In essence, I am going to share a pattern with you.<br /><br />First, let&#8217;s look at one of the most common kinds of objections. Here are some examples. They all have something in common:<br /><br /><ul><li>&#8220;Sometimes you <em>are</em> gonna need it, so you&#8217;re wasting time if you don&#8217;t build it in from the beginning. Therefore, we should build what we know we&#8217;ll need.&#8221;  </li><br /><li>&#8220;Some bugs simply can&#8217;t be found through automated unit tests, sorry. This is why we have to use a programming language with static typing.&#8221;  </li></ul><br />What these objections all have in common is what I call the &#8220;gotcha!&#8221; <a href="http://www.infidels.org/library/modern/mathew/logic.html" title="Logic and Fallacies">fallacy</a>. The underlying assumption is that if your idea does not work 100% of the time, on 100% of the cases, it is no damn good. And thus I call an objection based on the gotcha fallacy a <strong>Gotcha Objection</strong>. A gotcha objection is a proposition that your idea is false based on a premise that is true infrequently or only true for some small number of cases.<br /><br /><strong>P is for Pharmaceutical</strong><br /><br />Think about therapies in medicine. None of them are deterministic! Every pill, every technique, every therapy is described in probabilistic terms: <em>When compared to the control group who drank a glass of red wine daily but did little exercise, 36.7% of those who combined daily exercise with a glass of red wine had an average improvement of 22.1% in their combined evaluation scores for cardiovascular health</em>.<br /><br />Try this the next time you&#8217;re at the doctor&#8217;s office: point out to your physician that you have heard that some people who exercise <a href="http://en.wikipedia.org/wiki/Jim_Fixx" title="Jim Fixx">drop dead right after their daily run</a>. Use this as an excuse not to exercise.<br /><br />Now, software development is not the same thing as medicine, and I am not suggesting you respond to criticism by saying that since some drugs do not work for some patients that your ideas have merit regardless of evidence or suggestions to the contrary. But I will walk you through the reasoning that leads to the same conclusion.<br /><br /><strong>How to respond to gotcha objections</strong><br /><br />Our pattern for responding to these gotcha objections is to establish that software development is <em>probabilistic</em> in practice. Once we establish this premise, we then turn the debate from whether there are cases where a particular practice does not appear to be optimal to whether the overall results of applying that practice is better than not applying that practice.<br /><br />That&#8217;s it, and if you&#8217;re in a hurry you can stop right here: everything else is an elaboration of this idea.<br /><br /><strong>Exempli gratia: the technique in action</strong><br /><br /><strong>Objection</strong>: &#8220;Sometimes you <em>are</em> gonna need it, so you&#8217;re wasting time if you don&#8217;t build it in from the beginning. Therefore, we should build what we know we&#8217;ll need.&#8221;  <br /><br /><strong>Response</strong>: Well, sometimes you need it, sometimes you don&#8217;t. And when you don&#8217;t need it, you save the code you would have written as well as all the other design that becomes coupled to the code you end up throwing out. Of course, sometimes you end up throwing out some stub code, but think about the possibility that you will wind up getting more features done, earlier in the cycle where we can get feedback and reduce risk. Why don&#8217;t we look at whether, in aggregate, more projects will succeed using YAGNI than will succeed using &#8220;Build everything we might need&#8221;?<br /><br /><strong>Objection</strong>: &#8220;Some bugs simply can&#8217;t be found through automated unit tests, sorry. This is why we have to use a programming language with static typing.&#8221;  <br /><br /><strong>Response</strong>: Sure enough, some can&#8217;t be detected with automated unit tests. But our choice of a dynamic language provides us with many other benefits, most especially in the areas of metaprogramming and code reduction. By writing less code, we may even have fewer bugs overall. Shouldn&#8217;t we try to compare similar projects written in a static language against those written in a dynamic language, and see whether the projects in the dynamic language had fewer bugs and whether the projects written in the dynamic language were more likely to be successful?<br /><br />Now that you have seen the <em>results</em> of applying the technique, we will patiently examine the reasoning in detail.<br /><br /><strong>Theory D and Theory P in Software Development</strong><br /><br /><blockquote><br />  Theory P states that the time and effort required to measure all of the variables influencing a software development project precisely enough to predict the outcome with certainty and in advance exceeds the time and effort required develop the software.<br /></blockquote><br /><br />There are two schools of thought about the <em>practice</em> of managing software development (the theory of managing software development is of little use to us because &#8220;the gap between theory and practice is larger in theory than it is in practice&#8221;).<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536"><img border="0" src="http://raganwald.github.com/uploaded_images/critical_chain-794734.jpg"  width="140" height = "208" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0884271536" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br/><a href="http://www.amazon.com/gp/product/0884271536?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0884271536">Critical Chain</a> explains project management from the ground up in probabilistic terms. It's a significant improvement over the classical approach for managing risk and uncertainty in software development.<br/></div>One school is that everything is fully deterministic in practice (&#8220;Theory D&#8221;). If development appears, from the outside, to be probabilistic, it is only because we haven&#8217;t discovered the &#8220;hidden variables&#8221; that fully determine the outcome of software development projects. And, since we are talking about development in practice, it is <em>practical</em> to measure the variables that determine the outcome such that we can predict that outcome in advance.<br /><br />The other school of thought is that development is fully probabilistic in practice (&#8220;Theory P&#8221;), that there are no hidden variables that could be used to predict with certainty the outcome of a software development project. Theory P states that the time and effort required to measure all of the variables influencing a software development project precisely enough to predict the outcome with certainty and in advance exceeds the time and effort required develop the software.<br /><br />Theory P does not mean that software development cannot be managed in such a way that the desired outcome is nearly certain: the flight of an airplane is fully probabilistic as it encounters atmospheric conditions, yet we have a huge industry built around the idea that airplanes arrive at their destinations and land on the runway as planned.<br /><br />Which theory fits the evidence collected in sixty years of software development? To date, Theory P is the clear winner on the evidence, and it&#8217;s not even close. Like any reasonable theory, it explains what we have observed to date and makes predictions that are tested empirically every day.<br /><br />(Sidebar: do not confuse Computer Science&#8212;the study of the properties of computing machines&#8212;with Software Development, the employment of humans to build computing machines. The relationship between Computer Science and Software Development parallels the relationship between Engineering, the hard science of the behaviour of constructions, and Project Management, the employment of humans to construct engineered artefacts.)<br /><br /><strong>The first response to the gotcha objection</strong><br /><br /><blockquote><br />  The race may not always be to the swift nor the victory to the strong, but that&#8217;s how you bet<br />  &#8212;Damon Runyan<br /></blockquote><br /><br />Before we can go anywhere with gotcha objections, there is something you absolutely, positively must do when you respond. And it must be the very <em>first thing you do</em>. You must establish the fact that the premise of the objection is not universal and not predictable, it is probabilistic.<br /><br />The objection is of the form that &#8220;since your idea works out badly some of the time, your whole idea is bad.&#8221; You must respond by establishing that some of the time the idea doesn&#8217;t appear to work out, and some of the time it does appear to work out. It isn&#8217;t universally bad or universally good.<br /><br />If you are in a face to face discussion, you can solicit agreement from the objecting party. For example:<br /><br /><ul><li>&#8220;Well, sometimes you need it, sometimes you don&#8217;t, sometimes you&#8217;re wasting time, sometimes you aren&#8217;t. Is that right?&#8221;  </li><br /><li>&#8220;So there are <em>some</em> bugs that can&#8217;t be found with automated unit tests and some that can&#8212;am I understanding you correctly?&#8221;</li></ul><br />In a less interactive environment like a running language flame war on Usenet, you can start by simply stating that the premise is not universal.<br /><br />Having established that the premise is not universal you must then establish that the cases where the premise applies are not easily distinguished from the cases where the premise does not apply. Establish that nobody knows whether the premise will apply or not until after it has happened.<br /><br />We simply can&#8217;t tell in advance whether the bugs that would be caught by a static type system will end up being significant to the outcome of a project. We can&#8217;t tell in advance which constructs will end up being a waste of time. And we can&#8217;t tell in advance which people will fail when they try to pair program. (The last point is absolutely true if the people involved are not doing the arguing about whether pair programming will work. If the programmers involved do not believe it will work, they may have a point.)<br /><br />This is the other aspect of establishing that the premise is probabilistic: not only does it only apply some of the time, but we don&#8217;t have a good way of knowing in advance when it applies and when it doesn&#8217;t.<br /><br />Okay, we&#8217;ve gone through all of this dry pseudo-academic talk of theories and probabilistic development. Time for a vacation to Las Vegas.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://flickr.com/photos/markhardie/269236151/"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/casino_royale-725195.jpg" border="0" alt="Casino Royale, follow link for rights information." title="Casino Royale, follow link for rights information." /></a><br /><strong>How do casinos make money?</strong><br /><br /><blockquote><br />  The casino&#8217;s strategy is so secure, there is just one danger to its profits: if the casino plays very few games for very high stakes relative to their capitalization, they could lose their capital.<br /></blockquote><br /><br />Casinos make money by wagering money on the outcome of games with gamblers. (If the gambling industry offends you, I apologize. We could choose to look at how insurance companies make money, it is entirely the same thing.) The games are arranged in such a way they the casino holds a small mathematical edge on each play. Over the long run, with many gamblers playing the games many, many times, the casino inexorably makes money. The casino may lose games here and there, and some gamblers may enjoy temporary winning streaks, but overall, the casino wins more than it loses.<br /><br />The very briefest exploration of statistics reveals the following facts about the casino&#8217;s strategy for making money:<br /><br /><ol><li>The casino must have an edge on each play;</li><br /><li>The more games played, the more likely that the casino will profit overall;</li><br /><li>Runs of good luck for some gamblers are offset by runs of bad luck for other gamblers.</li></ol><br /><div class="book"><a href="http://www.amazon.com/gp/product/0521540364?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0521540364"><img style="cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/understanding_probability-706271.jpg" border="0" alt="" /></a><br/>Henk Tijms&rsquo;s <a href="http://www.amazon.com/gp/product/0521540364?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0521540364">Understanding probability</a> explains probability in simple terms requiring very little mathematics. Examples drawn from everyday life include analyzing investment returns, lotteries, and gambling. The book continues to build on the basics, worthing through Bayes' theorem up to multivariate and conditional distributions. A must-read for those working with data or seeking to understand risk analysis.<br/></div>In fact, the casino&#8217;s strategy is so secure, there is just one danger to its profits (besides the obvious fear of losing their license to print money): if the casino plays very few games for very high stakes relative to their capitalization, they could lose their capital. One celebrated &#8220;whale,&#8221; <a href="http://en.wikipedia.org/wiki/Akio_Kashiwagi">Akio Kashiwagi</a>, won more than $19 million in one casino and on another occasion won $6 million in a siangle session playing baccarat for $200,000 a hand.<br /><br />Therefore, the casino&#8217;s prime safeguard is to <em>avoid risking large amounts of capital on games played very few times</em>.<br /><br />To summarize, the casino&#8217;s strategy is to:<br /><br /><ol><li>Arrange a small advantage on each game played;</li><br /><li>Play a very large amount of games;</li><br /><li>Ignore good and bad runs, they will offset each other;</li><br /><li>Do not risk large amounts of capital on games played very few times.</li></ol><br />Now that we know the casino&#8217;s strategy, let&#8217;s consider how they evaluate games. Imagine them sitting around a conference table, and someone suggests, &#8220;Let&#8217;s create a new game, Alaska Freeze.&#8221; What do they use to evaluate whether to add this new game to their casino?<br /><br />Space in a casino is at a premium. If Alaska Freeze goes in, something else comes out. So there has to be an Incremental Value calculation: do they make more money with Alaska Freeze in and something else out? Or less? This calculation has two simple components: does Alaska Freeze have a larger or smaller mathematical edge than whatever it replaces, and will Alaska Freeze be played more or less often than whatever it replaces?<br /><br />Ok, let&#8217;s return to handling gotcha objections. I&#8217;m sure you knew all of this, I was just presenting it in a palatable morsel so you can feed it to someone objecting to your idea.<br /><br /><strong>From casinos back to objections</strong><br /><br /><blockquote><br />  The process of developing software is just like the business of running a casino.<br /></blockquote><br /><br />You are handling an objection and you have established that its premise is neither universal nor predictable, it is probabilistic. Well, if it has an uncertain outcome, it is <em>just like a casino game</em>. And the process of developing software is just like the business of running a casino.<br /><br />So the question is not whether a new practice ever has a case where it appears to &#8220;lose,&#8221; for the same reason that evaluating a new game for a casino does not involve worrying about whether gamblers will ever win.<br /><br />The way to evaluate the idea is to examine it and see whether it fits the casino model:<br /><br /><ol><li>Does it offer a probable advantage each time it is employed?</li><br /><li>Can it be employed many times?</li><br /><li>Do streaks of &#8220;losses&#8221; and &#8220;wins&#8221; offset each other?</li><br /><li>Can we avoid risking the entire outcome of the project infrequent events?</li></ol><br />And if it does, to identify what idea or practice it replaces to determine whether it is a net win or a net loss overall:<br /><br /><ul><li>Does it offer a larger or smaller mathematical edge over the practice it replaces? In other words, does it lose less often?</li><br /><li>Can it be applied more or less often than the idea it replaces? In other words, how much benefit can we obtain from it?</li></ul><br />Now, I am not going to say that XP, YAGNI, or dynamically typed programming languages <em>necessarily</em> fit the casino model and are necessarily better than the practices they replace (Classical Project Management, BDUF, and static typing). But what I will say is that there is a huge difference between saying &#8220;some of the time, for some of the people, that idea loses&#8221; and saying &#8220;overall, when applied to an entire project, the project does worse than whatever idea it replaced.&#8221;<br /><br />So to handle a gotcha objection, we establish that it is probabilistic in nature, then we analyse it as we would analyse any other probabilistic practice: we look at the overall effect of the practice on the entire project, comparing it to whatever practice it would replace. And I have some easy-to-remember phrases for doing that.<br /><br /><strong>The second response to the gotcha objection</strong><br /><br />The next step is rather obvious. You have to state the payoff those times that your idea or practice &#8220;wins.&#8221; And to be fair, you also have to agree to the cost of your idea or practice when it &#8220;loses.&#8221;<br /><br /><ul><li>&#8220;When teams are disciplined about not writing code that won&#8217;t be needed in the current iteration, we get more of the features developed earlier, where we can analyse and learn from them. This lowers our technical and requirements risk. Of course, sometimes this means that they have to throw stub or temporary scaffolding code out later, so there is some wasted code.&#8221;</li><br /><li>&#8220;When projects are written using dynamic languages, they can use techniques like meta-programming to write less code and to concentrate the <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html" title="Economizing can be penny-wise and pound foolish">green code</a> in one place. Of course, we do not have the compiler telling us about certain types of errors.&#8221;</li></ul><br />Needless to say, if you are in a face to face meeting you should solicit agreement to this second response as well. If you can&#8217;t establish that there are <em>any</em> benefits to your suggested practice, you have a great deal more work to do to handle this objection.<br /><br /><strong>The third, and final response to the gotcha objection</strong><br /><br />The final step is the clincher. Having established that the objection&#8217;s premise is probabilistic, and that for those times the idea or practice &#8220;wins&#8221; there is a positive payoff, it&#8217;s time to compare the overall benefit of the idea or practice to whatever it replaces. You want to shift the debate from debating the premise to debating the overall benefit.<br /><br />And in fact, there are two different forms of the clincher. You can use either, or preferably both:<br /><br /><ol><li>Ask whether you can balance the benefits of using the practice when it wins against the cost of using the practice when it loses, and evaluate the overall benefit <em>in comparison to</em> the benefits and costs of the alternative and see whether you would get more of a benefit <em>over one entire project</em>, or;</li><br /><li>Ask whether you can compare the success rate of teams using the practice to the success rate of teams using the alternative <em>in aggregate</em>, or;</li><br /><li>Both.</li></ol><br />And here are the example responses again, demonstrating the three forms of clincher:<br /><br /><strong>Objection</strong>: &#8220;Sometimes you <em>are</em> gonna need it, so you&#8217;re wasting time if you don&#8217;t build it in from the beginning. Therefore, we should build what we know we&#8217;ll need.&#8221;  <br /><br /><strong>Response</strong>: Well, sometimes you need it, sometimes you don&#8217;t. And when you don&#8217;t need it, you save the code you would have written as well as all the other design that becomes coupled to the code you end up throwing out. Of course, sometimes you end up throwing out some stub code, but think about the possibility that you will wind up getting more features done, earlier in the cycle where we can get feedback and reduce risk. Why don&#8217;t we look at whether, in aggregate, more projects will succeed using YAGNI than will succeed using &#8220;Build everything we might need&#8221;?<br /><br /><strong>Objection</strong>: &#8220;Some bugs simply can&#8217;t be found through automated unit tests, sorry. This is why we have to use a programming language with static typing.&#8221;  <br /><br /><strong>Response</strong>: Sure enough, some can&#8217;t be detected with automated unit tests. But our choice of a dynamic language provides us with many other benefits, most especially in the areas of metaprogramming and code reduction. By writing less code, we may even have fewer bugs overall. Shouldn&#8217;t we try to compare similar projects written in a static language against those written in a dynamic language, and see whether the projects in the dynamic language had fewer bugs and whether the projects written in the dynamic language were more likely to be successful?<br /><br />Good luck handling objections. What is your experience: do you have another technique you can recommend?<br /><br /><strong>A Personal Note</strong><br /><br />As Mike pointed out in the first comment, this post explains how to handle this one type of objection, the gotcha objection, by moving the debate away from the exception case and towards the overall case. But it does not follow up by presenting hard data to justify the example ideas presented.<br /><br />First, I want to say that even with hard data you will not foster change with numbers: you need to show how your idea addresses an urgent priority. That should have happened <em>before</em> you got to this point. If you have addressed the problem correctly, it really is sufficient to point out the fallacy in the objection and allow your original argument to stand.<br /><br />Second, there is a dearth of hard data about anything to do with software development. Repeat after me: &ldquo;the plural of anecdote is not data.&rdquo; If you have a source of hard data about any practice, be it programming languages, practices, or even interviewing techniques, I would very much like to read and learn from it.<br /><br />Does this mean that we should never change, that since there&rsquo;s no <strong>proof</strong> that new ideas are an improvement over old ones?<br /><br />If you are happy with your current situation, maybe not. If you are unhappy with your current situation, if you want things to be better, you may want to change something. It&rsquo;s your call.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="permanent link">5:16 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, January 14, 2007</div>
			

			<div class="Post"><a name="116866063058399558">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="permanent link">What I've Learned From Sales, Part I: Don't Feed the Trolls</a></span>
					<div style="clear:both;"></div>This is the first part of “What I’ve Learned From Sales.” In this part, “Don’t Feed the Trolls,” I present my explanation for why people act like “trolls,” raising objection after objection to new ideas, and I suggest how to side-step this behaviour and deal directly with their concerns.<br /><br />(Part II, <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">Wanna Bet?</a>, describes how to handle one very common form of objection. Part III, <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html">How to use a blunt instrument to sharpen your saw</a>, describes the mind-set that there are opportunities for improvement to be found everywhere.)<br /><hr /><br />“Oh no,” you must be thinking, “another <a href="http://garage.com" title="Garage Ventures">Guy Kawasaki</a> wanna-be trying to tell me how to sell things.” Well, <em>yes</em> to the wanna-be accusation, but <em>no</em> to the proposition that this is a general-purpose article about sales. I am not going to pretend to tell you how to promote your business, turn your product idea into a money-maker, or even how to sell yourself to an employer.<br /><br />What I am going to share with you is some experience I have had with sales that strongly parallels my experience discussing new ideas with people. (I know, reasoning by analogy is often faulty. But it’s what we humans do, we’re pattern-matching machines.) If you find that people seem unreasonably resistant to good ideas like <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="Are we Blub programmers?">more powerful programming languages</a>, <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="Wasabi cannot cure rotten fish">putting people before process</a>, or <a href="http://raganwald.github.com/2005/06/working-code-attracts-people-who-want.html" title="Working code attracts people who want to code">valuing working code above documents</a>, you may find this helpful.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0673461750?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0673461750"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/the_macintosh_way-791759.gif" alt="" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;o=1&a=0673461750" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br />Guy Kawasaki’s <a href="http://www.amazon.com/gp/product/0673461750?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0673461750">The Macintosh Way</a> explains how to create and evangelize great ideas, whether they are products for sale or world-changing movements.<br /></div>Our model here is that the mental process of considering a new idea is the same as the mental process behind buying something. If you are discussing a new idea with someone—even if you aren’t actively trying to “sell” it to them—they are still going through the buying process. And if they have trouble accepting the idea, they will resist, or in sales jargon, they will “raise objections.”<br /><br />Do you think this is specific to sales? No, when we see new ideas like the Ruby programming language, we encounter objection after objection. Some are ironic: Some Java enthusiast objects to Ruby on performance grounds: perhaps they are too young to remember when the C/C++ folks objected to Java on performance grounds? Or perhaps it will be the IDE support objection, or the Not Invented By Microsoft (a/k/a Not a Corporate Standard) objection, or any of a million others that are not completely unreasonable, but are also usually irrelevant.<br /><br /><span style="font-weight: bold;">What is an objection?</span><br /><br />On the face of it, an objection is an expression of a discrepancy between your idea and what someone wants. So if they say “Lisp has too many parentheses,” you might think that they are saying “I would use Lisp if it didn’t have so many parentheses.”<br /><br />The great secret we can learn from sales is that <em>this is not true</em>. As we will see below, people say what they think other people want them to say. So someone might be thinking “Lisp is too hard for me, all this talk of <code>let</code> and <code>lambda</code> and <a href="http://raganwald.github.com/2005/11/repost-closures-in-ruby.html" title="Closures in Ruby">closures</a> and <a href="http://raganwald.github.com/2006/09/scientists-announce-empirical-evidence.html" title="Scientists Announce Empirical Evidence for Greenspun's Tenth Rule">tail recursion</a> is confusing.” But they are embarrassed to admit this, so they seize on something that sounds more reasonable, like “the syntax is weird.”<br /><br />We need to understand this, because <em>the absolute worst thing you can do with an objection is answer it directly</em>. If someone is really thinking “Lisp is too hard,” what good does it do to try to persuade them that parentheses are their friends? They don’t really care. Worse, if you trot out the benefits of homiconicity and its applications to macros and introspection and <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="The significance of the meta-circular interpreter">meta-circularity</a>, you’re actually making Lisp sound <em>harder</em>, not easier.<br /><br /><blockquote><br /> At one time I was a Macintosh salesperson. I used to sell Mac SEs and Mac IIs in “The Dark Times” after Steve Jobs was expelled from Apple by the vile and treacherous Prince John…<br /></blockquote><br /><br />Let me give you an example from my own experience in sales. At one time I was a Macintosh salesperson. I used to sell <a href="http://en.wikipedia.org/wiki/Macintosh_SE">Mac SEs</a> and <a href="http://en.wikipedia.org/wiki/Macintosh_II">Mac IIs</a> in “The Dark Times” after Steve Jobs was expelled from Apple by the vile and treacherous <a href="http://en.wikipedia.org/wiki/John_Sculley" title="John Sculley">Prince John</a>… <em>but I digress</em>. I was a Macintosh salesperson at a time much like this time: nineteen out of twenty computer sales were PCs.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0596007191?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0596007191"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/revolution_in_the_valley-742074.jpg" alt="" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;o=1&a=0596007191" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br /><a href="http://www.amazon.com/gp/product/0596007191?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0596007191">Revolution in the Valley</a> tells the incredible story of the creation of the Macintosh—from the perspectives of the people who were actually there. It’s packed with behind-the-scenes anecdotes and little-known secrets. Much of the material is available on line <a href="http://folklore.org">for free</a>.<br /></div>You would think that selling Macintoshes would be a lonely existence. But no, the phone would ring regularly and customers would visit the office on a daily basis, always with the same question, <em>Why should I buy a Macintosh instead of a PC?</em> And at first, I would answer this question. Macintoshes were superior to PCs in every way. (Actually, this was technically very true at that time. Why, you could run as many as six monitors on a Macintosh II! But I am digressing from my digression.)<br /><br />I learned a funny thing about answering people’s questions. I would answer their questions, and they would <em>argue</em> with me. I would say that you could run multiple monitors on a Macintosh II, making yourself more productive. And they would say “but I don’t need to be <em>that</em> productive, so that doesn’t count.” Or I would say that the mouse and windowing interface is easier to use, you can learn to use more programs. And they would say “but all I need is a word processor and a spreadsheet, so I don’t need to learn new programs.”<br /><br />(Why would they do that? It was so that if someone asked them, “did you shop around and make an intelligent decision?,” they could reply, “why yes, I shopped around, I checked out Macs and PCs, I did a lot of research, and surprise surprise, I ended up with the <em>exact same thing that my neighbour Bob has</em>, except mine is running at 12Mhz and poor Bob is stuck with 10Mhz.” It may sound to you like they are doing an awful lot of work just to be able to say that one thing with a straight face, but I can tell you that there is this multi-billion dollar automobile industry that works on this principle: people want to be a little better than their neighbour, but not so much better that they are <em>different</em> than their neighbour.)<br /><br />I can give you many more examples, but the interesting thing is not whether people wanted this stuff or not, but no matter how convincingly I answered their question, they would just ask another one. Their questions had nothing to do with how they were making up their mind.<br /><br /><blockquote><br /> What people think often bears no relationship to how they behave<br /></blockquote><br /><br />I learned very quickly that what people think often bears no relationship to how they behave. People usually say the things that they think other people expect them to say, but they go ahead and do whatever it is they always wanted to do. In the case of buying computers, my observation is that most people want to buy whatever it is that most people are buying. They want to <em>belong</em>, to <em>fit in</em>. So they are going to buy a PC. Or an iPod.<br /><br />So what was <em>really</em> on their mind was fitting in, even though they argued about the Macintosh’s technical merits.<br /><br />The lesson I learned is that before we can introduce a new idea to someone, we first need to understand what is really on their mind.<br /><br />Salespeople call this “uncovering the hidden objection”. They have all these elaborate techniques for figuring out what’s really on a prospect’s mind when they encounter resistance to the sales pitch. I’m not going to suggest we do that. Instead, I’m going to suggest we avoid the objections in the first place by “qualifying.”<br /><br /><blockquote><br /> The most important principle of effective selling is that qualifying the customer is more important than overcoming objections.<br /></blockquote><br /><br /><span style="font-weight: bold;">What is “qualifying” and why is it the most important step in the sales process?</span><br /><br />Many people say the most important step is “closing,” the art of getting the prospect to hand over the money, the end of the sale. If you judge by the behaviour of people selling time shares, fitness club memberships, and automobiles, this is the only thing salespeople work on: haranguing prospects and ‘overcoming objections’ by arguing.<br /><br />Experienced and successful salespeople follow a different path. Experienced salespeople believe that the most important step is <em>qualifying</em>, the art of discovering whether a prospect has an actual need for the product, the <em>beginning</em> of the sale. Salespeople who are strong qualifiers spend almost no effort on closing because they are always working with prospects who want to buy.<br /><br />On the other hand, if you do not discover their real problem, you extol virtues that have no attraction for them and neglect to address any perceived issues in their mind. The principle at work is that if you know what someone really needs, you address their needs from the very beginning. When you arrive at the conclusion, you have already addressed any questions they may have.<br /><br />This is true for sales. It is also true for new ideas. If someone fears that an idea like learning Lisp (or meta-programming, or designing a program in the technical interview) would be too difficult for them, you will only be successful if you first explain how <a href="http://raganwald.github.com/2006/12/giles-bowkett-turns-language-elitism.html" title="Giles Bowkett Turns language Elitism Upside Down">easily they will learn the new idea</a>, and only then explain how wonderful the idea is.<br /><br /><blockquote><br /> If someone doesn’t have a headache, you cannot establish the value of an aspirin for them… Don’t focus on how you think your new idea can help them be better. Instead, focus on whether they have an urgent problem that your new idea can fix.<br /></blockquote><br /><br />Although there are various models for understanding people’s motivations—such as <a href="http://en.wikipedia.org/wiki/Maslow%27s_Hierarchy_of_Needs">Maslow’s Hierarchy of Needs</a>, or the Greed-Belonging-Exclusivity-Fear Quartet—for development tools and methodologies my experience is that the simplest model fits best: people are motivated to <strong>solve their problems</strong>: if you can identify a problem they think they have, you can show them how to solve it.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0805074562?ie=UTF8&amp;tag=raganwald001-20&link_code=as3&amp;amp;camp=211189&creative=373489&amp;creativeASIN=0805074562" title="On Intelligence by Jeff Hawkins"><img style="cursor: pointer;" src="http://raganwald.github.com/uploaded_images/on_intelligence-797528.jpg" alt="" border="0" /></a><br />In <a href="http://www.amazon.com/gp/product/0805074562?ie=UTF8&amp;tag=raganwald001-20&link_code=as3&amp;amp;camp=211189&creative=373489&amp;creativeASIN=0805074562" title="On Intelligence by Jeff Hawkins">On Intelligence</a>, Jeff Hawkins explains how the human neocortex matches visual, audible, and kinaesthetic patterns—and replays them to form the basis of prediction. He makes a convincing case that the neocortex is the single most important distinction between humans and other species… and therein explains what makes humans human.<br /></div>People without problems are not good prospects for lightweight development methodologies, new development tools, programming languages, or any other “change for the better.” Just the other day I was lunching with Dmitri from <a href="http://www.opalis.com">Opalis</a>. We were talking about a development tool I am trying to build, and Dmitri was suggesting that it was a <a href="http://disruptivethoughts.com/2007/01/08/aspirin-vs-vitamins/" title="Aspirin vs. Vitamins">“vitamin” and not an “aspirin”</a>.<br /><br />I was taken aback. Isn’t improving software development important for everyone? Then I remembered my sales training and asked him about how things were going at Opalis. Dmitri admitted that his team was performing well and that he had built a lot of trust with his organization. So he didn’t have a problem. Quite simply, if someone doesn’t have a headache, you cannot establish the value of an aspirin for them.<br /><br />Now, even Dmitri’s team has room for improvement, so it is not correct to say that there is no value in improved methodologies, tools, languages, or anything else for him. However, such things may not be a <em>priority</em> right now. This is exactly the same case as trying to sell a Macintosh to Bob’s neighbour: I believed that absolutely everyone could have benefited from owning a Macintosh. However, Bob’s neighbour didn’t think he had a usability problem, he thought he had an urgent “keeping up with Bob” problem.<br /><br />And there’s the key: Don’t focus on how <em>you</em> think your new idea can help them be better. Instead, focus on whether they have an urgent problem that your new idea can fix.<br /><br />Discovering their priorities shouldn’t difficult. Why don’t we simply ask them? Well, there’s a trick to asking someone about their priorities. Remember, they will tell you what they think other people want to hear, not what they are thinking. Here’s an example concerning agile development:<br /><br /><strong>Agilist</strong>: “What’re your priorities for the development team in the next 60-90 days?” <br /><br /><strong>Manager Says</strong>: “I have a total commitment to process improvement and faster response to business initiatives,” …<strong>but thinks</strong>… <em>CMM Level Four—or, God willing, Level Five—will get me a higher profile and a shot at the CIO position. I need some consultants in here to start imposing some bondage and discipline over our development processes.</em> <br /><br />The trick is to <em>get specific and objective</em>. Never take objections as evidence of their real needs, and never accept vague feel-good values at face value. Top salespeople don’t. Try calling a busy estate agent and saying you’d like to buy a house. I guarantee that the agent will ask you, “when do you need to buy a new house?” And so it is with new ideas:<br /><br />You cannot position lightweight development, tools, languages, or any other type of change without being able to fit them into the specific and objective problems someone is trying to solve. You need to relentlessly pursue the immediate, urgent priority:<br /><br /><strong>Startup Founder</strong>: “I’ve heard that Agile stuff is crap—it only works for star programmers who would be good no matter how you manage them.” <br /><br /><strong>Agilist</strong>: “Well, there’re a lot of opinions out there. Tell me, what would you say is the most pressing issue facing your development team right now?” <br /><br /><strong>Startup Founder</strong>: “Well, we have hacked together some great stuff, but we need to scale, and to scale without imploding we’ll need some discipline, some real management of the development team. That’s why we need a <em>real</em> methodology.” <br /><br /><strong>Agilist</strong>: “I can understand the importance of scaling up. So, have you set some specific objectives for scaling up over the next month or two?”<br /><br /><strong>Startup Founder</strong>: “For the next couple of months? Oh, it’s all about recruiting, definitely recruiting. I need another two or three top people to work on a new project that could be worth millions. We’ve identified some good candidates, but it’s very difficult to get them to accept an offer from a start up.” <br /><br /><strong>Agilist</strong>: “You know, we really ought to consider whether using Agile might help you recruit—have you considered the possibility that some star candidates might be looking for an environment that is more Agile than the one they are leaving?” <br /><br /><strong>Startup Founder</strong>: “Hmmm…” <br /><br />As you can tell, once you have a specific problem with specific dates attached to when the problem needs to be resolved, you can discuss a specific solution. You’ve side-stepped the useless “objections.” One more time: do not accept vague objectives, get specific objectives with near-term dates attached to them.<br /><br />If someone really doesn’t have any applicable near-term objective, you will not be able to introduce a new idea to them. So don’t be surprised if they express very little interest. But when you have an immediate, specific objective in hand, you can position the idea as a solution to their problem.<br /><br />And that works for almost any idea. Say you had a new programming language designed for set-top boxes. But it turns out nobody has a “programming set top boxes” problem. So they raise objections about the speed of your virtual machine, or the fact that programmers cannot manage memory in your language, so they cannot squeeze programs into very small spaces.<br /><br />Should you keep pounding away at that? Or go looking for an immediate problem people have, like building web applications?<br /><br />If you side-step their objections—like memory management—and get to the root of their immediate needs, you might be able to introduce a new popular programming language. Good luck!<br /><br /><span style="font-style: italic;">Part II, <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">Wanna Bet?</a>, describes how to handle one very common form of objection. If you liked this post, you might also like a related post, </span><a href="http://raganwald.github.com/2007/01/false-dichotomy-of-choosing-between.html" title="permanent link"><span style="font-style: italic;">The false dichotomy of choosing between your values and expediency</span></a><span style="font-style: italic;">.</span><span class="PostTitle"></span><a href="http://raganwald.github.com/2007/01/false-dichotomy-of-choosing-between.html" title="permanent link"><br /></a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="permanent link">12:47 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, December 11, 2006</div>
			

			<div class="Post"><a name="116585510985838698">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/12/you-call-this-progress.html" title="permanent link">You call this progress?</a></span>
					<div style="clear:both;"></div><blockquote>One of the things most people want to measure is progress towards project completion. But you can’t measure project completion progress unless you have completed features: developed, integrated, and tested features. A completed feature is done enough for someone to use.</blockquote><div style="text-align: right;">Johanna Rothman, <a href="http://www.jrothman.com/weblog/2006/12/measuring-project-completion-progress.html">Measuring Project Completion Progress</a><br /></div><br />I can’t emphasize this point strongly enough. In a mini-presentation on <a href="http://raganwald.github.com/assets/Connecting_Outcomes_to_Project_Success.pdf">connecting outcomes to project success</a>, I suggested that when measuring progress, evidence of achieving the “ends” is more valuable than evidence of achieving the “means.”<br /><br />In other words, evidence of completed features, things of use and value, is more useful than evidence that we are “on plan” or “in compliance with the methodology.”<br /><br />Always.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/12/you-call-this-progress.html" title="permanent link">11:11 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, December 06, 2006</div>
			

			<div class="Post"><a name="116542582083142772">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/12/repost-how-to-manage-iteration-with.html" title="permanent link">Repost: How to Manage an Iteration with a Cork Board and a Stack of Three by Five Cards</a></span>
					<div style="clear:both;"></div>On a recent project, we had very good results managing the work within iterations with a giant cork board. The board was divided into columns.<br /><br />To begin, stories were written by a program manager. He owned the absolute right to define “done-ness” for a story. The stories were written on <a href="http://en.wikipedia.org/wiki/Index_card">three by five cards</a> and placed in the first column, “story”.<br /><br />Programmers were assigned to work with the program manager to size stories. They would usually, but not always, end up working on the code. But first, they negotiated acceptance tests with the program manager. Both sides had a veto on the test suite (an acceptance test is not exactly the same thing as a unit test: see <a href="http://raganwald.github.com/2004/07/how-to-use-acceptance-tests-to-ship.html">How to Use Acceptance Tests to Ship Software</a>).<br /><br />When they agreed on a set of tests, the tests were documented (preferably on the card) and the card moved to the next column, “accept-able”.<br /><br />The programmers were blocked from coding or estimating until this point. Very important! Now they negotiated estimates. When an estimate was done, the card advanced to “sized”. But no programming started.<br /><br />Based on estimates for most or all of the stories, the stories were prioritized and some could be dropped or delayed. The stories that would be in the iteration stayed in “sized” but now would have names attached to them. By convention, we placed the assigned stories in the lower half of the board.<br /><br />Now a date was set for the entire iteration and coding would begin.<br /><br />When a story was ready for testing, it advanced to the next column, “test-able”. The program manager would validate the story, and it would advance again to “accepted”.<br /><br />If it didn&#8217;t validate (boo) it bounced back to “sized”: we had no column for “work-in-progress” (the assumption was that if a story was sized and assigned to someone, they were thinking and/or coding).<br /><br />When all the stories were “accepted,” we&#8217;d do a big acceptance test again, catching any regressions. Some of the stories would bounce to a “penalty box” in the lower right hand corner of the board. We felt it was important to highlight the shame of something being “accepted” but breaking.<br /><br />The iteration was done when all of the stories were simultaneously “accepted.”<br /><br />So the columns were:<br /><ol><li>Story</li><br /><li>Accept-able</li><br /><li>Sized:<br /><ul><br /><li>(upper) Not Assigned</li><br /><li>(lower) Assigned</li><br /></ul></li><br /><li>Test-able</li><br /><li>Acceptance:<br /><ul><br /><li>(upper) Accepted</li><br /><li>(lower) Penalty Box</li><br /></ul></li></ol>That&#8217;s it!<br /><br /><strong>The Benefits</strong><br /><br />This process was really light weight. That made it possible for us to have more iterations within the project; we worked on one and two week iterations.<br /><br />The visibility of the cork board was invaluable: everyone knew where we were, every day. This created a sense of urgency right from the start of each iteration: “we have to get all this done for next Friday? let&#8217;s get those acceptance tests defined right now!”.<br /><br />The process was rigid where we needed it to be rigid (acceptance tests before estimates), but flexible where we needed to be flexible (negotiating acceptance tests, locking down the set of stories after estimates)<br /><br />Putting the entire team into binary, project-wide iterations really lowered our integration grief.<br /><br /><strong>The Fine Print</strong><br /><br />Other methods were used for choosing themes for iterations and managing the project as a whole. This is just how we worked within an iteration. In fact, by strict definition the cork board didn&#8217;t manage the iteration so much as help us understand where we were and help us follow a set process for movement: I call this <em>Administration</em> rather than <em>Management</em>.<br /><br />“Now a date was set for the entire iteration and coding would begin.”: That&#8217;s a lot of hand waving! Deciding what to include and what to drop is a really complex weaving a deep understanding of the project risk factors, a desire to show constant visible progress (“Demo or Die”), negotiation with stakeholders, negotiation with the developers&#8230; A very hard problem.<br /><br />(Many thanks to Eric Torreborre, whose post <a href="http://etorreborre.blogspot.com/2006/10/writing-on-walls.html">Writing on the Walls</a> reminded me how important the physical manifestation of a project is to getting the project done.)<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/12/repost-how-to-manage-iteration-with.html" title="permanent link">12:12 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, December 05, 2006</div>
			

			<div class="Post"><a name="116534753870548629">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/12/five-things-customers-want-to-hear_05.html" title="permanent link">Five things customers want to hear from you</a></span>
					<div style="clear:both;"></div><blockquote>When we’re in front of executives, we quickly learned to talk about only five things:<br /><ol><li>How do we increase revenue?</li><br /><li>How do we reduce expenses?</li><br /><li>How do we bring in more customers?</li><br /><li>How do we get more business out of each existing customer?</li><br /><li>How do we increase shareholder value?</li></ol>When we work with teams, we teach them to follow the money and look for the pain. Somewhere in your organization, someone is feeling pain because they aren’t getting the answers they want to one of the questions above.</blockquote><div style="text-align: right;">—<a href="http://www.informationdesign.org/special/spool_interview.php">Jared Spool: The InfoDesign interview</a> (<span style="font-style: italic;">via </span><a style="font-style: italic;" href="http://www.webpagesthatsuck.com/biggest-mistakes-in-web-design-1995-2015.html">Biggest Mistakes in Web Design 1995-2015</a>)</div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/12/five-things-customers-want-to-hear_05.html" title="permanent link">2:33 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, October 01, 2006</div>
			

			<div class="Post"><a name="115975754405971453">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/three-questions-and-three-answers.html" title="permanent link">Three questions and three answers about Wasabi and Rotten Fish</a></span>
					<div style="clear:both;"></div><span style="font-size:100%;"><span style="font-style: italic;">I have read some questions about my post <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html">Wasabi cannot cure rotten fish</a>. Here are the questions and my replies:</span><br /><a href="http://metadeveloper.blogspot.com/2006/09/people-process.html"><br /></a><span style="font-weight: bold;"> Reg, </span><a href="http://metadeveloper.blogspot.com/2006/09/people-process.html"><span style="font-weight: bold;">are you really saying "a good team will succeed despite methodological strategy"</span></a><span style="font-weight: bold;">?</span><br /><br />No. I'm saying that a "good" methodology cannot save a bad team. That does not mean that a good team can survive a bad methodology. There are <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">four critical parts</a> of a successful software project, and in my experience you cannot succeed if any of them are missing. People are the first of those, management the last. Methodology is a part of management in my view. In some situations, strong management can impose an informal rather than a formal methodology. But it would be stretching a point to claim that such situations lacked process or had a bad process.<br /><br /><span style="font-weight: bold;">Reg, when you say "the quality of the result is almost entirely driven by the quality of the programmer", </span><a style="font-weight: bold;" href="http://blog.labnotes.org/2006/10/01/rounded-corners-34/">are you also saying "the quality of the tool employed is irrelevant to the quality of the result"</a><span style="font-weight: bold;">?</span><br /><br />No, although I might have chosen better words for this idea. </span><span style="font-size:100%;">What I'm saying is that the difference in results between good and bad programmers using the same tool is much, much larger than the difference in results for programmers of equal abilities using good and bad tools. The good tools are wasted on bad programmers, who find ways to write Visual Basic in any language. The bad tools are the source of frustration for good programmers, who waste time and energy "<a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule">greenspunning</a>" the bad tools into passable tools.<br /><br />So I am <span style="font-style: italic;">not</span> saying that (good programmer, bad tool) == (good programmer, good tool). I <span style="font-style: italic;">am</span> saying that:<br /><br /></span><span style="font-size:100%;">(good programmer, any tool) - </span><span style="font-size:100%;">(bad programmer, same tool) ><br /></span><span style="font-size:100%;">(any programmer, good tool) - </span><span style="font-size:100%;">(same programmer, bad tool)<br /></span> <span style="font-size:100%;"><br />So it is to your advantage to combine good programmers with the best tools available to them. It is always possible to cause a project to fail by selecting bad tools. There is still a difference in result between a good programmer with a good tools and a good programmer with a bad tool. Just because it is a much smaller difference than the difference between good and bad programmers doesn't change the fact that there is a difference.<br /><br />As Paul Graham and Assaf have pointed out, tool selection strongly drives your ability to attract and retain good programmers. So while in theory you may be able to combine good programmers with bad tools, in practice you may have programmers who are experts in buzzword obfuscation and UML refactoring, but they are not competent in actual programming.<br /><br />Some "bad" tools have such fatal flaws that it is unrealistic to expect even talented teams to overcome the weaknesses in the tool. In that case my expectation is that a good programmer will fail just like a bad programmer, but the good programmer will alert you to the tool's weaknesses much earlier than a bad programmer, perhaps in the exit interview. Good luck with any project where your best people quit because of poor tools, management, or working conditions.<br /><br />Finally, in some situations management does not restrict themselves to only prescribing a poor tool but compounds the error by proscribing effective use of the poor tool. In plain English, they don't just force their "A" programmers to use a "C" programming language, but they tell them to write software that they think a "C" would be comfortable maintaining.<br /><br />(Aside: The usual intent is to "make the code easy to read and maintain." But the measure of "easy to read and maintain" is wrongly "would </span><span style="font-size:100%;">an inexperienced</span><span style="font-size:100%;"> programmer write the code this way</span>." This is <span style="font-style: italic;">not</span> the same thing as "<span style="font-style: italic;">would an inexperienced but motivated programmer be able to study this code, learn from this code, understand this code, and then maintain this code</span>.")<br /><br />There is a much larger difference between good programmers using good tools and good programmers forced to use bad tools and bad programming practices. There is some debate as to whether my assertion holds for this "worst case scenario" (such organizations often go for broke, treating the <a href="http://www.joelonsoftware.com/articles/fog0000000043.html">Joel Test</a> as a golf score and do things like demand that their programmers wear ties or refrain from using the Internet).<br /><br />It may be that the formula becomes:<br /><br /><span style="font-size:100%;">(good programmer, good tool) - </span><span style="font-size:100%;">(bad programmer, good tool) ><br /></span><span style="font-size:100%;">(good programmer, good tool) - </span><span style="font-size:100%;">(good programmer, bad tool+bad practices)</span><span style="font-size:100%;"> ><br /></span><span style="font-size:100%;">(bad programmer, good tool) - </span><span style="font-size:100%;">(bad programmer, bad tool+bad practices)<br /><br /><span style="font-weight: bold;">Reg, I don't get the connection to the <a href="http://www.joelonsoftware.com/items/2006/09/01b.html">Wasabi</a> DSL!?<br /><br /></span>The title was actually snarfed from Guy Kawasaki, who wrote this aphorism approximately twenty years ago. It may be traditional Japanese wisdom. Then again, it may not.<br /><br /><span style="font-weight: bold;">Reg, not everyone can hire the top 1%, 5%, 10%, or even 50% of all developers. So <a href="http://blog.qualityaspect.com/2006/10/02/hiring-great-developers/">isn't your simplistic "hire great developers" suggestion broken</a>?<br /><br /></span>(</span><span style="font-size:100%;">Make that <span style="font-style: italic;">four</span> questions and answers)<br /><br />You know, this kind of question reminds me why I'm prejudiced in favour of working for CEOs that have a background in competitive fields like sales or competitive team sports like Soccer.<br /><br />In sales, nobody abandons the idea of hiring good salespeople because "not everyone can hire the top salespeople." Imagine being appointed coach of an <a href="http://www.upa.org">Ultimate</a> team. Do you abandon the idea of recruiting the most gifted athletes you can find because every team ought to be able to do the same thing and therefore you will have to settle for average players?<br /><br />No, obviously not. There can only be one top company. There can only be one championship team. To win in a competitive arena, you have to have better people, and better strategy, and you have to out-execute your competitors.  Your goal is to be the one company, to be the one team.<br /><br />Of course your strategy won't work for everyone, it won't work if everybody tries it.  By definition, in a competitive (or "zero-sum") game there is <span style="font-style: italic;">no</span> strategy that can help every player win.<br /><br /></span><span style="font-size:100%;">That's ok,</span><span style="font-size:100%;"> you are not interested in World Peace, in every company providing nice working conditions and good management for programmers. You are ruthlessly attempting to beat those companies into oblivion. You want them closed, bankrupt. If they have any talented programmers you want to hire those programmers away from them and put them to work building your dream while their former employers mumble platitudes about "methodologies that produce great results from mediocre people".<br /><br />Consultants can wander around selling utopian visions of methodologies that work for every company and every programmer, no matter how inexperienced or incapable.  Language and tool vendors can spend billions convincing everyone that their silver bullet eliminates all of the bugs that cause projects to fail. IDE mavens can tout the code generation and auto-completion  bells and whistles that will give every programmer, no matter how mundanely talented, the productivity of a wizard.<br /><br />These people have a vested interest in maintaining the illusion that software development is a positive sum game where everyone can win, where every project can succeed, where every product will make money.<br /><br />But if you are working in a start up where you have to compete for talent, compete for funding, and compete for business success,  you do not care whether your strategy can work for 100% of the projects in the world. You care whether it works for just one project, yours.<br /><br />If you are working on an internal project where you compete with the prospect of your work being outsourced, where you compete for funding with other projects, where you compete for executive mind share, you do not care </span><span style="font-size:100%;">whether your strategy can work for 100% of the projects in the world. You care whether it works for just one project, yours.<br /><br />Honestly, <a href="/http://raganwald.github.com/2006/08/words-to-blog-by-off-topic.html">what matters to <span style="font-style: italic;">me</span> is how I manage my own projects</a>.<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">post scriptum</span>: Not everyone wants to be the top salesperson, some people play competitive sports for the camaraderie, not to win, and some people go to work for the purpose of collecting nothing more than a pay cheque. If this describes you, you may find a kindred spirit in the "Angry Aussie": <a href="http://angryaussie.wordpress.com/2006/09/29/in-praise-of-an-average-career/">In praise of an average career</a>.</span></span><span style="font-size:100%;"><br /></span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/three-questions-and-three-answers.html" title="permanent link">10:25 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, September 30, 2006</div>
			

			<div class="Post"><a name="115961926939112412">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="permanent link">Wasabi cannot cure rotten fish</a></span>
					<div style="clear:both;"></div>There is only one problem with development methodologies. Just one. It affects <span style="font-style: italic;">all</span> methodologies, agile and otherwise: No methodology can 'fix' projects that are staffed with underperforming people. People are more important than process, period.<br /><br />This is the underlying issue with the language 'wars' as well. No magical combination of JSON, static typing, design patterns, IDE whizzies, and frameworks will somehow help a million monkeys produce any of Shakespeare's works.<br /><br /><span class="body"><blockquote>If you want to build a ship, don't drum up people to collect wood and don't assign them tasks and work, but rather teach them to long for the endless immensity of the sea.</blockquote></span><div style="text-align: right;"><a href="http://www.brainyquote.com/quotes/authors/a/antoine_de_saintexupery.html">Antoine de Saint-Exupery</a><br /></div><br />Steve Yegge has <a href="http://steve-yegge.blogspot.com/2006/09/good-agile-bad-agile_27.html">suggested</a> that if 90% of the projects adopting a methodology fail, you have to stop blaming the people. You have to stop saying "you're not doing it right." You have to say <span style="font-style: italic;">there's something wrong with the methodology itself if 90% of the projects fail to use it properly</span>.<br /><span style="font-style: italic;"><br /></span>Sounds reasonable. But why would this be true for methodologies but not true for programming languages?<br /><br />99.999% of the software written in almost any language (including Lisp, Python, and Ruby) is buggy. Yet we readily say that the problem is the programmer. We think that some languages are better than others, that some languages help eliminate certain classes of bugs, but we take as a given that good tools are not sufficient unto themselvesfor good results. We know that the quality of the result is almost entirely driven by the quality of the programmer.<br /><br /><blockquote>I have the uncomfortable feeling that others are making a religion out of it, as if the conceptual problems of programming could be solved by a single trick, by a simple form of coding discipline!</blockquote><div style="text-align: right;">Edsger Dijkstra<br /></div><br />Home Depot might suggest that buying a new table saw will cause beautiful woodwork to appear in your home. Yet just because a duffer with a table saw cannot make built-in closets all by himself, we don't abandon table saws outright. We assume that good woodworking is <span style="font-style: italic;">better</span> with good tools. And if we are blessed with the skill to make a built-in closet with a hand saw, we know that we can also make the closet with a table saw, and <span style="font-style: italic;">we judge the table saw on whether and how it can improve the results we could have obtained with another tool</span>.<br /><br />This is my criteria for judging a methodology. Can it improve a team that is already fundamentally qualified to write software?<br /><br />If you want to stop reading here, my statement is that you can only judge a methodology on the basis of the results it delivers for a team that has already proven it can ship software. You judge it on the basis of <span style="font-style: italic;">incremental value</span>. You don't compare its results to the results some other team gets, or to your fantasy of what results the team 'ought' to get.<br /><span style="font-style: italic;"><br /></span><span style="font-weight: bold;">The mythical marginal</span><span style="font-style: italic;"><br /></span><br />What I've written seems obvious. Yet, billions of dollars are paid every year to people who are selling a different perspective. What is it that causes companies to buy silver bullet after silver bullet? Why do companies lurch from consultant to methodology to programming language like infomercial junkies looking for something that will flatten their tummies without sweaty exercise or unpleasant diets?<br /><br />I bifurcate teams into those that are fundamentally qualified and those that aren't. And I believe that to fix an unqualified team, you start with the people, not the process or the tools. So what could the rest of the IT industry possibly believe?<br /><br />I have observed a belief in a marginal team. A team that is somehow straddling the fence between incompetence and competence. They can ship software, but only with help from their process and tools. If 'marginal' is too perjorative a term, you could think of them as having <span style="font-style: italic;">unactualized potential</span>.<br /><br />In truth, I have worked with several such teams, so I believe they exist. However, I believe that such teams are quite rare, while proponents of silver bullets make a living convincing customers that marginal teams are commonplace.<br /><br />The primary example I have observed of a marginal team is a team composed of individuals who are not working together well, yet they have achieved success on other teams in prior roles. Something like the Los Angeles Lakers before Phil Jackson arrived. There is a lot of latent championship potential in the individuals, but the team isn't performing.<br /><blockquote>Shipping software is not an emergant property of competent programming, nor is it a consequence of management technique.</blockquote>Why does the IT industry believe that perhaps most teams that fail are marginal teams? They have to believe this, otherwise they wouldn't waste time and money trying new silver bullets ("everything should be a stored procedure," "tests are the only documentation that matter").<br /><br /><span style="font-weight: bold;">It always comes back to hiring</span><br /><br />My broken-record assertion is that the industry as a whole embraces the above model of a marginal team: latent potential in the individuals. The difference between the industry and I is that I have an objective measure of latent potential: <span style="font-style: italic;">has the individual demonstrated success shipping software in the past</span>.<br /><span class="body"></span><blockquote><span class="body">True happiness comes from the joy of deeds well done, the zest of creating things new.</span> </blockquote><div style="text-align: right;"><a href="http://www.brainyquote.com/quotes/authors/a/antoine_de_saintexupery.html">Antoine de Saint-Exupery</a><br /></div><br />The industry doesn't apply this test rigorously, if at all. A typical interview with a developer focuses on patterns and archiecture, on talking about past achievements. Developer's don't <a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html">juggle</a>. Developer's don't <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">design software</a>. And especially, managers don't hire developers with super-strong references from strong employees that have worked with the candidate in the past.<br /><br />Basically, managers ask developers if they can ship software and then take the candidate's word for it. If you take only one thing from this blog post, take this: <span style="font-style: italic;">shipping software is not an emergant property of competent programming, nor is it a consequence of management technique</span>. Someone can demonstrate the ability to write software but lack the ability to actually ship software.<br /><br /><span style="font-style: italic;">(Update</span>: nothing in this post should be construed to suggest that people cannot become better developers through study, mentorships, or training. However, training is to hiring as tools are to skill. And they are not mutually exclusive, any more than good programmers and good tools are mutually exclusive.)<br /><br />I believe that the reason why the IT industry believes that most failing teams are marginal rather than outright incompetent is that they believe that these teams are composed of individuals who can write software and managers who can direct work. All they need are the right tools to write software "better" and better software will emerge. All they need is a methodology to manage software development better and software will ship.<br /><br />If you have a marginal team, a team composed of individuals with proven ability to ship working software, you might have something there. But if a team isn't even marginal, no methodology will help. And that's why a useful methodology can still fail to help 90% of the teams that try it.<br /><br />For the same reason that Wasabi makes Sushi divine.<br /><br /><span style="font-size:85%;">Follow-up: <a style="font-style: italic;" href="http://raganwald.github.com/2006/10/three-questions-and-three-answers.html">Three questions and three answers about Wasabi and Rotten Fish</a></span><br /><br /><span style="font-size:85%;">Postscript: <span style="font-style: italic;">The difference between Sashimi and Nigiri</span></span><br /><br /><span style="font-size:85%;">If we're judging success or failure of a development methodology, we have to judge the results on whether the development itself was successful. We can't judge whether the software made money, or whether the company's stock soared. Such things can be studied, however those are <span style="font-style: italic;">product management<span style="font-style: italic;"> </span></span>problems, not <span style="font-style: italic;">software development problems.<br /><br /></span>People have criticised Google, saying that althought it has a track record for shipping products, only one, AdWords, is financially successful. If you want to compare product management methodologies, that's fine, but you aren't talking about software development. You have to compare similar kinds of projects, for example you can't compare an in-house IT project with a known ROI (reduce the time spent entering a new Blort Ticket by 50%, saving $47.32 per week per Fizbang team member) to speculative product development like a new Web 2.0 calendar.<br /><br />Who else is trying to create new products? Apple? Microsoft? Dan Bricklin? Compare <span style="font-style: italic;">them</span> to Google, and if they are doing a better job of making money with their projects, post a critique of Google's product management on your blog.<br /><br />-r.b.<br /></span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" title="permanent link">8:13 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, August 11, 2006</div>
			

			<div class="Post"><a name="115530532347740461">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html" title="permanent link">Dear Agile Metaprogrammer</a></span>
					<div style="clear:both;"></div>I read and enjoy your weblog. You are fairly witty and your stories about attending Woodstock-like <a href="http://ll2.ai.mit.edu/">love-in</a>s are always amusing. And although I have no intention of even trying <a href="http://www.rubycentral.com/book/lib_standard.html">Ruby</a> on <a href="http://www.loudthinking.com/">Rails</a>, <a href="http://planet.lisp.org/">Lisp</a>, <a href="http://spyced.blogspot.com/">Python</a>, <a href="http://lambda-the-ultimate.org/">Haskell, Lua, or whatever else you are fawning over</a> at the moment, there are some snippets of interesting technical knowledge to be gleaned from your experiences.<br /><br /><a href="http://www.flickr.com/photos/raganwald/212610290/" title="(c) 2005 Darrin Weissinger"><img src="http://static.flickr.com/62/212610290_37a4d863f5.jpg" alt="(c) 2005 Darrin Weissinger" border="0" height="412" width="500" /></a><br /><br />For example, just the other week I realized that with fewer than 500 lines of intricate code and a few pages of boilerplate interfaces (I was going to have to define all those Java types and methods anyway, so it's free, right?), I could use an <a href="http://java.sun.com/j2se/1.3/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a> to remove some duplication from my code. I would never have thought of that if I hadn't read about how Ruby lets you make delegates with one line of code.<br /><br /><a href="http://philip.greenspun.com/research/">Philip</a> would be proud of me. But let's get to why I'm writing, ok?<br /><br /><span style="font-weight: bold;">Your posts are getting tiresome</span>.<br /><br /><a href="http://mark-watson.blogspot.com/2006/06/incredible-what-few-lines-of-ruby-code.html">Blah, blah, blah</a> <span style="font-style: italic;">the indexing takes about 20 lines of code and took less than 10 minutes to get working</span>. <a href="http://magicmodels.rubyforge.org/">Blah, blah, blah</a> <span style="font-style: italic;">magic models</span>. <a href="http://tinyurl.com/loxac">Blah, blah, blah</a> <span style="font-style: italic;">rewrite reddit in Lisp in one hundred lines and twenty minutes</span>. Worst of all, <a href="http://www.jroller.com/page/obie?entry=productivity_arbitrage">blah, blah, blah</a> $<span style="font-style: italic;">800,000 contract</span>. That's real money!<br /><br />I don't mind fanboys, <a href="http://en.wikipedia.org/wiki/Luser">luser</a>s that brag about these 'metaprogramming' languages but never actually do any work with them.<br /><br />But how irritating to hear yet another Rubyist, Pythonista, or Lisper brag about getting actual work done in half the time, with half the effort, then taking the rest of the day off to enjoy the <a href="http://flickr.com/photos/raganwald/16406258/">Real World</a>.<br /><br />Some of us are busy doing <a href="http://duckdown.blogspot.com/2006/03/large-enterprises-and-why-they-dont.html">Enterprise</a> work, you know, and we're man enough to put in seventy hour weeks debugging our XML parsers, <a href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/FrontController.html">Front Controllers</a>, and verbosely typed languages (<a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html">VTL</a>s). We don't want to hear about your Euro-style three hour lunch breaks and incremental delivery schedules.<br /><br />We do the heavy lifting and <a href="http://news.com.com/Vista+debut+hits+a+delay/2100-1016_3-6052270.html">we have the GANTT charts to prove it</a>.<br /><br />So just cut it out, ok?<br /><br />p.s. <em>I'm sorry I'm so testy, but I've been up all night trying to talk to our QA team located in Bangalore. It's bad enough that I don't speak any of their five mother tongues, but it looks like their QA plan is based on a different version of the specs than we got in our supposedly locked down briefing package from the <a href="http://www.kuro5hin.org/story/2005/9/27/95759/4240">consultants</a> that were hired to gather requirements.</em><br /><br />p.p.s. <em><a href="http://raganwald.github.com/2006/08/and-another-thing-you-software-as.html"> And another thing, you Software As A Service gadfly...</a></em><br /><span style="font-size:78%;"></span><p></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html" title="permanent link">9:46 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, February 22, 2006</div>
			

			<div class="Post"><a name="114062471547022140">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/02/better-testing-presentation.html" title="permanent link">Better Testing Presentation</a></span>
					<div style="clear:both;"></div>Here's a brief presentation I gave for the Toronto chapter of the <a href="http://www.torontospin.com/">Software Process Improvement Network</a> ("SPIN").<br /><br />Download "<a href="http://www.raganwald.com/assets/better-testing.ppt">Better Testing</a>" (584Kb, PowerPoint).<br /><br />It emphasizes principles rather than giving specific tips, how-tos, or examples. This was written for the cerebral QA or development manager who is seeking some insight into why some things work well and others don't, rather than a prescription for an inexperienced manager looking for specific direction.<br /><br />I started developing the presentation with a completely different plan for what it would contain and communicate. I really wanted to talk about burn-down charts and talk about various metrics I have personally found to be useful.<br /><br />I imagined a kind of diagnosis model where the presentation would list specific project problems and talk about what you can empirically measure to confirm the problem. However, as I wrote out explanations for each metric, I noticed a problem.<br /><br />Every time I'd explain a metric, I found myself writing out various caveats and disclaimers. The trouble is that metrics can be completely misused, causing teams to chase the numbers rather than develop software. So with each metric there are good things you can discover with measurement, but there are also pathological problems you can experience if you focus on the metric to the exclusion of the underlying principle.<br /><br />After a while, I realized that this problem seemed more interesting to me than the metrics themselves. This is a cliché for programmers. We start developing a to-do list application and end up with an entire <a href="http://rubyonrails.org">web development framework</a> because we find the underlying common problem more interesting than the application.<br /><br />So, this presentation is really about what makes some tests better than others, rather than specific tests. I'd appreciate any and all feedback, especially suggestions for improvement.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/02/better-testing-presentation.html" title="permanent link">10:21 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, February 15, 2005</div>
			

			<div class="Post"><a name="110844800623490553">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/02/presentation-four-things-ive-learned.html" title="permanent link">Presentation: Four things I've learned from my failures</a></span>
					<div style="clear:both;"></div>...and what Agile could have done to help...<br /><br />Here's the final version of the presentation I gave on February 15th at the <a href="http://www.xptoronto.com/news.jsp">XP/Agile Toronto Users Group</a>: [<a target="_self" href="http://raganwald.github.com/assets/fourthings.ppt">fourthings.ppt</a> (updated)].<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/02/presentation-four-things-ive-learned.html" title="permanent link">1:08 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, January 24, 2005</div>
			

			<div class="Post"><a name="110658172625169319">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/01/powerpoint-presentations-on-software.html" title="permanent link">PowerPoint Presentations on Software Development</a></span>
					<div style="clear:both;"></div>Here are four PowerPoint presentations I've delivered over the last few years. Caveat: I structured these decks as visual aids for extemporaneous talks. In other words, they do not provide a coherent, narrative story on their own.<br /><br />(In future talks I plan to experiment with different structures. Some presentations, such as business plans, need to function as stand-alone documents because they are intended to be passed around and reviewed long without your presence.)<br /><a href="http://raganwald.github.com/assets/scrum.ppt"><br />   Scrum: One Person's Perspective</a>: Shortly after obtaining my certification in the Scrum development methodology (I'm now a "Certified Scrum Master"), I gave this outline of Scrum to the <a href="http://www.torontospin.com/torontospin/default.asp">Toronto Chapter</a> of the Software Process Improvement Network.<br /><br /><a href="http://raganwald.github.com/assets/evidence.ppt">    Evidence-based Software Development Practices</a>: How to develop higher quality software in less time with dramatically less risk by emphasizing the role of collecting and analyzing evidence. This is the cornerstone of my approach to delivering software on time and without drama.<br /><br /><a href="http://raganwald.github.com/assets/agile-critical-chain.ppt">    Agile Development or Critical Chain? Yes!</a>: An outline of the Critical Chain Project Management (CCPM) approach and how to integrate it with Agile approaches to software development.<br /><br /><a href="http://raganwald.github.com/assets/agile-methods.ppt">    Agile Methods in a Product Development Setting</a>: Sharing my personal experience using Agile methods to develop software products, with particular emphasis on the ways in which product development differs from custom/project oriented work.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/01/powerpoint-presentations-on-software.html" title="permanent link">9:51 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, January 07, 2005</div>
			

			<div class="Post"><a name="110506474145257282">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html" title="permanent link">What I've learned from failure</a></span>
					<div style="clear:both;"></div><blockquote>I have been fired from more jobs than most people have had.<br /></blockquote><div style="text-align: right;"><a href="http://www.blogmaverick.com/">Mark Cuban</a><br /></div><br /><strong>Why does failure matter?</strong><br /><br />It's a funny thing. After almost twenty years of drawing a paycheque for creating software, people generally want to hire me because they want me to duplicate the successes I've had. The model seems to be "do the things you've done successfully before, and you'll be successful now."<br /><br />My experience is that this has never worked on its own. Success in software development is at least as much about avoiding failure modes as it is about "best practices." I conjecture it's because software development on a commercial scale is so hard that almost any mistake will sink a project if left uncorrected or even worse, actively encouraged.<br /><blockquote>We tend to seek easy, single-factor explanations of success. For most important things, though, success actually requires avoiding many separate causes of failure.<br /></blockquote><div style="text-align: right;">Jared Diamond<br /></div><br />With that in mind, I've taken a little time to jot down some thoughts about situations where I've personally failed. I'm not going to tell you about some theoretical anti-pattern, or relate some broken thing I've fixed, I'm going to share things that caused me to leap from the deck of a burning boat to avoid drowning.<br /><blockquote>If you decide to run with the ball, just count on fumbling and getting the shit knocked out of you, but never forget how much fun it is just to be able to run with the ball<br /></blockquote><div style="text-align: right;">Jimmy Buffett<br /></div><br />Some of them, in retrospect, would be comical if it wasn't for the human misery, damaged careers, and money wasted on failed projects. Or worse, in my opinion, the opportunity cost of putting good people to work on things that never end up delighting the world. I weep for what might have been.<br /><br /><strong>The four most important causes of failure</strong><br /><blockquote>Things which matter most must never be at the mercy of things which matter least.<br /></blockquote><div style="text-align: right;">Johann Wolfgang Von Goethe (1749-1832)<br /></div><br />The first thing I've learned from failure is that the four things which matter most are:<br /><ol>   <li>The quality of the people doing the development</li>   <li>The expected value of the product to its stakeholders</li>   <li>The fitness of the proposed solution</li>   <li>The quality of project management and expectations communication</li> </ol> In my experience, you need all four working to have a successful project. I've personally failed when even one of those four things was bad and not corrected immediately. If two, three, or all four were wrong, my discovery is that I've been unable to avert disaster. (This list obviously doesn't cover all of the factors needed for business success: I'm just talking about getting the software to ship).<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/exec/obidos/tg/detail/-/0976694026/?tag2=raganwald001-20"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://raganwald.github.com/uploaded_images/behind_closed_doors-736290.jpg" alt="" border="0" /></a>Now that I've learned this, I have four new things to evaluate when placed in charge of a new project. And regardless of what I'm told, I'm going to investigate these four things every time, right away, without fail.<br /><br />I've never seen a project where strength in one area made up for weaknesses in others. I've never personally seen a great technology platform, for example, that magically enabled low-quality developers to produce commercial-quality results.<br /><br />And don't talk to me about XP being a magic bullet: all of the good XP teams I've seen happened to have quality developers, a valuable objective, decent technology, and yes, good project management.<br /><br /><strong>People</strong><br /><blockquote>I think the root of your mistake is saying that macros don't scale to larger groups. The real truth is that macros don't scale to stupider groups.<br /></blockquote><div style="text-align: right;"><a href="http://www.paulgraham.com/">Paul Graham</a> on the <a href="http://ll4.csail.mit.edu/">Lightweight Languages</a> mailing list<br /></div><br />I've been involved with strong teams and weak teams, and the weak teams always failed. Weak teams have individuals whose performance is weak. The strongest indication of a weak team is the realization that if you were to quit and start your own business, you wouldn't try to poach any of your colleagues.<br /><br />Painful experience has taught me some of the signs that a team doesn't have the chops to perform up to par. The first sign of a weak team is poor hiring practices.<br /><br />Developing software is a difficult job. It requires a panoply of strengths. Hiring good people is never as simple as interviewing three people with "five years of J2EE" on their résumés and making an offer to the best of the three. Strong teams have almost impossibly high hiring standards. Strong teams will always leave a desk empty rather than settling for less than the best.<br /><br />Another sign of a weak team is poor development hygiene. There are dozens of development practices that seem trivial to the inexperienced outsider or to the manager focusing on "big wins." Examples of development hygiene include source code versioning, maintenance of an accurate bug or issue database, significant use of automated testing, continuous integration, and specifications that are kept current (whether incredibly detailed or high-level overviews).<br /><br />One team I audited were not just unwilling, but were actually unable to build a product that was in sustaining development. In other words, the product was in the field, in use by customers, and the team were not able to rebuild it from source. They were issuing all of their bug fixes as patches on their existing binaries. This was not a good sign.<br /><br />Does this mean that nothing can be done if the team is weak? Not exactly. Some of the time I've had the authority to replace members of the team. I've always had the ability to set an example and suggest practices. But sometimes I've thought that an organization would be unreceptive to calls for change. And for want of courage, projects have been lost.<br /><br />The bottom line is that when I've failed to recognize weakness in the team and/or failed to take immediate and decisive action to bring the team up to world-class strength, I've failed.<br /><blockquote>Argue with idiots, and you become an idiot.<br />If you compete with slaves you become a slave.<br /></blockquote><div style="text-align: right;"><a href="http://www.paulgraham.com/">Paul Graham</a> and Norbert Weiner, respectively<br /></div><br />I've mentioned that I've failed with weak teams. Would you believe I've compounded this failure by failing with weak stakeholders? Whenever I've had stakeholders who didn't have the horsepower or the will to recognize that a project was in trouble, I've wound up in the E.R. having the brick dust removed from my forehead.<br /><blockquote>A chicken and a pig decided to open a diner together. The pig asked the chicken what they should call their new restaurant. The chicken suggested "Ham and Eggs." The pig thought about it for a while, then decided she didn't want any part of the venture. "You," she told the chicken, "would only be interested in serving breakfast. I'd be committed."<br /></blockquote><div style="text-align: right;">as told by <a href="http://www.controlchaos.com/">Ken Schwaber</a><br /></div><br />Getting away from weak teams, another source of failure is the omnipresent threat of "chickens." A chicken is not necessarily a weak individual, but a sign of a weak management structure. A chicken is an individual who has significant authority over your project, but does not make a personal commitment to the success of the project. Significant authority includes the authority to impose constraints on the team.<br /><br />Even a single chicken can take a project out. Chickens are a special case of "external dependencies." Special, because they are often politically entrenched. I've worked with teams where the pay scale was determined by an edict from H.R. They were literally prevented from hiring top talent, and it wasn't a question of budget: they did not have the freedom to replace three mediocre programmers with two good programmers for the same price.<br /><br />Another situation involved a team that were continually pestered to include functionality and architecture for "strategic" reasons by a Business Development person. Although senior management made the importance of the strategic functionality clear, they were unwilling to relax tactical requirements like the ship date or the target revenues. They had to constantly manage the "chicken" in order to succeed.<br /><br />I've managed around chickens here and there, but I've failed to deliver a successful project whenever I've failed to limit the effect of chickens on the management of projects.<br /><br /><strong>Action</strong><br /><blockquote>Always dive down into a problem and get your hands on the deepest issue behind the problem. All other considerations are to dismissed as "engineering details"; they can be sorted out after the basic problem has been solved.<br /></blockquote><div style="text-align: right;"></div> <div style="text-align: right;">Chris Crawford<br /></div><br />The next thing I've learned from my failures is something familiar to the test-driven development crowd. It's mandatory to fail early. You need to know you're in trouble right away. That's essential when taking over an existing project or starting something new. You have to find out how you're doing within weeks. Not quarters, not months. The longer you wait, the more inertia the failure will have.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0884271536/104-5191901-1508708?ie=UTF8&tag=raganwald001-20&linkCode=xm2&creativeASIN=0884271536"><img style="float:left; margin:0 10px 10px 0;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/critical_chain-794734.jpg" border="0" alt="" /></a>You have to come in, take over, and establish some incredibly short-term goals and be prepared to take action based on the project's performance. I've learned that there's no such thing as too little time between milestones. Looking back at projects where I've failed, many contained some uncertainty or risk that I didn't address immediately.<br /><br />In one case there was a critical piece of functionality that was so important the entire architecture was designed around it. The CTO and every developer swore it was the greatest thing since sliced bread. I made a back-of-the-envelope risk calculation and scheduled testing of that functionality to begin three months before the project was to be delivered.<br /><br />A week before the function was to go into test, the technical lead informed me that it didn't work, had never worked, and that no attempt to fix it would work, because there was a major, glaring flaw that had been overlooked. A rewrite would be required.<br /><br />The stakeholders agreed and appointed a new team to handle the rewrite. Needless to say, the old team's job security suffered a major hit.<br /><br />Today, older and wiser, I would demand immediate proof of feasibility of all critical pieces of the product, no matter how obvious things may be to everyone else. I should have said "Great! It's a slam dunk! Wonderful, let's schedule a demo next week." At least we would have felt the pain early.<br /><br /><strong>Details</strong><br /><br />Whenever I've allowed the details of a project to escape me, I've failed. On one project, the technical lead was a Ph.D. and refused to describe his work, saying that although I was the managing product development, he wasn't going to try to explain his rarified code or architecture to a layperson.<br /><blockquote>No, I'm not presponsible for what happened. I'm accountable for how we dealt with it, but I'm not responsible for it.</blockquote><div style="text-align: right;">Julian Fantino<br /></div><br />Needless to say, I was unable to ship a successful project. On another project the CEO would ask me the same question every few days: "draw on my whiteboard who's working on what." I had no trouble with this on that particular project, but looking back there have been projects where I was not tracking people's work on a day to day basis.<br /><br />And I can tell you, whenever the details of a project have slipped from my grasp, the project has started to drift into trouble. I make no apologies for now insisting on knowing exactly who, what, where, when, and why. There's a big difference between being asked to explain your work in detail and being told how to do your job.<br /><br />My personal experience is that attention to detail has always accompanied successful projects.; losing track of the details has always accompanied failing projects.<br /><br /><strong>The Schedule</strong><br /><blockquote>In most companies if a good quality project ships late then the managers will still get it in the neck whereas if poor quality project ships on time then the managers say "we did our best - obviously the dev team seem to be of a poor standard".<br /></blockquote><div style="text-align: right;">Daniel H. Steinberg<br /></div><br />Dates are sacred. I've learned this lesson in good times and bad. Stakeholders treasure good dates. Stakeholders despise bad dates and the people who make flawed promises. That would have been me, more than once.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0130676349/104-5191901-1508708?ie=UTF8&tag=raganwald001-20&linkCode=xm2&creativeASIN=0130676349"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/asdws-735191.jpg" border="0" alt="" /></a>Every time, the lesson has been clear. Don't get the dates wrong. I'll confess: I don't really think Scrum is an order of magnitude more effective than anything else at producing beautiful, world-changing software. It may be worse. But it does produce software every month, month after month.<br /><br />And every time I've delivered software on schedule milestone after milestone, my influence and standing with stakeholders has grown. And every time I've missed a date, I've suffered, regardless of whether the late software was demonstrably better than what was originally planned for the missed date.<br /><blockquote>If documents don't serve to avoid stupid things, mitigate risks or calculate budgets then what are they for? They're to show you have a "process" and a "paper trail" so that you can get ISO certified. That's all they look for, they don't care if you read them or not.</blockquote><div style="text-align: right;">Skagg on   <a href="http://discuss.fogcreek.com/joelonsoftware/">http://discuss.fogcreek.com/joelonsoftware/</a></div><br />Back to the measurable processes. I've learned from failure that stakeholders like to know what's going on. I hate producing useless documentation. The net result is that I've tried to find the happy medium where I generate weekly management reports on projects.<br /><br />A management report is something that is used to actually make a decision. Everything else is garbage. I've learned that when I haven't had management reports for a project, failure has resulted. Worse, sometimes I've had documents and metrics that were used to justify bad decisions that sank the ship.<br /><br />So my lesson from these failures is that every project needs a set of regular reports that contain information you'll actually use to make decisions.<br /><br /><strong>Software</strong><br /><blockquote>Few projects are cancelled because their designs and implementation weren't complicated enough. Many are cancelled because they become so complicated that no one can understand them anymore; any attempt to change or extend the system results in so many unintended side effects that continuing to extend the system becomes practically impossible.<br /></blockquote><div style="text-align: right;">Steve McConnell<br /></div><br />One of the reasons people associate me with "Agile" development approaches is that I'm always trying to simplify, simplify, simplify. This is because almost every time I added something to a milestone, I've gotten burned. It seems like it's always better to say "just finish what we planned, get that 100% functional, and then we'll add foobars."<br /><br />I recently got burned twice in the same project adding functionality in between milestones. Both times I was sure that the changes were low risk. Both times I burned myself. Now I'm licking my wounds and swearing I'll never, ever break my agile principles of restricting scope changes to between increments. <blockquote>It's important to remember that when you start from scratch there is absolutely no reason to believe that you are going to do a better job than you did the first time. First of all, you probably don't even have the same programming team that worked on version one, so you don't actually have "more experience". You're just going to make most of the old mistakes again, and introduce some new problems that weren't in the original version.<br /></blockquote><div style="text-align: right;"><a href="http://www.joelonsoftware.com/articles/fog0000000069.html">Things You Should Never Do, Part I</a><br /></div><br />Here's something that I've screwed up repeatedly. Sometimes I've bounced back, sometimes the project has paid the ultimate price. The grand "this time we'll get it right" mantra is absolute garbage.<br /><blockquote>It had taken 3 years of tuning to get code that could read the 60 different types of FTP servers, those 5000 lines of code may have looked ugly, but at least they worked.</blockquote><div style="text-align: right;">Lou Montulli, one of the founding engineers at Netscape<br /></div><br />Don't talk to me about porting to Java, or new design patterns. If you must refactor, refactor here, and there, and there to solve this, and that, and the other specific problem that has a specific feature or bug attached to it. And show me that you had 100% unit testing coverage on the affected code and completed each refactoring in a day or so and then ran all the unit tests and got a green light.<br /><br />If you can't do that, you're going to fail. I know it, because I've failed when I didn't do that. And when I cried on a friend's shoulder, he told me "I also made that mistake once, and I suffered the same horrible fate."<br /><br />Thinking that a major rewrite is going to solve all of your problems is just revisiting my four things that matter most and planning on having one, the fitness of the proposed solution, overpower defects in the people, expected value, and process. It won't happen.<br /><br />A major rewrite should produce a major new product that offers an order of magnitude more expected value. And you'll need to be 100% sure your team has the horsepower to get the job done and is going to use a process that can handle the load. I say this because I've tried and failed to rewrite entire applications, and I've taken over other people's rewrite projects and failed there too.<br /><br /><strong>Power</strong><br /><blockquote>Some days you are the bug, some days you are the windshield.</blockquote>I've learned a little about politics from failing. What I've learned is that if you stick your neck out and evangelize change, you will be blamed if you do not achieve results. You may or may not care about that. But be aware of the fact that making changes involves spending your personal credibility. If you don't want to lose it, don't ante up: get out of the project.<br /><blockquote>Don't have good ideas if you aren't willing to be responsible for them.<br /></blockquote><div style="text-align: right;">Alan Perlis<br /></div><br />And if you decide to make changes, have the courage to go 100% with your gut. I've failed more than once when I watered down my convictions in order to appease dissenters. The only thing worse than evangelizing change and failing is looking back and realized you might have succeeded if you'd held firm on your convictions. What a waste!<br /><blockquote>Making an employee work and profiting from that work are two different things.<br /></blockquote><div style="text-align: right;">Eliyahu Goldratt<br /></div><br />I've seen a number of "sweat shops," and I've worked in several places where long hours and rhinoplastic intimacy with the grind stone were demanded of the team. I can honestly say that hard work makes no long-term difference to failing software development teams.<br /><br />I disagree with those who say that long hours are 100% detrimental to software development: I''ve seen lots of situations where people worked around the clock, motivated by passion. But those were successful projects.<br /><br />I've learned that redoubling effort when a project is in trouble has not fixed the project. The conclusion I draw is that although teams have worked long hours on many successful projects, there is no causal relationship between long hours and success (It's another example of the fallacy of "best practices": copying a single element of a successful project does not guarantee that another project will be improved).<br /><br />My experience with failing projects is that the exhortation "<a href="http://www.imdb.com/title/tt0151804/quotes">Ahh, I'm going to have to go ahead and ask you to come in on Sunday, too...</a>" has always been interpreted as punishment, not a meaningful way to fix the project. It has had no effect on under-performing members of the team and tends to strongly demotivate the people who are pulling more than their fair share of the weight.<br /><blockquote>It is impossible to sharpen a pencil with a blunt axe. It is equally vain to try to do it with ten blunt axes instead.      </blockquote><div style="text-align: right;">Edsger Dijkstra<br /></div><br />Good luck convincing stakeholders of this. One of the reasons people love to hand out overtime like candy is that hours in the office are measurable. The team's behind? Make them stay until midnight every night. Even if it doesn't work, the executive handing out this order can be sure she can measure compliance.<br /><br />The bottom line is, it's easy to measure how many axes you're using to sharpen a pencil. When you discover that a blunt axe isn't sharpening the pencil, how do you propose to measure "sharpness"? How do you measure "working smarter"?<blockquote>If we wish to count lines of code, we should not regard them as lines produced but as lines spent.<br /></blockquote><div style="text-align: right;">Edsger Dijkstra<br /></div><br />So another thing I've learned about failure is that when things start to go wrong, stakeholders want two things:<br /><ol>   <li>New processes<br /></li>   <li>A way to measure compliance with the new processes</li> </ol> Overtime meets both criteria nicely, as do other simple panaceas like generating reports with every build or compliance with coding standards.<br /><br />Fixing failing projects demands lots of things that are easy to measure and some that aren't. I've learned that if you don't control your stakeholder's expectations around change, you'll find yourself fending off demands for things like overtime and reports.<br /><br /><strong>History</strong><br /><blockquote>Even when my proposals are seen as significant improvements, they are often rejected on the grounds that they are not intuitive. It is a classic Catch-22: The client wants something that is significantly superior to the competition. But if it is to be superior, it must be different. (Typically, the greater the improvement, the greater the difference.) Therefore, it cannot be intuitive, that is, familiar. What the client wants is an interface with at most marginal differences from current practice... that, somehow, makes a major improvement.<br /></blockquote><div style="text-align: right;">Jef Raskin<br /></div><br />When I've been brought in specifically to "work out" a failing project I've failed when I didn't have the authority and support to make major changes. This is saying the same thing I've said several times already, but it needs to be repeated.<br /><br />Often, the stakeholders have just finished casting someone into the darkness and think that they've cast failure into the darkness with him. Take a moment and look up the definition of the word "<a href="http://dictionary.reference.com/search?q=scapegoat&r=67">scapegoat</a>." They may have symbolically cleansed the project of sin, but the sins remain, and I have inherited them whenever I've allowed the project to continue to do business as usual.<br /><blockquote>The most damaging phrase in the language is, <em>It's always been done that way.</em><br /></blockquote><div style="text-align: right;">Rear Admiral Grace Hopper<br /></div><br />I've heard dozens of variations on the same line (yes, I've failed dozens of times!) The line is "Well, so-and-so failed because he didn't x. But now you're here, you'll get x cleaned up, and we'll start succeeding right away. We were hardly failing, really, a little behind, nothing serious."<br /><br />Every time I've been told that, things have ended up being seriously dire. No, it wasn't as simple as implementing monthly sprints or formalizing acceptance tests or nightly builds. The rot went right to the core and the stakeholders were usually (unwittingly) enabling it by not understanding or being in denial of the real problems. When people don't see the depth of the problem, they don't accept the importance of making changes.<br /><br />It has boiled down to something so simple that you've probably heard it described in jest as the definition of insanity. If a project has been doing things a certain way, and the stakeholders are not 100% happy with the results, doing things substantially the same way will not produce substantial changes in the results.<br /><br /><strong>Finishing</strong><br /><blockquote>There are two kinds of people in the world: those who finish what they started.</blockquote> Getting back to failing early, I've learned it's important to completely fail. Get fired. Shoot the project, then burn its corpse. Melt the CVS repository and microwave the backup CDs. When things go wrong, I've often tried to play the hero from start to finish. Guess what? Some projects are doomed no matter what. Some need skills I don't possess. And some need a fresh face.<br /><blockquote>The best way to fix a bad project is to not be part of it.<br /></blockquote><div style="text-align: right;">Norman Nunley & Michael Schwern<br /></div><br />I've ridden more than one project down in flames, and as painful as it is to 'fess up and admit defeat, it's important to know when to fold your cards and quit. Yes, that sounds defeatist. But most success stories are comebacks from personal failures, not wondrous turn-arounds.<br /><br />Sometimes you shouldn't finish what you started. Sometimes you shouldn't finish what somebody else started.<br /><br />Every essay ought to end with a summary. Since this isn't an essay, I'll end with an adaptation of a Taoist story:<br /><blockquote>A musician performed a new piece he had written for his best friend. The friend sat in wonder and listened to the entire piece. When it was over, he nodded and told the musician that the music was wonderful. But what, he wondered, did the piece mean?<br /><br />The musician nodded at this question and bent over his instrument, then played the entire piece again from the beginning.</blockquote><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/passion.html">passion</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html" title="permanent link">7:33 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, September 20, 2004</div>
			

			<div class="Post"><a name="109571336219525721">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/09/goal-of-qa-is-to-provide-ongoing.html" title="permanent link">The goal of QA is to provide an ongoing induction of reality</a></span>
					<div style="clear:both;"></div><a href="http://www.mccarthy-tech.com/">Jim McCarthy</a> on QA:
<br /><blockquote>"If QA feels its charter is to test the product that Development has created--or Development is convinced that its job is to create a product that QA then tests--some alarm bells should go off...
<br />
<br />"QA's principal function--and it is a principal function--is to continually assess the state of the product so that the rest of the team's activities can be properly focused.
<br />
<br />"QA's ongoing assessment is integral to the act of software creation, not an <span style="font-style: italic;">ex post facto</span> event. Naturally, a good deal of testing and analysis is required to properly gauge status, but the goal of QA is to support the product development process by providing an ongoing induction of reality."</blockquote>
<br /><div style="text-align: right;">--from <a href="http://www.mccarthy-tech.com/store.asp">Dynamics of Software Development</a>
<br /></div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/09/goal-of-qa-is-to-provide-ongoing.html" title="permanent link">4:29 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, September 06, 2004</div>
			

			<div class="Post"><a name="109447868879430882">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/09/how-to-reduce-testing-time.html" title="permanent link">How to reduce testing time</a></span>
					<div style="clear:both;"></div>From <a href="http://www.jrothman.com/weblog/archive/2004_09_01_mpdarchive.html#109422365549707790#109422365549707790">How Long Should the Testing Take?</a>:<br /><blockquote><em>Here's what I have noticed from my work with multiple organizations. The groups who want to decrease testing time tend to perform the least proactive work reducing the overall number of defects...<br /><br />"If you want to reduce testing time, create a low-defect product, test all the way through with a variety of test techniques, and use iterations, so you know at the end of 2-4 weeks where you stand with defects. The lower the number of defects and the more sophisticated your tests, the faster your testing time will be.</em></blockquote>Also:<br /><ul><li><a class="article" href="http://www.mountaingoatsoftware.com/articles/AMeasuredResponse.pdf">A Measured Response: Useful Metrics to Give Managers Numbers to Back Up Project Hunches </a></li><li><a href="http://www.io.com/%7Ewazmo/papers/testers_and_developers.pdf">Testers and Developers Think Differently</a></li><li><a onmousedown="return clk(this,'res',9)" href="http://www.agiledata.org/essays/tdd.html">Test Driven Development</a></li></ul><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/09/how-to-reduce-testing-time.html" title="permanent link">9:51 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, August 30, 2004</div>
			

			<div class="Post"><a name="109172123943436354">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/08/do-programmers-create-intellectual.html" title="permanent link">Do programmers create intellectual property or merely transform it?</a></span>
					<div style="clear:both;"></div>The late mathematician Paul Erdös described a mathematician as "a machine for turning coffee into theorems" (Hoffman, P. <em>The Man Who Loved Only Numbers: The Story of Paul Erdos and the Search for Mathematical Truth</em>. New York: Hyperion, 1998, p. 7)
<br />
<br />Once I stopped chuckling at the thought of programmers turning coffee into code, I was siezed by a question: <strong>do programmers create intellectual property or merely transform it?</strong> There is a marked difference between creating IP ("the creational model") and transforming IP ("the transformational model").
<br />
<br />I'm going to hand wave over whether producing software is like making things in a factory. Let's grant that it may be: that doesn't affect whether programmers create or transform IP: if producing software is like a factory, we are now arguing about whether programmers produce the <em>raw materials</em> or simply <em>work the machines</em>.
<br />
<br />In this model, there is IP that comes into the factory (perhaps in the form of "requirements" or "design patterns"), it is transformed into bits by some process, and the result is a software product of some value to consumers (by consumers I mean the users, stakeholders, and "product owners", not consumers in the broad market sense).
<br />
<br />If programmers create IP, their ideas, designs, and problem solutions are part of the raw materials of the eventual product. If the quality of their ideas is poor, no wonderful practices or processes will save the finished work: poor programmers necessarily produce finished work of low value to its consumers (be they customers or stakeholders).
<br />
<br />On the other hand, if programmers merely work the process, transforming IP, then the value of the finished work can be highly insulated from the quality of the programmers, just as minimum wage employees can be a part of a rigidly controlled production process. Poor programmers can produce finished work of acceptable or even high value to its consumers, provided the right process and tools are in place.
<br />
<br />I've just talked about the effect of poor programmers in the factory. What about good or even great programmers? What about the mythical hacker? What happens when you use great programmers?
<br />
<br />If programmers create IP, then great programmers produce great products. Of course, it is possible to screw this up with incredibly poor process (imagine a factory that collapses on its workforce), but having great programmers drives the value of the finished product on a polynomial or even exponential basis.
<br />
<br />On the other hand if programmers merely transform IP, then great programmers will have very little effect on the value of the finished product. While they might finish work a little sooner with fewer defects, these benefits will not translate into higher value for consumers. Their efforts are somehow wasted.
<br />
<br />I hear arguments for both models. I see this type of thinking reveal itself in the attitudes recruiters have when offering me candidates: "She has 5 years of C++ and three years of Unix, she has the experience you need."
<br />
<br />The implication is that programming is a job with specific tasks and rote methods to be applied, like assembling parts in a factory. Requirements come dribbling down the conveyor belt, you apply the text editor and compiler tools, and the conveyor belt takes your work down the line to QA.
<br />
<br />There are voices expressing dissent with the transformational model. One <a href="http://dictionary.reference.com/search?r=10&amp;q=vociferous">vociferous</a> example is <a href="http://www.joelonsoftware.com/">Joel Spolsky</a>. Although he insists that API experience is necessary, he also insists that programmers be <a href="http://www.joelonsoftware.com/articles/fog0000000073.html"><em>smart</em> and <em>get things done</em></a>.
<br />
<br />If I look at companies where programmers work, I see some places where the quality of the programmers (and their management) make vast differences in the value of the product they create. I also see others where the quality of the programmers makes little or no difference.
<br />
<br />For example, start-ups need the best people they can find. Forget time to market, you have time to the next round of funding to deal with. People that get it, that can write robust software with high quality in impossibly little time can make or break a start-up, especially in this time when money doesn't rain from the skies.
<br />
<br />On the other hand, some ISVs have relatively mature products with modest growth plans. I've heard at least one such company owner saying he'd rather have modestly skilled people with little appetite for solving hard problems. I suspect he's built his business in such a way that adding great people won't double or treble the value of his product.
<br />
<br />And if you look at a business that isn't even in the software business, the outlook is dismal for programmers: do you realy think that delivering a big bank's application in half the time really makes a difference? Before you say "every bank wants to save $500,000 on their next big project," ask yourself why so many of them hire IBM Global Services. Not to save money.
<br />
<br />Maybe it's because the real value of the project as measured by the people who fund it is measured in political points. And programmers don't generate politicial points, so they can't add value to the stakeholders.
<br />
<br />So in the end I think that <strong>there's a continuum between programmers who create IP and programmers who transform IP</strong>. The difference is driven by characteristics of the environment. Specifically, it isn't "politics" or "culture" at the end of the day. It's the potential for the finished software to add value.
<br />
<br />What does this mean if you're a software developer? If you really believe you are great, you must search for an environment where you have the greatest leverage. That's where you're going to make the greatest contribution.
<br />
<br />Here are some key questions that have worked well for me in the past when evaluating opportunities to add value:
<br /><ul><li>Can you quantify the difference between failure, acceptable, and great performance of the project to the company? (Not yourself personally: if the project is high risk, high value, you'll have a great opportunity no matter what role you take)</li><li>Who are the stakeholders in this project (who has the athority to make major decisions)?</li><li>What is the impact of a project failure to the accountabilities of the stakeholders? (You won't get a straight "they'll be fired" answer in a job interview, but you can certainly get a feel for whether they care one way or another.)</li></ul><p>The first question establishes whether there is in fact a wide range in expected outcomes of the project. If there is very little range between acceptable and great performance, then you are dealing with people who believe (rightly or wrongly) that programmers trasnform IP and that there is no opportunity to add value other than keeping your seat warm and following orders.</p><p>The second and third questions establish whether the factory's roof will stay on. The primary impediment to providing value in an otherwise promising environment in meddling from people who are not committed to the success of the project. And the main reason for a lack of commitment is having the authority to direct the project without being held accountable for the result.</p><p>Again, I believe that some factories provide an opportunity for great programmers to create IP, but some do not. And although I've cut myself short, I believe that it is possible to determine whether an environment will allow great programmers to create IP through judicious examination.</p>
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/08/do-programmers-create-intellectual.html" title="permanent link">8:31 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, August 24, 2004</div>
			

			<div class="Post"><a name="109335163109276661">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/08/quiz-answers-plus-instilling.html" title="permanent link">Quiz Answers, plus "Instilling Responsibility"</a></span>
					<div style="clear:both;"></div>In <a href="http://www.braithwaite-lee.com/weblog/2004/08/surprize-quiz.html">Surprise Quiz!</a>, I asked:
<br /><blockquote>You have just been promoted to head of an important department in your organization. The previous head has been transferred to an equivalent position in a less important department. Your understanding of the reason for the move is that the performance of the department as a whole has been mediocre. There have not been any glaring deficiencies, just a perception of the department as so-so rather than very good. Your charge is to shape up the department. Results are expected quickly. Rate the quality of the following strategies for succeeding at your new position.</blockquote><ol><li>Always delegate to the most junior person who can be trusted with the task.</li><li>Give your superiors frequent progress reports.</li><li>Announce a major reorganization of the department that includes getting rid of whomever you believe to be "dead wood."</li><li>Concentrate more on your people than on the tasks to be done.</li><li>Make people feel completely responsible for their work.</li></ol>
<br />In <a href="http://www.gladwell.com/2002/2002_07_22_a_talent.htm">The Talent Myth</a>, Malcolm Gladwell reported "how well people do on a test like this predicts how well they will do in the workplace: good managers pick (2) and (5); bad managers tend to pick (3)".
<br />
<br />What I find interesting about this snippet is the relationship between the answers and Agile values: Frequent reporting and personal responsibility are key elements of Scrum, for example. I may be stretching here, but in my experience, one of the most valuable benefits of incremental delivery is the responsibility ethos it creates.
<br />
<br />Yes, I know that I wrote an article where <a href="http://www.braithwaite-lee.com/weblog/2004/07/requirements-changes-and-acceptance.html">I described the benefit of incremental deliver in risk management terms</a>. However, explaining things in dry terms "sells" better than explaining the effect on people, especially to management types. (Managers are often the least people-oriented people in the company.)
<br />
<br />Back to incremental development. When a developer has a task, and you explain that they are on the critical path, and you show them a GANTT chart the size of the conference room wall, they're going to shrug their shoulders. Likewise, if you show them a huge baroque architecture and explain their component's place, they're again going to shrug their shoulders.
<br />
<br />The twin problems facing us are that any task in a long, architecturally complex project suffers from a lack of urgency and a lack of importance, because over the remaining time in the project lots of things can change.
<br />
<br />There's so much uncertainty in any project more than a month long that there's absolutely no way to instill a sense of urgency until about four weeks away from a milestone. And likewise there's absolutely no importance attached to any task until people can see that deliverable functions are going to break if the task isn't completed.
<br />
<br />When you have milestones a month or so apart, there's a constant sense of urgency around the dates. Now what about responsibility? Well, if a developer's work is due by the milestone but it's hidden away in some dusty recess of the framework, there's urgency but no importance.
<br />
<br />To instill responsibility, you need urgency AND importance. You add the importance by tying the work as closely as possible to functionality in the finished software. When a developer can see that her work must be done in the next four weeks otherwise some function that stakeholders/users/customers want will break, she's motivated. She can take responsibility.
<br />
<br />Thus, incremental development. When you identify increments of the finished product to be delivered on a monthly basis, you are making urgency and importance plain and visible. And oh yeas, that buys you "frequent reporting."
<br />
<br />Maybe Agile is, at the end of the day, just good management practice.
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/08/quiz-answers-plus-instilling.html" title="permanent link">8:38 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, August 23, 2004</div>
			

			<div class="Post"><a name="109326512802409931">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/08/surprize-quiz.html" title="permanent link">Surprize Quiz!</a></span>
					<div style="clear:both;"></div>Try to answer this question honestly, without trying to "reverse engineer" the correct answer. This isn't a job interview, so you gain the most if you answer correctly and learn something about yourself:
<br /><blockquote>You have just been promoted to head of an important department in your organization. The previous head has been transferred to an equivalent position in a less important department. Your understanding of the reason for the move is that the performance of the department as a whole has been mediocre. There have not been any glaring deficiencies, just a perception of the department as so-so rather than very good. Your charge is to shape up the department. Results are expected quickly. Rate the quality of the following strategies for succeeding at your new position.
<br /></blockquote><ol><li>Always delegate to the most junior person who can be trusted with the task. <em>This gives juniors an opportunity to learn and develop, raising the overall competence of the group.</em></li><li>Give your superiors frequent progress reports. <em>This makes your star shine brightly, obtaining support from stakeholders. More importantly, frequent reports are opportunities for frequent feedback, keeping the group's direction in harmony with the organization's goals.</em></li><li>Announce a major reorganization of the department that includes getting rid of whomever you believe to be "dead wood." <em>Letting go of "C" players is harsh, but it's just as important as hiring people who are "smart" and "get things done." The team is only as strong as the weakest link.</em></li><li>Concentrate more on your people than on the tasks to be done. <em>Process, process, process. Experienced people know how to do their jobs, but the performance of the group depends on motivating the team and process improvements.</em></li><li>Make people feel completely responsible for their work. <em>If no-one is accountable for results, there's no accounting for the results you'll obtain :-)</em></li></ol>This question was crafted by Richard Wagner, a psychologist at Florida State University (I have added the italicized points to the strategies). I found the question in <a href="http://www.gladwell.com/2002/2002_07_22_a_talent.htm">The Talent Myth</a>, an excellent article by Malcolm Gladwell (author of <em>The Tipping Point</em>) on the relationship between talent and job performance.
<br />
<br /><span style="font-style: italic;">Gladwell's explanation of the results, plus a comparison to my experience with Agile practices, can be found in</span> <a href="http://www.braithwaite-lee.com/weblog/2004/08/quiz-answers-plus-instilling.html">Quiz Answers, plus "Instilling Responsibility"</a>.
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/08/surprize-quiz.html" title="permanent link">8:29 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, August 19, 2004</div>
			

			<div class="Post"><a name="109296957739160916">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/08/agile-is-attitude-not-product.html" title="permanent link">Agile is an attitude, not a product</a></span>
					<div style="clear:both;"></div><p>Ken Schwaber, creator of the <a href="http://www.controlchaos.com/">Scrum</a> product development methodology (I reproduce his remarks with permission):</p><blockquote><p>"At XP/AU 2004, I kept hearing the question of how to "sell Agile to the executives." I also heard a lot of discussion about "crossing the chasm," the book about the evolution of products from early adoption to mainstream to late adoption. I got a chance to talk about this with several other people (whose names I will only disclose under duress), and I had the following insight: Agile is not a product. Because it isn't a product, we shouldn't be thinking about selling it, we shouldn't be thinking about it crossing a chasm.</p><p>"Thinking of Agile as a product is particularly damaging because it will cause Agile to have the same failure that CMM had when it was viewed as a saleable commodity, as a product. People believed that they could market it and make money from it. </p><p>"People who bought it thought that they could then install it, train people on it, and then they would be better. Bob Schatz from <a href="http://www.primavera.com/">Primavera</a> has often pointed out that bringing Agile in is the start of an extensive change process. Deciding on Agile is a commitment to an effort, not the purchase of a solution. I've been concerned for a while about organizations having some success with Agile and deciding to go "Agile" whole hog.</p><p>"Their comments reflect a belief that Agile is something that can be implemented, solving a problem, and then they can move on. More to the truth, Agile is a commitment to collaboration, empowerment, respecting each other, courage, flexibility, facing the truth, and trust. It is about people, not products and solutions. I think people who think they can buy an "Agile" product are going to be in for a rude shock.</p><p>"I believe that Agile is part of a social revolution to help people learn together to collaboratively figure out how to work and live in an increasingly complex world. Agile is an attitude, not a product. Agile is spirituality, not a religion. We don't have to sell it as a product. We don't have to evangelize it. We simply (and with difficulty) have to live it. People will observe us and envy our joy at work, and quake in fear and be defeated by our productivity. For the old way of doing things doesn't cut it anymore. The Agile way is the appropriate response to our complex times.</p><p>"So, be wary, Our culture thinks of everything as a saleable product. It is the metaphor of our consumer society. We will fall back into thinking of Agile as a product over and over, and it will confuse our thinking. Whenever this happens to your neighbor, help them out.</p></blockquote><p>Note that Primavera develop software for managing projects and portfolios in the Classical, Analytical model. And yes, they use Scrum to develop their Classical project management software, because they understand that building software is not like building bridges.</p><p><em>Deb Hartmann pointed out that Ken's remarks have sparked a lively thread on the Scrum Development mailing list. You can read more on line </em><a href="http://groups.yahoo.com/group/scrumdevelopment/message/4124"><em>here</em></a><em>. Warning: Intrusive Flash advertising.</em></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/08/agile-is-attitude-not-product.html" title="permanent link">10:37 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, August 06, 2004</div>
			

			<div class="Post"><a name="109179511648447440">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/08/how-to-guarantee-product-failure.html" title="permanent link">How to guarantee product failure</a></span>
					<div style="clear:both;"></div><a href="http://www.cauvin-inc.com/articles/ProductFailure.htm">How to guarantee product failure</a> from <a href="http://www.cauvin-inc.com/">Roger Cauvin</a> lists five fatal mistakes product managers make when writing requirements. It's a fast read, and well worth the time.
<br />
<br />The article hit home with me: I'm reviewing our development process right now. Although we do a good job of writing requirements, many of the roadblocks to shipping on time stem from the fact that we then immediately write a specification and the rest of our process is driven by the specification instead of the functional and non-functional requirements.
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/08/how-to-guarantee-product-failure.html" title="permanent link">8:25 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, July 30, 2004</div>
			

			<div class="Post"><a name="109008359785826210">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/how-to-use-acceptance-tests-to-ship.html" title="permanent link">How to Use Acceptance Tests to Ship Software</a></span>
					<div style="clear:both;"></div>Validation tests are tests that measure some aspect of an implementation's behaviour against an expectation and answer whether the software complies with the expectation. For example, a test that measures the time required to perform a specific task is not a validation test. A test that measures the time required to perform a specific task and compares it to a benchmark is a validation test.
<br />
<br />One very strong benefit of using validation tests is that creating the tests forces the development team to achieve detailed and objective designs. This extends beyond the coding team to include program and product management: <span style="FONT-WEIGHT: bold">writing tests that validate compliance with requirements force product management to articulate detailed and objective requirements</span>.
<br />
<br />Thinking the requirements through in detail is more valuable than thinking the design through in detail: if the design is not solid, you will end up with a poor solution to a good problem. This can be refactored. If the requirement are not well understood, you will end up with a solution to the wrong problem: this is more difficult to change.
<br />
<br />The two most important types of validation tests are:
<br /></span><ul><li>Acceptance tests, which validate an implementation's compliance with requirements. </li><li>Unit tests, which validate an implementation's compliance with a design. </li></span></ul><span style="FONT-WEIGHT: bold">Acceptance Tests
<br />
<br /></span>Acceptance tests validate an implementation's compliance with requirements. One style of development is to write detailed requirements and then translate the requirements into acceptance tests. When the requirements are sufficiently detailed, the acceptance tests flow freely from the requirements and the role of the team is to validate that the acceptance tests properly express the requirements.
<br />
<br />A lightweight approach is to write less detailed requirements and to consider the acceptance tests as an extension of the requirements document. This works well in smaller organizations. When using the lightweight approach, it is important that customer or market facing contributors retain 'ownership' of the expression of requirements. A protocol I have seen work very well is for a program manager to write requirements, and then the program manager negotiates acceptance tests with the programming team.
<br />
<br />The program manager <em>owns</em> the definition of the acceptance tests, and the programming team <em>validates</em> the tests, raising red flags if they have concerns or cannot 'connect the dots' between the requirements and the acceptance tests. For example, a programmer is allowed to reject any acceptance test that validates an implementation rather than a requirement. This is quite properly the province of unit tests and not an issue for the program manager to determine.
<br />
<br />Let's review this last point. Consider a high-level Market Requirements Document ("MRD"). What does it mean to "flesh out the MRD with more detail" or to "drill down into one of the requirements"? Well, it doesn't mean "write specs for a solution." That's a common pitfall: when asked for more detail, product managers get sucked into designing software.
<br />
<br />More detail for an MRD should mean "describe the problem to be solved in more detail." The most useful detail possible is a complete list of acceptance tests.
<br />
<br />Writing an acceptance test is easy: write a sentence that begins: "the software is acceptable when..." Now all you have to do is make sure that your acceptance test is implementation-free, just like any good requirement. This test is now a detailed expansion of some requirement. Write as many acceptance tests as you can.
<br />
<br />For incredible leverage, automate your acceptance tests using tools like <a href="http://fitnesse.org/FitNesse.WhatIsFitNesse">Fitnesse</a>.
<br />
<br /><span style="FONT-WEIGHT: bold">Unit Tests </span>
<br />
<br />Unit tests validate an implementation's compliance with a design. Since requirements are implementation-free, there should be no coupling between the definition of unit tests and the definition of acceptance tests.
<br />
<br />Unit tests express one and only one fact, which they express in the abstract: code that is written with well chosen and sufficient unit tests can be considered of good quality and likely to be delivered on time with high confidence. Customer or market facing contributors such as program managers have an abstract interest in unit tests for this reason.
<br />
<br /><span style="FONT-WEIGHT: bold">Why Unit Test are not Acceptance Tests</span>
<br />
<br />Unit tests should not be confused with acceptance tests, for the same reasons that
<br /></span><ul><li>the design should not be confused with the requirements</li><li>the project plan should not be confused with the release plan, and,</li><li>technical management should not be confused with product management</li></span></ul>A design is one possible solution to the problem of "writing software that complies with the requirements." A project plan is one possible solution to the problem of "implementing a design using the available resources in compliance with the release plan." Technical management is the art of finding and implementing these solutions.
<br />
<br />Unit tests should not be confused with acceptance tests because they do not express some requirement of the release plan: it is possible to completely refactor the design and the project plan, rewriting every single unit test, without changing any of the acceptance tests. But changes to acceptance tests reflect changes to the product contract: they are an element of the Plan of Record.
<br />
<br /><span style="FONT-WEIGHT: bold">Bugs and Defects</span>
<br />
<br />When a release (internal or external) is tested, bugs are inevitable. A bug report expresses a kind of validation test in the negative: "the software ought to... But instead it..." A good bug report explains how to reproduce the problem: "Install the software on a dual Triton system with less an 4GB of RAM, then boot it in greedy mode..."
<br />
<br />This is a validation test. Ideally, this test was already expressed as an acceptance or unit test. In practice, a bug report often expresses an implicit test, one that wasn't spelled out as part of the process. This is not a bad thing: tests evolve as the team's understanding evolves.
<br />
<br />It's important to distinguish bugs that reflect shortcomings in acceptance from bugs that reflect shortcomings in design. If you look at a bug and it reflects some fundamental aspect of the requirements of the software, you need to treat it with considerably more care than a bug that reflects some shortcoming in design.
<br />
<br />I call such bugs "defects." A defect must absolutely, positively be remedied, because if the software does not conform to the acceptance criteria, it is not "done."
<br />
<br />For example, you may have a requirement that some aspect of the UI conform to generally accepted principles. Say there's a menu option that displays a shortcut key, but the key doesn't work. That bug is interesting. You can write a unit test for this bug: "pressing control J should invoke the Jump command."
<br />
<br />But that isn't an acceptance test. An acceptance test would be "for every menu item that displays a shortcut key, the shortcut key should invoke the command." Why the generalization? Because one way to fix the broken control J would be to not display the shortcut key in the menu. The software would still conform to the acceptance test, but it would fail the unit test.
<br />
<br />Bug reports are an excellent source of acceptance criteria, however product management and development need to analyze the tests to decide which bugs are defects and to extract acceptance criteria, just as requirements need to be analyzed to remove implementation, design, and specifications.
<br />
<br />I'll end with one anti-pattern: if you don't distinguish bugs that reflect acceptance shortfalls from bugs that reflect implementation shortfalls, you paint yourself into a corner where you cannot manage the bug list: all you can do is try to fix as much as you can and hope for the best.
<br />
<br />If you separate the defects out and give them their own special place in your process, you are now (a) learning more about the detailed requirements of your software, and (b) you have a smaller list of defects that must absolutely, positively be fixed. Prioritizing defects over bugs is one excellent way to raise your chances of shipping acceptable software on time.
<br /></span>
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/how-to-use-acceptance-tests-to-ship.html" title="permanent link">9:50 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, July 26, 2004</div>
			

			<div class="Post"><a name="109086199736458365">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/selling-agile-difference-between-sales.html" title="permanent link">Selling Agile: The Difference Between Sales and Marketing </a></span>
					<div style="clear:both;"></div>There's an interesting Yahoo! Group centered around "selling" agile: convincing stakeholders and developers to adopt Agile Methods to improve their software development. 
<br />
<br /><a href="http://finance.groups.yahoo.com/group/SellingAgile/">http://finance.groups.yahoo.com/group/SellingAgile/</a> 
<br />
<br />I spent a few years as a salesman, with decent results. I recall one thing from my sales career that seems quite relevant to the 'problem' of selling organizations on changing their development culture: 
<br />
<br /><strong>Know the difference between Sales and Marketing</strong> 
<br />
<br />Sales is persuading a prospect that now is the time to act and that you are the best choice. Everything else is marketing. 
<br />
<br />What's the difference? Fundamentally, marketing lowers the cost of getting your message to prospects by&nbsp;publishing a fairly generic message in bulk. Sales increases the effectiveness by arranging for a sales person to engage a prospect interactively. 
<br />
<br />Effective sales companies use lower-cost marketing to educate customers about their products or services so that customers understand whether or not they have a problem and at the very least know that the company should be on the short list for choosing a solution when the customer is ready to act. 
<br />
<br />Then, effective sales companies use medium-cost prospecting (like direct mail and tele-sales) to locate customers that may make a decision in the near future. Those 'leads' are turned over to salespeople for closing. 
<br />
<br />The high-cost sales-people then have just two jobs: urge the customer to act now and urge the customer to buy from the company. If the customer needs to be convinced that there is a problem worth solving, the salesperson shouldn't be talking to the customer. 
<br />
<br />That's why salespeople spend so much time <strong>qualifying</strong>. Talk to a top salesperson. They'll tell you that there are only two skills that pay the mortgage: qualifying and closing. Everything else is secondary. 
<br />
<br />Why do we Agilists care? Because most companies don't think they have problem. Or if they think they have a problem, they think they have a personnel problem, or an estimation problem, or a discipline problem. They don't think their methodology is fundamentally broken. 
<br />
<br />By my reckoning, this is a marketing problem, not a sales problem. If you talk to these companies about Agile, you need to get them to understand that their process is broken. That's an expensive conversation. It's far, far better to market Agile to those companies. That means write books, publish weblogs, speak at seminars... All low-ish cost ways of getting the message out. 
<br />
<br />There's one big problem with this. Some Agilists take full-time jobs with non-Agile organizations and want to "sell" internally. That's a problem, because they have failed to perform the crucial first step in Sales: they failed to qualify the customer. If you want to practice Agile, you need to restrict your job search to companies that practice Agile, or at the very least companies that are hiring you because what they're currently doing doesn't work. 
<br />
<br />If your boss thinks that what you're currently doing is "not bad" or "good enough," then there's no sale to be made. You need to market, not sell. And that's a long, drawn-out proposition.
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/selling-agile-difference-between-sales.html" title="permanent link">12:54 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, July 20, 2004</div>
			

			<div class="Post"><a name="109035046343688026">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/requirements-changes-and-acceptance.html" title="permanent link">Requirements Changes and Acceptance Debt</a></span>
					<div style="clear:both;"></div><p>Andre asked:</p><blockquote><p>Part of agile is the idea of not complaining when the spec changes -just go ahead and make the change - even if it means rewriting a large part of the project because the software wasn't originally designed to accommodate the new requested functionality.</p><p>How do you deal with this in the real world?</p></blockquote><p>In <strong>any</strong> environment where there are stakeholders, you must inform the stakeholders of their options and solicit their preference. This is true in Agile, this is also true in Classical project management. The only difference (which I will address) is your ability to handle the change.</p><p>Where Agile is beneficial is in reducing the cost so that the likelihood of "rewriting a large part of the project because the software wasn't originally designed to accommodate the new requested functionality" is lower.</p><p>How can this be so? How can Agile reduce (not eliminate) the cost?</p><p>One of the answers is by reducing <strong>Acceptance Debt</strong>.</p><p>At any one time in any project, the stakeholders will have a finite list of requirements. They will have tested the unfinished product against zero or more of those requirements. If they test, they will pronounce the product to have satisfied zero or more of the requirements.</p><p>This is acceptance testing. Code that does not contribute to satisfying one or more requirements accepted by the stakeholder is unaccepted code. Note that you must actually test, and the stakeholder must be satisfied. This eliminates "requirements drift," where you test against a stale requirements document. The stakeholder must validate the acceptance test.</p><p>During a development cycle ("iteration" in XP, "sprint" in Scrum, "release" in Classical), new code is unaccepted. You're building "Acceptance Debt" as you write every line. At the end of the iteration, you acceptance test. You eliminate the debt by proving that the code satisfies the stakeholders.</p><p>Why is it debt? Because you pay out resources and time to obtain code. You're "out of pocket" until the stakeholder accepts that the code satisfies their requirements.</p><p>Agile reduces Acceptance Debt in several ways. First, Agile has short iterations (2 weeks for XP, 30 days for Scrum). You have less unaccepted code at any one time. It's like being on a contract and negotiating progress payments: you have better cash flow and less risk.</p><p>Agile also eschews coding for requirements you cannot satisfy during an iteration. This doesn't mean don't think ahead and don't design, just don't write code you can't test.</p><p>Classical uses very long development cycles with little or no acceptance testing until the end of the project. Lots of unaccepted code (no, unit testing does <strong>not</strong> reduce Acceptance Debt). So Classical builds up huge acceptance debt.</p><p>So, how does lowering acceptance debt lower the cost of requirements changes?</p><p>Well, you can devise a scenario that is an exception to any generalization, but I will suggest to you that most requirements changes tend to keep substantially all of the existing requirements. One or two get lopped off and an entirely new set get added on that you didn't anticipate.</p><p>So what happens? Let's look at your acceptance debt. What happens when a requirement you haven't satisfied yet gets dropped? In the Agile world, you have no problem, because you didn't write any code to partially satisfy requirements.</p><p>This is different than the Classical World. Most Classical architects develop things in nice layers of abstractions with frameworks and delegates and tiers. So at any one time you have huge acceptance debt in the form of code that doesn't satisfy a requirement today but it might help satisfy one next month. Those architects have a problem when those unsatisfied requirements change.</p><p>So, I suggest the Agile project has less acceptance debt from unsatisfied requirements than the Classical project, because the Classical project hasn't satisfied as many requirements, and even the ones that have been satisfied haven't been accepted by the stakeholders.</p><p>Now what happens when a requirement you've already satisfied gets dropped? Some or all of the code supporting that requirement just became unaccepted, and you have instant Acceptance Debt. This is not so good. Is it the same for the Agile and Classical World?</p><p>No, it is not the same. In the Agile World the stakeholder has accepted the requirement. You didn't send her an email saying some task was done, you didn't show some demo that might have really been PowerPoint or Flash, you stress tested the Product Increment and gave it to them to use in a production setting. They know it was done.</p><p>In the Classical world they take your word for it that it was done, but the Product Increment isn't in production. How is this different? In theory it shouldn't be different, it shouldn't matter because they no longer need the software to satisfy the dropped requirement.</p><p>In practice, when the stakeholder has already accepted the product increment, they understand the wastage in a visceral sense. It's like buying a sedan, then taking it back to the dealer to ask them to cut the roof off and make it a convertible. If you already took the car for a drive, you appreciate the fact that metal must be cut and welded. But if the car hasn't been delivered yet, you just say "sorry, I changed my mind, change the car for me." The roof is the dealer's problem.</p><p>Anyways, the stakeholder is adamant, so you just piled up acceptance debt. So what? Okay, there's less debt for the Agile project. So what? In practice, this debt now weighs you down. It takes more time because you're rooting through the now unaccepted code trying to change it, without breaking anything that satisfied a requirement that hasn't changed.</p>So, the less acceptance debt you have, the easier it is to satisfy the new requirements. Therefore, the consequences are less, and thanks to getting the stakeholder to accept the satisfied requirements as you went along, the consequences are more visible. 
<br />
<br />This answer is already way too long, so I'll just mention three other things without explaining them. As explained above, acceptance debt adds rework when requirements change. But acceptance debt also adds uncertainty. So you have more work to do, and it's harder to estimate how much work needs to be done. 
<br />
<br />Second, the development cycles in the Agile project explicitly include re-examining requirements, encouraging changes to appear earlier. The objective is to hear about the change earlier in the process, again reducing acceptance debt. 
<br />
<br />Third, you are "test infected" on an Agile project, so as you go through the code ripping out the unaccepted stuff, you find out right away when you accidentally break something, you don't wait for weeks or months, so you again reduce uncertainty. This is very similar to what Agile developers say about the relationship between unit testing and refactoring.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/requirements-changes-and-acceptance.html" title="permanent link">3:07 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, July 15, 2004</div>
			

			<div class="Post"><a name="108989169800010345">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/email-explaining-code-review.html" title="permanent link">An Email Explaining a Code Review</a></span>
					<div style="clear:both;"></div>From: Reg Braithwaite-Lee 
<br />To: F---- S------- 
<br />Subject: An hour before your first Code Review at XXX 
<br />
<br />F---- : 
<br />
<br />In about an hour you will be participating in one of the most important events in your career with XXX, your first code review. 
<br />
<br />Code reviews are the foundation of team software development. The Code Review is where we have an opportunity to synchronize on what's important, what's not important, how things should work, and how much progress we are making. 
<br />
<br />Other organizations have other paths to team software development. For example, some organizations take an autocratic approach. Your manager would normally review your code personally and dictate changes to you, possibly accompanied by explanations of why the changes are important. Such companies often have "style police," architects or managers that dictate programming conventions and audit code for compliance. 
<br />
<br />We aren't going to do that. Having the team review the code together means that we can discuss the code and we can also discuss what's important and why. It's an opportunity for peer to peer communication, which is way more important and valuable to us than dictates from managers. 
<br />
<br />So thanks, you're a part of something very important. 
<br />
<br />Now that I've explained the importance of this, I want to set your expectations correctly. We are probably going to come up with a lot of 'opportunities for improvement' with your code. Why? 
<br />
<br />Well, for starters, there's the number of eyes. You look at your code with two eyes. A group looks at it with twelve or twenty eyes or more. It's almost impossible for anything to be so perfect nobody can suggest an improvement. And quite frankly, if you're optimizing every algorithm, you may be working on perfection at the expense of goodness. 
<br />
<br />Another reason has to do with synchronizing our ideas of importance. Do you know what I think is important to the success of the project? You probably have an incomplete idea. I probably have an incomplete idea of what you think is important. T--, A--, E--, and S-- probably have other ideas. 
<br />
<br />Under the circumstances, there's probably no piece of code that would meet with everyone's approval. Quite likely, the code you write does a good job of expressing your idea of what's important. If you can express your own ideas, you are coding well. 
<br />
<br />Part of this review will be discussing what is important and why. That way, we will all share the same ideas. And the next piece of code you write will express those shared ideas. As will the next piece of code S-- or O-- writes. 
<br />
<br />I want to stress that developing software in a team environment is an ongoing process of refinement and improvement. It simply doesn't work to try to 'start at the finish.' For example, you could have taken the weekend, interviewed me extensively, and rewrote your code to express my ideas. But such a body of code wouldn't help the team learn and communicate. 
<br />
<br />So it's better for XXX that we 'follow the path' and 'take each step once.' And you're a big part of our next step. 
<br />
<br />Once again, thank you in advance. 
<br /><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/email-explaining-code-review.html" title="permanent link">7:40 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, July 14, 2004</div>
			

			<div class="Post"><a name="108980814372677511">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/defining-tasks-with-acceptance-tests.html" title="permanent link">Defining Tasks with Acceptance Tests</a></span>
					<div style="clear:both;"></div>Here's an email from a few years back:
<br />
<br />From: Reg Braithwaite-Lee 
<br />Sent: Monday, August 28, 2000 6:52 PM 
<br />To: XXX 
<br />Subject: RE: Software 
<br />
<br />XXX wrote: 
<br />
<br /><blockquote>I have a software guy who is undisciplined - he wants to just be left alone and write software to his spec. 
<br />
<br />Any tips and hints there for me?  :)</blockquote> 
<br />
<br />The terse response is that you must be synchronized on expectations. 
<br />
<br />My practise is to set up "acceptance tests." An acceptance test is a written understanding of what it means for a piece of software or task to be "done." An acceptance test has a Boolean output: pass/fail, done/not done. 
<br />
<br />Acceptance tests start with a one sentence executive summary. The best acceptance tests strive to be objective "The sort function shall be deemed to have acceptable performance when it can demonstrate sorting 100,000 randomly generated strings in x seconds or less." 
<br />
<br />When you and the developer have agreed on a one sentence summary, you drill down to specific tests. You can probably dictate the summary, but the developer should participate as a reasonably equal partner in fleshing out the tests: 
<br />
<br />"The sort function shall be deemed to have acceptable performance when it can demonstrate sorting 100,000 randomly generated strings in x seconds or less: 
<br />
<br />Random strings to be in a text file, one string per line, strings to be 10 characters long. Standard Unix conventions. Test to be run using a simple shell that reads the entire file into RAM before timing the sort.  Timing will be established using the systemTimeInMilliseconds() function. The test is a pass if the time for the sort is less than x milliseconds. The machine for the testing will be any of our usual testing systems (currently YYY running Linux)." 
<br />
<br />Large point:  I forbid coding until the acceptance test has been signed off. Moving ahead is tempting for the developer and the manager, but resist! I also do not accept any time estimates for a task that does not have acceptance tests defined. How does (s)he know how long it will take if you haven't agreed on when it will be done? 
<br />
<br />Small point: for some tasks, setting up and writing the tests takes as long as the coding. This is normal, and an acceptable cost of development. It is a false saving to thug on ahead to avoid the "overhead" of acceptance tests. 
<br />
<br />Medium Point: Tugging over acceptance tests is an important part of the development process: it is a valuable brainstorming activity and quickly identifies what is important and what is not. 
<br />
<br />p.s. Something like a sort requires multiple acceptance tests. Here's another for the sort function: 
<br />
<br />"The sort function shall sort strings into alphabetical order: 
<br />
<br />Random strings to be in a text file, one string per line, strings to be 10 characters long. Standard Unix conventions. A sorted copy of the file will be generated using Unix standard sort. Test to be run using a simple shell that reads the entire file into RAM and writes the sorted result to a file. The veracity of the sort will be validated by comparing the output with the Unix sort version. The machine for the testing will be any of our usual testing systems (currently YYY running Linux)."
<br /><hr/>
<br />Looking back, I didn't really address my friend's concerns directly. First, there was the concern of 'his spec', as in the developer's spec. That's really what this email addresses: making sure that the developer is working on the right thing.
<br />
<br />There's another entire problem of 'being left alone', also known as 'going dark.' My email doesn't address that problem at all. Perhaps I'll post something on that topic in the future...<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/defining-tasks-with-acceptance-tests.html" title="permanent link">8:21 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, July 13, 2004</div>
			

			<div class="Post"><a name="108972725304595138">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/hazards-of-hiring.html" title="permanent link">Hazards of Hiring</a></span>
					<div style="clear:both;"></div><a href="http://msdn.microsoft.com/longhorn/understanding/columns/default.aspx?pull=/library/en-us/dnsoftware/html/software07072004.asp">Hazards of Hiring</a>
<br />
<br />An excellent article with a balanced look at the hiring process. The author runs a small ISV, so you get a highly pragmatic perspective.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a>, <a rel='tag' href="http://raganwald.github.com/labels/jobs.html">jobs</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/hazards-of-hiring.html" title="permanent link">10:00 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="108972056319141550">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2004/07/whats-all-fuss-with-build-process.html" title="permanent link">What's all the fuss with the build process?</a></span>
					<div style="clear:both;"></div>Hello!
<br />
<br />You may have overheard C****, D*****, and B**** talking about overhauling the build process lately. What's all the fuss about?
<br />
<br />The short answer is, we want to cut the amount of time required to develop O---- core and add ons, while increasing quality. So we look around, and what do we see? Smart people working hard. So the answer is NOT work harder. The answer is "work smarter."
<br />
<br />Of course, not everyone agrees on what it means to "work smarter." Some people might come in here and tell us we need more UML diagrams, or throw out the C++ and start again with a so-called "better" programming language, or perhaps move everybody into their own offices and remove the telephones.
<br />
<br />Those suggestions have some merit, but if you look around you'll find some companies that do very well using those ideas, and some that do very well doing the opposite. Let's put those kinds of suggestions aside for the moment. They might work for us, they might not. The problem with those suggestions is that they don't come with much of a guarantee. We have to study them a lot harder before trying any of them.
<br />
<br />There's another kind of suggestion, like "hire the best people you can find." Almost every company that ignores this suggestion fails to ship software. It seems to be a "best practice." It comes with a good track record. Suggestions for producing software faster with higher quality that have good track records are priorities for us.
<br />
<br />So back to the build process. I'm going to share a FACT with you. If you want to research this yourself, spend a few minutes with Google using keywords like "continuous integration" or "daily build." Here's the fact:
<br />
<br />Companies that build their software more often produce higher quality products, faster.
<br />
<br />Here are some opinions backing up this fact:
<br />
<br /><a href="http://www.stevemcconnell.com/bp04.htm">http://www.stevemcconnell.com/bp04.htm</a>
<br /><a href="http://www.joelonsoftware.com/articles/fog0000000023.html">http://www.joelonsoftware.com/articles/fog0000000023.html</a>
<br />
<br />Please read them both. All of them. It'll take you less than sixty seconds each. I'll wait while you read them. There will be a test later.
<br />
<br />*****
<br />
<br />Did you read them both? You didn't? You'll get to them "later"? Come on, read them right now, I'll wait, I really will. Take two minutes and make yourself a more professional programmer!
<br />
<br />Okay, you've read them. Thank you. Wasn't that worth it?
<br />
<br />Now, hopefully you're excited about daily builds. You might even want to build more often. XP zealots actually say "daily builds are for wimps": they build as they go, triggering a build dozens of times a day. Great. But we have to start somewhere. And that's why we're taking a hard look at our build process and working towards building at least once a day.
<br />
<br />So... When you hear talk of the build process, you now know what's going on: we're "working smarter".
<br />
<br />You read the articles, right? So you can tell me:
<br />
<br />1. Jim McCarty wrote a book that mentions the daily build. What's its name?
<br />2. When projects get really big, the build takes a long time. If you have more than five million lines of code, should you still do daily builds, or is your project too big for this technique?
<br />3. Joel has a test for engineering group. How many questions are in his test?
<br />4. Extra bonus: what's our score in the "Joel Test"?
<br />5. Extra bonus: where can you get Jim's book?<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/agile.html">agile</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2004/07/whats-all-fuss-with-build-process.html" title="permanent link">8:07 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://weblog.raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://weblog.raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://weblog.raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://raganwald.github.com/uploaded_images/coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://raganwald.github.com/uploaded_images/coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>