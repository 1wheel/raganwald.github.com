<html> 
<head>
        
        <title><script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>raganwald</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
<link rel="me" href="http://www.blogger.com/profile/13132345822387028437" />
</head>

<body>

	<div id="leftcontent">
			<img src="http://weblog.raganwald.com/assets/raganwald_2008_350_150" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Friday, November 09, 2007</div>
			

			<div class="Post"><a name="2961100763442932381">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="permanent link">Really useful anamorphisms in Ruby</a></span>
					<div style="clear:both;"></div><a href="http://weblog.raganwald.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="Really simple anamorphisms in Ruby">Really simple anamorphisms in Ruby</a> introduced a very simple <a href="http://raganwald.com/source/unfold.rb.html" title="unfold.rb">unfold</a>. Its chief characteristics were that it generated an Array from a value of some sort, and it did so by applying an incrementor block to its seed recursively until it generated nil. For example:<pre><code><br />10.class.unfold(&amp;:superclass)<br />    =&gt; [Fixnum, Integer, Numeric, Object]<br /></code></pre>A very simple modification allows us to separate the two blocks with a :while or :to pseudo-keyword, and to add a :map keyword for transforming the state into the desired result. Thus, this really simple unfold:<pre><code><br />1.unfold(<a href="http://weblog.raganwald.com/2007/10/stringtoproc.html" title="String#to_proc">&amp;'_+1 unless _==10'</a>).map(&amp;'**2')<br />    =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br /></code></pre>Can also be expressed as:<pre><code><br />1.unfold(:to =&gt; '==10', :map =&gt; '**2', &amp;'_+1')<br />    =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br /></code></pre>The latter form is helpful once unfolds become larger and more complex than these simple one-liners.<br /><br />(There is another style of writing :unfold, using method chaining and lazy evaluation to eliminate lambda keywords, but we will save that for another time: it is a great examination of syntax but does not change :unfold&rsquo;s fundamental behaviour.)<br /><br /><strong>Let&#8217;s turn it up a notch</strong><br /><br />These trivial examples are not particularly compelling. Unfold is touted as the complement to :inject. So you would expect :unfold to be as useful as :inject. And :inject is very, very useful&mdash;you &#8220;reduce&#8221; lists of things to values all the time.<br /><br />But how often do you need to turn a value into a list? How often do you need to turn &#8216;10&#8217; into &#8216;[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&#8217;? And if you do, what&#8217;s wrong with using <code>(1..10).map(&amp;'**2')</code>?<br /><br />Remember that :unfold can be applied to objects with a lot more information to them. The thing that had me stuck when I first saw :unfold was thinking of it as the opposite of :inject. Or at least, the opposite of how I used :inject. I tended to use :inject in a way that reduced information. For example:<pre><code><br />[7, 6, 10, 3, 9, 4, 8, 5, 2, 1].inject(&amp;'+')<br /></code></pre>This gives us the sum of the numbers from one to ten, as it happens. It also gives us a value that is considerably simpler than the list we used to generate the number. Information is lost when we use :inject to &#8220;reduce&#8221; a list to a very simple value. So my first reaction to :unfold was to think of ways to use :unfold on very simple values, like numerics.<br /><br />But :unfold doesn&#8217;t have to work with simple values. It can work with arbitraily complex data structures. Consider:<pre><code><br />def zip(*lists)<br />  lists.unfold(<br />      :while =&gt; '.first', <br />      :map =&gt; '.map(&amp;".first")',<br />      &amp;'_.reject(&amp;".length &lt; 2").map(&amp;"[1..-1]")')<br />end<br /></code></pre>Zip is a function that takes two (or more, but let&#8217;s just say two for now) lists, and produces a list of pairs of items. So:<pre><code><br />zip([:a, :b, :c], [1, 2, 3])<br />    =&gt; [[:a, 1], [:b, 2], [:c, 3]]<br /></code></pre>How does :unfold do it? First, of course, it makes a single list of lists. It then performs an unfold on this single data structure. The incrementor successively reduces each sublist by removing the first items. So the output of the successive incrementor operations is:<pre><code><br />[<br />    [[:a, :b, :c], [1, 2, 3]],<br />    [[b, :c],      [2, 3]]<br />    [[:c],         [3]]<br />]<br /></code></pre>The :map then extracts the first items from each sublist and presents them as a list:<pre><code><br />[<br />    [:a,           1], <br />    [:b,           2], <br />    [:c,           3]<br />]<br /></code></pre>Neat. But why do we care about zip? Well, if you&#8217;ll notice, we already have a bunch of really useful things we can do with lists, like :map, :select, :reject, :detect, and so on. What would you do if you had two lists and needed to do something with each pair in the list, like&#8230; A list of first names and surnames that need to be catenated together?<pre><code><br />zip(first_names, surnames).map(&amp;'"#{_[0]} #{_[1]}"')<br /></code></pre>Zip is useful when we have a bunch of parallel lists and there&#8217;s something we want to do with each tuple from the lists.<br /><br /><strong>Generalized iteration</strong><br /><br />We recognize this &#8220;pattern,&#8221; it&#8217;s one of the most powerful in programming. Zip was one algorithm, a way of iterating over several lists simultaneously. The other algorithm was <code>"#{_[0]} #{_[1]}"</code>, a recipe for what to do with the successive tuples of values.<br /><br /><div class="book"><hr/><em><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://weblog.raganwald.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to functional programming techniques just like these.</em><hr/></div>The powerful idea was to separate the mechanics of turning a data structure into a linear series of values&#8212;iterating&#8212;from what we want to actually do with each value. (In OO-style programming, we would define a method for lists of lists that returns an iterator over the tuples of values. Same thing, proving that how you do it is not as important as understanding <em>why</em> you do it.)<br /><br />Unfold has other uses, but this one alone is worth the trouble to understand the pattern even if you aren&rsquo;t rushing to implement this exact unfold method: Converting a single data structure to a list is one way to implement iteration: for any data structure, you can use unfold to define a linear iteration. You can then use :each or :map or :inject just as our parents before us would have used DO or FOR loops.<br /><br />Consider this (inelegant, but I&#8217;m writing this rather late at night) unfold:<pre><code><br />[[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10].unfold(<br />  :while =&gt; '.first',<br />  :map =&gt; lambda { |first|<br />    first = first.first while first.kind_of?(Array)<br />    first<br />  }<br />) { |state|<br />  state = state.first + state[1..-1] while state.first.kind_of?(Array)<br />  state[1..-1]<br />}<br />    =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br /></code></pre>This is the same idea, only we convert a tree into a list representing a depth-first search of a simple tree. You may recognize it as Array&#8217;s :flatten method. Once again, it&#8217;s really a way of iterating over the elements of a tree. So one way to think of this :unfold is that it is an iterator over a tree&#8217;s leaves:<pre><code><br />def flatten(arr)<br />  arr.unfold(<br />    :while =&gt; '.first',<br />    :map =&gt; lambda { |first|<br />      first = first.first while first.kind_of?(Array)<br />      first<br />    }<br />  ) { |state|<br />    state = state.first + state[1..-1] while state.first.kind_of?(Array)<br />    state[1..-1]<br />  }<br />end<br /></code></pre><strong>But I already know how to write Zip and Flatten methods, honest I do.</strong><br /><br />Zip and Flatten <em>are</em> relatively common, that&rsquo;s why :flatten and :zip can both be found in Ruby&rsquo;s standard Array class. And if there&rsquo;s a data structure that needs regular unfolding, you ought to weigh the advantages and disadvantages of writing an :unfold for it or using more humdrum ways of writing an iterator.<br /><br /><div class="book"><hr/><em>  <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089"><img src="http://weblog.raganwald.com/uploaded_images/haskell_school_of_expression.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089">The Haskell School of Expression</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is a terrific and relatively jargon-free introduction to the language that popularized fold, unfold, and all of the other functional programming idioms. As Eric Kidd says, it will make your head explode. Recommended!</em><hr/></div>However, what do you do when you only need to unfold something once? For example, perhaps you have code that obtains some data in JSON format, and having used a library to parse the JSON into a one-off list or hash, you want to iterate through it.<br /><br />With unfold, you can write your one-time, specific iterator right in place. This is no different than using blocks and lambdas in Ruby for one-off functions that really don&rsquo;t need the cermony and weight of being implemented as methods.<br /><br />When you want to iterate through something, and you want to separate the mechanism for iterating through the data from what you do with the data, :unfold should be in your tool box.<br /><br /><strong>Unfold and the bio-sciences. Not really.</strong><br /><br />I like to think of :unfold like unfolding a protein molecule. When you stare at a data structure, it&#8217;s dense, opaque. But you supply an unfold algorithm, and what looked like a messy ball of twine unravels into a long filament made up of simple elements. You can then operate on the simple elements, without getting what you want to do en-snarled in how you iterate over the data structure.<br /><br />So there you have it. Unfold can be really useful if we see it as a standardized way to write iterators for data structures.<br /><br /><hr/><em>Update: <a href="http://citeseer.ist.psu.edu/283921.html">The under-appreciated unfold</a>.</em><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="permanent link">10:46 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, November 07, 2007</div>
			

			<div class="Post"><a name="5076659457761846917">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="permanent link">Really simple anamorphisms in Ruby</a></span>
					<div style="clear:both;"></div><a href="http://tunes.org/wiki/Morphism" title="Morphisms">Anamorphisms</a> are functions that map from some object to a more complex structure containing the type of the object. They are the dual&#8212;a fancy word for complement&#8212;of Catamorphisms, functions that map from some complex structure down to a simpler object.<br /><br />In simpler terms, a Catamorphism is a function like <strong>inject</strong>: In Ruby, Inject takes a collection and produces something simpler. It is also called <strong>fold</strong> or <strong>reduce</strong> in other languages. Inject can do something like produce the sum of a list:<br /><pre><code><br />(1..5).inject <a href="http://weblog.raganwald.com/2007/10/stringtoproc.html" title="String#to_proc">&amp;'+'</a> =&gt; 15</code></pre><br /><strong>Unfold</strong> does the reverse: it takes a single value and turns it into a collection. Now, a proper unfold can be configured with a seed value, a transformation, a stopping predicate, maybe a distinction between states and output values, and even the type of structure you want to create. A proper unfold would even work with <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html" title="Haskell, Ruby and Infinity">lazy lists</a> if it didn&#8217;t have a stopping condition.<br /><br />But sometimes you want something really simple. The state and the output value could be the same thing, eliminating a transformation from state to output. The stopping predicate could simple, it could stop when it reaches <strong>nil</strong>. And it could always return Arrays. So you could use such a simple unfold whenever you have a seed value and some sort of function (expressed as a block) that returns nil when it has no more values.<br /><br />For example:<br /><pre><code><br />10.unfold { |n| n-1 unless n == 1 }.inspect =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]<br />10.class.unfold(<a href="http://pragdave.pragprog.com/pragdave/2005/11/symbolto_proc.html" title="Symbol#to_proc">&amp;:superclass</a>).inspect =&gt; [Fixnum, Integer, Numeric, Object]</code></pre><br />Hey, what happens if you combine really simple anamorphisms with really simple catamorphisms?<br /><pre><code><br />5.unfold(&amp;'_-1 unless _==1').inject(&amp;'*') =&gt; 120</code></pre><br />Here is the code <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a>. (If <a href="http://weblog.raganwald.com/2007/10/too-much-of-good-thing-not-all.html" title="Not all functions should be object methods">overloading core classes with too much responsibility</a> is not to your taste, it is trivial to express unfold as a function taking a seed and a block as arguments).<br /><br />Now that I&#8217;ve whet your appetite, here&#8217;re <a href="http://weblog.raganwald.com/2007/11/really-useful-anamorphisms-in-ruby.html">Really useful anamorphisms in Ruby</a>. And for another implementation, <a href="http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/1052c289b22c60a5" title="multiple blocks (unfold)">everything you ever wanted to know about implementing a true unfold in Ruby</a>.<br /><br />Enjoy!<br /><br />(Code courtesy of <a href="http://www.mcommons.com/about/jobs">Mobile Commons</a>. Thanks!)<br /><br /><br/><em>Here&rsquo;s an interesting email from Hugh Sasse:</em><br /><br /><blockquote>I was reading <a href="http://www.amazon.com/gp/product/0735619670?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0735619670">Code Complete 2</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0735619670" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> last night and Steve McConnell says that he wouldn&#8217;t hire a programmer who wrote a recursive factorial function. [I&#8217;m not sure that would be such a crime in languages like <a href="http://www.lua.org/" title="The Programming Language Lua">Lua</a> with proper tail recursion, but still. (I&#8217;m probably wrong, now I&#8217;ve written that! &#8220;Open mouth, insert foot, echo internationally&#8221; as they used to say on Fidonet :-))] I thought &#8220;that seems a bit harsh&#8221;, especially since in real life they&#8217;d get one from a library most of the time, anyway.<br /><br />So, as I have often run out of stack on Ruby, I&#8217;ve tried to rewrite <a href="http://weblog.raganwald.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="Really simple anamorphisms in Ruby">unfold</a> as an iterative function. It seems to be working. The script as modified blows up at 5000 on my system with the recursive version, but the iterative version succeeds at 5000.<br /><br />Thanks for this blog entry. There&#8217;s something REALLY nice about this idea, which I can&#8217;t put my finger on. Might be something to do with loops terminating when they should, and The Pragmatic Programmers&#8217; article about &#8220;cook until done&#8221;<br /><br /><a href="http://www.pragprog.com/articles/cook-until-done" title="Cook Until Done">http://www.pragprog.com/articles/cook-until-done</a><br /><br />Unfold feels like a &#8220;do until finished&#8221; loop.<br /></blockquote><pre><code><br />class Object<br />  # As above, but iterative, rather than recursive.<br />  def unfold2 &block<br />    result = [self]<br />    x = block.call(self)<br />    while not x.nil?<br />      result.push x<br />      x = block.call(x)<br />    end<br />    return result<br />  end<br />end<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/11/really-simple-anamorphisms-in-ruby.html" title="permanent link">5:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, October 27, 2007</div>
			

			<div class="Post"><a name="6254612993372428372">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/10/stringtoproc.html" title="permanent link">String#to_proc</a></span>
					<div style="clear:both;"></div><i>Breaking news! The irb enhancement gem <a href="http://weblog.raganwald.com/2007/12/utility-belt.html">Utility Belt</a> includes String#to_proc</i><br /><br />String#to_proc is an addition to Ruby&rsquo;s core String class to enable <a href="http://rickyclarkson.blogspot.com/2007/09/point-free-programming-in-java-7-beyond.html">point-free</a> <a href="http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)">hylomorphisms</a>&hellip;<br /><br />I&rsquo;ll start again. String#to_proc adds a method to Ruby&rsquo;s core String class to make lots of mapping and reducing operations more compact and <em>easier to read</em> by removing boilerplate and focusing on what is to be done. In many cases, the existing black syntax is just fine. But in a few cases, String#to_proc can make an expression <em>even simpler</em>.<br /><br />String#to_proc is a port of the String Lambdas from Oliver Steele&#8217;s <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">Functional Javascript</a> library. I have modified the syntax to reflect how String#to_proc works in Ruby.<br /><br />We&rsquo;ll start with the examples from String Lambdas so you can see what is actually going on. Then we&rsquo;ll look at how to use the <code>&</code> coercion to make working with arrays really simple.<br /><br /><code>to_proc</code> creates a function from a string that contains a single expression. This function can then be applied to an argument list, either immediately:<br /><pre><code><br />'x+1'.to_proc[2];<br />     → 3<br />'x+2*y'.to_proc[2, 3];<br />     → 8<br /></code></pre>or (more usefully) later:<br /><pre><code><br />square = 'x*x'.to_proc;<br />square(3);<br />     → 9<br />square(4);<br />     → 16<br /></code></pre><strong>Explicit parameters</strong><br /><br />If the string contains a <code>-&gt;</code>, this separates the parameters from the body.<br /><pre><code><br />'x y -&gt; x+2*y'.to_proc[2, 3];<br />     → 8<br />'y x -&gt; x+2*y'.to_proc[2, 3];<br />     → 7<br /></code></pre>Otherwise, if the string contains a <code>_</code>, it&#8217;s a unary function and <code>_</code> is name of the parameter:<br /><pre><code><br />'_+1'.to_proc[2];<br />     → 3<br />'_*_'.to_proc[3];<br />     → 9<br /></code></pre><strong>Implicit parameters</strong><br /><br />If the string doesn&#8217;t specify explicit parameters, they are implicit.<br /><br />If the string starts with an operator or relation besides <code>-</code>, or ends with an operator or relation, then its implicit arguments are placed at the beginning and/or end:<br /><pre><code><br />'*2'.to_proc[2];<br />     → 4<br />'/2'.to_proc[4];<br />     → 2<br />'2/'.to_proc[4];<br />     → 0.5<br />'/'.to_proc[2, 4];<br />     → 0.5<br /></code></pre>&#8217;.&#8217; counts as a right operator:<br /><pre><code><br />'.abs'.to_proc[-1];<br /> → 1<br /></code></pre>Otherwise, the variables in the string, in order of occurrence, are its parameters.<br /><pre><code><br />'x+1'.to_proc[2];<br />     → 3<br />'x*x'.to_proc[3];<br />     → 9<br />'x + 2*y'.to_proc[1, 2];<br />     → 5<br />'y + 2*x'.to_proc[1, 2];<br />     → 5<br /></code></pre><strong>Chaining</strong><br /><br />Chain <code>-&gt;</code> to create curried functions.<br /><pre><code><br />'x y -&gt; x+y'.to_proc[2, 3];<br />     → 5<br />'x -&gt; y -&gt; x+y'.to_proc[2][3];<br />     → 5<br />plus_two = 'x -&gt; y -&gt; x+y'.to_proc[2];<br />plus_two[3]<br />     → 5<br /></code></pre><strong>Using String#to_proc in Idiomatic Ruby</strong><br /><br />Ruby on Rails popularized <code>Symbol#to_proc</code>, so much so that <a href="http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l168" title="Changes in Ruby 1.9">it will be part of Ruby 1.9</a>.<br /><br />If you like:<br /><pre><code><br />%w[dsf fgdg fg].map(&amp;:capitalize)<br />    → ["Dsf", "Fgdg", "Fg"]<br /></code></pre>then <code>%w[dsf fgdg fg].map(&amp;'.capitalize')</code> isn&#8217;t much of an improvement.<br /><br />But what about doubling every value in a list:<br /><pre><code><br />(1..5).map &amp;'*2'<br />    → [2, 4, 6, 8, 10]<br /></code></pre>Or folding a list:<br /><pre><code><br />(1..5).inject &amp;'+'<br />    → 15<br /></code></pre>Or having fun with factorial:<br /><pre><code><br />factorial = "(1.._).inject &amp;'*'".to_proc<br />factorial[5]<br />    → 120<br /></code></pre>String#to_proc, in combination with <code>&amp;</code> coercing a value into a proc, lets you write compact maps, injections, selections, detections (and many others!) when you only need a simple expression.<br /><br />Caveats: String#to_proc uses <code>eval</code>. Cue the chorus of people&#8212;pounding away on quad 3Ghz systems&#8212;complaining about the performance. You&#8217;re an adult. Decide for yourself whether this is an issue. After <a href="http://www.yourdictionary.com/wotd/wotd.pl?word=manky">mankying</a> things about to deduce the parameters, String#to_proc evaluates its expression in a different binding than where you wrote the String. This matters if you include free variables. My thinking is that it ceases to be a simple, easy-to-understand hack and becomes a cyrptic nightmare once you get too fancy.<br /><br /><blockquote>You know that Voight-Kampff test of yours&#8230; did you ever take that test yourself?</blockquote><div style="text-align: right;">&#8212;Rachael, Blade Runner</div><br /><br />I have been using <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">Functional Javascript</a> for quite some time now, and I use the String Lambdas a lot. However, Ruby and Javascript are very different languages. Once you get out of the browser&#8217;s DOM, Javascript is a lot cleaner and more elegant than Ruby. For example, you don&#8217;t need to memorize the difference between a block, a lambda, and a proc. Javascript just has functions.<br /><br />However, Javascript is more verbose: Whereas in Ruby you can write <code>[1, 2, 3].map { |x| x*2 }</code>, if Javascript had a <code>map</code> method for arrays, you would still have to write <code>[1, 2, 3].map(function (x) { return x*2; })</code>. So it&#8217;s a big win to make Javascript less verbose: code is easier to read at a glance when you don&#8217;t have to wade through jillions of function keywords.<br /><br />Nevertheless, I still find myself itching for the String Lambdas when I&#8217;m writing Ruby code. It may be a matter of questionable taste, but for certain extremely simple expressions, I vastly prefer the point-free style. <code>(-3..3).map &amp;:abs</code> is shorter than <code>(-3..3).map { |x| x.abs }</code>.<br /><br />It is also cleaner to me. <code>abs</code> is a <em>message</em>, especially in a language like Ruby that supports the sending arbitrary messages named by symbols. Writing <code>(-3..3).map &amp;:abs</code> looks very much like sending the <code>abs</code> message to everything in the list. I don&#8217;t need an <code>x</code> in there to tell me that.<br /><br />Thus, I obviously like <code>(-3..3).map &amp;'.abs'</code>. But I like <code>(1..5).map &amp;'*2'</code> for the same reason. It isn&#8217;t just shorter, it hides a temporary variable that really doesn&#8217;t mean Jack to me when I&#8217;m reading the code. And quite honestly, <code>(1..10).inject { |acc, mem| acc + mem }</code> raises more questions than it answers about what <code>inject</code> does and how it does it. <code>(1..10).inject &amp;'+'</code> gets right down to business for me. I&#8217;d prefer that it be called &#8220;fold,&#8221; but the raw, naked <code>+</code> seems to describe what I want <em>done</em> instead of how I want the computer to do it.<br /><br />Symbol#to_proc also supports named parameters, either through implication (<code>&amp;'x+y'</code>) or with the arrow (<code>'x y -&gt; x*y'</code>). I haven&#8217;t thought of a case where that would be a win over using a Ruby block: <code>{ |x, y| x*y }</code>.<br /><br />I&#8217;m divided about the underscore notation. It seems like a good compromise for expressions where there is a single parameter and it doesn&#8217;t fall on the left or the right side of an expression. Standardizing on an unusual variable name is, I think, a win. Underscore often means a &#8220;hole&#8221; in an expression or a computation, so it feels like a good fit. I would honestly much rather see something like: <code>&amp;'(1/_)+1'</code> than <code>&amp;'(1/x)+1'</code>. The underscore jumps out in an obvious way, and it wouldn&#8217;t be magically clearer to write <code>{ |x| (1/x)+1 }</code>.<br /><br />That being said, I haven&#8217;t actually written an underscore expression yet in actual code, so far I&#8217;m getting by using the point-free expressions to simplify things and using Ruby blocks for everything else.<br /><br /><strong>RSpec</strong><pre><code><br />describe "String to Proc" do<br /><br />  before(:all) do<br />    @one2five = 1..5<br />  end<br /><br />  it "should handle simple arrow notation" do<br />    @one2five.map(&amp;'x -&gt; x + 1').should eql(@one2five.map { |x| x + 1 })<br />    @one2five.map(&amp;'x -&gt; x*x').should eql(@one2five.map { |x| x*x })<br />    @one2five.inject(&amp;'x y -&gt; x*y').should eql(@one2five.inject { |x,y| x*y })<br />    'x y -&gt; x**y'.to_proc()[2,3].should eql(lambda { |x,y| x**y }[2,3])<br />    'y x -&gt; x**y'.to_proc()[2,3].should eql(lambda { |y,x| x**y }[2,3])<br />  end<br /><br />  it "should handle chained arrows" do<br />    'x -&gt; y -&gt; x**y'.to_proc()[2][3].should eql(lambda { |x| lambda { |y| x**y } }[2][3])<br />    'x -&gt; y z -&gt; y**(z-x)'.to_proc()[1][2,3].should eql(lambda { |x| lambda { |y,z| y**(z-x) } }[1][2,3])<br />  end<br /><br />  it "should handle the default parameter" do<br />    @one2five.map(&amp;'2**_/2').should eql(@one2five.map { |x| 2**x/2 })<br />    @one2five.select(&amp;'_%2==0').should eql(@one2five.select { |x| x%2==0 })<br />  end<br /><br />  it "should handle point-free notation" do<br />    @one2five.inject(&amp;'*').should eql(@one2five.inject { |mem, var| mem * var })<br />    @one2five.select(&amp;'&gt;2').should eql(@one2five.select { |x| x&gt;2 })<br />    @one2five.select(&amp;'2&lt;').should eql(@one2five.select { |x| 2&lt;x })<br />    @one2five.map(&amp;'2*').should eql(@one2five.map { |x| 2*x })<br />    (-3..3).map(&amp;'.abs').should eql((-3..3).map { |x| x.abs })<br />  end<br /><br />  it "should handle implied parameters as best it can" do<br />    @one2five.inject(&amp;'x*y').should eql(@one2five.inject(&amp;'*'))<br />    'x**y'.to_proc()[2,3].should eql(8)<br />    'y**x'.to_proc()[2,3].should eql(8)<br />  end<br /><br />end</code></pre>Go ahead, download the <a href="http://raganwald.com/source/string_to_proc.rb.html">source code</a> for yourself.<br /><hr/><em>Update: <a href="http://weblog.raganwald.com/2007/11/fun-with-symboltoproc.html">Reg smacks himself in the head!</a></em><br /><br />I had a look at the source code for <code>Symbol#to_proc</code>:<pre><code><br />class Symbol<br />  # Turns the symbol into a simple proc, which is especially useful for enumerations. Examples:<br />  #<br />  #   # The same as people.collect { |p| p.name }<br />  #   people.collect(&:name)<br />  #<br />  #   # The same as people.select { |p| p.manager? }.collect { |p| p.salary }<br />  #   people.select(&:manager?).collect(&:salary)<br />  def to_proc<br />    Proc.new { |*args| args.shift.__send__(self, *args) }<br />  end<br />end<br /></code></pre>Look at that: Although the examples are all of unary messages like <code>.name</code>, the lambdas created handle methods with arguments. And since almost everything in Ruby is a method, including operators like <code>+</code>&hellip; You can use Symbol#to_proc to do some of the point-free stuff I like:<pre><code><br />[1, 2, 3, 4, 5].inject(&:+)<br />     → 15<br />[{ :foo => 1 }, { :bar => 2 }, { :blitz => 3 }].inject &:merge<br />     → {:foo=>1, :bar=>2, :blitz=>3}<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/10/stringtoproc.html" title="permanent link">11:22 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, October 26, 2007</div>
			

			<div class="Post"><a name="3596521528719407366">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/10/sneak-preview.html" title="permanent link">map(&"(1.._).inject(&'*')")</a></span>
					<div style="clear:both;"></div>Some working Ruby code:<pre><code><br /> (1..3).map(&amp;'*2') =&gt; [2, 4, 6]<br /> (1..3).map(&amp;'[-1, _, 0]') =&gt; [[-1, 1, 0], [-1, 2, 0], [-1, 3, 0]]<br /> (1..3).map(&amp;'x -&gt; y -&gt; x * y').map(&amp;'[2]') =&gt; [2, 4, 6]<br /> (1..5).select(&amp;'&gt;2') =&gt; [3, 4, 5]<br /> (1..3).map(&amp;'x -&gt; y -&gt; x * y').map(&amp;'.call(2)') =&gt; [2, 4, 6]<br /> [5].map(&"(1.._).inject(&'*')") => [120]</code></pre><br /><br />See <a href="http://weblog.raganwald.com/2007/10/stringtoproc.html">String#_to_proc</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/10/sneak-preview.html" title="permanent link">10:53 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 25, 2007</div>
			

			<div class="Post"><a name="5039489814009701313">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/10/too-much-of-good-thing-not-all.html" title="permanent link">Too much of a good thing: not all functions should be object methods</a></span>
					<div style="clear:both;"></div>OOP is several different ideas put together, the most important of which is <em>Fine-Grained Information Hiding</em>.<br /><br /><blockquote>One can think of information hiding as being the principle and encapsulation being the technique. A software module hides information by encapsulating the information into a module or other construct which presents an interface.<br /></blockquote><div style="text-align: right;">&mdash;<a href="http://en.wikipedia.org/wiki/Information_hiding" title="Information hiding - Wikipedia, the free encyclopedia">Information Hiding</a> on Wikipedia</div><br /><br />The basic principle of all OO languages is that relatively small things&#8212;such as individual accounts in a business program&#8212;each encapsulate both their data (in the form of members) and their algorithms (in the form of methods). Our notions of members and polymorphism both work to this goal of hiding information. There&#8217;s a lot more to most OO languages, such as whether they include a notion of types and what mechanisms they use for sharing common behaviour. But let&#8217;s look at this one principle: <em>objects are responsible for their data and for their algorithms</em>.<br /><br /><strong>should objects be responsible for all of their own behaviour?</strong><br /><br />There&#8217;s a general idea that in a well-constructed program, each object &#8220;knows&#8221; how it ought to behave. That&#8217;s what its methods are for. Quite obviously, objects cannot be responsible for <em>everything</em> involving them in a program. If each object completely encapsulated all of the things it could do or be involved in, you would never pass one object as a parameter in a message to another object.<br /><br /><blockquote>For every complex problem, there is a solution that is simple, neat, and wrong.<br /></blockquote><div style="text-align: right;">&mdash;H. L. Mencken</div><br /><br />For example, you would never have collections. If every object &#8220;knew&#8221; how to organize itself into collections, you wouldn&#8217;t need an Array or Hash, would you? In practice, each object in a system can be involved in many different actions. It has to be responsible for some of them, and it has to play a secondary, passive role in others. Most OO programs do not have every object implement its own collections methods. They may include some form of specialization so you can have an array of accounts, but an array of accounts is still not an account.<br /><br /><strong>subject.verb(object)</strong><br /><br />In the English language, we have the idea of a <em>Subject</em> and an <em>Object</em> in a sentence. For example, when we say &#8220;Jack loves Jill,&#8221; Jack is a subject and Jill is an object. Jack loves. Jill is loved. It&#8217;s the same in OO programs. Sometimes objects are actively doing things through their methods. Sometimes other object&#8217;s methods are doing things with them.<br /><br /><blockquote>Verbing Weirds Language<br /></blockquote><div style="text-align: right;">&mdash;Bill Watterson, <a href="http://en.wikipedia.org/wiki/Calvin_and_Hobbes" title="Calvin and Hobbes - Wikipedia, the free encyclopedia">Calvin and Hobbes</a></div><br /><br />Good OO design is, in part, doing a good job of choosing the right bifurcations: given a list of nouns and verbs, making the right decisions about which nouns ought to be the active nouns, the subjects, the ones that &#8220;own&#8221; the verb in the form of a method. And thus consciously making decisions about which objects ought to be the passive nouns, the objects of the verbs, the ones that <em>don&#8217;t</em> implement the methods.<br /><br />Unfortunately, there are lots of places where we can err on the side of giving too much responsibility to individual objects. It&#8217;s understandable, given that OO is theoretically all about objects being responsible for themselves. But as in many other things, in practice good OO is about objects being responsible for a little as possible (but no less!), not as much as possible.<br /><br /><strong>the kingdom of nouns</strong><br /><br />One common symptom of this problem is <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" title="Stevey's Blog Rants: Execution in the Kingdom of Nouns">a system that has objects for all of the obvious nouns or entities, but not for the verbs</a>. OO began with languages like <a href="http://en.wikipedia.org/wiki/Simula" title="Simula - Wikipedia, the free encyclopedia">Simula</a>, where the paradigm was trying to represent real-world entities such as automobiles on a highway. From that time forward, the emphasis has been on having objects for each noun in the problem domain. In such traditionally-organized OO programs, the &#8220;verbs&#8221; or actions are all attached to objects as methods. <br /><br /><div class="book"><hr/><em><a id="lnx0" name="evtst|a|0201379430" href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201379430"><img src="http://weblog.raganwald.com/uploaded_images/object_design-719894.jpg" border="0" height="160" width="128"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0201379430" href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201379430">Object Design: Roles, Responsibilities, and Collaborations</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> focuses on the practice of designing objects as integral members of a community where each object has specific roles and responsibilities. The authors present the latest practices and techniques of Responsibility-Driven Design and show how you can apply them as you develop modern object-based applications.  <br><br></em><hr/></div>Not all &#8220;verbs&#8221; have a clear separation between a single entity that is the subject or active entity that ought to own the verb&#8217;s definition and the secondary, passive subject entities that should not own the verb&#8217;s definition. The easiest examples of this are operations that are intended to be <a href="http://en.wikipedia.org/wiki/Commutativity" title="Commutativity - Wikipedia, the free encyclopedia">commutative</a>.<br /><br />For example, many languages define addition as a method belonging to numbers or magnitudes. In Smalltalk, the expression <code>1 + 2</code> actually means &#8220;<em>send the message</em> <code>+ 2</code> <em>to the object</em> <code>1</code>.&#8221; At first glance, this seems elegant: the number <code>1</code> handles the message <code>+ 2</code> as integer addition, while <code>1.0</code> would handle the same message with floating point arithmetic. What more could you want?<br /><br />Well, there is a huge problem with this arrangement: <em>Addition is commutative</em>. <code>1.0 + 2</code> must give the same result as <code>2 + 1.0</code>. Using a simple message to implement addition means that you must be excruciatingly careful to handle all of the possible cases so that you do not accidentally violate this property. Now of course, the designers of system classes like <code>Integer</code> and <code>Float</code> went to this trouble. But if you want to add another magnitude class&#8212;say <code>CurrencytwoPlaceDecimal</code>&#8212;you have to open up all of the system classes and modify them so that <code>1 + ThirtyCents</code> gives the same result as <code>ThirtyCents + 1</code>.<br /><br /><strong>beware of breaking symmetry</strong><br /><br />Of course, you may not need to implement a new magnitude class. Fine. But what about <a href="http://en.wikipedia.org/wiki/Symmetric_relation" title="Symmetric relation - Wikipedia, the free encyclopedia">symmetric relations</a> like <em>comparison</em>? This is a major pitfall for OO developers: in many cases you need to write a test of equivalence or equality (operations like <code>==</code>, <code>equal?</code>, <code>eql?</code>, <code>eqv?</code> and all of the other variations on the same theme). In every one of these cases, horrible things will happen if your operation is not symmetric. For every case, <code>x.eql?(y)</code> if-and-only-if <code>y.eql?(x)</code>.<br /><br />This is obviously easy when <code>x</code> and <code>y</code> are both the same kind of object. <a href="http://weblog.raganwald.com/2007/04/what-does-barbara-liskov-have-to-say.html" title="What does Barbara Liskov have to say about Equality in Java?">What happens when they&#8217;re different, but still logically equivalent?</a> It turns out that implementing commutative operations and symmetric relations as methods doesn&#8217;t work very well. It forces you to smear duplicate logic over many different classes (or prototypes, if your language swings that way).<br /><br />Here&#8217;s a practical example. Let&#8217;s say you want to implement a form of equivalence for collections. For ordered collections like lists, what you want is that if two ordered collections have the same members, in the same order, they are equivalent. It&#8217;s easy to imagine writing such a method as a <a href="http://en.wikipedia.org/wiki/Mixin" title="Mixin - Wikipedia, the free encyclopedia">mixin</a> for all of your ordered collections. It obviously knows about iterating over ordered collections (recursively, if you grew up with <a href="http://www.amazon.com/gp/product/0465026567?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0465026567" title="Amazon.com: Godel, Escher, Bach: An Eternal Golden Braid by Douglas R. Hofstadter">Godel, Escher, Bach</a> on your night stand). Note that you may not have an indexed collection: you might have a <code>list</code> where you simply retrieve values in order.<br /><br />And likewise, you can write a collection equivalence method for dictionaries like hash tables: if two objects have the same values at the same keys, they are equivalent. Again, a simple mixin will handle things for dictionaries.<br /><br />Now comes the wrinkle: you decide that an ordered collection ought to be equivalent to a dictionary where the keys are the integers ascending from zero. In other words, <code>('foo' 'bar' 'blitz')</code> ought to be equivalent to <code>{ 0 =&gt; 'foo', 1 =&gt; 'bar', 2 =&gt; 'blitz' }</code>. How are you going to code this? Well, the dictionary mixin could obviously handle equivalence to an ordered list. But we need symmetry, so we have to &#8220;open up&#8221; the ordered collection mixin and add code for equivalence to dictionaries.<br /><br /><blockquote>Actually I made up the term object-oriented and I can tell you I did not have C++ in mind. The important thing here is that I have many of the same feelings about Smalltalk.<br /></blockquote><div style="text-align: right;">&mdash;Alan Kay</div><br /><br />I&#8217;m holding my nose, we have not one but two different code smells: 1) Why is one piece of logic in two different places? 2) Why do ordered collections know anything at all about dictionaries, and why do dictionaries know anything at all about ordered collections? The latter is especially disturbing: the whole point of OO is information hiding. How does having ordered collections and dictionaries knowing about each other help us to hide information?<br /><br />The obvious answer to me is that the knowledge of how to compare an ordered collection to a dictionary does not belong in ordered collections or in dictionaries. The requirement that relations like equivalence be symmetrical across heterogeneous types implies that the types themselves cannot be responsible for implementing equivalence for themselves.<br /><br />There are similar problems of code duplication and information leakage apply to modelling relations (why do we declare <code>has_one</code> and <code>belongs_to</code> in Rails) and implementing the <code>&lt;=&gt;</code> operator in Ruby. It looks like having verbs &#8220;belong to&#8221; the subject noun is often a good idea, but not always a good idea.<br /><br /><strong>commuting the sentence of execution</strong><br /><br />Maybe some verbs belong to objects, but some are best on their own? Maybe <code>+</code> and <code>&lt;=&gt;</code> and <code>equivalent?</code> really ought to be emancipated from their subservience to objects and ought to have their own definitions.<br /><br /><blockquote>There are two real approaches to object-orientation. The first is known as message-passing. You send an object a message and ask it to deal with it. (This would not work with many people in this newsgroup.) The meaning of the message is local to the object, which inherits it from the class of which it is an instance, which may inherit it from superclasses of that class&#8230;<br />  <br />  The second approach is generic functions. A generic function has one definition of its semantics, its argument list, and is only specialized on particular types of arguments. <br /></blockquote><div style="text-align: right;">&mdash;<a href="http://groups.google.com/group/comp.lang.lisp/msg/60f4c36a707db3fe">Erik Naggum discussing CLOS on comp.lang.lisp</a></div><br /><br />What we ought to do is take some of the verbs and give them their own place in our programs, instead of hanging them off nouns. This isn&#8217;t such a revolutionary idea: Common Lisp&#8217;s <a href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262610744" title="Amazon.com: The Art of the Metaobject Protocol by Gregor Kiczales">Metaobject Protocol</a> does this exact thing, providing <a href="http://en.wikipedia.org/wiki/Generic_function" title="Generic function - Wikipedia, the free encyclopedia">generic functions</a>. A generic function is, in effect, a verb raised to the same level of abstraction as a noun.<br /><br />This isn&#8217;t some revolutionary idea limited to &#8220;powerful&#8221; languages either: the Java collections framework uses a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Comparable.html" title="Comparable (Java 2 Platform SE v1.4.2)"><code>Comparable</code></a> interface for ordering collections. The <code>compareTo(...)</code> method belongs to an object. By way of&#8212;ahem&#8212;comparison, the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Comparator.html" title="Comparator (Java 2 Platform SE v1.4.2)"><code>Comparator</code></a> interface extracts comparison out of the subject object and puts it in a separate function object. You can perform sorts in Java either way.<br /><br />If we aren&#8217;t using Common Lisp, can we build the verbs we want out of the tools at our disposal? In other words, can we <a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule" title="Greenspun's Tenth Rule - Wikipedia, the free encyclopedia">Greenspun</a> generic functions in languages like Java and Ruby?<br /><br /><strong>generic functions in java, plus a detailed look at method dispatching</strong><br /><br />Let&#8217;s start by thinking about generic functions in a Java-like language.<br /><br />Returning to our example of writing <code>equivalent?</code>, we might make an <code>Equivalent</code> class with a single method, perhaps we can call it <code>eval</code>. So we end up with something like <code>Eqivalent.eval(foo, bar)</code>. Java-like languages allow us to write different versions of the <code>eval</code> method with different type signatures, so we can write:<br /><pre><code><br />public static boolean eval (List foo, List bar) { ... }<br />public static boolean eval (List foo, Map bar) { ... }<br />public static boolean eval (Map foo, List bar) { return eval(bar, foo); }<br />public static boolean eval (Map foo, Map bar) { ... }</code></pre><br />And so forth. Are we done?<br /><br />No, our code is broken. What happens when we decide that the &#8220;default&#8221; equivalence is the <code>==</code> relationship. We can&#8217;t write:<br /><pre><code><br />public static boolean eval (Object foo, Object bar) { return foo == bar; }</code></pre><br />This is hideously broken in languages like Java. You&#8217;re almost all nodding in agreement, but please be patient while I explain it anyway: you probably want to pass this along to someone who really needs to be told why it is broken, so why don&#8217;t I go ahead and explain it for <em>them</em>?<br /><br />What you want is that if two objects are of the more specific types&#8212;<code>List</code> and <code>Map</code>&#8212;we will call the more specific version of the <code>eval</code> methods. But if we can&#8217;t &#8220;match&#8221; one of the more specific <code>eval</code> methods, we want to use <code>eval (Object foo, Object bar)</code>. Too bad, that&#8217;s not how Java works. <em>Java uses two completely different ways to figure out which method to call when you overload methods!</em><br /><br />Way number one is is for figuring out that when you call <code>noun.verb(...)</code>, where do we find the definition for <code>verb</code>? This lookup is effectively done at run time, so that even if your code looks like this:<br /><pre><code><br />public static void printSomething(Object foo) {<br />    System.out.println(foo.toString());<br />}</code></pre><br />Java will look up the method <code>toString</code> based on <code>foo</code>&#8217;s actual type when the method is called, even though you declared it to be an <code>Object</code>. That&#8217;s polymorphism at work, and it&#8217;s the information hiding working for us. Each object can do it&#8217;s own thing where <code>toString</code> is concerned, and we don&#8217;t have to worry about it. This is called <a href="http://en.wikipedia.org/wiki/Single_dispatch" title="Dynamic dispatch - Wikipedia, the free encyclopedia">single dispatch</a>, because it figures out which method to call based on just one of the nouns, the subject noun a/k/a the receiver of the method invocation.<br /><br />But that&#8217;s not what happens when we write this:<br /><pre><code><br />public static void printSomethingElse (Object foo, Object bar) {<br />    if (Equivalent.eval(foo, bar))<br />        System.out.println("2 x " + foo);<br />    else System.out.println(foo.toString() + ", " + bar.toString());<br />}</code></pre><br />It will <em>always</em> call <code>eval (Object foo, Object bar)</code>. It will <strong>not</strong> call <code>eval (List foo, List bar)</code> if you pass it two lists. That&#8217;s because although each of our methods have the same name&#8212;<code>eval</code>&#8212;Java treats them as different methods, and it figures out which one to call based on the declared types of the parameters at compile time, not on the actual types of the parameters&#8217; values at run time.<br /><br /><div class="book"><hr/><em><a id="lnx0" name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158"><img src="http://weblog.raganwald.com/uploaded_images/a_little_java-777624.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262561158" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><em><br><br>Free your mind with <a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of <a name="evtst|a|0262560992" href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262560992" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> and <a name="evtst|a|026256114X" href="http://www.amazon.com/gp/product/026256114X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256114X">The Little MLer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256114X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em><br><br></em><hr/></div>Besides writing a Lisp interpreter in Java, your next best bet for building a generic function the way we want it is to find a way to turn Java&#8217;s single dispatch into a multi-dispatch, to dispatch on two nouns, <code>foo</code> and <code>bar</code>.<br /><br />The good news is this: dispatching at run time on two different types is a well-known problem, and the solution is called <a href="http://en.wikipedia.org/wiki/Double_dispatch" title="Double dispatch - Wikipedia, the free encyclopedia">double dispatch</a>. The problem with double dispatch is that it moves our equivalence code back into our nouns, and we don&#8217;t want that.<br /><br />The <a href="http://en.wikipedia.org/wiki/Visitor_pattern" title="Visitor pattern - Wikipedia, the free encyclopedia">Visitor</a> pattern might be handy: it&#8217;s a way to add methods to an object at run time in a language like Java that supposedly doesn&#8217;t do that. If we decide that everything to be compared using <code>Equivalent.eval</code>implements an interface called <code>Visitable</code>, we can build a double dispatch system that doesn&#8217;t require putting an <code>equivalent?</code> method in the entities being compared:<br /><pre><code><br />interface Visitable {<br />    Object accept(final Visitor visitor);<br />}<br /><br />interface Visitor {<br />    Object visit(final Object obj);<br />    Object visit(final List list);<br />    Object visit(final Map map);<br />}<br /><br />public class Equivalent {<br /><br />    static boolean list_list (List foo, List bar) { ... }<br />    static boolean list_map (List foo, Map bar) { ... }<br />    static boolean map_map (Map foo, Map bar) { ... }<br />    static boolean object_object (Object foo, Object bar) { ... }<br /><br />    public static boolean eval (final Visitable foo, final Visitable bar) {<br />        return foo.accept(<br />            bar.accept(<br />                new Visitor () {<br />                    public Object visit(final Object bar) {<br />                        return new Visitor () {<br />                            public Object visit(final Object foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final List foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final Map foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                        }<br />                    }<br />                    public Object visit(final List bar) {<br />                        return new Visitor () {<br />                            public Object visit(final Object foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final List foo) {<br />                                return list_list(foo, bar);<br />                            }<br />                            public Object visit(final Map foo) {<br />                                return list_map(bar, foo);<br />                            }<br />                        }<br />                    }<br />                    public Object visit(final Map bar) {<br />                        return new Visitor () {<br />                            public Object visit(final Object foo) {<br />                                return object_object(foo, bar);<br />                            }<br />                            public Object visit(final List foo) {<br />                                return list_map(foo, bar);<br />                            }<br />                            public Object visit(final Map foo) {<br />                                return map_map(foo, bar);<br />                            }<br />                        }<br />                    }<br />                }<br />            )<br />        )<br />    }<br />}</code></pre><br />If that looks like a lot of work to you, I agree. You&#8217;re basically replicating Java&#8217;s run time dispatching on two types, so you need a bit of a matrix. Is it worth the effort? Let&#8217;s consider what this wins you:<br /><br /><ul><li>Your entities or objects no longer need to know all about other types of entities;</li><br /><li>It&#8217;s easier to make sure that commutation and symmetry are preserved when the code for a relationship is in its own class and not smeared over multiple entities.</li></ul><br />And best of all, you have a nice place for your verbs, and they are no longer second-class citizens behind the nouns.<br /><hr/><br />Update: A few people have suggested alternate approaches to implementing multiple dispatch in Java. I think there are various trade-offs to be made, and several different implementations ought to be considered before you write production code.<br /><br />However, the point of the article is to suggest that not all functions should be implemented as methods of subject objects. I think it makes that point regardless of what you think of using a Visitor and a double dispatch.<br /><br />Here&rsquo;s an alternate approach from <a href="http://programming.reddit.com/user/LaurieCheers/">Laurie Cheers</a>:<br /><pre><code>interface Classifiable<br />{<br />    int classify();<br />}<br /><br />// I know this isn't valid Java, but it makes the example much clearer. The alternative is to tiresomely spell out every combination.<br />#define PAIR(a,b) (a|(b&lt;&lt;4))<br /><br />abstract class DoubleDispatchable<br />{<br />    abstract Object list_list(List a, List b);<br />    abstract Object list_map(List a, Map b);<br />    abstract Object map_map(Map a, Map b);<br />    abstract Object object_object(Object a, Object b);<br /><br />    const int OBJECT = 0;<br />    const int LIST = 1;<br />    const int MAP = 2;<br /><br />    Object dispatch(Classifiable a, Classifiable b)<br />    {<br />        switch(PAIR(a.classify(), b.classify))<br />        {<br />            case PAIR(LIST, MAP): return list_map(a,b);<br />            case PAIR(MAP, LIST): return list_map(b,a);<br />            case PAIR(LIST, LIST): return list_list(a,b);<br />            case PAIR(MAP, MAP): return map_map(a,b);<br />            default: return object_object(a,b);<br />        }<br />    }<br />}<br /><br />class Equivalent extends DoubleDispatchable<br />{<br />    Object list_list(List a, List b) {...}<br />    Object list_map(List a, Map b) {...}<br />    Object map_map(Map a, Map b) {...}<br />    Object object_object(Object a, Object b) {...}<br /><br />    bool eval(Classifiable a, Classifiable b) { return dispatch(a,b) != false; }<br />}<br /></code></pre><br />What trade-offs, you ask? The Visitor pattern given gets the compiler to guarantee that you write each of the nine cases, whereas hand-written tests and logic simplifies the code.<br /><br />I specifically chose the Visitor pattern because it seemed more in keeping with the spirit of the Java language and culture, trading verbosity for compiler safety.<br /><br />I'm extremely comfortable with the other trade-off, emphasizing readability and simplicity. Although, if you go far enough down that road, you might as well look at other languages ;-)<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/10/too-much-of-good-thing-not-all.html" title="permanent link">11:24 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, August 26, 2007</div>
			

			<div class="Post"><a name="4181946194975037390">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/08/ruminations-about-performance-of.html" title="permanent link">Ruminations about the performance of anonymous functions in naive Javascript implementations</a></span>
					<div style="clear:both;"></div><a href="http://weblog.raganwald.com/2007/08/block-structured-javascript.html" title="raganwald: Block-Structured Javascript">Block-Structured Javascript</a> (better known as the <em>Module Idiom</em>) looks like this:<br /><pre><code><br /> (function () {<br />    var something_or_other;<br />    // code elided<br />    return something_or_other;<br /> })()<br /></code></pre><br />This creates a new, anonymous function with its own local scope. Whenever this code is execututed, the interpreter creates a function record in its memory. The exact same thing happens if you create a function and bind it to a variable with <code>var foo = function (...) { ... };</code>.<br /><br /><div class="book"><em><hr><br /><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://weblog.raganwald.com/uploaded_images/seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is devoted to the myriad uses of first class functions. Luckily for us, the ideas in this provocative book map directly to Javascript (see the plug for <a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668">Lisp in Small Pieces</a> below).<br /><br />When you close the back cover you will be able to compose programs from functions in powerful new ways, and you can use these new techniques in Scheme, Ruby, and Javascript immediately.<br /><hr></em></div>Now let&rsquo;s consider another common pattern, the <em>Inner Function</em>: we have a function, and the function needs a helper function. We define the helper function inside our function to make our code more <em>encapsulated</em>:<br /><pre><code><br /> var factorial = function (n) {<br />     var factorial_acc = function (acc, m) {<br />         if (0 == m) {<br />             return acc;<br />         } else {<br />             return factorial_acc(m * acc, m - 1);<br />         }<br />     };<br />     return factorial_acc(1, n);<br /> };<br /></code></pre><br />What happens when we invoke <code>factorial</code> it six times?<br /><br />When the interpreter first encounters the code defining <code>factorial</code>, it creates a function and assigns it to the variable <code>factorial</code>. Then each time we invoke the <code>factorial</code> function, the interpreter creates a new function record for <code>factorial_acc</code>. So in total, the interpreter creates <em>seven</em> functions in memory, not two.<br /><br /><strong>hand-rolling</strong><br /><br />If this code needed hand optimization, you might want to consider ‘lifting&rsquo; the definition of <code>factorial_acc</code> outside of factorial, so it doesn&rsquo;t get recreated with every invocation:<br /><pre><code><br /> var factorial_acc = function (acc, m) {<br />     if (0 == m) {<br />         return acc;<br />     } else {<br />         return factorial_acc(m * acc, m - 1);<br />     }<br /> };<br /> var factorial = function (n) {<br />     return factorial_acc(1, n);<br /> };<br /></code></pre><br />This produces exactly the same result as our Inner Function version. <code>factorial_acc</code> doesn&rsquo;t use any of <code>factorial</code>&rsquo;s parameters or variables, so it does not really need to be inside its scope to produce the correct result.<br /><br />Now you only need two function records, not seven. Two is cheaper than seven. The problem with this approach is that you are proliferating names. If you are binding functions to names in the global environment, it quickly becomes crowded. And you also have a readability issue. Does anything else need to use <code>factorial_acc</code>? The original code made it very obvious that <code>factorial_acc</code> is only ever used by <code>factorial</code>.<br /><br />A block can help. Yes, the cause of our performance consideration—dynamically creating functions—can actually be part of the solution:<br /><pre><code><br /> var factorial = (function () {<br />     var factorial_acc = function (acc, m) {<br />         if (0 == m) {<br />             return acc;<br />         } else {<br />             return factorial_acc(m * acc, m - 1);<br />         }<br />     };<br />     return function (n) {<br />         return factorial_acc(1, n);<br />     }<br /> })();<br /></code></pre><br />Now what happens? Well, we create an anonymous function for our block. One function record. Within that block&rsquo;s execution, we create two more functions,  one assigned to the variable <code>factorial_acc</code>, and one returned from the block (and then assigned to the variable <code>factorial</code>). This code creates three function records, which is still much better than seven.<br /><br />As a correspondent summarized in email, &ldquo;we&rsquo;ve shown how to replace a simple function containing an inner function with a block call that returns a closure referencing the inner function so as to avoid re-defining it on each call. That&rsquo;s all there is to it.&rdquo;<br /><br />(By the way, <a href="http://crockford.com/">Douglas Crockford</a> has done a very good job of explaining this idiom in Javascript, and named it the <em>Module Pattern</em>. Here&rsquo;s <a href="http://www.wait-till-i.com/index.php?p=467">a discussion</a> with particular emphasis on OO-style programming. And here&rsquo;s <a href="http://yuiblog.com/blog/2007/06/12/module-pattern/">a really detailed examination</a> from the YUI team.)<br /><br />So should you always rewrite inner functions to use a block like this?<br /><br />I don&rsquo;t personally fool around with this kind of hand optimization willy-nilly (Of course, you may find the block version more readable than the inner function version. If you do, it&rsquo;s a win to write it that way). It has a cost: in a more complex function, defining helpers outside of the function may be moving them further away from where they are used, which is a loss for readibility. If you prefer the inner function version, you should be very sure you have a performance problem before you leap to the conclusion that you should rewrite it.<br /><br /><strong>a heuristic for automatic optimization of inner functions and blocks</strong><br /><br />Lisp implementations have been optimizing this kind of code, automatically, for decades. That&rsquo;s because Lisp programmers have been writing programs in this style for decades, either directly or using macros like <code>let</code>. Here&rsquo;s the basic heuristic:<br /><br /><div class="book"><em><hr><br /><a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668"><img src="/uploaded_images/lisp_in_small_pieces.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521545668" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668">Lisp in Small Pieces</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521545668" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is one of the most important books about Javascript ever written. WTF!? may be your first thought. Hold on. Javascript at its heart, a very Lisp-like language with C syntax. So understanding Lisp helps you understand Javascript.<br /><br />What makes <a name="evtst|a|0521545668" href="http://www.amazon.com/gp/product/0521545668?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521545668">Lisp in Small Pieces</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521545668" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> special for Javascript programmers is that it illustrates the principles underlying Lisp (and therefore Javascript) by creating a series of implementations, each of which illustrates the basic mechanisms in the language.<br /><br />These deep ideas are exactly the things that make Javascript different from other C-syntax languages like Java or Visual Basic. This book, more than any other, will take your understanding from knowing what works on the surface to understanding why and how it works.<br /><hr></em></div><ul><li>Find every <code>function</code> invocation that is nested inside another <code>function</code>.</li><br /><li>Analyze all of its variable references lexically. If there are no references to a parameter or local variable of its immediate parent,<sup><font size="1">1</font></sup> promote the function by defining it in its grand-parent and assigning the definition to a new variable in the grand-parent.</li><br /><li>Replace the original definition in the parent with a reference to the variable you just created in the grand-parent.</li><br /><li>Repeat until all functions are either global or refer to variables in their immediate parent functions.</li></ul><br />There&rsquo;s also a well-know optimization for making blocks themselves free or nearly free: <a href="http://en.wikipedia.org/wiki/Lambda_lifting" title="Lambda lifting - Wikipedia, the free encyclopedia">lambda lifting</a>. So before optimizing things prematurely, test your implementation and see if it is already fast enough for your purposes.<br /><br />You may discover that you don&rsquo;t save anything by rewriting things yourself. (You may make your code slower: some optimizations rely on knowing the exact scope of the code being optimized. If you proliferate names by lifting things yourself, the optimizer may not be able to use all of its tricks.)<br /><br />These techniques have been known for <em>twenty-five years</em>. If a <a href="http://en.wikipedia.org/wiki/Internet_explorer" title="Internet Explorer - Wikipedia, the free encyclopedia">Javascript implementation that you are forced to target</a> doesn&rsquo;t include it, why not demand that the implementers get with the program and, you know, use some of the stuff we&rsquo;ve known about programming for almost as long as they&rsquo;ve been alive? Especially if they brag about their prowess at creating programming languages?<br /><br /><strong>conclusion: nice-to-know, but not essential</strong><br /><br />My personal conclusion is that the behaviour of a naïve implementation is a &ldquo;nice-to-know.&rdquo; I don&rsquo;t personally worry about optimizing it until I have a known performance issue, at which point it is essential to test to see whether some of the hand-optimizations will actually help.<br /><br />YMMV.<br /><hr><br />1. Full closures make things tricky:<br /><br />Functions that refer to variables in their immediate parent scope are much trickier to optimize away. Sometimes, such a function is supposed to be created anew for each invocation of its parent.  For example, if you want to construct a bank balance thingy without using objects, you might write:<br /><pre><code><br />    function (balance) {<br />      return function (amount) {<br />          balance = balance + amount;<br />          return balance;<br />        };<br />    };<br /></code></pre><br />You pass in an initial balance, and it gives you a single function that you can use to deposit (pass a positive number), withdraw (pass a negative number), or check the balance (pass zero). It returns the updated balance in each case.<br /><br />The inner anonymous function cannot be lifted or optimized away because of its reference to <code>balance</code> in its parent and because the function can be shown to &ldquo;escape&rdquo; its parent.<br /><br />Whereas in this contrived example:<br /><pre><code><br />    function (balance, owner) {<br />      return function (amount) {<br />          return {<br />              new_balance: (function () {<br />                  if (balance + amount &gt;= 0)<br />                      return balance + amount;<br />                  else return balance;<br />              })(),<br />              account_owner: owner<br />          }<br />        };<br />    };<br /></code></pre><br />Although the inner function still cannot be optimized away, the block within it can be lifted into the inner function and removed, producing:<br /><pre><code><br />    function (balance, owner) {<br />      return function (amount) {<br />          var __temp;<br />          if (balance + amount &gt;= 0)<br />              __temp = balance + amount;<br />          else __temp = balance; <br />          return {<br />              new_balance: __temp,<br />              account_owner: owner<br />          }<br />        };<br />    };<br /></code></pre><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/08/ruminations-about-performance-of.html" title="permanent link">11:44 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, August 20, 2007</div>
			

			<div class="Post"><a name="8261916568550175558">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/08/block-structured-javascript.html" title="permanent link">Block-Structured Javascript</a></span>
					<div style="clear:both;"></div>Javascript provides <em>closures with first-class access to variables declared in the enclosing environment</em>. Besides being a handy piece of trivia if you are ever playing Programming Jeopardy, what use is this to the actual working programmer?<br /><br />There are a lot of ways to take advantage of Javascript&#8217;s closures, I am going to describe just one, replicating Algol&#8217;s block structure (or Lisp&#8217;s <code>let</code> and <code>begin</code> macros, if you prefer). When we&#8217;re all done you&#8217;ll have a handy tool for making your code more readable, separating its concerns, and generally making life easier for programmers who have to read what you&#8217;ve written.<br /><br /><strong>From Bricks to Blocks</strong><br /><br />A block is a chunk of code inside a function. Blocks have well-defined entry and exit points. Blocks have their own local variables and functions, and they also have first-class access to variables and functions defined around them. Blocks may nest.<br /><br />Structuring code into blocks makes large functions more readable and easier to refactor. All of the variables and logic needed for one thing are encapsulated together in the blocks where they are needed, not scattered about in functions everywhere.<br /><br /><blockquote>when a better design&mdash;if unfamiliar&mdash;is shown to developers or experienced users, they tend to reject it. Often, it takes careful explanation and having them gain experience with it before the improvement is understood.<br /></blockquote><div style="text-align: right;">&mdash;Jef Raskin</div><br /><br />While the idiom may be slightly unfamiliar to some, I think you&#8217;ll agree that it is highly accessible and not some sort of &uuml;ber-contruct of interest only to the self-professed hacker. And when a programmer encounters it in your code, she will have no trouble figuring out what it does and how it does it.<br /><br /><strong>block structured code</strong><br /><br />I think everyone can agree that structured programming is a good thing. Functions should be composed of blocks, with the blocks linked together by constructs such as <code>if</code> statements:<br /><pre><code><br />if (some_condition) {<br />    // a block<br />}<br />else {<br />    // another block<br />}<br /></code></pre><br />Back before structured programming was introduced, there were <code>gotos</code> everywhere. Looking at a piece of code with labels, it was hard to know what the flow of control might be at run time. In short, you never had the confidence that everything you needed to know about that code was right there next to that code.<br /><br />Like almost all modern languages, Javascript&#8217;s blocks do structure the flow of control so that you have nice clean entries and exits from each block. And also like most other modern languages, Javascript does nothing to structure access to variables inside blocks. For example:<br /><pre><code><br />var j = 0;<br />if (some_condition) {<br />    // a block with some code elided<br />}<br />alert(j);<br /></code></pre><br />What will be shown? You can&#8217;t guarantee that zero will pop up, because the blocks might modify <code>j</code>, like this:<br /><pre><code><br />var j = 0;<br />if (true) {<br />    var j = 42;<br />}<br />alert(j);<br /></code></pre><br />This looks like a programmer error. After all, the <code>var</code> keyword should be used to declare a new variable. The code between the braces isn&#8217;t really a new block of code with its own variables. This is hardly a problem with trivial examples. But if you start building some larger functions, the possibility of accidentally overwriting some code looms larger. Especially once you start refactoring and moving blocks of code around.<br /><br />What can we do? How about this: the &#8220;block&#8221; idiom (you can also call it  <code>let</code> or <code>begin</code> if you want to sound like a Schemer). Here&#8217;s the code:<br /><pre><code><br />var j = 0;<br />if (true) <br />    (function () {<br />        var j = 42;<br />    })();<br />alert(j);<br /></code></pre><br />There&#8217;s a lot of syntactic noise, what does it mean? In short, we said: &#8220;Create a new function. In the body of the new function define a variable called <code>j</code> and assign 42 to it. Then call that function without any parameters.&#8221; Because our new instance of <code>j</code> is inside a function, it is not the same variable as the <code>j</code> outside of the function. That can be handy.<br /><br />Are there any other benefits of this idiom? Yes indeed. Sometimes you have an assignment and you need some logic on the right hand side. How do you write:<br /><pre><code><br />var proven = {<br />    var n = Math.round(100*Math.random());<br />    var total = 0;<br />    for (var i = 0; i &lt;= n; ++i) {<br />        total = total + (2*i) + 1<br />    }<br />    return total == ((n + 1) * (n+1));<br />};<br />alert(proven);<br /></code></pre><br />You can&#8217;t, of course. There are two problems with trying to use braces in this case. First, Javascript only allows braces to form code blocks in conjunction with specific keywords like <code>if</code> and <code>function</code>. Second, Javascript code blocks are not <em>expressions</em>&mdash;they do not produce values. This is why languages like Javascript need an if statement <em>and</em> a ternary operator: if blocks produced values, you would only need if expressions. <br /><br />So in traditional Javascript style, you have to define a function somewhere else and call it&#8230; You&#8217;ll notice our block idiom includes defining and calling a function. What if our function returns a value? In that case, we can use a block anywhere we want a value, for example:<br /><pre><code><br />var proven = (function () {<br />    var n = Math.round(100*Math.random());<br />    var total = 0;<br />    for (var i = 0; i &lt;= n; ++i) {<br />        total = total + (2*i) + 1<br />    }<br />    return total == ((n + 1) * (n+1));<br />})();<br />alert(proven);<br /></code></pre><br />This new idiom allows us to make first-class blocks anywhere we like. Our blocks are <em>expressions</em>, and we can use them anywhere we need a value. And as above, Our variables are fully encapsulated, they do not overwrite variables defined elsewhere.<br /><br /><strong>blocks vs. named functions</strong><br /><br />You may be wondering, "Why can&rsquo;t we use a named function?" This is the style in languages like Python, where the Benevolent Dictator does not permit constructions like this. Here is the above code using a named function:<br /><pre><code><br />var proven_helper = function () {<br />    var n = Math.round(100*Math.random());<br />    var n_plus_1_squared = function (n) {<br />        return (n + 1) * (n+1); <br />    };<br />    var sum = function (n) {<br />        var total = 0;<br />        for (var i = 0; i &lt;= n; ++i) {<br />            total = total + (2*i) + 1<br />        }<br />        return total;<br />    };<br />    return sum(n) == n_plus_1_squared(n);<br />};<br />var proven = proven_helper();<br />alert(proven);<br /></code></pre><br /><br />I find this almost as good as the block. Since you only use it in one place, it is defined where you use it. That is good. And the name might be helpful documentation, just like a one or two-word comment. Balanced against this is the fact that you have added a new function to the outer scope. Reading it later, you might have to scan the rest of the code to see if it is used elsewhere.<br /><br />There's also a very small advantage of the block over the named function: since you need two statements (one to name a function, another to use it), you can only use a named function in normal code blocks. You cannot use a named function when you need an expression, unless you resign yourself to naming the function in one place and using it somewhere else.<br /><br />For example, when constructing array or hash literals, you can use expressions. A block is an expression, while two statements (one to create a named function and one to call it) are not an expression. So a named function would need to be defined outside of an array or hash literal, while a block can be used inside it, placing the code closer to where it is used.<br /><br /><strong>block structure and cleaner code</strong><br /><br /><div class="book"><em></em><hr><em><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596101996"><img border="0" src="/uploaded_images/javascript.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0596101996" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596101996">JavaScript: The Definitive Guide</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0596101996" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> takes the time to actually discuss the language, to explain what Javascript can do and how to do it. And of course, the book also provides an in-depth reference of every function and object you are likely to encounter in most implementations. Recommended.<br /></em><hr></div>Structuring code into blocks makes large functions more readable and easier to refactor. All of the variables and logic needed for one thing are encapsulated together in the blocks where they are needed, not scattered about in functions everywhere. If you see a variable declared inside a block, you know it is only used inside the block. If you see a variable with the same name outside the block&#8212;a regrettable occurrence&#8212;you know that moving or changing the block will not affect the code working with variables outside of the block.<br /><br />You probably know that you can put a function inside of a function in Javascript:<br /><pre><code><br />var factorial = function (n) {<br />    var factorial_acc = function (acc, n) {<br />        if (0 == n) {<br />            return acc;<br />        } else {<br />            return factorial_acc(n * acc, n - 1);<br />        }<br />    };<br />    return factorial_acc(1, n);<br />}<br />alert(factorial(6));<br /></code></pre><br />And this is a good thing, it keeps the function <code>factorial_acc</code> inside of <code>factorial</code>. Since that&#8217;s the only place you need it, why declare it anywhere else? The fact that you can put a function inside of a function implies that you can put a function inside of a block as well:<br /><pre><code><br />var proven = (function () {<br />    var n = Math.round(100*Math.random());<br />    var n_plus_1_squared = function (n) {<br />        return (n + 1) * (n+1); <br />    };<br />    var sum = function (n) {<br />        var total = 0;<br />        for (var i = 0; i &lt;= n; ++i) {<br />            total = total + (2*i) + 1<br />        }<br />        return total;<br />    };<br />    return sum(n) == n_plus_1_squared(n);<br />})();<br />alert(proven);<br /></code></pre><br />If you only need the functions <code>n_plus_1_squared</code> and <code>sum</code> to do this one job, in this one place, why should they be defined at top level cluttering up your code? Why force other programmers to search through your code figuring out where they are used before making changes?<br /><br />Block structure may seem <i>unfamilar</i> at first, but give blocks a try and see whether you start finding the code even easier to read and refactor with blocks. Like me, you will find that structuring your code with blocks puts the things you use right where you use them.<br /><br /><strong>update</strong>: <a href="http://weblog.raganwald.com/2007/08/ruminations-about-performance-of.html">Ruminations about the performance of anonymous functions in naive Javascript implementations</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/08/block-structured-javascript.html" title="permanent link">10:08 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, July 16, 2007</div>
			

			<div class="Post"><a name="4267051248388428321">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/07/javascript-on-jvm-in-fifteen-minutes.html" title="permanent link">How to Run Javascript on the JVM in Just Fifteen Minutes</a></span>
					<div style="clear:both;"></div><strong>what and why</strong><br /><br />This post is about executing Javascript inside the JVM without using a browser. Besides the fact that people are talking about <a href="http://steve-yegge.blogspot.com/2007/06/rhino-on-rails.html" title="Stevey's Blog Rants: Rhino on Rails">running Javascript on the server</a> (<a href="http://helma.org/" title="Helma - Javascript Web Application Framework">again</a>, and <a href="http://peter.michaux.ca/article/3001" title="Server-Side JavaScript with Rhino and Jetty">again</a>), here&#8217;s why my colleagues and I used it on a recent project:<br /><br />We have some logic that needs to run on the server and on the client, depending on when the application applies it. There is like an incredibly complex form validation involed. Think of a loan application, for example. Zillions of rules like &#8220;at least five years at current location <em>or</em> at most three locations in ten years <em>or</em> owns current location for at least one year.&#8221; The whole thing forms a big logical expression that needs to be evaluated in such a way that we can report which pieces are missing or do not meet requirements (<em>Declined because income is insufficient and does not state purpose of loan</em>).<br /><br />There are a couple of ways to handle this. One is to submit the form back to the server for validation. Another is to write everything in Java, but use <a href="http://code.google.com/webtoolkit/" title="Google Web Toolkit">a sophisticated tool to render the Java into Javascript</a>. Naturally, our team chose a third option, The Rails Way (available for <a href="http://www.amazon.com/gp/product/0321445619?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321445619" title="The Rails Way (Addison-Wesley Professional Ruby Series)">pre-order</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0321445619" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />).<br /><br />We have a Domain-Specific Language for describing the rules. Business users use the DSL, and another tool writes code from that. We could, in theory, write Java methods for the server <em>and</em> write Javascript for the client. We chose to start with Javascript, and we&#8217;ll write Java for the server if running Javascript on the server turns out to be <strike>unperformant</strike> slow.<br /><br />In the mean time, we decided that having some Java make a simple function call to a Javascript function and process a simple result was a reasonable first step. As a side benefit, we run all our server-side Javascript unit tests in Java test suites alongside our Java unit tests.<br /><br />And after some fiddling around, we got Javascript working on the JVM. My bet is that you can get it working too, and it won&#8217;t take more than fifteen minutes.<br /><br />Care to try it?<br /><br /><strong>step zero: the Java Virtual Machine (JVM)</strong><br /><br />You&#8217;ll need JDK 1.5 or 1.6 from Sun. If you already have this, move on to step one. Still reading? You&#8217;ll need to do a big install before we go further.<br /><br />Go to the <a href="http://java.sun.com/javase/downloads/index.jsp" title="Java SE Downloads">downloads page</a> and download the latest thing they have on offer with the words &#8220;JDK&#8221; in it. You won&#8217;t need JEE (the framework formerly known as J2EE) for this exercise, but if you know what it is you know enough to decide whether to download it.<br /><br />Right now, you want <strong>JDK 6u2</strong>. Go get it and suffer through the installation process.<br /><br /><strong>Step one: Bean Scripting Framework</strong><br /><br />Java6 has a new framework for running &#8220;scripting&#8221; languages, and it&#8217;s built into Java6. We&#8217;re not going to use it today, just because some of you may still need to make stuff work with JDK 1.5 in production. Instead, we&#8217;re going to go get the Jakarta Bean Scripting Framework (BSF). <a href="http://jakarta.apache.org/bsf/" title="Jakarta BSF - Bean Scripting Framework">You can download it here</a>. We&#8217;ll need <code>bsf.jar</code>.<br /><br /><strong>step two: fix gotchas</strong><br /><br />YMMV, but I found that I couldn&#8217;t get BSF working without including the <a href="http://jakarta.apache.org/commons/logging/" title="Commons - Logging">Jakarta Commons-Logging</a> jar. So if you don&#8217;t have this floating around, go <a href="http://jakarta.apache.org/site/downloads/downloads_commons-logging.cgi" title="The Jakarta Site - Commons Logging Downloads">here</a> and download it. I experimented, and I could ignore everything except <code>commons-logging-1.1.jar</code>. If that was missing, BSF kakked.<br /><br /><strong>step three: Rhino</strong><br /><br />Since we&#8217;re going to run Javascript, we need an interpreter. <a href="http://www.mozilla.org/rhino/" title="Rhino - JavaScript for Java">Rhino</a> to the rescue. <a href="http://www.mozilla.org/rhino/download.html" title="Rhino Downloads">Download it</a>. We&#8217;ll need <code>js.jar</code>.<br /><br /><strong>step four: keeping things organized</strong><br /><br />Ready to code? Let&#8217;s start with a directory for all of our stuff. Call it <code>hello_javascript</code>. For the sake of keeping thing simple, set up the sub-structure as follows:<br /><br /><code>hello_javascript</code><br /><code>hello_javascript\lib</code><br /><br />You may be using a fancy IDE, you may be using a text editor and have to graft your classpaths together with chicken wire. The important thing is that your classpath, besides including all of Java&#8217;s required stuff, and your own Java classes, also includes <code>bsf.jar</code>, <code>commons-logging-1.1.jar</code> and <code>js.jar</code>.<br /><br />We&#8217;ll put all three in the <code>lib</code> subdirectory:<br /><br /><code>hello_javascript\lib\bsf.jar</code><br /><code>hello_javascript\lib\commons-logging-1.1.jar</code><br /><code>hello_javascript\lib\js.jar</code><br /><br /><strong>step five: &#8220;Hello, Javascript&#8221;</strong><br /><br />Let&#8217;s write some Java: create the following subdirectories and put a file called <code>HelloJavascript.java</code> in it:<br /><br /><code>hello_javascript\com\raganwald\public\HelloJavascript.java</code><br /><br />Let&#8217;s give it some code:<br /><br /><pre><code>package com.raganwald.public;<br /><br />import org.apache.bsf.BSFManager;<br /><br />public class HelloJavascript {<br />    public static void main (final String[] argv) {<br />        final BSFManager manager = new BSFManager();<br />        final Object jso = manager.eval("javascript", "(java)", 1, 1, "'hello, Javascript'");<br />        System.out.println(jso.toString());<br />    }<br />}<br /></code></pre><br /><br />Run your new Java application. Did you see that? It interpreted some Javascript <em>in the JVM without a browser</em>. Check your watch. Did you need more than a quarter of an hour? I didn&#8217;t think so.<br /><br />You can try more ambitious code:<br /><br /><pre><code> manager.eval(<br />    "javascript", "(java)", 1, 1, <br />    "var f = function (what) { return 'hello, ' + what; }; f('Javascript);");<br /></code></pre><br /><br /><strong>including other files is an exercise left for the reader</strong><br /><br />I didn&#8217;t find an easy way to get Javascript files to include other Javascript files. This isn&#8217;t the worst thing in the world, but you certainly don&#8217;t want to write anything substantial inside of Java strings. So try experimenting with reading javascript files right off the classpath.<br /><br />I created a subdirectory called <code>javascript</code>:<br /><br /><code>hello_javascript\javascript</code>  <br /><br />And you can read Javascript into your strings or Stringbuffers with some fairly simple code, thanks to a utility built into BSF:<br /><br /><pre><code>import org.apache.bsf.util.IOUtils;<br /><br />// ...<br /><br />static String readScript(final String fileName) throws Exception {<br />    final FileReader in = new FileReader(fileName);<br />    return IOUtils.getStringFromReader(in);<br />}<br /></code></pre><br /><br />That reads some script into a string. You can then prepend it to whatever you want to evaluate. Note that if you want to set up some sort of simple checking to make sure that you don&#8217;t &#8220;include&#8221; the same file twice, you will need to write yourself a little framework for that, perhaps using a <code>Set</code> to keep track of what you&#8217;ve already loaded.<br /><br /><strong>garbage in, garbage out</strong><br /><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/1933988037?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1933988037"><img border="0" src="/uploaded_images/prototype_and_scriptaculous_in_action.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1933988037" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.prototypejs.org/">Prototype</a> and <a href="http://script.aculo.us/">Scriptaculous</a> are the Javascript libraries that make slick transitions and UI effects easy one-liners. Prototype does more than just make an application look good: it adds Ruby and Smalltalk-like methods for handling Hashes, Arrays, and the DOM.<br /><br />This book is one of the fastest ways to get up to speed on taking Javascript to the next level.<br /></em><hr/></div>This is nice, and with a little work you could make a program that reads paths to Javascript files off the commend line and executes them. But to make things really interesting, you want to find a way to get Java data into your JavaScript and do something useful with the results, not just print it as a String.<br /><br />BSF provides a way to inject objects into the scripting language&#8217;s environment, so you could use that facility. When writing automated unit tests for that particular project, I chose a simpler route: I serialized the data into JSON and used that to call a Javascript function directly via BSF:<br /><br /><pre><code>manager.eval("javascript", "(java)", 1, 1, <br />    "myJavascriptFunction(" + myJSONString + ");");<br /></code></pre><br /><br />This is a <em>really bad idea</em> if your JSON is handed you from an insecure source, such as a public web page calling you back via <code>XMLHttpRequest</code>, but if you trust your source, this works wonderfully.<br /><br />Now what do you do with the result? If you are generating something esoteric like a Javascript function, I have no idea. In my own case, I return all values as simple trees of Hashes (Javascript objects without any special methods) and Arrays. I convert those into Java trees of Maps and Arrays:<br /><br /><pre><code>import org.mozilla.javascript.NativeArray;<br />import org.mozilla.javascript.ScriptableObject;<br /><br />import java.util.ArrayList;<br />import java.util.Arrays;<br />import java.util.HashMap;<br />import java.util.List;<br />import java.util.Map;<br /><br />// ...<br /><br />static List unwrapNativeArray (final NativeArray na) {<br />    return new ArrayList&lt;Object&gt; () {{<br />        for (int i = 0; i &lt; na.getLength(); ++i) {<br />            add(unwrapNative(na.get(i, null)));<br />        }<br />    }};<br />}<br /><br />static List unwrapPrototypeArray (final ScriptableObject sObj) {<br />    return new ArrayList&lt;Object&gt; () {{<br />        final List&lt;Object&gt; sObjIds = Arrays.asList(sObj.getAllIds());<br />        for (int i = 0; sObjIds.contains(i); ++i) {<br />            add(unwrapNative(sObj.get(i, null)));<br />        }<br />    }};<br />}<br /><br />static Map unwrapObject (final ScriptableObject sObj) {<br />    return new HashMap&lt;String, Object&gt; () {{<br />        for (Object id: sObj.getAllIds()) {<br />            put(id.toString(), unwrapNative(sObj.get(id.toString(), null)));<br />        }<br />    }};<br />}<br /><br />static Object unwrapNative (final Object obj) {<br />    if (obj instanceof NativeArray) {<br />        return unwrapNativeArray((NativeArray) obj);<br />    }<br />    else if (obj instanceof ScriptableObject) {<br />        final ScriptableObject sObj = (ScriptableObject) obj;<br />        final List&lt;Object&gt; sObjIds = Arrays.asList(sObj.getAllIds());<br />        if (sObjIds.contains("keys")) { // a prototype enumerable/hash<br />            return unwrapObject(sObj);<br />        }<br />        else if (sObjIds.contains("flatten")) { // a prototype enumerable/array<br />            return unwrapPrototypeArray(sObj);<br />        }<br />        else return unwrapObject(sObj);<br />    }<br />    else return obj;<br />}<br /></code></pre><br />Check your watch. Are you still under fifteen minutes? Great!<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/07/javascript-on-jvm-in-fifteen-minutes.html" title="permanent link">4:58 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, May 07, 2007</div>
			

			<div class="Post"><a name="8982350227311849405">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/05/parable-illustrating-importance-of.html" title="permanent link">A parable illustrating the importance of the differences between Scheme and Common Lisp in a world where Java is the Lingua Franca of Programmers</a></span>
					<div style="clear:both;"></div><a href="http://forum.ship-of-fools.com/threads/laugh_judgment/01f.html">An encounter on a bridge</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/05/parable-illustrating-importance-of.html" title="permanent link">1:13 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="6210153413294635201">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/05/style-matters.html" title="permanent link">Style Matters</a></span>
					<div style="clear:both;"></div><blockquote>Art Matters</blockquote><br /><div style="text-align: right;">&#8212;button on a fellow coffee lover&#8217;s lapel</div><br />Giles Bowkett has written an <a href="http://gilesbowkett.blogspot.com/2007/05/languages-only-do-so-much.html" title="Giles Bowkett: Languages Only Do So Much">entertaining opinion piece</a>, wherein he argues that the gulf between sophisticated programmer and fundamentalist programmer is far, far wider than the hairline between fundamentalist programmers that use different programming languages.<br /><br />You know, blog posts with sufficient depth (anything more than &#8220;How to call a COM+ object on Windows 2000 Server using CORBA over SOAP from IE 7&#8221;) are Rorschach Blots. If you&#8217;re predisposed to affinity, you read your own thoughts in them. And indeed, I immediately liked the article, because I thought he was saying that fundamentalist programmers use <a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html" title="raganwald: Are we Blub programmers?">Blub</a>, and that when he talks about the limitations of languages he was saying that <a href="http://weblog.raganwald.com/2006/10/three-questions-and-three-answers.html" title="raganwald: Three questions and three answers about Wasabi and Rotten Fish">people matter more than tools</a>.<br /><br /><div class="book"><hr/><br /><a href="http://www.amazon.com/gp/product/0262062178?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262062178"><img border="0" src="/uploaded_images/essentials_of_programming_languages.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262062178" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><em><a href="http://www.amazon.com/gp/product/0262062178?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262062178">Essentials of Programming Languages</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262062178" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is an in-depth exploration of the deep ideas behind programming languages. This is a hands-on book: you&#8217;ll build a series of interpreters that actually implement each language feature, building a full understanding of the way programming languages actually work.<br /><br />This is critical for learning how to use these features in languages that have them, but better than that it also teaches you how to greenspun them into languages that don&#8217;t!</em><hr/><br /><br /></div>Of course, he&#8217;s actually saying a little of that but also a little of something else, and what&#8217;s really important <em>to me</em> are the ways in which what he says are different than the things I was already thinking. A mirror is a dangerous tool for experiencing the universe!<br /><br />And then I read <a href="http://listeningtoreason.blogspot.com/2007/05/languages-matter.html" title="Listening To Reason: Languages Matter">Andrew Norris&#8217; reply</a>, and what struck me was that Andrew may have had the opposite reaction to Giles&#8217; opinions: he seemed to fixate on the differences between what Giles was saying and what Andrew was thinking. But closely reading Andrew&#8217;s impassioned response, I recognize so many similarities to the two points of view that I&#8217;m shocked they aren&#8217;t both the same person.<br /><br />As a colleague used to say, these two men are in <em>violent agreement</em>. Giles is talking about the importance of the programmer&#8217;s deep understanding, and Andrew is talking about the importance of the programmer&#8217;s deep understanding as well!<br /><br />They both seem to agree without reservation on the utter dead-endedness of the fundamentalist, &#8220;all innovation stopped with the invention of language X&#8221; thinking, for all values of X (including Lisp!). You can sort out the differences for yourself, they pale in comparison.<br /><br /><strong>Styling</strong><br /><br />What I find most valuable (in the sense of expanding my own thinking, not just confirming what I already thought I knew) about Giles&#8217; post is his assertion on the value of a personal style, of having a voice, on finding something unique to contribute, something that shines through the specific language and platform you use.<br /><br />Isn&#8217;t that related to the entire <a href="http://weblog.raganwald.com/2007/03/approach-to-composing-domain-specific.html" title="An Approach to Composing Domain-Specific Languages in Ruby">meta-programming/DSL </a>thingie? This idea that the language is a platform for a program so personal it deserves its own programming language?<br /><br />Isn&#8217;t that <strong>exactly</strong> what both Giles and Andrew are promoting? Giles says &#8220;develop your personal style that is independent of the programming language.&#8221; Andrew says &#8220;use the tool that fits the job.&#8221; Well, what could be more personal than bending a tool to become a new tool customized for the problem? What could be more &#8220;polyphonic?&#8221;<br /><br />And Giles&#8217; example of Avi Bryant brings up an important component of developing a personal style. Giles pointed out the common thread in Avi&#8217;s work. he suggests it is Avi&#8217;s style, and it is. But Avi can&#8217;t use that style on any arbitrary problem. To a certain extent, Avi selects problems that fit his style.<br /><br />To develop a style, you must be ready to apply it to problems, and you must also be prepared to walk away from problems where it really doesn&#8217;t apply. Otherwise, you will become the jack of all trades but the master of none. of course a great programmer can use shell scripts, C, and Python. But the programmer who has equal facility with all three problem domains is inferior to the programmer who &#8220;knows enough to be dangerous&#8221; in most domains but has obtained mastery in a very few of them.<br /><br />So, Develop your style. Choose problems wisely. And learn your tools deeply, so that you may choose the right tools to express your style.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/05/style-matters.html" title="permanent link">9:27 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, May 02, 2007</div>
			

			<div class="Post"><a name="4729744864722341492">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/05/steves-road-into-godawful-swamp.html" title="permanent link">Steve's road into the godawful swamp</a></span>
					<div style="clear:both;"></div><blockquote>You&rsquo;ve all read about the <a href="http://wiki.alu.org/The_Road_to_Lisp_Survey">Road to Lisp</a>. I was on it for a little over a year. It&rsquo;s a great road, very enlightening, blah blah blah, but what they fail to mention is that Lisp isn&rsquo;t the at the end of it.<br /><br />Lisp is just the last semi-civilized outpost you hit before it turns into a dirt road, one that leads into the godawful swamp most of us spend our programming careers slugging around in.<br /><br />I guarantee you there isn&rsquo;t one single Lisp programmer out there who uses exclusively Lisp. Instead we spend our time hacking around its inadequacies, often in other languages.</blockquote><br /><div style="text-align: right;">&mdash;Steve Yegge, <a href="http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html">Lisp is not an acceptable Lisp</a> (April, 2006)</div><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/05/steves-road-into-godawful-swamp.html" title="permanent link">7:20 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, April 13, 2007</div>
			

			<div class="Post"><a name="8074916481331990114">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/04/from-abstraction-to-zipf.html" title="permanent link">From Abstraction to Zipf</a></span>
					<div style="clear:both;"></div><em>Alpha&#8230;</em><br /><br /><a href="http://damienkatz.net/" title="Damien Katz">Damien Katz</a> raised an interesting question the other day: he wondered whether elements of computer programs followed a <a href="http://en.wikipedia.org/wiki/Zipf's_law" title="Zipf's law - Wikipedia, the free encyclopedia">Zipf distribution</a>. In other words, he wondered whether the most frequently used item occurred a lot more than the next most frequent, which occurs a lot more than the third most frequent, and so forth.<br /><br />That&#8217;s an interesting question. Is it true? And if it is, what does that tell us about composing programs?<br /><br />Looking at computer programs, some things seem to follow Zipf&#8217;s law and others don&#8217;t. In C++ programs, loop indices called <code>i</code> probably are an order of magnitude more common than those called <code>j</code>. Unless you use <a href="http://www.joelonsoftware.com/articles/Wrong.html" title="Making Wrong Code Look Wrong - Joel on Software">Apps Hungarian</a>, of course. But are <code>for</code> loops that much more common than <code>if</code> statements? That might vary from place to place within a single program, but overall they might be roughly equal in frequency.<br /><br />If we step up a level and look at idioms, my gut tells me that there is a strong Zipf distribution. Although each program will differ, some programs might make heavy use of lists, others of maps. Some might do a lot with closures, others with objects. These are fairly generic, of course.<br /><br />If we have a look at the more domain-specific items in a program, we really see a Zipf distribution. Some things pop up again and again and again in a program, others are rare.<br /><br /><strong>Why Abstract?</strong><sup>1</sup><br /><br />The most important tool we have for composing programs is <em>abstraction</em>. When we create an abstraction for something, we get one and a half wins (a <a href="http://en.wiktionary.org/wiki/sesqui-" title="sesqui- - Wiktionary">sesqui</a>-win).<br /><br /><div class="book"><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844"><img src="http://weblog.raganwald.com/uploaded_images/the_ruby_way.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|0672328844" href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to implement advanced ideas like metaprogramming.<br /><br /></div>The full win is that we get to take a common element and place its responsibility in once place. For example, if your language gives you a <code>map</code> function or method, there is one place for the code that applies a function to each element of a collection and produces a collection of the results. Unlike a &#8220;pattern,&#8221; you don&#8217;t have to re-implement map every time you use it, you just use it. The centralization of responsibility in a single place is very powerful way to <a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html" title="Why Why Functional Programming Matters Matters">separate concerns</a>.<br /><br />The half win is that we don&#8217;t need to understand its implementation, we only need to understand its interface. I honestly don&#8217;t know whether Ruby&#8217;s built-in <code>map</code> method applies itself to a collection one at a time from the start to the end or in some other order. I suspect it&#8217;s from start to end for ordered collections, but I don&#8217;t know and I don&#8217;t have to know.<br /><br />This is only half a win, because for anything too complicated to explain on a PowerPoint slide where you are promising the newest silver bullet, abstractions have a nasty habit of leaking. <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html" title="The Law of Leaky Abstractions - Joel on Software">Leaky abstractions</a> force you to understand the implementation to use them.<br /><br />There are some drawbacks to abstractions. As noted, sometimes the abstraction leaks. In that case, you often have to look up what an abstraction does. If there was no abstraction and the implementation was right there in the middle of your code, you wouldn&#8217;t have to look it up. So when you see:<br /><br /><pre><code>class BlogPost &lt;&lt; ActiveRecord::Base<br />    has_many :comments<br />    # ...<br />end<br /></code></pre><br />You obviously to need to know that <code>has_many</code> creates methods like <code>comments</code>, <code>comment_ids=</code> and <code>comments&lt;&lt;</code> automagically for you. In fact, that is kind of the point of <code>has_many</code>. But if you are doing anything non-trivial, you also need to know whether <code>has_many</code> actually <em>defined</em> <code>comments</code>, <code>comment_ids=</code> and <code>comments&lt;&lt;</code> or whether it has merely modified <code>BlogPost</code> to <em>handle</em> those messages. In that sense, the abstraction leaks.<br /><br />You get much the same thing if you build a Java class hierarchy that is umpteen levels deep festooned with abstract base classes, factories, and dependency injection. In one sense you get a really tight abstraction. In another sense, you have a big leak: you need to know its internals to get any real work done.<br /><br />Another drawback to abstractions fall out of their strength. If you haven&#8217;t seen a particular abstraction before, you don&#8217;t know what it does and how it works. Contrary to popular hype, self-documenting names are not enough. If you are a Rails user, raise your hand if you can tell me what all of the various options for <code>has_many</code> are and what they do. You have to learn each abstraction&#8217;s interface, just as you had to learn what a <code>for</code> loop does for you.<br /><br />The win (not having to know how it works) is also a loss (not knowing what it does).<br /><br /><strong>An abstraction is an abstraction is an abstraction</strong><br /><br />I think most people agree that named subroutines (or functions, or procedures) are an excellent abstraction. First-class functions and anonymous functions seem to be an acquired taste (just one taste, and your programs will quickly acquire them). Objects&#8212;in the strong sense of polymorphic programs&#8212;are well-regarded abstractions.<br /><br /><blockquote>Macros, DSLs, and other means of writing your own mini-language provoke the wildest claims of productivity and equally baseless fears of unreadable, fragile, &#8220;magic&#8221; code built out of gossamer dreams.</blockquote><br /><br />What these all have in common is that these functional abstractions live happily within the syntax provided by the host programming language. They abstract function without abstracting syntax. For the most part, non-syntactic abstraction is uncontroversial.<br /><br />There seems to be debate over syntactic abstraction. Macros, DSLs, and other means of writing your own mini-language provoke the wildest claims of productivity and equally baseless fears of unreadable, fragile, &#8220;magic&#8221; code built out of gossamer dreams. The basic &#8220;problem&#8221; with syntactic abstractions like <code>has_many</code> in Rails or <code>let</code> in Scheme is that syntactic abstractions force you to learn their interface.<br /><br />They are right in your face, especially if they are very brief. Consider:<br /><br /><pre><code>BlogPost.find_or_create_by_name('From Abstraction to Zipf').comments &lt;&lt; Comment.new('bleh!', 'anonymous')<br /></code></pre><br />Don&#8217;t bother searching for the <code>find_or_create_by_name</code> method or the <code>comments&lt;&lt;</code> method in the code base.<br /><br />All the same, syntactic abstractions are <em>just like</em> functional abstractions. You get some wins, and you pay some costs in understanding and potential &#8220;leakiness.&#8221;<br /><br /><strong>Zipf to the rescue</strong><br /><br />So should we zealously abstract everything we can? Or should we conservatively avoid &#8220;magic&#8221; like syntactic abstractions?<br /><br />Every abstraction has a fixed learning cost. That cost is amortized over all of the instances we&#8217;ll encounter. So you need to learn how <code>has_many</code> works just once, and then you benefit every time you read it or write it. This is why abstractions built into a programming language are big wins: you amortize their cost over every program written in the language. Isn&#8217;t that why Java and C# look so much like C++ which looks so much like C? They were offering abstractions that have been paid up for years.<br /><br /><blockquote>Zipf&#8217;s law tells us that each application only needs a very few new kinds of abstractions to get most of the benefits. There are only a few low-hanging fruits, but each is plump and juicy.</blockquote><br /><br />An abstraction built into a framework like <code>Rinda</code> or <code>MapReduce</code> is amortized over fewer programs. A domain-specific abstraction for a single organization is amortized over a very few programs, and an abstraction built into one program is only amortized over instances in the one code base. Unsurprisingly, opportunities for abstraction follow the Zipf distribution.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262610744"><img border="0" src="http://weblog.raganwald.com/uploaded_images/art_of_mop.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262610744" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262610744">The Art of the Metaobject Protocol</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262610744" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is one of the most important books ever written on the subject of building abstractions with objects. If the idea that there is more than one way to structure objects and classes seems surprising, then learning about the Meta-Object protocol will teach you what your language has kept secret.<br /><br /></div>Of course, that distribution is self-similar: the abstractions <em>within a program</em> follow the same distribution as the abstractions <em>within an organization</em>. So even if you aren&#8217;t inventing a new programming language, Zipf can help.<br /><br />Quite simply, it pays to aggressively abstract the few things that are encountered the most frequently. In a CRUD web application, schema relationships like <code>belongs_to</code> are incredibly frequent. There&#8217;s a big win from creating a syntactic abstraction, even if the learning curve looks daunting to newcomers. Creating a domain-specific language for database schema changes is also a big win.<br /><br />Note that we aren&#8217;t saying that <code>has_one</code>, <code>belongs_to</code>, and <code>has_many</code> appear more than 50% of the time. They may be quite infrequent. The point is that they are far more frequent than something else you could abstract, and the other thing will take just as much time to learn to read but will pay off far less often.<br /><br />But should you create a DSL for <a href="http://weblog.raganwald.com/2007/03/approach-to-composing-domain-specific.html">list comprehensions</a> in your CRUD application or just use the language&#8217;s built-in collections? I would say, you would need an application that uses an awful lot of lists before a syntactic abstraction for lists is a win.<br /><br />It might be, but the nice thing is, it probably won&#8217;t be close: Zipf&#8217;s law tells us that each application only needs a very few new kinds of abstractions to get most of the benefits. There are only a few low-hanging fruits, but each is plump and juicy.<br /><br /><em>&#8230;Omega</em><br /><br />I think it is a win to use aggressive abstraction techniques like metaprogramming, but only if you restrain yourself to abstracting the very few things that appear most frequently in your code base. The things that are used less frequently should be abstracted using less aggressive techniques.<br /><br />The resulting program may not be magically 50% shorter than an unabstracted program, because the &#8220;long tail&#8221; of idioms and patterns are simply not worth abstracting away even though we have the tools for doing so.<br /><br />You can probably tell whether a program has the proper level of abstraction just by checking its distribution.<br /><br />If you find a big abstraction framework for one thing while frequently used idioms are expressed using patterns instead of abstractions, you are probably looking at an improperly abstracted program. You have to wade through verbiage to read everything, and the one time you don't need to abstract the code away, you have to chase definitions through indirection.<br /><br />And in a well-written program, I would expect that the things that occur most frequently are expressed at the highest and most powerful levels of abstraction, while things that happen infrequently are expressed in a more direct and explicit way. Such a program would be easy to read throughout.<br /><br /><hr /><br /><ol><li><a href="http://www.amazon.com/gp/product/B000NK48VO?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000NK48VO">Why Abstract?</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=B000NK48VO" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is a delightful and wonderfully brief book that explains the appeal of abstract art in a simple and direct way. It&#8217;s one of the treasures on my bookshelf and I urge you to find a copy through a used book seller.</li><br /><li>Suprised? There is no footnote two. But if there was, it would be to mention that Paul Graham&rsquo;s incredible book <a href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0130305529">On LISP: Advanced Techniques for Common LISP</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0130305529" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is <a href="http://www.bookshelf.jp/texi/onlisp/onlisp.html">freely available online</a>. This is a <em>must read</em> for anyone interested in composing syntactic abstractions in any language.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/04/from-abstraction-to-zipf.html" title="permanent link">12:52 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, April 04, 2007</div>
			

			<div class="Post"><a name="8511257161778092284">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/04/haskell-not-just-for-language-weenies.html" title="permanent link">Don't have a COW, man? What Haskell teaches us about writing Enterprise-scale software</a></span>
					<div style="clear:both;"></div><a href="http://factorlang-fornovices.blogspot.com/">Berlin Brown</a> asked:<br /><blockquote>I read programming.reddit religiously but I rarely see something that could be used in a non-startup environment.  Am I wrong, or are you considering deploying a haskell enterprise web application?  And if the stuff discussed isn&#8217;t relevant for the next 5 years (i.e. an erlang based webapp) will it ever be relevant?<br /></blockquote><br />Yes, I use what I read on <a href="http://programming.reddit.com/" title="reddit.com: programming - what&#39;s new online">programming.reddit.com</a> in my day job. That&#8217;s one of the reasons I <em>have</em> this day job: it&#8217;s part of what I do to sift through all of the cool stuff and find the things that are practical today.<br /><br />Since you mentioned <a href="http://www.haskell.org/" title="HaskellWiki">Haskell</a>:<br /><br />Consider a multi-threaded application with shared memory, like a really big web server that has some big shared collection of things in memory. From time to time you add things to the big collection, from time to time you remove them.<br /><br /><strong>Pessimism and coarse-grained locking</strong><br /><br />One way to arbitrate multiple threads is to have one copy of the collection with strict locking protocols that apply to its coarse-grained operations like <code>add</code>, <code>remove</code>, and <code>fetch</code>.<br /><br />In a language like Java, you can <code>synchonize</code> those methods and you&#8217;re done. You have just implemented <em>mutex locking</em>: only one thread can use the collection at a time. If one thread is fetching something from the collection, all other threads must wait, even if all they want to do is fetch things as well.<br /><br />That sucks <a href="http://rot13.com?text=tbng%20qvpx">tbng qvpx</a>, especially if you do lots of reading: why should thread <code>546</code> have to wait to fetch something just because thread <code>532</code> is currently fetching something?<sup>1</sup><br /><br /><strong>Read and write locks</strong><br /><br />The next improvement is to have two kinds of locks: <em>read locks</em> and <em>write locks</em>. Two or more threads can lock the collection for reading, but if any thread locks the collection for writing, all of the other threads have to wait until it is done.<br /><br />This works for about 17 clock ticks, and then you fix the bug by adding a new rule: if a thread wants a write lock but one or more threads have read locks, it has to wait, but any other threads that want read locks can&#8217;t have them. Even though the only threads with locks have read locks, they still have to wait.<br /><br />The thread waiting to write gets a kind of pending write lock that blocks all other threads from taking out new locks. And then you fix the next bug by saying that all threads waiting wait in a priority queue so that the read threads aren&#8217;t starved by write threads and the write threads aren&#8217;t starved by read threads.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0521663504?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0521663504"><img border="0" src="http://weblog.raganwald.com/uploaded_images/purely_functional_data_structures.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521663504" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0521663504?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0521663504">Purely Functional Data Structures</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521663504" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> takes you step by step through the design and implementation of copy on write collections. These collections <em>can</em> be used in purely functional languages, but they are just as useful in multi-paradigm languages like Java, Ruby, or Python handling multiple threads and performance optimization. The author&#8217;s <a href="http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf" title="Purely Functional Data Structures">thesis</a> is available on line for free.<br /><br /></div>You now have a system that is pretty fast a long as you don&#8217;t write things very often. For example, you could build a fairly nice cache using read-write locking provided it is tuned so that you get lots of hits and only rarely have to drop things from the cache or add things to the cache. But if you&#8217;re doing something like maintaining a big index in memory where you have to make lots of updates, the writes will slow everything down.<br /><br />These kinds of locking protocols are called <em>pessimistic</em> protocols: you assume bad things will happen and prevent them from happening up front by blocking threads from executing until it is safe to proceed.<br /><br /><strong>Multi-version concurrency control</strong><br /><br />Another way to arbitrate multiple threads is to make copies of the collection whenever you perform an update.<sup>2</sup> You maintain multiple <em>versions</em> of the collection. When a thread needs the collection, it grabs the latest copy. When it wants to <code>remove</code> or <code>add</code> elements, it writes a new copy without disturbing an existing copy.<br /><br />This works really well in that threads that only want to read are never blocked. They always run at full speed, even if another thread is in the middle of an update. Hand-waving over how you figure out the whole &#8220;latest copy&#8221; thing, this scheme doesn&#8217;t work so well for threads that write.<br /><br />The problem is one of <em>serialization</em>: this word means, if some set of operations takes place on the collection, the result must be the same as if the operations were conducted one at a time on the collection. There is no guarantee of the <em>order</em> of the operations, just that the result is the same as if they had been carried out in some order.<br /><br />Let&#8217;s use an example. Say our collection is a Map. It starts empty:<br /><br /><pre><code>{ }<br /></code></pre><br /><br />Operation <code>A</code> adds an element:<br /><br /><pre><code>{...a: "A"...}<br /></code></pre><br /><br />As does operation <code>B</code>:<br /><br /><pre><code>{...b: "B"...}<br /></code></pre><br /><br />And operation <code>C</code>:<br /><br /><pre><code>{...c: "C"...}<br /></code></pre><br /><br />If we start with an empty hash and perform all three operations, the result should be <code>{ a: "A", b: "B", c: "C" }</code>, exactly the same result as if each operation were performed serially, one after the other. But what happens if each operation is performed by a thread that grabs the initial copy, <code>{}</code> and writes its result back to the collection? Something called a <em>race condition</em>: the result will be <code>{ a: "A" }</code>, <code>{ b: "B" }</code>, or <code>{ c: "C" }</code>, with the &#8220;winner&#8221; being the last one to write its result.<br /><br />We can fix this problem in a couple of ways. One way is to keep the versions so that reading threads work at full speed, but use mutexes for write locks so that only one thread can write at a time. That&rsquo;s simple, and if you can figure out a cheap way to make copies, works pretty well.<br /><br />That&rsquo;s your pessimistic protocol again (threads that write have to wait on other threads that write), but it&rsquo;s a huge win for threads that read.<br /><br />Making this work is tricky. Copying the entire thing is expensive, so you need to do clever tricks where you only copy the things that change and share the things that don&#8217;t change. And you can get a big, big win if you can avoid write conflicts by arbitrating conflict at a finer grain. For example, a <code>HashMap</code> uses a set of linked lists. If two different threads write to different &#8220;buckets,&#8221; you can merge their results rather than rolling one back and starting again.<br /><br /><div class="book"><hr/><br />One of the best books ever written on the subject of implementing fault tolerant concurrency (either on a single system or a distributed network) is <a href="http://www.amazon.com/gp/product/0201107155?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201107155">Concurrency Control and Recovery in Database Systems</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0201107155" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.<br /><br />Don&rsquo;t be fooled by the word &ldquo;database&rdquo;&mdash;the techniques described are just as useful for implementing distributed algorithms like MapReduce, concurrent data structures like high-performance collections, or for building multi-threaded communication systems based on queues.<br /><br />Like all classics, it&rsquo;s also available <a href="http://research.microsoft.com/users/philbe/ccontrol/">online</a> for free.<br /><br /><hr/> <br /></div>There is a lot of extra overhead for this if a thread wants to write while another thread is reading a version, so it is only a big win if writes are fairly rare. Remember, one of the big wins is that reads <em>never</em> wait on writes because they work with immutable versions of the collection.<br /><br />Depending on how many threads you have, what kinds of operations are most likely, and other factors, this kind of system can be orders of magnitude faster than coarse-grained pessimistic locking.<br /><br />Sometimes you want a slightly different protocol. The aforementioned is often called <em>single write, many reads.</em> It requires threads that plan on writing to know in advance they need to write. But for something like a cache, you don&#8217;t know you need to write until you miss the cache. And then it&#8217;s too late to get a write lock.<br /><br /><strong>Optimism and many writes, many reads</strong><br /><br />The easiest way to avoid having to pre-declare whether a thread is a reader or a writer is by letting all of the threads do as they please. They all get the latest version and chug happily along.<br /><br />When they are finished, if they never executed an <code>add</code> or <code>remove</code> we let go of the copy of the collection and we&#8217;re done. If a thread wants to write, it makes a copy as above and writes to its copy. But it doesn&rsquo;t have to grab a lock while it is writing, so writes don&rsquo;t wait on other writes.<br /><br />Now, if a thread <em>has</em> executed a write (an <code>add</code> or <code>remove</code>), when it is done we check the result to see if it violates serializability.<br /><br />For example, we can number our versions. Let&#8217;s say that <code>{}</code> is version <code>0</code>. The first thread to finish, let&#8217;s say it&#8217;s the thread performing operation <code>B</code>, creates its result: <code>{ b: "B" }</code>. Now it checks the collection to see if anyone has updated it since <code>B</code> read the collection. The collection is still at version <code>0</code>, so <code>B</code> can write its result. <code>B</code> writes <code>{ b: "B" }</code> to the collection and calls it version <code>1</code>.<br /><br />Next <code>A</code> finishes and notices that the collection is at version <code>1</code>. This is a problem, because <code>A</code> is working with an updated version <code>0</code>, so it has to throw out its work, fetch version <code>1</code>, and try again. This is exactly the same thing as using a source code control system like <a href="http://subversion.tigris.org/" title="subversion.tigris.org">Subversion</a> to resolve conflicts.<br /><br />This many reads, many writes strategy is called an <em>optimistic protocol</em> because you do work in the hope that nothing will cause you to throw it out and try again. It&rsquo;s a big win if writes do happen at the same time, but they rarely conflict.<br /><br />For example, if you have a good strategy for <em>merging</em> writes, this is huge.<br /><br /><strong>So what?</strong><br /><br />Well, it would be great if you didn&#8217;t have to reinvent the wheel and have to work out all of the implications when you want to make a really fast shared collection in a multi-threaded environment. What you want is someone to share a wealth of experience about how to make really fast copies of things by only changing the little bits that you change instead of the whole thing, and so forth.<br /><br /><blockquote>I like languages which say, &ldquo;No, you don't want to write it the way you&rsquo;re thinking. There&rsquo;s a vastly better way to solve this whole class of problems.&rdquo; Me: <em>brain explodes</em></blockquote><br /><div style="text-align: right">&mdash;<a href="http://www.randomhacks.net/">Eric M. Kidd</a></div><br /><br />Where do you go for that kind of information? How about to people who spend all day thinking about collections that cannot change because their programming languages are purely functional?<br /><br />Yes, what I&#8217;ve just described is <em>exactly</em> how languages like Haskell implement mutable collections like dictionaries and lists. In purely functional languages, collections never change. Adding something to a collection is really creating a new collection with an extra element. This is the exact same implementation that we need for building optimistically locked collections in a multi-threaded environment!<br /><br />Haskell teaches us extremely useful techniques for writing Enterprise-scale software.<br /><br /><em>And more techniques: <a href="http://weblog.raganwald.com/2007/05/hard-core-concurrency-considerations.html">Hard-core concurrency considerations</a></em><br /><br /><hr /><br /><ol><li>Now, you might be saying, &#8220;what a waste, this is like locking a table in a database when we should be locking <em>rows</em>.&#8221; But if you look at the database closely, it does lock the table when you perform certain actions like deleting a row. Or it does something more complicated, and now that you&rsquo;ve read the entire post, you know what it really does.</li><br /><li>Making Copies on Writes is called <em>copy on write semantics</em>, or COW for short. Chew on that for a while.</ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/04/haskell-not-just-for-language-weenies.html" title="permanent link">10:38 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, March 16, 2007</div>
			

			<div class="Post"><a name="6177546136968725833">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/03/approach-to-composing-domain-specific.html" title="permanent link">An Approach to Composing Domain-Specific Languages in Ruby</a></span>
					<div style="clear:both;"></div><em>Whoa! This looks like a long post with a lot of code snippets. Am I going to have to do a lot of hard thinking, or can I just relax and enjoy a good rambling essay?</em><br /><br />This is a bit long, probably (like all my posts) 200% longer than necessary. If you just want to see a neat DSL that implements Haskell and Python&rsquo;s List Comprehensions written in Ruby, just <a href="#lcir">scroll to the bottom</a>.<br /><br /><em>If I do bother to read it all, will I learn some neat hacks?</em><br /><br />Yes, but you could learn them just as well by reading the <a href="#dslsource">source code</a> directly.<br /><br /><em>So the benefit of reading the whole thing is...?</em><br /><br />The List Comprehensions DSL is the <strong>what</strong>. The source code is the <strong>how</strong>. But the essay is the <strong>why</strong>.<br /><br />Reading the whole thing will take you through some of the pitfalls of writing DSLs and explain why I chose my particular workarounds.<br /><br />Furthermore, <a href="http://weblog.raganwald.com/2007/02/why-ruby-is-not-acceptable.html">there are a lot of corners in Ruby where you can easily assume that things work one way, but really they don&rsquo;t</a>. If you actually try the snippets on your computer, you&rsquo;ll have a much better chance of remembering where the pitfalls are. That&rsquo;s why I tried to give a working example for every point, rather than just explaining things in words.<br /><br />Of course, if you have no interest in writing your own Domain Specific Languages in Ruby just yet... this isn&rsquo;t meant as a <em>popular</em> essay, rather it&rsquo;s meant as an experience report for fellow <em>practitioners</em>. And honestly, there&rsquo;s a world market for maybe five tools for writing DSLs in Ruby.<br /><br />But since you&rsquo;re here, the essay starts below!<br /><br /><hr/><br /><strong>An Approach to Composing Domain-Specific Languages in Ruby</strong><br /><br />Ruby is often touted as a good language for writing Domain-Specific Languages (&#8220;DSLs&#8221;). There are a few arguments in favour of writing a DSL as part of an application.<br /><br />The first argument that comes to mind is that if the application&#8217;s domain experts have a specific natural language or jargon of their own, writing a DSL makes it easy for programmers and domain experts to collaborate. While it is rare to find substantial applications entirely written by non-programmers at this time in <em>any</em> language, it is quite feasible for non-programmers to write or validate portions of an application representing its &#8220;business rules&#8221; or domain logic, while programmers maintain its infrastructure.<br /><br /><pre><code>    include StarbucksDSL<br />    order = latte venti, half_caf, non_fat, no_foam, no_whip<br />    print order.prepare<br /></code></pre><p style="text-align: right;">&#8212;<a href="http://obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf">Building Domain Specific Languages in Ruby</a></p><br />Another argument in favour of a DSL is that even when non-programmers are not involved directly in coding an application, the programmers themselves often have a jargon of their own to describe entities, algorithms and data structures in the application. Having portions of the application written in a language closely resembling the programmer&#8217;s own jargon makes it easy for them to read each other&#8217;s work and understand its intent.<br /><br />Successful examples of DSLs embedded within existing languages and frameworks include <a href="http://www.rubyonrails.org/">Ruby on Rails</a>&#8217; ActiveRecord, where statements such as:<br /><br /><pre><code>    has_and_belongs_to_many :Bar<br />    validates_presence_of :blitz<br />    some_bars = Bar.find_by_tavern_license(license_number)<br /></code></pre><br />Are self-documenting to anyone familiar with relational models.<br /><br />The final argument I&#8217;ll repeat here is that a DSL is a very effective way to separate the <em>what</em> from the <em>how</em> of an algorithm. <a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html">Separation of concerns is a desirable property of good programs</a>, and DSLs provide this separation very clearly. In the ActiveRecord examples above, the exact mechanisms of relating tables, validating records, and performing searches is &#8220;abstracted away&#8221; from the code where the programmer declares how she would like the results used.<br /><br /><strong>Freedom is Slavery</strong><br /><br />DSLs can be hacked together quickly in Ruby (whether they can be made sufficiently robust for your production needs may require considerably more care). Hacking a DSL together with little effort is a benefit, especially when prototyping: sometimes the best way to design a DSL is to try to use it, so you can discover what you need to express.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0672328844"><img border="0" src="http://weblog.raganwald.com/uploaded_images/the_ruby_way.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0672328844?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0672328844">The Ruby Way</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0672328844" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is the perfect second Ruby book for serious programmers. The Ruby Way contains more than four hundred examples explaining how to do everything from distribute Ruby with Rinda to dynamic programming techniques just like these.<br /><br /></div>Some developers have raised the concern that extensive use of &#8220;magic&#8221; features leads to code that cannot be understood or maintained.<sup>1</sup> My own feeling is that DSLs lead to code that is easier to understand, not more difficult to understand. This leaves an argument about maintenance. Some techniques for meta-programming, such as extending core classes like Array, have what you might call &#8220;non-local effects.&#8221;<br /><br />For example, two different pieces of code might try to extend the same core class, interfering with each other. Each works in isolation and passes all of its unit tests. But when plugged into a larger application that uses them together, they break.<br /><br /><blockquote><br />  Lispers are among the best grads of the Sweep-It-Under-Someone-Else&#8217;s-Carpet School of Simulated Simplicity.<br /></blockquote><br /><p style="text-align: right;">&#8212;Larry Wall</p><br />Another problem occurs with extending the <code>Kernel</code> class or creating &#8220;top level&#8221; methods to be used as verbs in a DSL. You end up with name space crowding: you must be very careful that you do not redefine en existing method.<br /><br />To fix this problem, the code that implements the DSL needs to be contained so that it does not interfere with other code. We can still implement verbs as methods, but we must implement those methods in separate objects, classes, or modules.<br /><br /><strong>Zen in the Art of Program Maintenance</strong><br /><br />An established technique for implementing methods in objects is to define the methods and then execute a block of code using <code>instance_eval</code> so that it has access to the object&#8217;s methods.<br /><br /><blockquote><br />  I&#8217;m trying to get the Zen of building DSLs using Ruby. After reading a dozen or so pieces referenced by my favourite search engine, I have a feeling I&#8217;m still not quite getting it.<br /></blockquote><br /><p style="text-align: right;">&#8212;<a href="http://pluralsight.com/blogs/dbox/archive/2006/05/07/22985.aspx">Don Box</a></p><br />You know, code expresses an idea better than words express an idea&#8230; when the idea is about coding. Please try this example in irb. Don&#8217;t just skim the text and nod: there&#8217;s a powerful learning mechanism at work when you physically do things as you&#8217;re learning, even if it&#8217;s just copying, pasting, comparing the result in one window to the text in another, and so on:<br /><br /><pre><code>def bjarne<br />    'Barney'<br />end<br /><br />dsl = Object.new<br />def dsl.phred<br />    'Fred'<br />end<br /><br />plus = ' plus '<br /><br />print dsl.instance_eval {<br />    phred + plus + bjarne<br />}<br />##### "Fred plus Barney"<br /></code></pre><br />What does this show? Well, we have created a way to use a method defined in our <code>dsl</code> object, a local variable <code>plus</code>, and a top-level method <code>bjarne</code>. We can imagine scaling this up to defining a rich DSL in our DSL object and being able to mix verbs from the DSL with instance variables and other methods as we please.<br /><br />Touching back on the subject of containment, we have defined <code>bjarne</code> in <code>Kernel</code>. Now <code>bjarne</code> is essentially global. If we already defined <code>bjarne</code> somewhere else, we just clobbered it. And if we later run a piece of code that defines <code>bjarne</code>, we&#8217;ll clobber our own version. <code>phred</code> is different. It&#8217;s defined inside of an object, and it doesn&#8217;t conflict with any other <code>phred</code> we define elsewhere.<br /><br />Great! So&#8230; Can we cite a few examples of this technique in action (such as <a href="http://weblog.jamisbuck.org/2006/4/20/writing-domain-specific-languages">Jamis&#8217; post</a> where he calls <code>phred</code> and <code>bjarne</code> examples of <em>Sandboxing</em> and <em>Top-level methods</em>) and end the post here?<br /><br />No. The code above looks fine. But there is a hidden problem with this sandboxing technique:<br /><br /><pre><code>MyDsl = Object.new<br /><br />def MyDsl.phred<br />    'Fred'<br />end<br /><br />class ClientCode<br /><br />    def bjarne<br />        'Barney'<br />    end<br /><br />    def friends<br />        plus = ' plus '<br />        MyDsl.instance_eval { phred + plus + bjarne }<br />    end<br /><br />end<br /><br />ClientCode.new.friends<br />##### -:15:in `friends': undefined local variable or method `bjarne' for # (NameError) from -:15:in `friends' from -:20<br /></code></pre><br /><a href="http://worsethanfailure.com">WTF</a>?! This looks just like our top-level example, but we&#8217;ve placed our code inside of a <code>ClientCode</code> method. And <code>bjarne</code> is a method in ClientCode: this way we can continue to separate concerns, keeping <code>phred</code> inside our DSL and <code>bjarne</code> inside of the class where we are using the DSL. But it doesn&#8217;t work.<br /><br /><strong>Why <code>instance_eval</code> breaks (in tedious detail)</strong><br /><br />As you know, everything in Ruby is either a variable or a method (how it figures out the difference is a major irritation). When you invoke a method, you are actually sending a <em>message</em> to a <em>receiver</em>.<sup>2</sup> Sometimes you name the receiver (<code>some_object.a_method</code>), and there is no ambiguity.<br /><br />But when you just name the method (like <code>bjarne</code>), Ruby tries to find the method for itself. It does so by looking to see whether it is an instance method, in which case it behaves like <code>self.bjarne</code>. If not, it looks to see whether <code>bjarne</code> is top-level, in which case it calls that method in the <code>Kernel</code>. See for yourself:<br /><br /><pre><code>def foo<br />  'top level foo'<br />end<br /><br />def bar<br />  'top level bar'<br />end<br /><br />class Test<br />  def bar<br />    'instance method bar'<br />  end<br />  def test<br />    p foo<br />    p bar<br />  end<br />end<br /><br />Test.new.test<br />##### "top level foo" "instance method bar"<br /></code></pre><br />See? It looks for instance methods and then for top-level methods if it can&#8217;t find anything. (Again, we are hand-waving over the pesky problem with instance variables in the case where we don&#8217;t use <code>()</code>). What&#8217;s the problem? Well, I actually mis-described what happens. Here it is again, with more precision:<br /><br />It looks for methods defined in the object <code>self</code>, and then for top-level methods if it can&#8217;t find anything. Of course, <code>self</code> is the current object. Unless it isn&#8217;t: That&#8217;s what <code>instance_eval</code> does: it evaluates a block but it changes <code>self</code> to point to its receiver instead of the object where the code is executing. Everything else stays the same. One more example to show the mechanism:<br /><br /><pre><code>def foo<br />  'top level foo'<br />end<br /><br />def bar<br />  'top level bar'<br />end<br /><br />class Test<br />  def bar<br />    'instance method bar'<br />  end<br />  def blitz<br />    'current object blitz'<br />  end<br />  def test<br />    p foo<br />    p bar<br />    o = Object.new<br />    def o.blitz<br />        'redefined self blitz'<br />    end<br />    p o.instance_eval { blitz }<br />    p o.instance_eval { 'bar within o gives: ' + bar }<br />  end<br />end<br /><br />Test.new.test<br />##### "top level foo" "instance method bar" "redefined self blitz" "bar within o gives: top level bar"<br /></code></pre><br />Now we see: when we use <code>instance_eval</code>, we route around our current object and all of our methods are ignored within the block. Ruby really only has two levels of scope: whatever belongs to self and whatever belongs to Kernel.<br /><br />This state of affairs is unsatisfactory: we would like to introduce a DSL in such a way that we retain access to all of our methods without kludges (like storing the current object in an instance variable).<br /><br /><strong>Nesting Scopes</strong><br /><br /><div class="book"><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://weblog.raganwald.com/uploaded_images/seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is devoted to the myriad uses of first class functions. This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will be able to compose programs from functions in powerful new ways.<br><br></div>You can think of the current <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29">scope</a> as being nested inside of the top-level scope. <code>instance_eval</code> doesn&#8217;t change the scope for things like local variables, it just points <code>self</code> elsewhere.<br /><br />What we want is a new scope for our DSL nested inside of the current scope. So when we search for a method, we should check the DSL. If we don&#8217;t find it there, check the current object&#8217;s scope. If we don&#8217;t find it there, check the top-level.<br /><br /><blockquote><br />  Those who do not learn from the History of Lisp are doomed to repeat it.<br /></blockquote><br />Oops. <a href="http://www-formal.stanford.edu/jmc/">John McCarthy</a> called from 1960. He wants Lisp&#8217;s <em>dynamic scoping</em> back. Yes, our new feature is almost fifty years old. This is why either a through grounding in CS theory or a hobbyist&#8217;s interest in the history of programming are important for programming: much of what we want to do has already been done before, and sometimes in unexpected contexts. Who would have thought that a technique for helping programmers collaborate with Bond Traders has roots in Lisp 1.5?<br /><br /><a href="http://raganwald.com/source/dsl_and_let.html">Here&#8217;s an implementation of a nested scope construct</a> that does exactly what we want. You declare a new class that extends <code>DomainSpecificLanguage</code>, and then you can use methods from your DSL, from your current object, and from the top-level (if you so choose). For example:<br /><br /><pre><code>require 'dsl'<br /><br />class MyDSL &lt; DomainSpecificLanguage<br /><br />  def bjarne<br />    'Barney'<br />  end<br /><br />end<br /><br />class TheGreat<br /><br />  def phred<br />    'Fredrick'<br />  end<br /><br />  def test<br />    plus = ' plus '<br />    MyDSL.eval { p phred + plus + bjarne }<br />  end<br /><br />end<br /><br />TheGreat.new.test<br />##### "Fredrick plus Barney"<br /></code></pre><br />This does <em>exactly</em> what we want with methods.<br /><br />There's also a single extension to <code>kernel</code>, the method <code>with</code>. <code>with</code> replaces the <code>eval</code> method so you can also say:<br /><pre><code><br />    with MyDSL do<br />      p phred + plus + bjarne<br />    end<br /></code></pre><br /><br />The <code>eval</code> method creates a new instance of your DSL class, so you can track state within an evaluation. For example:<br /><br /><pre><code>class Censor &lt; DomainSpecificLanguage<br />  attr_reader :ok_on_tv<br /><br />  def initialize (given_binding)<br />    super(given_binding)<br />    @ok_on_tv = true<br />  end<br /><br />  def say something<br />    something.split.each do |word|<br />      @ok_on_tv = false if ['feces', 'urine', 'love', 'pudendum', 'fellator', 'oedipus', 'mammaries'].include?(word)<br />    end<br />  end<br /><br />end<br /><br />class GeorgeCarlin<br />  def test<br />    Censor.eval {<br />      say "People much wiser than I have said, I'd rather have my son watch a film with two people making love than two people trying to kill one other."<br />      say "And I of course agree. I wish I know who said it first, and I agree with that."<br />      ok_on_tv<br />    }<br />  end<br />end<br /><br />p GeorgeCarlin.new.test<br />##### "false"<br /></code></pre><br /><strong>let</strong><br /><br />The first obvious drawback of this approach is that the blocks we pass to <code>eval</code> cannot take parameters. For this reason, rumour has it that a method called <code>instance_exec</code> will be added to Ruby in 1.9. (There are some <a href="http://termos.vemod.net/object-instance_exec">implementations</a> available that work in Ruby 1.8 if you would like to experiment.)<br /><br />The second is that you don&#8217;t get anything like nested local variables, a &#8216;la Pascal, Scheme, or any other language with block structure. Block structure is very powerful: You can use a variable within a particular scope and nowhere else. Here&#8217;s a trivial example:<br /><br /><pre><code>with Let do<br />  let :x =&gt; 0, :y =&gt; 1 do<br />    assert_equal(1, x + y)<br />    let :x =&gt; 2 do<br />      assert_equal(3, x + y) <br />    end<br />    assert_equal(0, x)<br />  end <br />end<br /></code></pre><br />We're using the <code>with</code> syntax. In the <code>Let</code> DSL, there&rsquo;s a new method called <code>let</code>. <code>let</code> creates a new DSL within <code>Let</code>. You can see that re-declaring <code>x</code> does not clobber the value in the outer scope. That is because when <code>let</code> wrote a new DSL, it added <code>x</code> and <code>y</code> as methods.<br /><br />So really, that block of code says &ldquo;Write a new DSL where <code>x</code> and <code>y</code> are methods returning zero and one. Execute some code in that new DSL. That code will create <i>another</i> DSL where <code>x</code> is a method returning two.&rdquo;<br /><br />Because <code>let</code> defines methods and not local variables, bad things happen when you try to override real local variables. It&#8217;s best to use <code>Let</code> for some things and local variables for others, but not mix the two.<br /><br />Like what, you ask?<br /><br /><strong><a name="lcir">List Comprehensions in Ruby</a></strong><br /><br />A <a href="http://en.wikipedia.org/wiki/List_comprehension">List Comprehension</a> is syntactic sugar that lets you build collections using set-like notation. For example, <code>S = [ x | x&lt;-[0..], x^2&gt;3 ]</code> is a list comprehension in Haskell.<br /><br />Here is a <a href="http://raganwald.com/source/comprehensions.html">List Comprehensions DSL in Ruby</a>. Let&#8217;s say we&#8217;re building up a multiplication table. We want tuples of the form <code>[x, y, x * y]</code> given <code>x</code> is in the range <code>1..12</code> and <code>y</code> is in the range <code>1..12</code>. Let&#8217;s write that:<br /><pre><code><br />require 'comprehension'<br /><br />class MultiplicationTable<br />  def twelve_by_twelve<br />    with Comprehension::DSL do<br />      list { [x, y, x * y] }.given(:x =&gt; 1..12, :y =&gt; 1..12)<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve<br />##### [[1, 1, 1], [1, 2, 2], [2, 1, 2], [1, 3, 3], [2, 2, 4] ...<br /></code></pre><br />(In everyday use, you don&rsquo;t need a class and a method for each comprehension: the important bit is <code>list {</code> <code>[x, y, x * y]</code> <code>}.given(:x =&gt; 1..12,</code> <code>:y =&gt; 1..12)</code>. I just wrote it this way so you could see that comprehensions work fine inside of methods. You can also use more than one comprehension inside of a single <code>with Comprehension::DSL do...</code> <code>end</code> block: see the unit tests for examples.)<br /><br />The expression in the block doesn&#8217;t have to be a tuple:<br /><pre><code><br />class MultiplicationTable<br />  def twelve_by_twelve<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(:x =&gt; 1..12, :y =&gt; 1..12)<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve<br />##### ["1 times 1 is 1", "1 times 2 is 2", "2 times 1 is 2", "1 times 3 is 3", "2 times 2 is 4", ...<br /></code></pre><br />And you can stick a &#8220;where&#8221; block on the end:<br /><pre><code><br />class MultiplicationTable<br />  def twelve_by_twelve_odds<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(:x =&gt; 1..12, :y =&gt; 1..12) { (x % 2 == 1) &amp;&amp; (y % 2 == 1) }<br />    end<br />  end<br />end<br />p MultiplicationTable.new.twelve_by_twelve_odds<br />##### ... 3 times 5 is 15", "5 times 3 is 15", "7 times 1 is 7", "1 times 9 is 9", ...<br /></code></pre><br /><br />Would you like to nest them? Your expression is the interpreter&rsquo;s command:<br /><pre><code><br />class MultiplicationTable<br />  def odds_times_evens<br />    with Comprehension::DSL do<br />      list { "#{x} times #{y} is #{x * y}" }.given(<br />          :x => list { x }.given(:x => 1..12) { x % 2 == 0 } , <br />          :y => list { x }.given(:x => 1..12) { x % 2 == 1 } )<br />    end<br />  end<br />end<br />p MultiplicationTable.new.odds_times_evens<br />##### ... "2 times 11 is 22", "4 times 9 is 36", "6 times 7 is 42", ...<br /></code></pre><br /><strong>List Comprehensions and Let</strong><br /><br />What is the relationship to <code>Let</code>? Well, <code>Let</code> builds the scopes needed for evaluating the where clause and the block defining the elements of the list. Yes, we&#8217;ve built a DSL on top of a DSL on top of a DSL. Does this seem like weird trickery? I don&#8217;t know why. Do you have <em>any idea</em> how many levels of abstraction are responsible for you reading this essay right now?<br /><br />This is what we humans do: we build tools on top of tools. Your browser runs on an OS, possibly in a VM, perhaps in a hypervisor, on top of a BIOS, and on and on. This is the normal state of affairs, not an exception.<br /><br /><strong>Closing Remarks</strong><br /><br />It is possible to build DSLs in Ruby to facilitate cross-functional teamwork and separation of concerns. Care must be taken to avoid polluting the top-level name space, but it is possible to work within sandboxes and still have access to the current object&#8217;s context.<br /><br />Oh yes, and programming is fun as always<br /><br /><strong><a name="dslsource">Source Code</a></strong><br /><br /><em>Update: The copy of <code>dsl.rb</code> has been updated to the latest version. I had committed a rather typical manual synchronization error: I copied the latest file to the wrong directory when I first posted this. Thanks, Justin!</em><br /><br /><ul><li><a href="http://raganwald.com/source/dsl_and_let.html">DomainSpecificLanguage and Let</a></li><br /><li><a href="http://raganwald.com/source/comprehensions.html">Comprehension</a></li></ul><br /><br /><strong>How to try it for yourself</strong>: Open <a href="http://raganwald.com/source/dsl_and_let.html">DomainSpecificLanguage and Let</a>. Save the text only (not the HTML) as <code>dsl.rb</code>. Open <a href="http://raganwald.com/source/comprehensions.html"><code>Comprehension</code></a></li>. Save the text only as anything you like, as long as it is in the same directory as <code>dsl.rb</code>: I use <code>comprehension.rb</code>. Run <code>comprehension.rb</code>.<br /><hr /><ol><li>I generally call &#8220;<a href="http://en.wikipedia.org/wiki/Bullshit%21">Bullshit</a>!&#8221; on any line of reasoning that sets up a straw man argument just to knock it down. So read on with skepticism!</li><br /><li>Alan Kay has said that he regrets popularizing the notion of &#8220;Object-Oriented&#8221; programming, and that he should have called it &#8220;Message-Oriented&#8221; programming.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/03/approach-to-composing-domain-specific.html" title="permanent link">12:19 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, March 11, 2007</div>
			

			<div class="Post"><a name="1990194990621630996">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html" title="permanent link">Why Why Functional Programming Matters Matters</a></span>
					<div style="clear:both;"></div>I recently re-read the amazing paper <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a> (&#8220;WhyFP&#8221;). Although I thought that I understood WhyFP when I first read it a few years ago, when I had another look last weekend I suddenly understood that I had missed an important message.<sup>1</sup><br /><br />Now obviously (can you guess from the title?) the paper is about the importance of one particular style of programming, functional programming. And when I first read the paper, I took it at face value: I thought, &#8220;Here are some reasons why functional programming languages matter.&#8221;<br /><br />On re-reading it, I see that the paper contains insights that apply to programming in general. I don&#8217;t know why this surprises me. The fact is, programming language design revolves around program design. A language&#8217;s design reflects the opinions of its creators about the proper design of programs.<br /><br />In a very real sense, the design of a programming language is a strong expression of the opinions of the designer about good programs. When I first read WhyFP, I thought the author was expressing an opinion about the design of good programming languages. Whereas on the second reading, I realized he was expressing an opinion about the design of good programs.<br /><br /><strong>Can we add though subtraction?</strong><br /><br /><blockquote>It is a logical impossibility to make a language more powerful by omitting features, no matter how bad they may be.</blockquote><br />Is this obvious? So how do we explain that one reason Java is considered &#8220;better than C++&#8221; is because it omits manual memory management? And one reason many people consider Java &#8220;better than Ruby&#8221; is because you cannot open base classes like <code>String</code> in Java? So no, it is not obvious. Why not?<br /><br />The key is the word <em>better</em>. It&#8217;s not the same as the phrase <em>more powerful</em>.<sup>2</sup> The removal or deliberate omission of these features is an expression about the idea that programs which do not use these features are better than programs which do. Any feature (or removal of a feature) which makes the programs written in the language better makes the language better. Thus, it <em>is</em> possible to make a language &#8220;better&#8221; by removing features that are considered harmful,<sup>3</sup> if by doing so it makes programs in the language better programs.<br /><br />In the opinion of the designers of Java, programs that do not use <code>malloc</code> and <code>free</code> are safer than those that do. And the opinion of the designers of Java is that programs that do not modify base classes like <code>String</code> are safer than those that do. The Java language design emphasizes a certain kind of safety, and to a Java language designer, safer programs are better programs.<br /><br />&#8220;More powerful&#8221; is a design goal just like &#8220;safer.&#8221; But yet, what does it mean? We understand what a safer language is. It&#8217;s a language where programs written in the language are safer. But what is a &#8220;more powerful&#8221; language? That programs written in the language are more powerful? What does that mean? Fewer symbols (the &#8220;golf&#8221; metric)?<br /><br />WhyFP asserts that you cannot make a language more powerful through the removal of features. To paraphrase an argument from the paper, <em>if removing harmful features was useful by itself, C and C++ programmers would simply have stopped using</em> <code>malloc</code> <em>and</em> <code>free</code> <em>twenty years ago</em>. Improving on C/C++ was not just a matter of removing <code>malloc</code> and <code>free</code>, it was also a matter of adding automatic garbage collection.<br /><br /><blockquote>This space, wherein the essay ought to argue that Java compensates for its closed base classes by providing a more powerful substitute feature, left intentionally blank.</blockquote><br />At the same time, there is room for arguing that some languages are improved by the removal of harmful features. To understand why they may be improved but not more powerful, we need a more objective definition of what it means for a language to be &#8220;more powerful.&#8221; Specifically, what quality does a more powerful programming language permit or encourage in programs?<br /><br />When we understand what makes a program &#8220;better&#8221; in the mind of a language designer, we can understand the choices behind the language.<br /><br /><strong>Factoring</strong><br /><br />Factoring a program is the act of dividing it into units that are composed to produce the working software.<sup>4</sup> Factoring happens as part of the design. (<em>Re</em>-factoring is the act of rearranging an existing program to be factored in a different way). If you want to compare this to factoring in number theory, a well designed program has lots of factors, like the number <code>3,628,800</code> (<code>10!</code>). A <a href="http://www.laputan.org/mud/">Big Ball of Mud</a> is like the number <code>3,628,811</code>, a prime.<br /><br />Composition is the construction of programs from smaller programs. So factoring is to composition as division is to multiplication.<br /><br />Factoring programs isn&#8217;t really like factoring simple divisors. The most important reason is that programs can be factored in orthogonal ways. When you break a program into subprograms (using methods, subroutines, functions, what-have-you), that&#8217;s one axis of factoring. When you break an a modular program up into modules, that&#8217;s another, orthogonal axis of factoring.<br /><br />Programs that are well-factored are more desirable than programs that are poorly factored.<br /><br /><blockquote>In computer science, <strong>separation of concerns</strong> (SoC) is the process of breaking a program into distinct features that overlap in functionality as little as possible. A concern is any piece of interest or focus in a program.<br />  <br />  SoC is a long standing idea that simply means a large problem is easier to manage if it can be broken down into pieces; particularly so if the solutions to the sub-problems can be combined to form a solution to the large problem.<br />  <br />  The term separation of concerns was probably coined by Edsger W. Dijkstra in his paper <a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">On the role of scientific thought</a>.</blockquote><br />&#8212;Excerpts from the Wikipedia entry on <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns</a><br /><br />Programs that separate their concerns are well-factored. There&#8217;s a principle of software development, <a href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=211189&amp;creative=374929&amp;creativeASIN=0201379430" title="Object Design: Roles, Responsibilities, and Collaborations">responsibility-driven design</a>. Each component should have one clear responsibility, and it should have everything it needs to carry out its responsibility.<br /><br />This is the separation of concerns again. Each component of a program having one clearly defined responsibility means each concern is addressed in one clearly defined place.<br /><br /><blockquote>Let’s ask a question about Monopoly (and Enterprise software). Where do the rules live? In a noun-oriented design, the rules are smooshed and smeared across the design, because every single object is responsible for knowing everything about everything that it can ‘do’. All the verbs are glued to the nouns as methods.</blockquote><div>&#8212;<a href="http://weblog.raganwald.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a></div><br /><br />In a game design where you have important information about a rule smeared all over the object hierarchy, you have very poor separation of concerns. It looks at first like there&#8217;s a clear factoring &#8220;Baltic Avenue has a method called <code>isUpgradableToHotel</code>,&#8221; but when you look more closely you realize that every object representing a property is burdened with knowing almost all of the rules of the game.<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256100X"><img border="0" src="http://weblog.raganwald.com/uploaded_images/seasoned_schemer.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256100X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256100X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is devoted to the myriad uses of first class functions. This book is approachable and a delight to read, but the ideas are provocative and when you close the back cover you will be able to compose programs from functions in powerful new ways.<br><br></div>The concerns are not clearly separated: there&#8217;s no one place to look and understand the behaviour of the game.<br /><br />Programs that separate their concerns are better programs than those that do not. And languages that facilitate this kind of program design are better than those that hamper it.<br /><br /><strong>Power through features that separate concerns</strong><br /><br />One thing that makes a programming language &#8220;more powerful&#8221; in my opinion is the provision of more ways to factor programs. Or if you prefer, <em>more axes of composition</em>. The more different ways you can compose programs out of subprograms, the more powerful a language is. <br /><br />Do you remember <a href="http://en.wikipedia.org/wiki/Structured_programming">Structured Programming</a>? The gist is, you remove <code>goto</code> and you replace it with well-defined control flow mechanisms: some form of subroutine call and return, some form of selection mechanism like Algol-descendant <code>if</code>, and some form of repetition like Common Lisp&#8217;s <code>loop</code> macro.<br /><br />Dijkstra&#8217;s view on structured programming was that it promoted the separation of concerns. The factoring of programs into blocks with well-defined control flow made it easy to understand blocks and rearrange programs in different ways. Programs with indiscriminate jumps did not factor well (if at all): they were difficult to understand and often could not be rearranged at all.<br /><br />Structured <a href="http://dmoz.org/Computers/Programming/Languages/Assembly/68k/">68k ASM</a> programming is straightforward in theory. You just need a lot of boilerplate, design patterns, and the discipline to stick to your convictions. But of course, lots of 68k ASM programming in practice is only partially structured. Statistically speaking, 68k ASM is not a structured programming language even though structured programming is possible in 68k ASM.<br /><br />Structured Pascal programming is straightforward both in theory and in practice. Pascal facilitates separation of concerns through structured programming. So we say that Pascal &#8220;is more powerful than 68k ASM&#8221; to mean that in practice, programs written in Pascal are more structured than programs written in 68k ASM because Pascal provides facilities for separating concerns that are missing in 68k ASM.<br /><br /><strong>For example: working with lists</strong><br /><br />Consider this snippet of iterative code:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_java"><span class="storage storage_type storage_type_java">int</span> numberOfOldTimers = <span class="constant constant_numeric constant_numeric_java">0</span>;<br /><span class="meta meta_definition meta_definition_constructor meta_definition_constructor_java"><span class="entity entity_name entity_name_function entity_name_function_constructor entity_name_function_constructor_java">for</span> <span class="meta meta_definition meta_definition_param-list meta_definition_param-list_java">(<span class="storage storage_type storage_type_java">Employee</span> emp: employeeList</span>) </span>{<br /><span class="meta meta_definition meta_definition_constructor meta_definition_constructor_java">    <span class="entity entity_name entity_name_function entity_name_function_constructor entity_name_function_constructor_java">for</span> <span class="meta meta_definition meta_definition_param-list meta_definition_param-list_java">(<span class="storage storage_type storage_type_java">Department</span> dept: departmentsInCompany</span>) </span>{<br />        <span class="keyword keyword_control keyword_control_java">if</span> (emp.getDepartmentId() <span class="keyword keyword_operator keyword_operator_comparison keyword_operator_comparison_java">==</span> dept.getId() <span class="keyword keyword_operator keyword_operator_logical keyword_operator_logical_java">&amp;&amp;</span> emp.getYearsOfService() <span class="keyword keyword_operator keyword_operator_comparison keyword_operator_comparison_java">&gt;</span> dept.getAge()) {<br />            <span class="keyword keyword_operator keyword_operator_increment-decrement keyword_operator_increment-decrement_java">++</span>numberOfOldTimers;<br />        }<br />    }<br />}<br /></span><br /></pre><br />This is an improvement on older practices.<sup>5, 6</sup> For one thing, the <code>for</code> loops hide the implementation details of iterating over <code>employeeList</code> and <code>departmentsInCompany</code>. Is this better because you have less to type? Yes. Is it better because you eliminate the fence-post errors associated with loop variables? Of course.<br /><br />But most interestingly, you have the beginnings of a <em>separation of concerns</em>: how to iterate over a single list is separate from what you do in the iteration.<br /><br /><blockquote>Try calling a colleague on the telephone and explaining what we want as succinctly as possible. Do you say &#8220;We want a loop inside a loop and inside of that an if, and&#8230;&#8221;? Or do you say &#8220;We want to count the number of employees that have been with the company longer than their departments have existed.&#8221;</blockquote><br />One problem with the <code>for</code> loop is that it can only handle one loop at a time. We have to nest loops to work with two lists at once. This is patently wrong: there&#8217;s nothing inherently nested about what we&#8217;re trying to do. We can demonstrate this easily: try calling a colleague on the telephone and explaining what we want as succinctly as possible. Do you say &#8220;We want a loop inside a loop and inside of that an if, and&#8230;&#8221;?<br /><br />No, we say, &#8220;We want to count the number of employees that have been with the company longer than their departments have existed.&#8221; There&#8217;s no discussion of nesting.<br /><br />In this case, a limitation of our tool has caused our concerns to intermingle again. The concern of &#8220;How to find the employees that have been with the company longer than their departments have existed&#8221; is intertwined with the concern of &#8220;count them.&#8221; Let&#8217;s try a different notation that separates the details of <em>how to find</em> from the detail of <em>counting what we&#8217;ve found</em>:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_ruby">old_timers = (employees * departments).select <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|emp, dept|<br />  emp.department_id == dept.id &amp;&amp; emp.years_of_service &gt; dept.age<br /><span class="keyword keyword_control keyword_control_ruby">end</span><br />number_of_old_timers = old_timers.size<br /></span><br /></pre><br />Now we have separated the concern of finding from counting. And we have hidden the nesting by using the <code>*</code> operator to create a Cartesian product of the two lists. Now let&#8217;s look at what we used to filter the combined list, <code>select</code>. The difference is more than just semantics, or counting characters, or the alleged pleasure of fooling around with closures.<br /><br /><div class="book"><br>  <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089"><img src="http://weblog.raganwald.com/uploaded_images/haskell_school_of_expression.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br>I’m not a Haskell user (yet), but <a name="evtst|a|0521644089" href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;amp;amp;o=1&amp;a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> has received rave reviews and comes with solid recommendations. It’s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you’re feeling generous!<br><br></div><code>*</code> and <code>select</code> facilitates separating the concerns of how to filter things (like iterate over them applying a test) from the concern of what we want to filter. So languages that make this easy are more powerful than languages that do not. In the sense that they facilitate additional axes of factoring.<br /><br /><strong>The Telephone Test</strong><br /><br />Let&#8217;s look back a few paragraphs. We have an example of the &#8220;Telephone Test:&#8221; when code very closely resembles how you would explain your solution over the telephone, we often say it is &#8220;very high level.&#8221; The usual case is that such code expresses a lot more <em>what</em> and a lot less <em>how</em>. The concern of what has been very clearly separated from the concern of how: you can&#8217;t even <em>see</em> the how if you don&#8217;t go looking for it.<br /><br />In general, we think this is a good thing. But it isn&#8217;t free: somewhere else there is a mass of code that supports your brevity. When that extra mass of code is built into the programming language, or is baked into the standard libraries, it is nearly free and obviously a Very Good Thing. A language that doesn&#8217;t just separate the concern of how but does the work for you is very close to &#8220;something for nothing&#8221; in programming.<br /><br />But sometimes you have to write the <em>how</em> as well as the <em>what</em>. It isn&#8217;t always handed to you. In that case, it is still valuable, because the resulting program still separates concerns. It still factors into separate components. The components can be changed.<br /><br />I recently separated the concern of describing &#8220;how to generate sample curves for some data mining&#8221; from the concern of &#8220;managing memory when generating the curves.&#8221; I did so by writing my own lazy evaluation code (Both the <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html">story</a> and the <a href="http://raganwald.com/source/lazy_lists.html">code</a> are on line). Here&#8217;s the key &#8220;what&#8221; code that generates an infinite list of parameters for sample bezi&eacute;r curves:<br /><br /><pre class="textmate-source sunburst"><br /><span class="source source_ruby"><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">magnitudes</span></span><br />  <span class="support support_class support_class_ruby">LazyList</span>.binary_search(<span class="constant constant_numeric constant_numeric_ruby">0.0</span>, <span class="constant constant_numeric constant_numeric_ruby">1.0</span>)<br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">control_points</span></span><br />  <span class="support support_class support_class_ruby">LazyList</span>.cartesian_product(magnitudes, magnitudes) <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|x, y|<br />    <span class="support support_class support_class_ruby">Dictionary</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>( <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; x, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; y )<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /><br /><span class="meta meta_function meta_function_method meta_function_method_without-arguments meta_function_method_without-arguments_ruby"><span class="keyword keyword_control keyword_control_def keyword_control_def_ruby">def</span> <span class="entity entity_name entity_name_function entity_name_function_ruby">order_one_flows</span></span> args = {}<br />  height, width = (args[<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>height</span>] || <span class="constant constant_numeric constant_numeric_ruby">100.0</span>), (args[<span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>width</span>] || <span class="constant constant_numeric constant_numeric_ruby">100.0</span>)<br />  <span class="support support_class support_class_ruby">LazyList</span>.cartesian_product(<br />      magnitudes, control_points, control_points, magnitudes<br />  ) <span class="keyword keyword_control keyword_control_ruby keyword_control_ruby_start-block">do </span>|initial_y, p1, p2, final_y|<br />    <span class="support support_class support_class_ruby">FlowParams</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>(<br />      height, width, initial_y * height,<br />      <span class="support support_class support_class_ruby">CubicBezierParams</span>.<span class="keyword keyword_other keyword_other_special-method keyword_other_special-method_ruby">new</span>(<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x</span> =&gt; width,          <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y</span> =&gt; final_y * height,<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x1</span> =&gt; p1.x * width,  <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y1</span> =&gt; p1.y * height,<br />        <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>x2</span> =&gt; p2.x * width,  <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby"><span class="punctuation punctuation_definition punctuation_definition_constant punctuation_definition_constant_ruby">:</span>y2</span> =&gt; p2.y * height<br />      )<br />    )<br />  <span class="keyword keyword_control keyword_control_ruby">end</span><br /><span class="keyword keyword_control keyword_control_ruby">end</span><br /></span><br /></pre><br />That&#8217;s it. Just as I might tell you on the phone: &#8220;Magnitudes&#8221; is a list of numbers between zero and one created by repeatedly dividing the intervals in half, like a binary search. &#8220;Control Points&#8221; is a list of the Cartesian product of magnitudes with itself, with one magnitude assigned to <code>x</code> and the other to <code>y</code>. And so forth.<br /><br />I will not say that the sum of this code and the code that actually implements infinite lists is shorter than imperative code that would intermingle loops and control structures, <a href="http://www.amazon.com/gp/product/B000002J27?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000002J27" title="A Trick of the Tail by Genesis, Track 2, Entangled">entangling</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=B000002J27" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <em>what</em> with <em>how</em>. I will say that it separates the concerns of what and how, and it separates them in a different way than <code>select</code> separated the concerns of what and how.<br /><br /><strong>So why does &#8220;Why Functional Programming Matters&#8221; matter again?</strong><br /><br />The great insight is that better programs separate concerns. They are factored more purely, and the factors are naturally along the lines of responsibility (rather than in Jenga piles of <code>abstract</code> <code>virtual</code> <code>base</code> <code>mixin</code> <code>module</code> <code>class</code> <code>proto_</code> <code>extends</code> <code>private</code> <code>implements</code>). Languages that facilitate better separation of concerns are more powerful in practice than those that don&#8217;t.<br /><br />WhyFP illustrates this point beautifully with the same examples I just gave: <a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">first-class functions</a> and <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html">lazy evaluation</a>, both prominent features of modern functional languages like Haskell.<br /><br />WhyFP&#8217;s value is that it expresses an opinion about what makes programs better. It backs this opinion up with reasons why modern functional programming languages are more powerful than imperative programming languages. But even if you don&#8217;t plan to try functional programming tomorrow, the lessons about better programs are valuable for your work in <em>any</em> language today.<br /><br />That&rsquo;s why <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a> matters.<br /><br /><hr /><ol><li>And now I&#8217;m worried: what am I <em>still</em> missing?</li><br /><li>Please let&#8217;s not have a discussion about <a href="http://en.wikipedia.org/wiki/Turing-complete">Turing Equivalence</a>. Computer Science &#8220;Theory&#8221; tells us &#8220;there&#8217;s no such thing as more powerful.&#8221; Perhaps we share the belief that <em>In theory, there&#8217;s no difference between theory and practice. But in practice, there is</em>.</li><br /><li>I am not making the claim that <em>I</em> consider memory management or unsealed base classes harmful, but I argue that there exists at least one person who does.</li><br /><li>The word &#8220;factor&#8221; has been a little out of vogue in recent times. But thanks to an excellent <a href="http://programming.reddit.com/info/18td4/comments">post on reddit</a>, it could make a comeback.</li><br /><li>So much so that we won&#8217;t even bother to show what loops looked like in the days of <code>for (int i = 0; i &lt; employeeList.size(); ++i)</code>. </li><br /><li>Another organization might merge employees and departments, or have each department &ldquo;own&rdquo; a collection of employees. This makes our example easier, but now the <em>data</em> doesn&rsquo;t factor well. Everything we&rsquo;ve learned from databases in the last forty years tells us that we often need to find new ways to compose our data. The relational model factors well. The network model factors poorly.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html" title="permanent link">10:21 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, February 26, 2007</div>
			

			<div class="Post"><a name="4134602127458276092">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">Haskell, Ruby and Infinity</a></span>
					<div style="clear:both;"></div>Languages like Haskell support <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>. In principle, you only compute what you actually need, everything else just goes away. If you usually need everything you compute, this may seem like a frill: elegant, even interesting, but having little practical importance. I find it is very much like Tail Call Optimization: if you don&rsquo;t have it, you code around it. Often it makes no difference, but from time to time there is a case where your code will be clearer and more maintainable if you express yourself succinctly and let the compiler do the work of making it efficient.<br /><br />This post is a switch from mumbling about <a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y Combinators</a> and using trivial cases to explain interesting ideas: I&rsquo;m going to show some actual code I&rsquo;m writing. I apologise in advance if this adds so much background that it obscures the message about lazy evaluation: extremely simplistic examples sometimes work against the argument because it is too easy to think of other ways to accomplish the needed results.<br /><br />I don&rsquo;t apologise <em>at all</em> for the unpolished nature of the code. This isn&rsquo;t a textbook. And besides:<br /><blockquote><br />Anybody can say you can&rsquo;t write. Let no one say you don&rsquo;t.<br /></blockquote><p style="text-align: right;">&mdash;Ken Rand, courtesy of <a href="http://chalain.livejournal.com/">Chalain</a><br /><br /></p><hr /><br /><br />I&rsquo;ve been <a href="http://en.wikipedia.org/wiki/Hacker">hacking</a> some na&iuml;ve code to cluster data sets.<br /><blockquote><br />In computer programming, a hacker is a software designer and programmer who builds elegant, beautiful programs and systems… For some, &ldquo;hacker&rdquo; has a negative connotation and refers to a person who &ldquo;hacks&rdquo; or uses kludges to accomplish programming tasks that are ugly, inelegant, and inefficient.<br /></blockquote><p style="text-align: right;">&mdash;Wikipedia</p>The clustering algorithm requires a very large, fixed set of curves.<sup>1</sup> I wrote the initial curve generation by building a gigantic list of parameter tuples, and then processing the list into records. Once the &ldquo;search space&rdquo; grew beyond a trivial size, the program began to eat enormous amounts of memory. The problem was that I was trying to write the generation code as clearly as possible, and that created a massive thicket of objects that all resided in memory simultaneously.<br /><br /><div style="float: right; width: 240px; margin-left: 10px; font-style: italic; text-align: center; font-size: 80%;"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Bezier_curve.svg/800px-Bezier_curve.svg.png" height="150" width="240" />The curves being generated are paths composed of cubic beziérs. Each segment on the path requires specifications for four different control points.<br /></div>I rejected the idea of a rewrite into looping, imperative form, I wanted to separate the &ldquo;list comprehension&rdquo; code from the &ldquo;make it run in less than a gigabyte&rdquo; code. Instead, I chose to use lazy evaluation: the principle is that although the code defines a huge data structure that takes up gigabytes, we only actually evaluate things as we need them, and we discard them when we are done, so the total memory footprint for the lazy form is about the same as the memory footprint for an imperative form.<br /><br />The easiest way to perform the refactoring&mdash;besides a rewrite in Haskell&mdash;was to switch all of the arrays I used for a lazy list data structure. A lazy list is a linked list composed of head and tail tuples (known as <a href="http://en.wikipedia.org/wiki/Cons">cons cells</a>). Where a normal linked list holds an element and the rest of the list, a lazy list holds an element and a function for computing the rest of the list (<a href="http://mitpress.mit.edu/sicp/">SICP</a> calls them &ldquo;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">streams</a>.&rdquo;)<br /><br />If a modicum of care is taken not to pin objects down, you can build fantastically large lazy lists and process them at will. In fact, lazy lists can be infinitely large if you provide the appropriate function for generating the list<br /><br />For that reason, you should never append one lazy list onto another lazy list. Consider <code>odd = LazyList.unfoldr(1) { |n| n + 2 }</code> and <code>even = LazyList.unfoldr(0) { |n| n + 2 }</code>. If you append <code>odd</code> onto <code>even</code>, the resulting list in theory has both even and odd numbers. But in practice you can never reach the odd numbers because there is an infinite quantity of even numbers at the front of the list.<br /><br />Instead, <code>merge</code> them together to produce a lazy union of the two lists. Merge interleaves alternating elements from each list, so the resulting lazy list contains all the elements of each list, and if you take a finite sample, such as the first 1,000 elements, you get 500 of each. <code>even.merge(odd) => (0 1 2 3 ...)</code>. (Other interesting operations that work with infinite lists include <code>cons</code>, <code>pairwise</code> and <code>product</code>.)<br /><br /><blockquote><br />Any sufficiently complicated Lisp or Ruby program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Haskell.<br /></blockquote><br />My current version of a <code>LazyList</code> class in Ruby is <a href="http://raganwald.com/source/lazy_lists.html">here</a>. As soon as I switched from the &ldquo;eager&rdquo; code using arrays to the &ldquo;lazy&rdquo; code using lazy lists, memory use went down and performance went up. Not as much as a switch to imperative (and not even close to writing a better clustering algorithm), but enough that I can move forward.<br /><br />Here is an example of a function using arrays to enumerate choices (<code>distribute(2, 1..4) -&gt; [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</code>):<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return [] if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    return range.to_a.map { |spot| [spot] }<br />  else<br />    (range.begin..(range.end - remaining_choices)).to_a.inject([]) { |acc, first_spot| acc + (distribute(remaining_choices, (first_spot + 1)..range.end).map { |remaining_distribution| remaining_distribution.unshift(first_spot) }) }<br />  end <br />end<br /></code></pre>And rewritten with lazy lists:<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return LazyList.new() if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    LazyList.from_range(range).map { |spot| LazyList.from_element(spot) }<br />  else<br />    LazyList.from_range(range.begin..(range.end - remaining_choices)).mapr(:merge) do |first_spot|<br />      distribute(remaining_choices, (first_spot + 1)..range.end).map do |remaining_distribution| <br />        LazyList.cons(first_spot, remaining_distribution) <br />      end<br />    end<br />  end <br />end<br /></code></pre>It&rsquo;s almost identical. <code>LazyLists</code> replace arrays, <code>mapr</code> replaces accumulating a list with <code>inject</code>, and <code>cons</code> replaces <code>unshift</code>, but otherwise it&rsquo;s the same code. Mission accomplished: we&rsquo;ve changed the behaviour without having to change the way we express our algorithms. Had we wanted to, we could have supported enough array syntax that Lazy Lists look exactly like arrays, but that isn&rsquo;t necessary.<br /><br />And when running the entire generator, the memory footprint is dramatically lower. For example, this small routine quoted above no longer generates an array of arrays: it generates a structure that can generate the lists when needed. Switching the data structure changes the evaluation behaviour of the generator code: it gets us 80% of having an imperative structure without having to tie the code to the implementation.<br /><br />This is exactly what separation of concerns is all about: <a href="http://weblog.raganwald.com/2006/12/economizing-can-be-penny-wise-and.html">green code here, yellow code there</a>.<br /><br /><strong>Lazy evaluation is the red pill</strong><br /><br />It&rsquo;s great to make a change to the code&rsquo;s behaviour without changing the way we think about the solution to our problem. But you know what? It isn&rsquo;t <em>interesting</em>. In fact, if lazy optimization was something we needed on a regular basis, we ought to switch to a <a href="http://en.wikipedia.org/wiki/Miranda_%28programming_language%29">language that does it for us</a>. Implementation details ought to be left to libraries, compilers, and virtual machines. That&rsquo;s what they&rsquo;re for.<br /><blockquote><br />A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.<br /></blockquote><p style="text-align: right;">&mdash;Alan Perlis</p>Now that we hold in our hands a tool for making infinitely long lists, the question to ask is, &ldquo;how does that affect the way we think about generating sample curves?&rdquo;<br /><br />The first thing that comes to mind is to ask why the set of sample curves we generate is finite. It isn&rsquo;t really finite, there are an infinite number of curves. (And not just any infinity, it&rsquo;s Aleph One, the children&rsquo;s book <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FOne-Two-Three-Infinity-Speculations%2Fdp%2F0486256642&amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">One Two Three… Infinity</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;amp;amp;l=ur2&o=1" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> explained that forty years ago.)<br /><p></p><div class="book"><br />  <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089"><img src="http://weblog.raganwald.com/uploaded_images/haskell_school_of_expression.jpg" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br />I&rsquo;m not a Haskell user (yet), but <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> has received rave reviews and comes with solid recommendations. It&rsquo;s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you&rsquo;re feeling generous!<br /><br /></div>What we really want is a <em>finite sample</em> of that infinite set of curves. Now let&rsquo;s zoom in and think about a single parameter, the <code>y</code> value for one of the control points on a curve. Let&rsquo;s say it&rsquo;s a rational number between <code>0.0</code> and <code>1.0</code> inclusive. It&rsquo;s relatively easy to generate a list of rationals in that range. Say we generate <code>0.0000...00001</code> (with jillions of zeroes elided: we want the smallest number our computer can represent), followed by <code>0.0000...00002</code> (the second smallest), and so on.<br /><br />If we leave the computer running for a few months or years, we should get all of the numbers between <code>0.0</code> and <code>1.0</code> that our computer can represent. That shouldn&rsquo;t be hard. But even taking into account the finite limitations on a computer&rsquo;s representation, that list is infinitely long.<br /><br /><strong>Useful samples</strong><br /><br />We need to take a finite sample of all of the infinite possibilities in that list.<br /><br />When working with an infinite list, what we want is that the front part of the list, the part we can access before the heat death of the Universe, contains a useful sample. If we were sampling a list like <code>(0.0000...00001 0.0000...00002 0.0000...00003 0.0000...00004 ... )</code> for control points, the first values are not useful at all. We&rsquo;d just get a line along the <code>x</code> access.<br /><br />There are various strategies for generating a more useful list. We could create an infinite list of random values. I&rsquo;ll outline another method below. But the take-away idea is this: we need lists where the most useful values are first. Working with infinite lists encourage us to think of infinitely sized sets of samples, ordered by usefulness.<br /><br />Let&rsquo;s say that when we generate <code>y</code>, we devise a list like <code>(0.0 1.0 0.5 0.75 0.25 ... )</code>. We&rsquo;re successively bisecting the intervals (which is why the library method is called <code>binary_search</code>). We can stop at any time and we have decent distribution. (And we can pipe dream that in the future, we can train our generator to favour points more likely to be useful to us.) That is much more useful!<br /><br />Here&rsquo;s some Lazy List code that does just that: given two seeds and an optional bisection block, it generates an infinite list of values:<br /><br /><pre><code>def binary_search seed1, seed2, &amp;block<br />  bisection_block = block || lambda { |x, y| (x-y)/2 + y }<br />  LazyList.cons(<br />    seed1,<br />    LazyList.new(<br />      seed2,<br />      delay {<br />        bisect(seed1, seed2, &amp;bisection_block)<br />      }<br />    )<br />  )<br />end<br /><br /># infinitely bisects a space, exclusive of the seed values<br /><br />def bisect seed1, seed2, &amp;block<br />  return EMPTY if seed1 == seed2<br />  half = block.call(seed1, seed2)<br />  LazyList.new(<br />    half,<br />    delay {<br />      merge(<br />        bisect(seed1, half, &amp;block),<br />        bisect(half, seed2, &amp;block)<br />      )<br />    }<br />  )<br />end<br /></code></pre>And indeed, <code>LazyList.binary_search(0.0, 1.0) -&gt; (0.0 1.0 0.5 0.75 0.25 ... )</code>.<br /><br /><strong><a href="http://en.wikipedia.org/wiki/Hilbert%27s_hotel">The Grand Hotel</a></strong><br /><br /><div class="book"><a name="evtst|a|0974514055" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611"><img style="" src="http://weblog.raganwald.com/uploaded_images/satan_cantor_infinity.jpg" alt="Satan, Cantor, and Infinity" border="1" /></a><br /><br /><a href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611">Satan, Cantor, and Infinity and Other Mind-boggling Puzzles</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0192861611" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> is a five-star introduction to Cantor&rsquo;s work on infinity, including a special treat: a completely different proof that Aleph One is greater than Aleph Zero based on games, very much in the style of Conway&rsquo;s Surreal Numbers. Currently out of print, but <strong>please</strong> get yourself a used copy from a bookseller: you won&rsquo;t be disappointed!<br /><br /></div>What happens when we try to combine two infinite lists? For example, we want a list of <code>(x, y)</code> tuples, generated as the Cartesian Product of our binary search list with itself. If we use a typical breadth-first or depth-first algorithm, we&rsquo;re sunk. We get <code>( (0.0 0.0) (1.0 0.0) (0.5 0.0) (0.75 0.0) (0.25 0.0)... )</code>. That has a nice distribution along one axis but still useless. What we need is a way of combining two infinite lists such that they give us a nice useful sample when we take a finite number of elements off the front.<br /><br />Here&rsquo;s a table describing how the ‘breadth-first&rsquo; algorithm for generating the product of two lists works. Consider two lists of three elements each. In the table below, columns represent one list and rows the other. The numbers represent the order that the product of the lists is generated:<br /><br /><table><tbody><tr><th colspan="3">Breadth-first mapping from elements to integers</th><br />      </tr><tr><td>1</td><td>2</td><td>3</td></tr><br />      <tr><td>4</td><td>5</td><td>6</td></tr><br />      <tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><br />This works fine for finite lists, but as we saw above it is useless for infinite lists. But looking at it in table form is useful. The product of two lists <em>is</em> tabular, the problem with a traditional algorithm is the order that we select elements from the table, not that the elements are tabular. Just as we solved the problem of how to sample <code>y</code> magnitudes by changing the order in which we selected rationals between <code>0.0</code> and <code>1.0</code>, what we need to do with Cartesian Products, what we need to do is select the products in an order that provides useful results.<br /><br />As it happens, there&rsquo;s an order that generates useful finite samples when dealing the product of two infinite lists: Instead of generating rows and appending them to each other, it generates <em>diagonals</em> and <em>merges</em> them with each other. The first diagonal is <code>1, 5, 9</code>. The second is <code>4, 8</code>. The third is <code>2, 6</code>. And so on. The advantage of this algorithm is that if given two infinite lists, it starts in the upper left-hand corner and supplies values, working its way right and down.<sup>2</sup><br /><br />Here&rsquo;re the first four values of the product of two binary searches with each other: <code>[{:x=&gt;0.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.5}]</code>. And the next four: <code>[{:x=&gt;1.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.25}]</code>. And the next eight: <code>[{:x=&gt;0.5, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.25}, {:x=&gt;0.5, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.75}, {:x=&gt;0.25, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.75}]</code>.<br /><br />We can take as many samples as we want, and more sample give us more &ldquo;resolution.&rdquo; We now have the tools we need to get rid of all of the limits and finite combinations and focus on describing what we&rsquo;re trying to generate without intermingling a lot of generating code.<br /><blockquote><br />And I&rsquo;m thinking about eternity<br />Some kind of ecstasy got a hold on me<br /></blockquote><p style="text-align: right;">&mdash;Bruce Cockburn, <a href="http://cockburnproject.net/songs&music/wwtla.html">Wondering Where The Lions Are</a></p>Now that we can generate an infinite list of useful magnitudes, plus we can combine infinite lists in a useful way, we can define an infinite list of sample curves. Here&rsquo;s the exact definition of an infinite list of partial beziérs (there are only three control points because the origin of the beziér is always the terminus of the previous beziér in the curve we are generating):<br /><p></p><pre><code>def sample_cubic_beziers<br />  magnitudes = LazyList.binary_search(0.0, 1.0)<br />  control_points = LazyList.cartesian_product(magnitudes, magnitudes) do |x, y|<br />    { :x => x, :y => y }<br />  end<br />  LazyList.cartesian_product(control_points, control_points, control_points) do |p1, p2, p3|<br />    {<br />      :p1 => p1,<br />      :p2 => p2,<br />      :p3 => p3<br />    }<br />  end<br />end<br /></code></pre>That&rsquo;s really simple, and really easy to understand.<sup>3</sup> The domain-specific code that defines a cubic Bezi&eacute;r is concise and readable. And the infrastructure code that handles combinatorics is shunted away out of sight where it doesn&rsquo;t clutter up our thinking.<br /><br />So what have we seen?<br /><ol><br /><li>Lazy evaluation solved a performance problem without needing an extensive rewrite of our generation code;</li><br /><li>Taking the red pill, infinite lists allowed us to radically simplify the original code.</li><br /></ol>Are there some opportunities to steal an idea like lazy evaluation from other languages and use them to simplify your code?<br /><br /><hr /><br /><ol><li>The data is a set of <code>(x,y)</code> tuples where <code>x</code> is time and <code>y</code> is a magnitude. The effort remaining in a <a href="http://www.mountaingoatsoftware.com/sprint_backlog">sprint backlog</a> is an example of this kind of data set. I need a function that computes the distance between any two data sets. I already have a function that computes the distance between a curve through the <code>xy</code> space and a data set, so if I build a lot of curves and then take the distance between each curve and each data set, I can find the distance between pairs of data sets by searching for the curve with the lowest total distance.<br /><br />This operation is On<sup>2</sup>, but that&rsquo;s why we invented distributed processing. Also, this operation is done infrequently relative to operations making use of the clusters, something like Google&rsquo;s indexing being far less frequent than searching Google. And of course, when my MacBook overheats and burns its way through my desk, I can come back and replace the brute force operation with something more intelligent.<br /><br />Well, all this requires generating the sample curves. I have code that makes curves out of Beziérs, provided I supply coördinates for the control points. the curves are actually <code>ActiveRecord</code> models. So all I needed was some simple code that generates all of the possible combinations and then write them to the database. It&rsquo;s the kind of thing candidates write in job interviews where employers actually care about their stone cutting skills.</li><br /><li>This problem is congruent to the proof that the set of all points on a plane is the same size as the set of all points in a line.</li><br /><li>And it could be simpler yet: a &ldquo;list comprehensions&rdquo; DSL for lazy lists <strike>is on the wish list</strike> <a href="http://weblog.raganwald.com/2007/03/approach-to-composing-domain-specific.html#lcir">would make things far more readable</a>.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">1:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, February 12, 2007</div>
			

			<div class="Post"><a name="677902229715311072">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/02/programming-language-stories.html" title="permanent link">Programming Language Stories</a></span>
					<div style="clear:both;"></div><strong>C</strong><br /><br />A fellow needs a dog house, so he hires a contractor. This guy is a C programmer who&#8217;s between jobs at the moment, and he says forget those wimpy &#8220;agile&#8221; wooden dog houses, he can build the dog house out of bricks, it will last forever and is stronger than any wood structure.<br /><br />The client is doubtful, but that sounds very impressive, and the contractor says this is how all the real-world dog houses are made, so he agrees. Well, it takes forever: it seems every time the contractor thinks it&#8217;s finished, they discover there&#8217;s a chink between the bricks and there&#8217;s a leak. With wood you just trim to fit, but with bricks you have to plan everything in advance so that the bricks line up just right.<br /><br />But Spring turns to Summer turns to Autumn, and the job is done. The client pays up, and the contractor&#8217;s about to leave when he stops and thinks for a moment before speaking.<br /><br />&#8220;Hey,&#8221; the contractor says, &#8220;You paid for a pallet of bricks, and I used all but one. It&#8217;s a shame if it goes to waste. Why don&#8217;t I see if I can use it somewhere?&#8221; The client asks like what, and before you know it the contractor has scored a contract to build a brick path for the dog from the back door to the dog house. He orders some more bricks, gets to work right away, and this time things go a little better.<br /><br />The contractor is now doing C++ on the side. And he uses some new bricklaying techniques he learned from <a href="http://www.amazon.com/gp/product/0321334876?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321334876">Effective C++</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321334876" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: there are these funny angle braces everywhere thanks to his path building templates. Soon that job is done and the contractor collects his fee. He&#8217;s about to leave, but he reaches into his tool chest and pulls out a brick.<br /><br />&#8220;Hey,&#8221; the contractor says, &#8220;You paid for another pallet of bricks, and I used all but one on the path. It&#8217;s a shame if it goes to waste. Why don&#8217;t I see if I can use it somewhere?&#8221; The client is happy with the path, asks like what, and before you know it the contractor has scored another contract, this time to build a brick wall enclosing the yard. He orders some more bricks, and gets to work right away.<br /><br />Meanwhile, the contractor has become a Visual C++ programmer and reads MSDN magazine religiously. He applies his new skills to building the wall: he has all these fancy tools that can put up sections of scaffolding when you push a button. of course, there are huge holes you have to fill in yourself, and the scaffolding has all these crazy joins and angles, it&#8217;s hard to change anything or understand how the entire wall fits together, but it feels like you&#8217;re getting a lot done because the system seems to move a lot of bricks for you.<br /><br />Well, the wall takes forever, and it doesn&#8217;t look that good when it&#8217;s finally done. But the client pays up and the contractor is ready to leave. But he stops for a moment and pulls a brick out of his tool chest.<br /><br />&#8220;Hey,&#8221; the contractor says, &#8220;You paid for two more pallets of bricks for the wall, and I used all but one. It&#8217;s a shame if it goes to waste. Why don&#8217;t I see if I can use it somewhere?&#8221;<br /><br />The client has had enough of this, and he decides he&#8217;s going to show the contractor how he feels. &#8220;Give me that brick,&#8221; he orders. The surprised contractor hands it over. &#8220;I don&#8217;t give a rat&#8217;s ass about this brick&#8221; the client huffs, and he throws the brick clear out of his yard.<br /><br />&#8220;I need to get work done, not talk to contractors all day about bricks. And besides, I&#8217;ve talked to the big landscape contracting companies, and they all say nobody is using bricks, everyone has switched to sharp tools and netting. Now get out.&#8221;<br /><br /><strong>Ruby on Rails</strong><br /><br />Just inside the gates of heaven, St. Peter sits at a desk checking people in.<br /><br />Peter:  &#8220;Welcome to heaven.  Programming language?&#8221;<br /><br />The man at the front of the line says, &#8220;<a href="http://www.amazon.com/gp/product/0133713458?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0133713458">Smalltalk</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0133713458" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.&#8221;<br /><br />Glancing at his clipboard, Peter says, &#8220;Room 33.  Be very quiet as you pass Room Six.&#8221;<br /><br />The process repeats itself with the next person in line:<br /><br />Peter:  &#8220;Welcome to heaven.  Programming language?&#8221;<br /><br />Person #2:  &#8220;<a href="http://www.amazon.com/gp/product/1590592395?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1590592395">Common Lisp</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1590592395" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.&#8221;<br /><br />Peter:  &#8220;Room 17.  Be very quiet as you pass Room Six.&#8221;<br /><br />The next person moves to the front of the line with a look of curiosity on her face.<br /><br />Peter:  &#8220;Welcome to heaven.  Programming language?&#8221;<br /><br />Person #3:  &#8220;<a href="http://www.amazon.com/gp/product/0596009259?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596009259">Python</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0596009259" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.&#8221;<br /><br />Peter:  &#8220;Room 54.  Be very quiet as you pass Room Six.&#8221;<br /><br />Person #3:  &#8220;Why do you keep telling us to be quiet as we pass Room Six?&#8221;<br /><br />Peter:  &#8220;Because the <a href="http://www.amazon.com/gp/product/0977616630?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0977616630">Ruby on Rails</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0977616630" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> People are in Room Six, and they think they&#8217;re the only ones here.&#8221;<br /><p style="text-align: right">&#8212;Snarfed from Eric Sink&#8217;s <a href="http://software.ericsink.com/articles/Boundaries.html">Baptists and Boundaries</a></p><br /><strong>Java</strong><br /><br />A mother was preparing the pot-roast for Sunday&#8217;s big family dinner. Before searing it and placing it in the pan, she carefully sliced the ends off. Her three year-old daughter asked &#8220;Mommy, why do you cut the ends off the roast?&#8221;<br /><br />She answered, &#8220;My mom taught me to do it that way, and it&#8217;s delicious, so it must be a good idea. Maybe the juices from the meat mix with the vegetables?&#8221;<br /><br />Everyone sits down for dinner, and when Father is serving the roast, the daughter remembers her question. She turns to Grandma and asks, &#8220;Grandma, why did you teach Mommy to cut the ends off the roast?&#8221;<br /><br />Grandma thinks for a moment and says, &#8220;What a delightful question! I always used to cut the ends off the roast, it&#8217;s how <em>my</em> mother taught me. I don&#8217;t know why she did that, there must have been a good reason.&#8221; Grandma sits for a moment, remembering her mother. &#8220;Well,&#8221; she continues, &#8221; there must have been a good reason. Now eat your dinner before it gets cold!&#8221;<br /><br />The holidays roll around, and they&#8217;re having dinner at Grandma and Grandpa&#8217;s house. &#8220;Hey!&#8221; Grandma says to the little girl, &#8220;You know what, I was going through your great-grandmother&#8217;s things, and I found the old roast pan. We sure made some good pot roast in it. Let&#8217;s make pot roast with it tonight in her honour!&#8221;<br /><br />They get out the pan and wash it up. It&#8217;s old, and well-seasoned. Grandma looks it over. &#8220;It&#8217;s smaller than I remember. I was a little girl, and everything looks bigger when you&#8217;re small!&#8221;<br /><br />They put the roast on the counter before searing it. Just then, Grandpa walks by. &#8220;Do you want me to cut the ends off the roast?&#8221; he asks. &#8220;It&#8217;s the only way you&#8217;ll get it to fit in that small pan.&#8221;<br /><br />Grandma and the little girl look at each other. And they smile.<br /><br /><strong>Scheme</strong><br /><br />A fellow is on vacation, and he decides to ride one of those &#8220;scenic&#8221; double-decker buses that drive around from attraction to attraction. The upper level is open-air, and he&#8217;s the only one up there. He looks around, and decides that instead of re-reading his copy of <a href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262560992" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, he&rsquo;s going to really enjoy himself: he lights a cigar.<br /><br />No sooner has he lit the cigar when a woman comes huffing and puffing upstairs, carrying one of those sub-miniature dogs people use as fashion accessories. She takes one look at our man and demands he put the cigar out: it is <em>offensive to the dog</em>.<br /><br />&#8220;Madam,&#8221; our man asserts, &#8220;this cigar is not offensive. Let me tell you its secrets.&#8221;<br /><br />&#8220;Eschewing inferior mass-market tobacco, I order whole, functional leaves&#8212;at great expense and with difficulty&#8212;from a small collective in Cuba that still grow cigar tobacco the old-fashioned, original way.&#8221;<br /><br />&#8220;Unsullied by automatic rolling machines or other push button devices, I roll each cigar, myself, by hand. Using secret tobacco-macro techniques that are impenetrable to the typical ignorant cigarette smoker, I am able to pack as much smoking pleasure into a single cigar as would take a carton of cigarettes&#8212;nay, it is impossible to enjoy a smoke from regular cigarettes as much as I enjoy the elite, exclusive flavour of my cigars.&#8221;<br /><br />The woman is not impressed. &#8220;If your cigars are so good, how come nobody smokes them?&#8221; she asks. &#8220;If your cigars are so good, how come so many clubs and restaurants permit cigarettes but forbid cigars?&#8221;<br /><br />Our fellow is so irate he begins to splutter. &#8220;If you or your dog are unable to understand that the purity, the perfection achieved long ago on a remote island far from consumerism and mass productio&#8212;&#8221; But he is unable to finish, for the woman imperiously sweeps the cigar from his mouth and flings it over the side of the bus.<br /><br />&#8220;That&#8217;s what I think of your pompous cigar.&#8221; She tells him.<br /><br />He glares at her for a moment, then years of oppression, of being forced to live with the hated cigarettes against his will, bring him to a boil and he commits an unthinkable act. With a wrench, he seizes the dog and flings it after his cigar. There is a moment of uncomprehending shock, and then the woman begins to howl.<br /><br />Well, the bus driver hears all this and slams on the brakes. For a moment everything is higgledy-piggledy, and just as the woman&#8217;s wails return to their full volume, everyone is shocked to see the dog come trotting up, unharmed.<br /><br />And what do you know: the dog has&mdash;nestled gently in its mouth&mdash;the most unexpected thing:<br /><br /><a href="http://www.rot13.com/index.php?text=Gur%20Oevpx" title="The Brick">Gur Oevpx</a>.<br /><hr><br />If you enjoyed these stories, you may also like <a href="http://weblog.raganwald.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a> and more recently, <a href="http://weblog.raganwald.com/2007/04/venture-capitalist-passes-away.html">A Venture Capitalist passes away peacefully, and...</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/02/programming-language-stories.html" title="permanent link">3:10 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, February 07, 2007</div>
			

			<div class="Post"><a name="117088092580614361">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/02/why-ruby-is-not-acceptable.html" title="permanent link">Why Ruby is not an acceptable implementation of Lisp</a></span>
					<div style="clear:both;"></div>The other day, while actually writing software (as opposed to <em>talking about writing software</em>), I wrote the following:<br /><br /><pre><code>distance = lambda do |given_scale|<br />  (magnitudes.map { |pair| <br />    (pair.evidence - (pair.flow * given_scale)) ** 2 <br />  }).inject { |acc, distance| acc + distance }<br />end<br /></code></pre><br /><br />If you are curious, <code>distance</code> is a function that computes the distance between a curve (called a &#8216;flow&#8217;) and some evidence, given a float that scales the flow. It&#8217;s used for finding a curve that &#8216;looks like&#8217; a set of data points.<br /><br />Can you spot the bug? I&#8217;ll expunge all of the excess and give you some code you can try yourself:<br /><br /><pre><code>require 'test/unit'<br /><br />class TestRubyNames &lt; Test::Unit::TestCase<br /><br />  def test_lambda_clobbering<br />    foo = lambda { (1..3).map { |foo| foo ** 2 } }<br />    assert_nothing_raised(NoMethodError) { foo.call() }<br />    assert_raise(NoMethodError) { foo.call() } # WTF?<br />  end<br /><br />  def test_local_clobbering<br />    foo = [1, 4, 9]<br />    bar = lambda { (1..3).map { |foo| foo ** 2 } }<br />    bar.call<br />    assert_equal(3, foo) # WTF?<br />  end<br /><br />end<br /></code></pre><br /><br /><div class="book"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0974514055"><img style="" src="http://weblog.raganwald.com/uploaded_images/programming_ruby-742816.jpg" alt="" border="1" /></a><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0974514055">Programming Ruby: The Second Edition</a> is an indispensable reference, especially to the latest libraries.<br /><br /></div>Is this what you expect? Ruby <em>looks</em> like a nice, block-structured language with lexical scope. But its standard implementation has serious issues. I believe these are <a href="http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l8">well-known and understood</a> issues, but issues nonetheless.<br /><br />One more example. I swore I wouldn&#8217;t write anything else about fixed-point combinators for a very long time, but try this exercise at home. Here&#8217;s my <a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">curry combinator</a>:<br /><br /><pre><code>require 'test/unit'<br /><br />class ExempliGratia &lt; Test::Unit::TestCase<br /><br />  CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br /><br />  def test_clean_up_loose_ends<br />    maker = lambda { |f|<br />               lambda { |func_with_me| CURRY.call(func_with_me, func_with_me) }.call(<br />                    CURRY.call(lambda { |inner_func, me, *args|<br />                                inner_func.call(CURRY.call(me, me)).call(*args) }, f)) }<br /><br />    factorial = maker.call(<br />      lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />    )<br />    assert_equal(120, factorial.call(5))<br />  end<br /><br />end<br /></code></pre><br /><br />Looks good. Now let&#8217;s prove that <code>CURRY</code> is referentially transparent by replacing every <code>CURRY</code> variable with the lambda:<br /><br /><pre><code>maker = lambda { |f|<br />           lambda { |func_with_me| (lambda { |f, a| lambda { |*b| f.call(a, *b) } }).call(func_with_me, func_with_me) }.call(<br />                (lambda { |f, a| lambda { |*b| f.call(a, *b) } }).call(lambda { |inner_func, me, *args|<br />                            inner_func.call((lambda { |f, a| lambda { |*b| f.call(a, *b) } }).call(me, me)).call(*args) }, f)) }<br /><br />factorial = maker.call(<br />  lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />)<br /><br />begin<br />  factorial.call(5)<br />  puts 'fine'<br />rescue SystemStackError<br />  puts 'wtf?'<br />end<br /></code></pre><br /><br />Hunh? Ruby <em>looks like</em> a nice language supporting anonymous functions, but sometimes they work and sometimes they don&#8217;t. <strike>I strongly suspect that this issue has something to do with the fact that with the &#8216;naked&#8217; lambdas we&#8217;re creating new functions with every call, whereas the version using a <code>CURRY</code> variable re-uses the same function, so the system stack overflows in one case and not the other.</strike><br /><br /><strong>Update</strong>: Mike Harris proved that this second problem is the same as the first problem: once again, variables are clobbering each other all over the place. In Ruby 1.8, blocks do not create new scope, <i>at all</i>.<br /><br />Here's Mike's submission, indented to fit:<br /><br /><pre><code><br />def test_full_anonymity<br />  assert_equal(120, (lambda { |f0|<br />                       lambda { |func_with_me| <br />                         (lambda { |f1, a1| <br />                           lambda { |*b1| f1.call(a1, *b1) } <br />                         }).call(func_with_me, func_with_me) <br />                       }.call(<br />                            (lambda { |f2, a2| <br />                              lambda { |*b2| f2.call(a2, *b2) } <br />                            }).call(<br />                              lambda { |inner_func, me, *args|<br />                                inner_func.call(<br />                                  (lambda { |f3, a3| <br />                                    lambda { |*b3| f3.call(a3, *b3) } <br />                                  }).call(me, me)).call(*args) <br />                              }, f0)) <br />                    }).call(<br />    lambda { |f| lambda { |n| n.zero? && 1 or n * f.call(n-1) } }<br />  ).call(5))<br />end<br /></code></pre><br /><br /><strong>Stop your sobbing</strong><br /><br />I&#8217;m <em>not</em> saying Ruby is an unacceptable Ruby.<br /><br />I&#8217;m <em>especially not</em> saying &#8220;See, that&#8217;s why we should stick with language X.&#8221; If language X doesn&#8217;t even try to support this kind of programming, it&#8217;s a lame argument to say that it&#8217;s a better choice. That&#8217;s like saying that your 1972 <a href="http://en.wikipedia.org/wiki/Ford_Pinto" title="The barbecue that seats four.">Pinto</a> is safer than my 2004 MX-3 because the Pinto doesn&#8217;t have air bags, and air bags can injure small children if they are sitting in the passenger seat.<br /><br />If you try to bend Ruby to do Scheme-ish things, you will run into some corner cases, some places where it does the unexpected. Can you figure them out and avoid them (some people will say avoiding corner cases makes for a <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">Leaky Abstraction</a>)?<br /><br />I think if you&#8217;re writing Ruby code in Ruby, you can easily avoid these problems. That&#8217;s why Ruby is an acceptable Ruby.<br /><br /><strong>Why isn&rsquo;t Ruby an acceptable implementation of Lisp?</strong><br /><br />But why isn&rsquo;t Ruby an acceptable implementation of Lisp? (Besides the lack of support for <a href="http://www.cs.indiana.edu/scheme-repository/R4RS/r4rs_12.html">hygienic macros</a>, of course!)<br /><br /><div class="book"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0130305529"><img style="" src="http://weblog.raganwald.com/uploaded_images/on_lisp-725931.jpg" alt="" border="0" /></a><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0130305529?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&camp=1789&amp;creative=9325&creativeASIN=0130305529">On Lisp: Advanced Techniques for Common Lisp</a> is <b>the</b> definitive text on metaprogramming and macros. Although written for Common Lisp, its ideas are easily applicable to Scheme and even Ruby metaprogramming.<br /><br /></div>The problem is that Lisp or Lisp-style programming is all about metaprogramming. Code that writes code. Code that evals code. It&#8217;s easy to look at something like the curry combinator and say &#8220;no programmer would ever write that convoluted a function in production.&#8221; But macros and code generators routinely combine snippets of code to produce monstrosities that a human wouldn&#8217;t even considering writing.<br /><br />When writing a piece of code that writes code, you are heavily dependent on the underlying implementation being regular and corner-case free. The whole point of writing code-writing code is that you intend for it to generate variations and combinations on your templates or scaffolds. And it&#8217;s only a matter of time before you are combining template A with generator B and meta-programming method C.<br /><br />When the underlying language is robust, none of this matters. The result works. If you look at it under the hood, you&#8217;re horrified at the result. But frankly, that isn&#8217;t an argument against meta-programming, it&#8217;s an argument <em>for</em> it: let the machine do the dirty jobs we don&#8217;t want to do, and let us deal with a nice abstraction like <em>A plus B plus C</em> that just works, never mind what the code looks like.<br /><br />(Don&#8217;t even think about arguing that we should do away with code that writes code. That debate was won by the code generation folks back when COBOL and FORTRAN and ALGOL were young. From time to time you&#8217;re welcome to pull out your assembly if you like, but we use High Level Languages because we want the machine to write the messy crap for us.)<br /><br />My fear is that code that writes code might one day write code that clobbers a variable. <strike>Or code that writes code might write some nested lambdas that overflow the stack.</strike><br /><br />And that&#8217;s why Ruby is not an acceptable implementation of Lisp.<br /><br /><hr /><br />Well, ok, I confess: the title is a bit of muckraking. <a href="http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp">Ruby is a pretty good implementation of Lisp</a>, and anyone who has two brains to rub together can point out that the issue is not whether there&#8217;s some corner case &#8220;gotcha,&#8221; but <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-ii.html">whether using Ruby is, on the whole, more beneficial than not using Ruby</a>.<br /><br />For what it&#8217;s worth, I consider corner cases like this a strong endorsement of trying new languages like Ruby: it&#8217;s like finding out that your sailplane has a tendency to go into an inverted flat spin when you loop at an unacceptably slow speed. It&#8217;s terrifying when it first happens, but you get through it and then you realize that the only reason you got into trouble was that you were pushing yourself hard.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/02/why-ruby-is-not-acceptable.html" title="permanent link">3:03 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, February 06, 2007</div>
			

			<div class="Post"><a name="117078492091356135">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/02/guest-blogger-tom-moertel-derives-y.html" title="permanent link">Guest Blogger: Tom Moertel derives the Y combinator in Ruby</a></span>
					<div style="clear:both;"></div><em>In a comment on <a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>, <a href="http://blog.moertel.com">Tom Moertel</a> derived an elegant version of the actual Y combinator in Ruby. I reproduce his words here with permission.<br /><br />Tom uses the alternate syntax for </em><code>call</code>, <code>[...]</code><em>. I avoided this to keep clear of a tiresome debate about operator overloading. (On one side: those who hate it. On the other side: those that hate Ruby disallowing overloading </em><code>(...)</code><em>).<br /><br />Ok Tom, take it away!</em><br /><hr/><br />Here&#8217;s my original Ruby definition:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |*args| f[y(&amp;f)][*args] }<br />end<br /></code></pre><br /><br />To get rid of the recursive call <code>y(&amp;f)</code>, let&#8217;s replace it with a variable <code>yf</code>, whose value we&#8217;ll say is magically equivalent to the result of the recursive call. To effect the binding of <code>yf</code>, we&#8217;ll need to wrap the method body in a new lambda expression and pass in the magic value:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |yf|<br />        lambda { |*args| f[yf[yf]][*args] }<br />    }[ &lt;&lt;&lt; placeholder for yf: we'll fill this hole next &gt;&gt;&gt; ]<br />end<br /></code></pre><br /><br />So, what value should we pass in for <code>yf</code>? Because the variable represents the value that would have been computed by calling <code>y(&amp;f)</code>, which is just the body of the <code>y</code> method, we can fill the hole with a duplicate of the body:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |yf|<br />        lambda { |*args| f[yf[yf]][*args] }<br />    }[ lambda { |yf| lambda { |*args| f[yf[yf]][*args] } } ]<br />end<br /></code></pre><br /><br />And we have our Y combinator:<br /><br /><pre><code>fac = y { |rec| lambda { |n| n &lt; 2 ? 1 : n * rec[n-1] } }<br />fac[5] # ==&gt; 120<br /></code></pre><br /><br />While the combinator works, its implementation repeats itself: there are two copies of the lambda expression<br /><br /><pre><code>lambda { |yf| lambda { |*args| f[yf[yf]][*args] } }<br /></code></pre><br /><br />in the method body. To factor them out, let&#8217;s let the variable <code>x</code> represent this expression. Then the method body simplifies to <code>x[x]</code>, which is very satisfying. To set <code>x</code> to the correct value, however, we need to add a wrapper lambda that binds <code>x</code> to the original expression. Putting it all together, we arrive at the final version:<br /><br /><pre><code>def y(&amp;f)<br />    lambda { |x| x[x] } [ <br />        lambda { |yf| lambda { |*args| f[yf[yf]][*args] } } ]<br />end<br /></code></pre><br /><br />And it, too, works:<br /><br /><pre><code>acc_fac = y { |rec| lambda { |n,acc| n &lt; 2 ? acc : rec[n-1, n*acc] } }<br />tail_fac = lambda { |n| acc_fac[n, 1] }<br />tail_fac[5] # ==&gt; 120<br /></code></pre><br /><br />Cheers! &#8212;<a href="http://blog.moertel.com">Tom</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/02/guest-blogger-tom-moertel-derives-y.html" title="permanent link">12:58 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="117073854086425300">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html" title="permanent link">But Y would I want to do a thing like this?</a></span>
					<div style="clear:both;"></div><blockquote><br />  Choose life. Choose a job. Choose a starter home. Choose dental insurance, leisure wear and matching luggage. Choose your future. But <a href="http://en.wikipedia.org/wiki/Y_combinator" title="Y combinator">Y</a> would <a href="http://en.wikipedia.org/wiki/Combinatory_logic#Examples_of_combinators" title="Identity combinator">I</a> want to do a thing like that?<br /></blockquote>Writing about <a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">first-class functions</a> and their <a href="http://weblog.raganwald.com/2007/02/hof-or-oop-yes.html">compatibility with object-oriented programming</a> naturally leads to the <a href="http://en.wikipedia.org/wiki/Y_combinator">Y combinator</a>. And that is the point where eyes glaze over and soft, snoring sounds rise from RSS readers everywhere.<br /><br />But please bear with me, this essay is not really about the Y combinator, it&#8217;s about learning new things and expanding our capacity to think.<br /><br /><strong>Sharpening the saw</strong><br /><br />Years ago I picked up Steven Covey&#8217;s book <a href="http://www.amazon.com/gp/product/0743269519?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0743269519">The 7 Habits of Highly Effective People</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0743269519" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. If the book is a test out of seven, I really wasn&#8217;t doing very well.<br /><br />If you&#8217;ve read the book, you probably remember that he talked about &#8220;Sharpening the Saw,&#8221; investing in your own abilities. That&#8217;s incredibly important, but I don&#8217;t need to tell you that. If you exercise with programming katas, or learn a new programming language once a year, or pick up a book like <a href="http://www.amazon.com/gp/product/0262562146?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262562146">The Reasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262562146" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <em>and actually go through the exercises</em>, then you are already in the top 1% of software developers for personal skills improvement. (Sorry, certifications <em>don&#8217;t count</em>. They are the classic case of doing the wrong thing for the wrong reason!)<br /><br />New ideas&#8212;by which I mean, new to you&#8212;are an important way to sharpen your saw. If for no other reason than this: the brain needs regular exercise to perform at or near its potential. Learning new things keeps you sharp, even if you don&#8217;t directly use the things you learned.<br /><br />Others have suggested that learning Lisp is beneficial to your programming skills in its own right. That&rsquo;s one good way to sharpen your saw. But I add to that an important caveat: to obtain the deepest benefit from learning a new language, you must learn to think in the new language, not just learn to translate your favourite programming language syntax and idioms into it.<br /><br /><strong>Think different</strong><br /><br />The interesting thing about that is that almost by definition, if you see something in, say, Lisp that solves a problem you already have, you won&#8217;t learn much from the Lisp code. It is tempting to think that Lisp (or any other language) will somehow do what you&#8217;re already doing in some wonderfully magic way that is obviously better. But no, that isn&#8217;t how it really works.<br /><br />For your problems are tuned to your existing tools. You simply can&#8217;t imagine problems that your tools can&#8217;t solve well, much less can&#8217;t solve at all. That&#8217;s why there are so few continuation-based web servers. Who&#8217;s going to invent one unless they have a programming paradigm with continuations?<br /><br /><div class="book"><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422"><img border="0" src="http://weblog.raganwald.com/uploaded_images/to_mock_a_mockingbird-785706"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: The most enjoyable text on the subject of combinatory logic ever written. What other textbook features starlings, kestrels, and other songbirds?<br /></div>And worse, when a new tool is applied to a problem you think you know well, you will probably dismiss the things the new tool does well. Look at how many people dismiss brevity of code. Note that all of the people ignore the statistics about the constant ratio between bugs and lines of code use verbose languages. Look at how many people dismiss continuation-based servers as a design approach. Note that all of them use programming languages bereft of control flow abstractions.<br /><br />Thus, to truly learn a new tool, you must not just learn the new tool, you must <em>apply it to new kinds of problems</em>. It&#8217;s no good learning to replace simple iteration with first-class functions: all you&#8217;ve learned is syntax. To really learn first-class functions, you must seek out problems that aren&#8217;t easily solved with iteration.<br /><br /><strong>The Why of Y</strong><br /><br />Which leads me back to fixed point combinators. They appear to have no practical (as in making money) use. And that&#8217;s why I&#8217;m suggesting to you that you figure out how to make one in your language of choice. The very fact that the problem is far outside of your realm of &#8220;practicality&#8221; guarantees that you will learn something. You won&#8217;t be simply applying your same-old, same-old techniques and patterns to a slightly new problem.<br /><br />Start your research with Richard P. Gabriel&#8217;s <a href="http://www.dreamsongs.com/NewFiles/WhyOfY.pdf">The Why of Y</a>. Try porting his examples directly to your favourite programming language. If what you want to use is too brain-damaged to support closures, you may need to do a little greenspunning and build a little <a href="http://en.wikipedia.org/wiki/Function_object">functor</a> infrastructure.<br /><br />Don&#8217;t be dissuaded if you have to follow the functor route: you are learning far more about your language and about programming in general than the shmoes that settle for learning five new buzzwords related to the latest WS-* interoperability with XPath 3.x.<br /><br />If you prefer a <a href="http://weblog.raganwald.com/2007/02/its-monday-its-snowing-and-im-actually.html">fun</a> approach to learning, you can do not better than Raymond Smullyan&#8217;s <a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: an enjoyable romp through the world of combinatory logic. After reading this book, you will have mastered the S, K, I, Y, and other combinators. Added bonuses include a safe that can only be opened by applying G&ouml;del&#8217;s Incompleteness Theorem to its combination. How can you read this book and <em>not</em> learn?<br /><br /><strong>Eating my own dog food</strong><br /><br />I thought of a few things to say along these lines last week and then I abruptly realizing I was asking you to &#8220;Do as I say, not as I do.&#8221; What good is recycling problems I first encountered in University textbooks two decades ago? I put this post aside and set to work on a problem of my own.<br /><br />I set out to write a function for making recursive functions&#8212;a function <a href="http://en.wikipedia.org/wiki/Extensional_equality">extensionally equal</a> to the Y combinator&#8212;in Ruby. The ultimate goal is to take something like:<br /><br /><pre><code>lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) } }<br /></code></pre><br /><br />And be able to have it call itself recursively. In this case, to compute the <code>factorial</code> function.<br /><br />This is trivial, given that Ruby supports named recursion, but if you want to write a fixed-point combinator you want to write a function that makes recursive functions <em>without using the host language&rsquo;s support for named recursive calls</em>. In other words, you are bootstrapping named recursion out of anonymous first-class functions.<sup>1</sup><br /><br />There are important theoretical implications of being able to do this, but the killer reason to try it is to learn.<br /><br />I started my quest for a function for making recursive functions with a rather trivial observation based on OO programming and the Curry function:<br /><br /><pre><code>require 'test/unit'<br /><br />class ExempliGratia &lt; Test::Unit::TestCase<br /><br />  CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br /><br />  def test_recursive_curry<br />    maker = lambda { |func_with_me|<br />      CURRY.call(func_with_me, func_with_me)<br />    }<br />    assert_equal(120, maker.call(lambda { |me, n| n.zero? &amp;&amp; 1 or n * me.call(me, n-1) }).call(5))<br />  end<br /><br />end<br /></code></pre><br /><br />In OO some language implementations, <code>this</code> (or <code>self</code>) is a hidden parameter passed to each method. Thus, there&#8217;s a parameter&#8212;<code>me</code> in the example code&#8212;that is added for handling recursion. If you write a recursive function&#8212;like the venerable <code>factorial</code>&#8212;with the extra <code>me</code> parameter, a trivial currying operation evaluates it recursively without any need for names.<br /><br />This is obviously deficient. As noted above, we want to write <code>factorial</code> like so:<br /><br /><pre><code>lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) }<br /></code></pre><br /><br />We&#8217;ll need an <code>f</code> from somewhere, and just as our Scheme colleagues do, we&#8217;ll bind one as a parameter in an enclosing lambda. So we want to write:<br /><br /><pre><code>lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or f.call(n-1) } }<br /></code></pre><br /><br />And somehow this should be transformed into a working <code>factorial</code> function. For the test-driven crowd, we want to write:<br /><br /><pre><code>def test_clean_up_loose_ends<br />  maker = ...<br /><br />  factorial = maker.call(<br />    lambda { |f| lambda { |n| n.zero? &amp;&amp; 1 or n * f.call(n-1) } }<br />  )<br />  assert_equal(120, factorial.call(5))<br /><br />  iterative_factorial = maker.call(<br />    lambda { |f| lambda { |n, acc| n.zero? &amp;&amp; acc or f.call(n - 1, n * acc) } }<br />  )<br />  tail_factorial = lambda { |n| iterative_factorial.call(n, 1) }<br />  assert_equal(120, tail_factorial.call(5))<br />end<br /></code></pre><br /><br />Of course, we need some code for <code>maker</code>. And the <code>iterative_factorial</code> case shows that <code>maker</code> works for functions with more than one parameter. The solution I came up with is:<br /><br /><pre><code>CURRY = lambda { |f, a| lambda { |*b| f.call(a, *b) } }<br />maker = lambda { |f|<br />       lambda { |func_with_me| CURRY.call(func_with_me, func_with_me) }.call(<br />            CURRY.call(lambda { |inner_func, me, *args|<br />                        inner_func.call(CURRY.call(me, me)).call(*args) }, f)) }<br /></code></pre><br /><br />The source code with each transformation from beginning to end is <a href="http://raganwald.com/source/curry_combinator.html">here</a> (I strongly suspect that this &#8220;curry combinator&#8221; is actually the Y combinator with a huge amount of cruft hanging off it).<br /><br />Unique or derivative, crap or craft, the process of getting it to work has enriched my mind by forcing me outside of my usual problem space. I still can&rsquo;t think of a practical application for what I&rsquo;ve just written. But I know I&rsquo;ve stretched myself.<br /><br />And now back to you: perhaps you&rsquo;re rushing off to try to implement a fixed-point combinator from first principles. Perhaps your plan is to code the canonical examples in your usual language. Those are both good paths. But whether you follow them today or not, remember the underlying principle exemplified by the fixed-point combinator:<br /><br /><em>Do not dismiss impractical or weird problems. While you may not have an immediate application for the code you write to solve such problems, you are maximizing your learning when you venture outside of your usual problem space.</em><br /><br /><hr/><br /><ol><li>Named recursion is stuff like <code>foo = lambda { |...| foo.call(:bar) }</code>. It takes advantage of the host language&rsquo;s variable binding to recurse. If you want anonymous recursion, you should be able to assign the same <code>lambda</code> to another name and have it work just as well, as in: <code>fufu = lambda { |...| foo.call(:bar) }</code>. That won&rsquo;t work if you are relying on Ruby&rsquo;s name for <code>foo</code>.</li></ol><br />p.s. Don&rsquo;t miss <a href="http://weblog.raganwald.com/2007/02/guest-blogger-tom-moertel-derives-y.html">Tom Moertel&rsquo;s derivation of the Y combinator in Ruby</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/passion.html">passion</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html" title="permanent link">12:06 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, February 02, 2007</div>
			

			<div class="Post"><a name="117042956864259931">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/02/hof-or-oop-yes.html" title="permanent link">HOF or OOP? Yes!</a></span>
					<div style="clear:both;"></div>It&#8217;s interesting how the brain works: I wrote an essay that I thought was <a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">an explanation of what first class functions and closures <em>are</em></a>, and why some people would like to see them added to the <a href="http://www.java.com">Kitchen Sink of Languages</a>.<br /><br />Then I read <a href="http://www.wuenschenswert.net/wunschdenken/archives/117">From Functional to Object-Oriented Programming</a>, which suggests that my essay seems to be making a general statement about Functional Programming as an advance over Object Oriented Programming.<sup>1</sup><br /><br />Nothing could be further from my intention or my opinion. Smalltalk, for example, has a clean and powerful syntax for first-class functions. And those first-class functions are objects, as is <em>everything</em> in Smalltalk. I am tempted to rewrite my essay using Smalltalk: it seems that using <a href="http://www.ruby-lang.org/">Ruby</a>, another language where everything is an object, is not making this point strongly enough. In my mind, it is easy to use languages that provide the OO paradigm as well as the first-class function paradigm. At the same time.<br /><br /><strong>What I actually said</strong><br /><br />So what I actually said is: &#8220;Here are these things called <em>first-class functions</em>. This &ldquo;thing&rdquo; is where functions are exactly the same kind of thing as everything else in a language. This is useful, here is why.&#8221; If functions are first class, functions aren&#8217;t magically more special, nor are they second-class citizens in a language (like those brain-damaged primitives in crippled languages). If a language is an OO language, this implies that first-class functions in such a language are objects and that programming with them <em>is</em> OO programming.<br /><br />You&#8217;ll notice that I am not using the words &#8220;Functional Programming.&#8221; That&#8217;s because <strong>I&#8217;m not talking about Functional Programming</strong>. I&#8217;m talking about closures and first-class functions. I imagine that these things are present in all contemporary Functional Programming Languages, but that has nothing to do with my essay about the value of having first-class functions in an OO language: Smalltalk has had them in an OO language <em>for nearly thirty years</em>, and while it wasn&rsquo;t the first OO language, it is the canonical definition of class-based OO.<br /><br />That&#8217;s all I said. If you want to debate the merits of pure functional programming languages like <a href="http://www.haskell.org/">Haskell</a> against OO languages like Ruby, you have to take that up with someone like <a href="http://blog.moertel.com/" title="Tom Moertel">Tom</a> or <a href="http://www.randomhacks.net/" title="Eric Kidd">Eric</a>.<br /><br /><strong>What I don&#8217;t understand</strong><br /><br />I don&#8217;t understand the author&#8217;s objection to higher-order functional programming. He(?) says something about higher-order functions and type inference as being bad. I don&#8217;t get the argument. It seems like he is saying that the constructs are somehow too deeply nested, that it is too easy to make mistakes. I may not understand him correctly, for I have trouble seeing how this is different from having data structures with a thicket of HAS-A relationships.<br /><br />Somehow we program just fine in business with complex data schema, and we manage to keep track of things just fine. Strong typing and compiler support helps. So does IDE support. So does drawing diagrams. How is &#8220;a function taking an integer and a function taking two integers, returning a function taking a list of integers and returning an integer&#8221; somehow more complex than &#8220;a record containing an integer and that has many records containing an integer&#8221;?<br /><br />The argument seems to be (and I am open to correction, since what I think he&#8217;s saying is so obvious that I worry I&#8217;m misunderstanding it) that naming things makes all the difference, as in &#8220;a customer record with an ID has many Sales Records, each of which has an ID.&#8221; That does sound easier to understand.<br /><br />But of course, nothing stops you from naming things if you have first-class functions in a type checked OO language, does it? I am not a practitioner, but I have been working my way through <a href="http://www.amazon.com/gp/product/026256114X?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=026256114X">The Little MLer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256114X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, and it is part of the ML programming paradigm to name first-class functional types for precisely the reasons the author seems to advocate.<br /><br /><strong>Anonymity considered harmful?</strong><br /><br />So perhaps the objection is to having too many anonymous things, to having too many values without names. There is certainly an appropriate balance to be sought. One language designer seems to dislike anonymous functions, to the point where his language won&#8217;t let you have any that won&#8217;t fit on a single line. He has an <em>opinionated</em> language.<br /><br />I have seen similar arguments with non-functions. That control flow branches should not be nested too deeply (you know, <code>case</code> and <code>if</code> and the evil ternary operator). I often use the &#8220;extract variable&#8221; refactoring to simplify expressions and make them more readable. Naming a part of an expression provides a certain level of abstraction that improves comprehension.<br /><br />Types and expressions involving functions are no different, and if that&#8217;s what the author is saying I endorse his perspective.<br /><br />That statement, however, is somewhat orthogonal to whether first-class functions should exist in a language. As long as you can name them, you have the tool to write comprehensible code. If your language has types, then you ought to be able to name types involving first-class functions. As long as you can name functional values and types, you can apply all the same style guidelines to first-class functions that you apply to record types.<br /><br /><strong>In Conclusion</strong><br /><br />First-class functions are a natural fit with OO, as evidenced by their presence in OO languages that aren&#8217;t glorified PDP-11 assemblers with some OO stuff bolted on the side by people with <a href="http://www.noodlesoft.com/blog/2007/01/23/the-sun-also-sets/">very little OO and/or GUI programming experience</a>. First-class functions can be used to write clean and legible code, using all of the same techniques we use for writing clean and legible code with records, objects, and other types.<br /><br /><a href="http://www.wuenschenswert.net/wunschdenken/archives/117">From Functional to Object-Oriented Programming</a> has some interesting points about FP and OOP and their historical context. This has nothing to do with my original post, but I think those words are worth reading and considering. The post raises some caveats about complex and anonymous first-class functions that are obviously sensible: we have noticed the same things with other forms of expression in programming.<br /><br /><hr/><br /><ol><li>I will come clean here: when I think of OO, I am <em>not</em> thinking of C++ or Java, especially as they are practised in business. I&#8217;m thinking of languages like <a href="http://research.sun.com/self/language.html">Self</a>, <a href="http://en.wikipedia.org/wiki/Actor">Actor</a>, and <a href="http://www.smalltalk.org/">Smalltalk</a>.</li></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/02/hof-or-oop-yes.html" title="permanent link">10:16 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, January 31, 2007</div>
			

			<div class="Post"><a name="117030666664178098">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html" title="permanent link">Closures and Higher-Order Functions</a></span>
					<div style="clear:both;"></div>There has been a great deal of interest in <em><a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html">closures</a></em> lately, driven in great part by the fact that there is talk of adding some form of anonymous functions to the Java. Most of the time, people talk about “adding closures” to Java, and that prompts a flurry of questions of the form “what is a closure and why should I care?”<br /><br />The discussion around closures tends to go on and on about the “closing over” of free variables and only lightly touch on the biggest change to Java: functions as first-class objects with a lightweight syntax for creating them. Making it easy to do something basic like define a new function is more than just a little syntactic sugar: it makes it easy to do new things with functions that were impractical when you needed a lot of boilerplate to make anything work.<br /><br /><blockquote>Without understanding functional programming, you can’t invent MapReduce, the algorithm that makes Google so massively scalable.<br /></blockquote><div style="text-align: right;">—Joel Spolsky, <a href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">The Perils of JavaSchools</a><br /></div><br />I’m going to try to explain first class functions using Ruby (it <em>is</em> possible to write code that does exactly the same thing using the current Java feature set, however the result is so wordy that it obscures the basic idea being presented: call it accidental complexity, or perhaps <a href="http://weblog.raganwald.com/2006/12/economizing-can-be-penny-wise-and.html">yellow code</a>.)<br /><br /><a href="http://www.ruby-lang.org/">Ruby</a> is a good language for demonstrating features that ought to be in Java. Like Java, Ruby uses squiggly brace syntax. Like Java, everything in Ruby is an object&mdash;whoops, Java has primitives. Okay, like Java, functions are represented as objects.<br /><br />In Java you write:<br /><br /><pre><code>interface IFromIAndI {<br />   Integer call(Integer a, Integer b);<br />}<br /><br />IFromIAndI add_two_integers = new IFromIAndI() {<br />   public Integer call(final Integer a, final Integer b) {<br />      return a + b;<br />   }<br />};<br /></code></pre><br />(The Java convention is to name things in <a href="http://en.wikipedia.org/wiki/CamelCase">lowerCamelCase</a>, but we’ll ignore that. If you need to print this essay on a dot-matrix printer you may want to make some changes first.)<br /><br />In Ruby you write the function as:<br /><br /><pre><code>add_two_integers = lambda { |a,b| a + b }<br /></code></pre><br />Later on, when you want to call your function in Java, you write:<br /><br /><pre><code>add_two_integers.call(35, 42);<br /></code></pre><br />And if you like semicolons, you write the <em>exact same thing</em> in Ruby:<br /><br /><pre><code>add_two_integers.call(35, 42);<br /></code></pre><br />You can do the same thing with multiplication:<br /><br /><pre><code>multiply_two_integers = lambda { |a,b| a * b }<br /></code></pre><br /><strong>First Class Functions</strong><br /><br />In the examples above, functions look a little like methods. The Java version is obviously implemented as a method. But what we did in both cases was assign the resulting function to a variable. In Java, assigning a method to a variable is not particularly easy (it is possible using reflection).<br /><br />Anything that can be assigned to a variable is a <em>value</em>. If it can also be passed as a parameter or returned from a method (or function), we say it is a <em>first class value</em>. Functions as first class values, or first class functions, are very interesting. For example, what can we do passing a function as a parameter to another function?<br /><br />Hmmm. Well, I am breaking a cardinal rule of selling something. We’re talking about shiny new toys without identifying a problem to be solved. Let’s talk about my favourite problem: writing the same thing more than once, violating the <acronym title="Don't Repeat Yourself">DRY</acronym> principle.<br /><br />Here are two pieces of similar Ruby code:<br /><br /><pre><code>adder_wth_acc = lambda { |acc, list|<br />   if list.empty?<br />      acc<br />   else<br />      adder_wth_acc.call(acc + list.first, list[1..-1]) # [1..-1] returns a copy of the list without the first element<br />   end<br />}<br />adder = lambda { |list|<br />   adder_wth_acc.call(0, list)<br />}<br />adder.call([1, 2, 3, 4, 5])<br /></code></pre><br />And:<br /><br /><pre><code>multiplier_with_acc = lambda { |acc, list|<br />   if list.empty?<br />      acc<br />   else<br />      multiplier_with_acc.call(acc * list.first, list[1..-1]) # [1..-1] returns a copy of the list without the first element<br />   end<br />   }<br />   multiplier = lambda { |list|<br />   multiplier_with_acc.call(1, list)<br />}<br />multiplier.call([1, 2, 3, 4, 5])<br /></code></pre><br />What do they both do? Pretty much the same thing: they accumulate the result of some binary operation over a list of values. <code>adder</code> accumulates addition, and <code>multiplier</code> accumulates multiplication. You could call this a “Design Pattern.” If you did that, you would use the exact chunk of code everywhere. I would call that retrograde. Didn’t our predecessors invent the subroutine so we could eliminate writing the exact same piece of code over and over again?<br /><br />Why can’t we do the same thing? Well, we can. A subroutine does the same thing over and over again, but it takes different parameters as it goes. What is different between adder and multiplier? Ah yes, the adding and multiplying. Functions. What we want is a function that takes a function as a parameter.<br /><br />Well, we said that with first-class functions, functions are values and can be passed as parameters. Let’s try it:<br /><br /><pre><code>folder = lambda { |default_value, binary_function, list|<br />   fold_with_acc = lambda { |acc, list|<br />      if list.empty?<br />          acc<br />      else<br />          fold_with_acc.call(binary_function.call(acc, list.first), list[1..-1])<br />      end<br />   }<br />   fold_with_acc.call(default_value, list)<br />}<br /></code></pre><br />Now we can use our function that takes functions as a parameter:<br /><br /><pre><code>folder.call(0, add_two_integers, [1, 2, 3, 4, 5])<br />folder.call(1, multiply_two_integers, [1, 2, 3, 4, 5])<br /></code></pre><br />This is <strong>much</strong> better. When functions can take functions as parameters, we can build abstractions like <code>folder</code> and save ourselves a lot of code. Note that this would be a lot harder to read if we had to surround all of our functions with Object boilerplate in Java. That’s one of the key reasons why ‘syntactic sugar’—making it brief—is a big win.<br /><br />And you know what? Functions are values, not just variables that happen to hold functions. These work just as well:<br /><br /><pre><code>folder.call(0, lambda { |a, b| a + b }, [1, 2, 3, 4, 5])<br />folder.call(1, lambda { |a, b| a * b }, [1, 2, 3, 4, 5])<br /></code></pre><br />There’s just one problem (actually two, but I’m saving one for later): everywhere you use our new <code>folder</code> function, you need to remember that <code>add_two_integers</code> needs a default value of zero, but <code>multiply_two_integers</code> needs a default value of one. That’s bad. Sooner or later you will get this wrong.<br /><br />What we need is a way to call <code>folder</code> without having to always remember the correct initial value. Should we extend our understanding of a function to include a default initial value for folding? If we’re thinking in Java, maybe our <code>IFromIAndI</code> interface needs a <code>getDefaultFoldValue</code>? I think not. Why should a function know anything about how it’s used? And besides, as we build other abstractions out of functions we’ll need more stuff.<br /><br />If we aren’t careful, we’ll end up implementing the <code>Visitor</code> pattern on functions, and all of our brevity will go out the window. No, what we want is this: in one place we define that folding addition starts with a default value of zero and in another place we say we want to fold, say, <code>[1, 2, 3, 4, 5]</code> with addition. Then when we want to fold something else with addition, like <code>[2, 4, 6, 8, 10]</code>, we shouldn’t have to say anything about zero again.<br /><br /><strong>Adding Curry</strong><br /><br />What we need is a function that folds addition. Didn’t we say that functions are values that can be returned from functions? How about a function that makes a folding function? We should pass it our initial value and our binary function, and it should return a function that performs the fold without needing an initial value as a parameter:<br /><br /><pre><code>fold_coder = lambda { |default_value, binary_function|<br />   fold_with_acc = lambda { |acc, list|<br />      if list.empty?<br />          acc<br />      else<br />          fold_with_acc.call(binary_function.call(acc, list.first), list[1..-1])<br />      end<br />   }<br />   lambda { |list|<br />      fold_with_acc.call(default_value, list)<br />   }<br />}<br /></code></pre><br />Now we can do the following:<br /><br /><pre><code>adder = fold_coder.call(0, lambda { |a, b| a + b })<br />adder.call([1, 2, 3, 4, 5])<br />adder.call([2, 4, 6, 8, 10])<br /></code></pre><br />No more remembering that addition starts with a default of zero.<br /><br /><blockquote>Actually, there’s a far simpler way to avoid having to remember the default value when you want to fold over addition. But let’s just play along so that we don’t have to come up with an entirely new set of examples to demonstrate the value of functions as first-class values.<br /></blockquote>Functional programmers (as opposed to the rest of us <em>dysfunctional</em> programmers) will recognize this as <a href="http://en.wikipedia.org/wiki/Currying">currying</a> our <code>folder</code> function. Currying is when a function takes more than one parameter and you combine one of the parameters and the function to produce a function that takes fewer parameters.<br /><br />Here’s a currying function in Ruby:<br /><br /><pre><code>curry = lambda { |fn,*a|<br />   lambda { |*b|<br />     fn.call(*(a + b))<br />   }<br />}<br /></code></pre><br />(<em>This is an improvement on an earlier version, thanks to Justin's <a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html#117037273013059827">comment</a>.</em>)<br /><br />So you can use our new function to create an increment function out of our adder and a treble function out of our multiplier:<br /><br /><pre><code>plus_one = curry.call(add_two_integers, 1)<br />times_three = curry.call(multiply_two_integers, 3)<br /></code></pre><br /><br />If you are ever asked, “what good is currying?,” I hope I’ve given you an example you can use to explain why currying matters, and why people do it all the time (possibly without explicitly naming it). Although it doesn’t look like much when looking at trivial examples like functions that multiply by three, it’s much more useful when creating folders and mappers where you want some of the parameters to remain constant.<br /><br /><strong>Composition</strong><br /><br />Our examples combined functions and non-functions to create new functions. Here’s an example from a recent post, <a href="http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html">Don’t Overthink FizzBuzz</a>, where I give a method for <em>composing</em> two functions. The idea is that if you have multiple functions that each take one argument, you can combine them using <code>compose</code>. I also have a method that generates functions, <code>carbnation</code>:<br /><br /><pre><code># fizzbuzz.rb<br /><br />def compose *lambdas<br />  if lambdas.empty?<br />    lambda { nil }<br />  elsif lambdas.size == 1<br />    lambdas.first<br />  else<br />    lambda do |n|<br />      lambdas.first.call(compose(*lambdas[1..-1]).call(n))<br />    end<br />  end<br />end<br /><br />def carbonation(modulus, printable_form)<br />  i = 0<br />  lambda do |n|<br />    (i = (i + 1) % modulus) == 0 && printable_form || n<br />  end<br />end<br /><br />print(((1..100).map   &compose(     carbonation(15, 'FizzBuzz'), carbonation(5, 'Buzz'), carbonation(3, 'Fizz'))).join(' '))<br /><br /></code></pre><br />The simple explanation of how it works is that <code>carbonation</code> generates functions that replace every so many elements of a list with a printable string. <code>Compose</code> composes any two or more methods together. So if you want to print out 100 numbers, but replace every third number with “Fizz,” every fifth with “Buzz,” and all those that are third <strong>and</strong> fifth with “FizzBuzz,” you generate a function for each replacement, compose them together with compose, and then map the numbers from one to one hundred to the resulting überfunction.<br /><br />When you look at this today, it seems weird and unreadable by Java standards. I wonder if adding first-class functions with simple syntax to Java will lead the Java community to a place where code like this will not appear out of place?<br /><br /><strong>Just one more thing</strong><br /><br />So we started by saying that people are getting hung up on what makes a closure a closure, and there has been less emphasis on the benefits of using functions as first-class values. Did you notice that our <code>folder</code> function actually includes a non-trivial closure?<br /><br />If you look at the <code>fold_with_acc</code> function, it makes use of <code>binary_function</code>, a variable from its enclosing lexical scope. This is not possible with the current version of Java: if you translate this to Java, when you make <code>fold_with_acc</code> and anonymous inner class, you will have to copy <code>binary_function</code> into a final member to use it. It simply won’t compile if you try an idiom-for-idiom translation, even adding explicit types.<br /><br />And then if you look at the anonymous function it returns, <code>lambda { |list| fold_with_acc.call(default_value, list) }</code>, that anonymous function uses <code>default_value</code>,another variable from the enclosing lexical scope. Once again you will have to fool around with final variables to make this work, or perhaps declare full-fledged object with constructors.<br /><br />(If you try writing this simple example out in Java, you quickly find yourself inventing a lot of classes or interfaces. And they have some complicated types, like a function taking an integer and a function taking two integers, returning a function taking a list of integers and returning an integer.<br /><br />After twenty minutes of that, you understand why the <a href="http://www.ml.com/">ML</a> and <a href="http://planet.haskell.org/">Haskell</a> communities use <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: If the types are that complicated, it&rsquo;s incredibly helpful to have the compiler check them for you. Yet if the types are that verbose, it&rsquo;s incredibly painful to write them out by hand. Even if your IDE were to write them for you, they take up half the code, obscuring the meaning.<br /><br />You also get why the Ruby on Rails community doesn&rsquo;t care about type checking: types for CRUD applications are way less complicated than types for first-class functional programs.)<br /><br /><strong>That’s Interesting</strong><br /><br />Part of the interest in closures is in simplifying the syntax around functions, and part of the interest is in the way that access to enclosing scope would simplify a lot of code. There’s a whole debate around the value of simplification in a world where all serious languages are <a href="http://scienceblogs.com/goodmath/2007/01/turing_equivalent_vs_turing_co.php#more">Turing Equivalent</a>.<br /><blockquote><br />I hope you’re convinced, by now, that programming languages with first-class functions let you find more opportunities for abstraction, which means your code is smaller, tighter, more reusable, and more scalable.<br /></blockquote><div style="text-align: right;">—Joel Spolsky, <a href="http://www.joelonsoftware.com/items/2006/08/01.html">Can Your Programming Language Do This?</a><br /></div><br />For me, simpler is just nicer until something reaches a certain tipping point: when it becomes so simple that the accidental complexity of using it goes away, I will start using it without thinking about it. Tail optimization is like that: as long as recursion is slower than iteration and sometimes breaks, I have to think about it too much. But when I’m not burdened with “except…” and “when performance is not a factor…” it becomes natural.<br /><br />And then something interesting happens. It changes the way I look at problems, and one day I see a whole new way to do something that I never saw before. Functions as first class values are definitely one of those things that change everything.<br /><br /><span style="font-weight: bold;">Further Reading<span style="font-weight: bold;"><br /><br /></span></span>If this has whet your appetite for more, <a href="http://www.amazon.com/gp/product/0262011530?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&camp=211189&amp;creative=373489&creativeASIN=0262011530">Structure and Interpretation of Computer Programs</a> is <span style="font-style: italic;">the</span> book on higher-order functions and how they can be used as building blocks to create more elaborate abstractions such as object-oriented programming.<br /><br /><a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a> devotes an entire book to the uses of functions. Although the examples are in Scheme, the language is dead simple to learn and the techniques in the book can be applied to Ruby and Java (or at least to a future version of Java where you do not need functors).<br /><br />The second edition of <a href="http://www.amazon.com/gp/product/0974514055?ie=UTF8&tag=raganwald001-20&amp;link_code=as3&camp=211189&amp;creative=373489&creativeASIN=0974514055">Programming Ruby</a> is an indispensable guide. Even if you will not be using Ruby immediately, pick it up and discover why so many people are lauding the language's simple, clean design and powerful Lisp-like underpinnings.<br /><br />As the author says, &ldquo;<a href="http://www.amazon.com/gp/product/1558607013?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1558607013">Higher-Order Perl: Transforming Programs with Programs</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=1558607013" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is about functional programming techniques in Perl. It&rsquo;s about how to write functions that can modify and manufacture other functions.<br /><br />&ldquo;Why would you want to do that? Because that way your code is more flexible and more reusable. Instead of writing ten similar functions, you write a general pattern or framework that can generate the functions you want; then you generate just the functions you need according to the pattern. The program doesn&rsquo;t need to know in advance which functions are necessary; it can generate them as needed. Instead of writing the complete program yourself, you get the computer to write it for you.&rdquo;<br /><br />It&rsquo;s worth reading even if you have no intention of using Perl: the ideas span languages, just as SICP is worth reading even if you don&rsquo;t use Scheme at work. And be sure to read <a href="http://interglacial.com/hoj/">Higher-Order JavaScript</a> and <a href="http://blog.grayproductions.net/articles/category/higher-order-ruby/">Higher-Order Ruby</a>. They translate HOJ&rsquo;s ideas to other languages.<br /><br /><i>Notable Follow-ups:</i><br /><br /><a href="http://www.randomhacks.net/articles/2007/02/01/some-useful-closures-in-ruby">Some useful closures, in Ruby</a>: &ldquo;The <a href="http://en.wikipedia.org/wiki/Dylan_programming_language">Dylan programming language</a> included four very useful functions for working with closures: <strong>complement</strong>, <strong>conjoin</strong>, <strong>disjoin</strong> and <strong>compose</strong>.  The names are a bit obscure, but they can each be written in a few lines of Ruby.&rdquo;<br /><br /><a href="http://www.wuenschenswert.net/wunschdenken/archives/117">From Functional to Object-Oriented Programming</a>: &ldquo;OO allows a traceable connection between the conceptual design level and the implementation level. Concepts have names, so you can talk about them, between programmers and architects.&rdquo;<br /><br /><a href="http://weblog.raganwald.com/2007/02/hof-or-oop-yes.html">HOF or OOP? Yes!</a>: &ldquo;First-class functions are a natural fit with OO, as evidenced by their presence in OO languages that aren’t glorified PDP-11 assemblers with some OO stuff bolted on the side.&rdquo;<br /><br /><a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>: &ldquo;To truly learn a new tool, you must not just learn the new tool, you must apply it to new kinds of problems. It’s no good learning to replace simple iteration with first-class functions: all you’ve learned is syntax. To really learn first-class functions, you must seek out problems that aren’t easily solved with iteration.&rdquo;<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html" title="permanent link">11:55 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, January 24, 2007</div>
			

			<div class="Post"><a name="116969364618986488">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html" title="permanent link">Don't Overthink FizzBuzz</a></span>
					<div style="clear:both;"></div>I noticed some traffic coming to my post on <a href="http://weblog.raganwald.com/2006/07/hiring-juggler_02.html">juggling</a> from <a href="http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding">Using FizzBuzz to Find Developers who Grok Coding</a>. Like me, the author is having trouble with the fact that <a href="http://www.joelonsoftware.com/items/2005/01/27.html">199 out of 200</a> applicants for every programming job can’t write code at all. I repeat: <em>they   can’t write any code whatsoever</em>.<br /><br /><em>UPDATE: If you think that I just claimed that 199 out of 200 working programmers cannot code, stop immediately and either read my <a href="http://weblog.raganwald.com/2007/03/thank-you-for-writing-such-heartfelt.html">follow-up explaining the math</a>, or read Joel&rsquo;s article on <a href="http://www.joelonsoftware.com/items/2005/01/27.html">why companies aren&rsquo;t as picky as they think they are</a>. Thank you.</em><br /><br />So the author has decided to set the bar ridiculously low. As the post says:<br /><br /><blockquote>I’ve come to discover that people who struggle to code don’t just struggle on big problems, or even smallish problems (i.e. write a implementation of a linked list). They struggle with tiny problems.<br /></blockquote>He gives an example of a “tiny” problem that is quite suitable for a phone interview:<br /><br /><blockquote>Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.<br /></blockquote>One of the nice things about using a tiny problem is that anyone who has written actual code in the last six months will solve it in less than ten minutes. This is good because (a) it leaves more time for talking about important things, and (b) if the candidate can’t solve the problem you will find out right away and save yourself a lot of grief.<br /><br /><a href="http://gilesbowkett.blogspot.com/2007/03/fizzbuzters.html" title="Fizzbuzters">As you can imagine</a> from a post like this, quite a few people have stepped forward with <a href="http://programming.reddit.com/goto?id=10d7w">creative solutions</a>. Here’s mine:<br /><pre><code># fizzbuzz.rb<br /># see <a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html</a><br /><br />def compose *lambdas<br />  if lambdas.empty?<br />    lambda { nil }<br />  elsif lambdas.size == 1<br />    lambdas.first<br />  else<br />    lambda do |n|<br />      lambdas.first.call(compose(*lambdas[1..-1]).call(n))<br />    end<br />  end<br />end<br /><br />def carbonation(modulus, printable_form)<br />  i = 0<br />  lambda do |n|<br />    (i = (i + 1) % modulus) == 0 &amp;& printable_form || n<br />  end<br />end<br /><br />print(((1..100).map<br />   &amp;compose(<br />     carbonation(15, 'FizzBuzz'), <br />     carbonation(5, 'Buzz'), <br />     carbonation(3, 'Fizz'))).join(' '))<br /></code></pre><br />Right away I think you want to be careful if you ever trot a solution like this out in an <em>actual</em> interview. Here are some of the things that could go wrong:<br /><ul><li>The interviewer merely wanted to go through the motions of demonstrating you could program. Now she’s going to have to get into a discussion with you about how your solution works, which is irritating and wastes time that could have been invested more profitably on a <a href="http://weblog.raganwald.com/2006/06/my-favourite-interview-question.html">design question</a>;</li><br /><li>The interviewer might presume that you will always find the most indirect route to the destination and decide you belong in an ivory tower;</li><br /><li>The interviewer might not understand your solution at first glance but will make up for this by “bikeshedding” and grilling you about some minor nit like the failure modes of using <code>&&amp;</code> and <code>||</code> instead of the <code>if</code> statement or the ternary operator;</li><br /><li>The interviewer might have just finished <a href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=026256100X">The Seasoned Schemer</a> and grill you over why your solution doesn’t use the <a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y Combinator</a> to implement <code>compose</code> (snap!).</li></ul>Of course, some interviewers are just looking for an excuse to talk about technical issues and will not prejudge you in any way. Speaking for myself, I would laugh if you wrote something like this out. But then again, I once worked for someone who had won the second <a href="http://fly.cc.fer.hr/ioccc/years.html#1985_lycklama" title="Ed Lycklama, 'strangest appearing program', 1985">International Obfuscated C Contest</a>.<br /><br /><span style="font-style: italic;">Update</span>: <span style="font-weight: bold;">Don’t Overthink the Interview Either</span><br /><br />If you are conducting an interview and you receive a cryptic answer, or an impossibly concise one-liner, or perhaps something like the above that is redolent of Higher Order Functions, do you embrace the candidate as a genius? Or perhaps avoid them as someone who cannot write clear, maintainable code?<br /><br /><div class="book"><a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158"><img src="http://weblog.raganwald.com/uploaded_images/a_little_java-777624.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262561158" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><em><br /><br />Love to program but you need to use Java? Free your mind with <a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of <a href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262560992" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> and <a href="http://www.amazon.com/gp/product/026256114X?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=026256114X">The Little MLer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=026256114X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em><br /><br /></div>I suggest the best answer is <span style="font-weight: bold;">neither</span>. Stay on track: you asked the question for the purpose of eliminating the 199 out of 200 that have absolutely no hope of ever producing working software. You have just identified that this person is the one in two hundred applicants who can actually code. Mission accomplished. You aren’t trying to get to HIRE or NO HIRE over the phone.<br /><br />Invite them in for an interview: that’s the place where you can drill down and obtain their views on professional programming. Remember, this is a <span style="font-style: italic;">toy</span> problem. Unless you load the question down with requirements that their answer resemble production code, why should you have any expectation that the candidate only knows one way to write software?<br /><br />This is like trying to hire programmers who know both languages, FORTRAN <span style="font-style: italic;">and</span> COBOL.<br /><br />If you do ask them for production code, don’t be surprised if the best candidates decide not to work for you: they will rightly point out that FizzBuzz is not a realistic example of a production problem.<br /><br />Overall I think the best approach as an interviewer is the simplest: pose the simple question. Indicate it is a screener designed to confirm that they are the person described on the resume.<br /><br />If anything, tell them that there is no need for production artifacts like documentation and unit tests, you just want working code in as little time as they are able. The no-hopers won’t get it no matter how simple the question, and the good people won’t waste a lot of time with JavaDoc and xUnit.<br /><br />And then make your decision based on one objective fact: <span style="font-style: italic;">does the code run and produce the desired output</span>. Everything else is superfluous to the question of whether the candidate should be asked into your office for a face-to-face meeting.<br /><br /><span style="font-weight:bold;">Update</span>: <a href="http://weblog.raganwald.com/2007/03/thank-you-for-writing-such-heartfelt.html">a response to some of the criticism</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/jobs.html">jobs</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html" title="permanent link">9:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, December 20, 2006</div>
			

			<div class="Post"><a name="116662103123989601">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/12/giles-bowkett-turns-language-elitism.html" title="permanent link">Giles Bowkett turns language elitism upside down</a></span>
					<div style="clear:both;"></div><blockquote><br />To say that <a href="http://onsmalltalk.com/programming/smalltalk/languages-of-the-gods/">Lisp is a language of the gods</a>, and Java is a language for mortals, that could in fact be getting everything entirely backwards. <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">Scheme is actually easier to use than Java</a>. So the easier language is the language of the gods, and the hard one is the one for regular people? How does that make sense?<br /></blockquote><div style="text-align: right;">—Giles Bowkett, <a href="http://gilesbowkett.blogspot.com/2006/12/what-if-there-are-no-gods.html">What If There Are No Gods?</a></div><br /><br />Isn&#8217;t the idea that <em>languages like Scheme and SmallTalk are easier to use than languages like C# and Java</em> very interesting? Is this true? How could this be? The conventional wisdom is that languages like Scheme are <em>too abstract</em>. How could so-called novices grasp concepts like recursion, mapping, and folding when they have trouble remembering that the <code>main</code> method must be <code>static</code>?<br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262561158"><img border="0" src="http://weblog.raganwald.com/uploaded_images/a_little_java-777624.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262561158" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><em><br /><br />The authors of The Little Schemer and The Little MLer bring deep and important insights to the Java language. Every serious Java programmer should own a copy.</em></div>Could it be that more abstract languages are <em>smaller</em> languages? With a more abstract language, there are obviously fewer things you need to use to write even complex functions. That&rsquo;s the expressiveness people talk about: everyone grasps the idea that some languages let you express an algorithm in fewer bits of information. So with these languages, you need to use fewer bits of information to express each idea.<br /><br />Could it be that these same languages require you to learn fewer bits of information as well?<br /><br />I am reminded of one of those silly &#8220;Men are from Mars, <a href="http://ourworld.compuserve.com/homepages/women_rebuttal_from_uranus/school.htm">degrees are from mail-order stores</a>&#8221; aphorisms. The idea was that every bit of kindness is worth one point, no more no less. One rose? One point. A dozen roses? The same one point.<br /><br />We talk about some ideas (like mapping and folding) as if they are intrinsically harder to grasp and learn than other ideas (like iteration). But maybe it doesn&#8217;t require more bits to learn? Maybe map is one point and iteration is one point, even though we want to think that map is twelve points and iteration is two points?<br /><br />If that&#8217;s the case, could a language with fewer ideas that can be combined in succinct ways be easier to learn than a language with lots of different weak ideas?<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/12/giles-bowkett-turns-language-elitism.html" title="permanent link">8:21 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, December 16, 2006</div>
			

			<div class="Post"><a name="116628208495215893">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html" title="permanent link">Lisp is not the last word</a></span>
					<div style="clear:both;"></div><a href="http://www.tilton-technology.com/">Ken Tilton</a> <a href="http://groups-beta.google.com/group/comp.lang.lisp/msg/c03b6b011661c011" title="comp.lang.lisp posting">asked</a>: <em>What is up the power continuum from Lisp?</em><br /><br />I don’t have a ready answer. However, just because I don’t have an answer doesn’t mean I don’t believe there’s an answer. It could be that Lisp is a little like Democracy. It could be the least powerful programming language possible, excepting all of the others invented so far. But you know what? I have faith <em>we can do better</em>.<br /><br />Ken doesn’t say there isn’t a language up the power continuum. And I won’t say we have already invented one: like Ken, I’ll pose a question: <em>what law of computer science places a limit on the power continuum at Lisp?</em><br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/1400077974?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=1400077974"><img style="" src="http://weblog.raganwald.com/uploaded_images/meta_math-757398.png" alt="" border="0" /></a><em><br /><br />G.J. Chaitin explains his proofs of Kurt Godel’s incompleteness theorem and Alan Turing’s “halting problem” in computation. Chaitin’s creative use of Lisp in mathematics and fervent belief that no theorem is proof against new analysis are welcome shots of espresso.</em></div>Human history is chock-a-block full of inventions and practices that were considered for decades or even centuries to be the final word, the ultimate expression and implementation of ideas. And then someone came along and demolished everything. Geocentricity. Heliocentricity. Newtonian celestial mechanics. Light as a wave. Light as a particle. Three dimensions. Uniform space. Euclidian geometry.<br /><br />Some of these new ideas took years to take root while the establishment derided them as “not even wrong.” Others were so obviously right they immediately displaced what had come before. We might now have invented a more powerful language. Or we might have invented one but not realize it yet. But who can say that we haven’t invented a more powerful language and will never do so?<br /><br />If you believe there <span style="font-style: italic;">is</span> a power continuum, if you are not so obsessed with Turing Completeness and theoretical equivalence, what is the argument that it has any limit whatsoever, let alone that its limit is Lisp?<br /><br />I believe that the only language that is affixed to the top of the power continuum is <a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html">Blub</a>. For everyone whose imagination soars above the ceiling of their laboratory, Lisp is not the last word.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html" title="permanent link">9:56 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, November 22, 2006</div>
			

			<div class="Post"><a name="116423826413955025">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html" title="permanent link">The significance of the meta-circular interpreter</a></span>
					<div style="clear:both;"></div>A <a href="http://en.wikipedia.org/wiki/Self-interpreter">self-interpreter</a> is a &#8220;programming language interpreter written in the language it interprets.&#8221; A <a href="http://en.wikipedia.org/wiki/Metacircular_Interpreter">meta-circular interpreter</a> is a special case of a self-interpreter that applies only to programs where the primary representation of the program is a primitive data type in the language itself (this property is called homoiconicity). Lisp is such a language because Lisp programs are lists of symbols and other lists. XSLT is such a language because XSLT programs are written in XML.<br /><br />(If you have ever written an XSLT that transforms other XSLTs, then you immediately grasp the advantage of a meta-circular interpreter over an &#8216;ordinary&#8217; self-interpreter: it is not just possible, but it is <em>easy</em> to write programs that write programs, because you don't have to fiddle with transforming each program into an abstract data structure (typically a tree) that can be manipulated by your program.)<br /><br />This is interesting to both language theoreticians and hobbyists. But does it matter to those of us trying to get things done? What is the significance of meta-circular interpreters and self-interpreters?<br /><br />The short answer is that if you are working on meta-programming, a self-interpreter makes all things not just possible, but practical. The lack of such an interpreter places a limit on how much you can accomplish using your implementation language.<br /><br /><h4 id="meta-programming">Meta-programming</h4>Let&#8217;s start our examination of the significance of self-interpreters with a review of meta-programming, or bottom-up programming. This is the practice of constructing a programming language tailored to your problem space. You get your language&#8217;s basics working by building it on top of a base, or <em>implementation language</em>, and then you build your solution in your <em>solution language</em>.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://weblog.raganwald.com/uploaded_images/men_with_tools-706630.jpg"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://weblog.raganwald.com/uploaded_images/men_with_tools-798729.jpg" border="0" alt="" /></a>While meta-programming, you are working on two tiers either simultaneously or alternately: you work on expressing your solution in your solution language, and you work on the implementation (whether that be fun stuff like making it expressive or plumbing stuff like making it fast enough to be practical) in your implementation language.<br /><br />An important and popular sub-domain of meta-programming is the practice of writing <a href="http://en.wikipedia.org/wiki/Domain-specific_programming_language">Domain-Specific Languages</a> or DSLs. DSLs are solution languages tailored to resemble as closely as possible the human jargon of &#8220;domain experts.&#8221;<br /><br />(<a href="http://www.jroller.com/page/obie">Obie Fernandez</a> has an excellent <a href="http://obiefernandez.com/presentations/obie_fernandez-agile_dsl_development_in_ruby.pdf" title="Building Domain Specific Languages in Ruby">presentation</a> on the rationale for and construction of DSLs.)<br /><br />DSLs are commonly cited as useful in areas where programmers who are not domain experts collaborate with domain experts who are not programmer. In my own experience, DSLs are also valuable even when the programmers are themselves the domain experts. My rule of thumb for whether a DSL would be worthy of consideration is to ask how two programmers discussing the solution to a problem over an IM client would talk. If their language would closely resemble the natural constructs and idioms of their chosen implementation language, there is no need for a DSL.<br /><br />This is not always the case. A very classic example is that of SQL. SQL is a DSL designed for programmers to express relational algebra rather than the imperative steps for performing queries and updates. Although complex cases are impenetrable to the journeyman, its general form closely follows the way even a non-technical person would express their thoughts about data that is stored in tables.<br /><br />Another example of a successful DSL for programmers is the regular expression engine present in almost every language (whether baked in or as a commonly available library). Programmers do not discuss searching for text patterns in terms of backtracking and lookup tables and loops unless they are implementing a search library themselves.<br /><br />Programmers talk about <em>matching the string &#8216;Nokia&#8217; followed by four digits, a forward slash, and two numbers separated by a period</em> in the User-Agent Header. Regular expressions, while imperfect, match the way programmers think and talk about text matching much more closely than writing out the most efficient steps using <code>strstr</code> and <code>for</code> loops.<br /><br /><h4 id="what_about_the_meta_circular_interpreter">What about the meta-circular interpreter?</h4>Meta-circular interpreters are nothing new. Lisp is most famous for its <a href="http://weblog.raganwald.com/2005/03/page-thirteen.html">meta-circular interpreter</a>. But do you know that one of the world&#8217;s most popular programming languages has the next best thing, a self-interpreter? The C programming language&#8217;s compiler is written in C. That&#8217;s interesting. But why is it significant?<br /><br />Well, instead of heading up the &#8216;power continuum&#8217; and talking about Lisp, let&#8217;s stay with C for a moment. If you&#8217;re a C programmer and you become very, very interested in building a better programming language, you have in your hands the tool to make changes as you see fit.<br /><br />You might, for example, start with a pre-processor and implement the first version of your C++ language by mechanically translating a C++ program to C. Or you might bootstrap your C++ language by writing a compiler for C++ in C. Because you have in your hands all of the tools for going from source to running program, you can enhance and change its behaviour exactly as you please.<br /><br />When a language is not implemented in itself, you have limitations on your ability to create new forms. One might argue that Lisp&#8217;s macros make it possible to build any other language paradigm on top of Lisp. This is partially correct, however macros alone are not a complete answer. Macros act to rewrite local sections of programs.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0521545668/104-5191901-1508708?ie=UTF8&tag=raganwald-store-20&linkCode=xm2&creativeASIN=0521545668"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://weblog.raganwald.com/uploaded_images/lisp-768094.jpg" border="0" alt="" /></a>You cannot&#8212;to my knowledge&#8212;take a dialect of Lisp that does not support tail recursion and use macros to execute tail calls in constant space without rewriting every function using your macro. A similar argument holds for using <a href="http://library.readscheme.org/page6.html">macros to implement continuations</a>. You must manually rewrite every function using your macros if you want to change the global behaviour of your program.<br /><br />Manually <em>blank</em> every <em>blank</em>. This sounds an awful lot like something we can automate. Automatically transforming entire programs is the province of interpreters and compilers, isn&#8217;t it?  If you wish to perform transformations that are global in scope, you want a custom interpreter. Of course, you can write one from scratch in your implementation language.<br /><br />But&#8230; This sounds like we are headed towards the <a href="http://weblog.raganwald.com/2004/10/beware-of-turing-tar-pit.html">Turing Tar Pit</a>. Isn&#8217;t it much easier to use the interpreter that&#8217;s built in? Implementation languages that provide an interpreter or compiler for themselves provide an industrial-strength, debugged platform for the construction of solution languages.<br /><br />This is the other half of the power of Lisp: if you want to change deeper fundamental language features like whether you have a Lisp-1 or a Lisp-n, or whether all evaluation is lazy, or&#8230;, or&#8230;, or&#8230; you can, because Lisp interprets Lisp and Lisp compiles Lisp.<br /><br />It is this reason that languages like Ruby, which is implemented mainly in C, provide less maximum power than languages like <a href="http://www.squeak.org/" title="Squeak">Smalltalk</a>, which is <a href="http://users.ipa.net/~dwighth/squeak/oopsla_squeak.html">implemented mainly in&#8230; Smalltalk</a>. For example, there is talk&#8212;at this time&#8212;that continuations will be <acronym title="like the Income Tax is temporary?">temporarily</acronym> dropped from Ruby 1.9. If you have an application making heavy use of continuations, what is your upgrade path?<br /><br />Of course, not everyone <a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html" title="Are we Blub programmers?">thinks they need</a> all of a more powerful meta-programming implementation. You will have to decide for yourself whether a language without a meta-circular evaluator or self-interpreter offers other benefits that outweigh this significant feature.<br /><br /><h4 id="serving the self-interpreter to your canine companion">Serving the self-interpreter to your canine companion</h4>As Simen pointed out in a <a href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html#116429036918590040">comment</a>,  Ruby does have a third-party project to interpret Ruby in Ruby called <a href="http://blog.fallingsnow.net/rubinius/">Rubinus</a>. Assuming it graduates from its current status as an experimental work-in-progress, how is this different from having a self-interpreter baked into the language?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://weblog.raganwald.com/uploaded_images/climbers_dog-765949.jpg"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;" src="http://weblog.raganwald.com/uploaded_images/climbers_dog-763491.jpg" border="0" alt="" /></a>When a language is built on top of a self-interpreter, the language designers are forced to <a href="http://en.wikipedia.org/wiki/Dogfooding">eat their own dog food</a>.<br /><br />Now it is not correct to say that Matz does not use Ruby. He does, and so he does eat his own dog food. And for the domains where he uses Ruby, he has optimized Ruby to be a useful tool. But since he <em>doesn&#8217;t use Ruby to build Ruby</em>, he does not have the same incentive to tune Ruby for the purpose of building languages.<br /><br />An obvious example is Ruby&#8217;s performance. It is perfectly fine for <a href="http://rubyonrails.org">building CRUD applications</a>. However, it lacks really high performance when working with complex data structures in memory. This is the kind of thing that an interpreter or compiler has to do when parsing code or managing <a href="http://ce.sharif.edu/~dic-ads/d.php?ref=1&origin=stack&r=cactusstack.7.">cactus stacks</a>.<br /><br />Imagine what would have happened had Matz become impatient waiting for Ruby to interpret itself when he was first building the language? I suggest that the implementation and language would both be tweaked to bring performance up an order of magnitude or more. Programmers are notoriously impatient with slow tools.<br /><br />The implementation is not the only thing that improves when a language designer eats her own dog food by baking a self-interpreter into the language. The design of the language itself changes. Larry Wall has said that &#8220;Languages differ not so much in what they make possible, but in what they make easy.&#8221; When a designer builds their new language in itself, the language invariably makes building languages easy.<br /><br />So I suggest that the presence of a self-interpreter <em>baked right into the language, not bolted on as an after-thought</em> forces a language to be useful for building solution languages.<br /><br />(<em>This is not a broad criticism of Ruby, or a suggestion that Ruby is not an excellent tool for building a wide variety of useful solution languages. I&#8217;m just trying to point out the salient distinction between baking a self-interpreter into a language from the beginning and bolting one on the side.</em>)<br /><br /><h4 id="but_i8217m_a_tool_maven_not_a_language_maven">But I&#8217;m a tool maven, not a language maven</h4>Of course <a href="http://www.zwitserloot.com/">you</a> are. So tell me, how does <a href="http://www.eclipse.org/">Eclipse</a> do all of its magic with <a href="http://www.java.com/">Java</a>, a language lacking a self-interpreter?<br /><br />The answer is <a href="http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html">here</a>. The Eclipse team based Eclipse on VisualAge for Smalltalk. They were more than familiar with the benefits of having a self-interpreter, so they wrote most of one in themselves, in Java. Self-interpreters are also the basis for building advanced tools.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html" title="permanent link">6:23 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, November 17, 2006</div>
			

			<div class="Post"><a name="116378772384103978">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/11/first-seven-books-i-would-buy-if-my_17.html" title="permanent link">The first seven books I would buy if my shelves were bare</a></span>
					<div style="clear:both;"></div><a href="http://www.rufy.com/">Lucas Carlson</a> won a $100 gift certificate on <a href="http://www.amazon.com">Amazon.com</a> for his 2nd place entry at <a href="http://www.railsday2006.com/">Rails Day</a> (in collaboration with John Butler). Congratulations, Lucas!<br /><br />Lucas asked for suggestions on spending the money. I tried suggesting a new <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FApple-iPod-Nano-Black-Generation%2Fdp%2FB000EPHP4U%2Fsr%3D8-10%2Fqid%3D1163787219%3Fie%3DUTF8%26s%3Delectronics&amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">iPod Nano</a> loaded up with the SICP lectures in <a href="http://feeds.feedburner.com/SICP">video podcast form</a>. But as you would expect for someone working in a music-related venture, he has plenty of toys already.<br /><br />So… here are the first seven books I would buy if my shelves were bare (in no particular order):<br /><ol><li><a href="http://www.amazon.com/gp/product/0262011530?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0262011530">Structure and Interpretation of Computer Programs</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0262011530" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. You can read it for free <a href="http://mitpress.mit.edu/sicp/">on line</a>, but it’s even better as a physical book. One for the ages, it’s the kind of thing that ought to be bound in rich leather (if you go for that sort of thing) and kept in the library you build for your luxury castle.</li><br /><li><a href="http://www.amazon.com/gp/product/0192801422?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0192801422">To Mock a Mockingbird</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0192801422" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. It seems you can’t raise micro-capital these days without understanding <a href="http://en.wikipedia.org/wiki/Y_combinator">fixed point combinators</a>. Here’s the most enjoyable text on the subject of combinatory logic ever written. What other textbook features starlings, kestrels, and other songbirds?</li><br /><li><a href="http://www.amazon.com/gp/product/0140097015?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0140097015">The Media Lab: Inventing the Future at M. I. T.</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0140097015" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. Stewart Brand’s book captures the legendary think tank’s culture and ideas. Compare and contrast their view of broadcatch with today’s RSS feeds, or narrowcasting with today’s 500 channel television.</li><br /><li><a href="http://www.amazon.com/gp/product/0805074562?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0805074562">On Intelligence</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0805074562" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> A book that shook my views about how my brain works. To pick one nugget out of many, neurons are so slow that in the time it takes for us to react suddenly—say to duck a flying object—there is only time for a chain of at most 100 steps to complete. 100 steps do not permit us to perform <em>any</em> complex reasoning or look-up. Jeff explains how the neocortex can accomplish complex tasks using layers of parallel switches.</li><br /><li><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FPhilip-Alexs-Guide-Web-Publishing%2Fdp%2F1558605347%2Fsr%3D1-1%2Fqid%3D1163785428%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">Philip and Alex’s Guide to Web Publishing</a>. While the technologies suggested (TCL, AOLServer) are unlikely to float your boat, this is the most beautiful technical book on my shelves. Philip’s advice on how to build software for web publishing and approach is still relevant several generations of web developers later. (Also available <a href="http://philip.greenspun.com/panda/">on line</a> for free.)</li><br /><li><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FRecursive-Universe-Complexity-Scientific-Knowledge%2Fdp%2F0809252023%2Fsr%3D1-1%2Fqid%3D1163786265%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">The Recursive Universe: Cosmic Complexity and the Limits of Scientific Knowledge</a>. Although it seems to be out of print, hunt down a copy for yourself. A thrilling journey into the ideas of the great John Horton Conway and computation’s building blocks. Best of all, it’s explained beautifully using the legendary <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>. Who knew that <a href="http://en.wikipedia.org/wiki/Puffer_train_%28CA%29">puffer trains</a> and <a href="http://en.wikipedia.org/wiki/Spaceship_%28CA%29">spaceships</a> are Turing Complete?</li><br /><li><a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FQED-Strange-Princeton-Science-Library%2Fdp%2F0691125759%2Fsr%3D1-1%2Fqid%3D1164028852%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&amp;amp;amp;linkCode=ur2&camp=1789&amp;creative=9325">QED: The Strange Theory of Light and Matter</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=ur2&amp;o=1" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" />. Yes, the full <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FFeynman-Lectures-Physics-Definitive-Extended%2Fdp%2F0805390456%2Fsr%3D1-1%2Fqid%3D1163786913%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">Feynman Lectures</a> are incomparable, and for further thrills you can listen to him give the lectures on <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FFeynman-Lectures-Physics-Richard-Phillips%2Fdp%2F0738209287%2Fsr%3D1-10%2Fqid%3D1163786913%3Fie%3DUTF8%26s%3Dbooks&amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">audiobook</a>. But in QED, Feynman does this one magical thing: he explains how a mirror reflects light. And in the process of explaining how light actually reflects off a mirror, Feynman deconstructs classical physics and rebuilds our understanding with Quantum Electrodynamics. For a moment, you can understand how little we really know about how the universe works.</li></ol><br />Is there a book you would <a href="http://www.blogger.com/comment.g?blogID=7618424&amp;postID=116378772384103978">recommend</a>? What’re <a href="http://www.blogger.com/comment.g?blogID=7618424&amp;postID=116378772384103978">your feelings</a> about the books I’ve suggested?<br /><br />p.s. Shane Sherman’s <a href="http://www.turnofthecrank.com/2006/12/01/the-5-books-that-every-programmer-should-read/">The 5 Books that Every Programmer Should Read</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/11/first-seven-books-i-would-buy-if-my_17.html" title="permanent link">12:31 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, October 16, 2006</div>
			

			<div class="Post"><a name="116105348803572321">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/10/irony.html" title="permanent link">Irony</a></span>
					<div style="clear:both;"></div><blockquote>Programs must be written for people to read, and only incidentally for machines to execute.</blockquote><div style="text-align: right;">Abelson &amp; Sussman, <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&linkCode=ur2&camp=1789&creative=9325">Structure and Interpretation of Computer Programs</a><br /></div><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FStructure-Interpretation-Computer-Programs-Engineering%2Fdp%2F0262011530%2Fsr%3D8-1%2Fqid%3D1163785017%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald001-20&linkCode=ur2&camp=1789&creative=9325"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://weblog.raganwald.com/uploaded_images/sicp-786043.jpg" alt="" border="0" /></a>From time to time people quote this as a justification for staying <em>away</em> from high-level languages like Lisp, Scheme, <a href="http://www.planetpython.org/">Python</a>, and <a href="http://poignantguide.net/ruby/" title="Why's (Poignant) Guide to Ruby">Ruby</a>, and not only sticking to popular languages but also staying within the lowest-common denominator when choosing idioms within those popular languages.<br /><br />Isn’t it interesting that the quote is from a book explaining concepts such as recursion and metalinguistic abstraction? In Scheme?<br /><br />The <a href="http://mitpress.mit.edu/sicp/">full text</a> is on line. If you have yet to read it, I recommend you give it a try.<br /><br /><i>update: if you enjoyed reading <acronym title="Structure and Interpretation of Computer Programs">SICP</acronym>, you may find my list of <a href="http://weblog.raganwald.com/2006/11/first-seven-books-i-would-buy-if-my_17.html">the first seven books I would buy if my shelves were bare</a> interesting.</i><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/10/irony.html" title="permanent link">10:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, October 12, 2006</div>
			

			<div class="Post"><a name="116068720976582522">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html" title="permanent link">Are we Blub programmers?</a></span>
					<div style="clear:both;"></div>From time to time I open my email and find someone asking a question:<br /><br /><blockquote>What the hell is Blub? I take from context that it may be a pejorative generalist term for programming languages that encourage writing pablum instead of programs. Or maybe it really is a new language out there that has a huge following I'm unaware of. </blockquote><div style="text-align: right;"><a href="http://chalain.livejournal.com/">Chalain</a>, the "<span style="font-style: italic;">if you're not having fun, you're doing</span><span style="font-style: italic;"> it wrong</span>" guy<br /></div><br /><a style="margin: 0pt 0pt 10px 10px; float: right;" href="http://www.flickr.com/photos/raganwald/15824364/" title="Preparing to climb Lollipop Kids"><img src="http://static.flickr.com/10/15824364_16defaae5e_m.jpg" alt="Preparing to climb Lollipop Kids" border="0" height="240" width="180" /></a>Actually, Blub is a hypothetical programming language Paul Graham invented when describing something very interesting: the <span style="font-style: italic;">Blub Paradox</span>:<br /><br /><blockquote>Blub falls right in the middle of the abstractness continuum... As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages... Blub is good enough for him, because he thinks in Blub.</blockquote><div style="text-align: right;">Paul Graham, <a href="http://www.paulgraham.com/avg.html">Beating the Averages</a><br /></div><br />The interesting things about this paradox is that almost <span style="font-style: italic;">any</span> language could be Blub. The pre-requisites for a language being Blub are (a) there is at least one language less powerful than Blub, (b) there is at least one language <span style="font-style: italic;">more</span> powerful than Blub, and (c) that there be at least one programmer using Blub who accepts (a) but refutes (b) because he or she cannot see how the more powerful language is more powerful. She does not think in the <a href="http://www.braithwaite-lee.com/weblog/2006/01/finding-signal-to-noise-ratio-in-never.html">idioms</a> that the more powerful language affords.<br /><br /><div style="margin: 0pt 10px 10px 0pt; width: 240px; float: left; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&amp;amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325"><img style="cursor: pointer;" src="http://weblog.raganwald.com/uploaded_images/little_mler-705423.jpg" alt="" border="0" height="180" width="180" /></a><em><br /><br />The Little MLer introduces ML (and Ocaml) through a series of entertaining and straightforward exercises leading up to the construction of the Y Combinator.<br /><br />ML and OCaml introduce powerful strong typing and type inference. Both are great languages to learn: you will stretch your understanding of defining types and writing correct programs.<br /></em></div>When <span style="font-style: italic;">I</span> use the term, I am thinking of the language and also the programmers around it. Could Java be Blub? Sometimes, possibly often, but only when I'm thinking about Java programmers who dismiss Ruby's features as unnecessary. <a href="http://t-a-w.blogspot.com/2006/08/programming-in-blub.html">Could Ruby be Blub</a>? Sometimes, but only when I'm thinking about Ruby programmers who dismiss macros as unimportant.<br /><br /><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html">Could Lisp be Blub?</a> I suspect that Erlang and Haskell programmers might say that it is, provided we can find a Lisp programmer who feels that all progress in programming languages stopped when Common Lisp was standardized.<br /><br />At the same time, Java is not Blub when I am thinking of programmers <a href="http://weblog.raganwald.com/2006/10/in-praise-of-informed-choices.html">who are perfectly aware of its shortcomings and deliberately Greenspun around them for pragmatic reasons</a>. The same goes for any other language: it is sometimes Blub, and sometimes not Blub.<br /><br />So... I use the term "Blub" to refer to a programming language in the context of intransigent programmers who feel that their chosen tool is the best tool possible.<br /><br /><blockquote>Programming consists of overcoming two things: accidental difficulties, things which are difficult because you happen to be using inadequate programming tools, and things which are <em>actually difficult</em>, which no programming tool or language is going to solve. </blockquote><div style="text-align: right;"><a href="http://www.joelonsoftware.com/items/2006/10/12.html">Joel Spolsky reviewing Beyond Java<br /></a></div><br />This provokes a very obvious question: <span style="font-style: italic;">How do we know which things are accidentally difficult and which are actually difficult</span>? Is it only because we haven't discovered the right tool yet?<br /><br />It's easy to find a Java programmer who believes that all of the Design Patterns in the GoF's book are necessary. She believes that the difficulties of applying those patterns are actual difficulties of programming systems. It is only when she learns a different language that she realizes how the patterns were strongly driven by limitations in Java's object model.<br /><br />At that point she has an epiphany and understands that what she thought were actual difficulties were merely accidental difficulties. And the line between "accidental" and "actual" moves for her.<br /><br />No matter how much each us us thinks we know right now, are we nevertheless like this Java programmer, unable to see the difference between accidental and actual differences because we simply haven't discovered a more powerful tool?<br /><br />Are we Blub programmers?<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">update</span>: <a href="http://weblog.raganwald.com/2006/10/in-praise-of-informed-choices.html">In praise of informed choices</a> and </span><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html">Lisp is not the last word</a><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/java.html">java</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html" title="permanent link">4:40 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, August 18, 2006</div>
			

			<div class="Post"><a name="115591828041681735">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/08/dynamic-is-opposite-of-static-not-of.html" title="permanent link">Dynamic is the opposite of Static, not of Explicit</a></span>
					<div style="clear:both;"></div>I recently read a post where the author said he does not care for Ruby's dynamic typing.<br /><br />When people start talking about types in programming languages, the terms fly around in a rather fast and loose manner. Here's a rather extensive and balanced discussion: the article on <a href="http://en.wikipedia.org/wiki/Type_system">Type Systems</a> in Wikipedia.<br /><br />Notice that Ruby is <span style="font-style: italic;">dynamically typed</span> (it's types are determined at run time and can change at run time), <span style="font-style: italic;">strongly typed</span> (it does not allow an operation to succeed on arguments which have the wrong type), and <span style="font-style: italic;">type-safe</span> (it does not allow operations or conversions which lead to erronous conditions).<br /><br /><a href="http://www.flickr.com/photos/raganwald/217905842/" title="Stuck on Stupid"><img src="http://static.flickr.com/62/217905842_095b0d071a_o.jpg" alt="Stuck on Stupid" border="0" height="400" width="400" /></a><br /><br />(There's another school of thought about how to name the properties of type systems. More on that at the bottom.)<br /><br />Proponents of <span style="font-style: italic;">explicit</span> <span style="font-style: italic;">types </span>may say that Ruby is not type safe because it is possible to compile programs that contain errors which will not be detected until the program is run and the erroneous condition is detected.<br /><br />Statically typed languages such as C# can detect a class of such errors at compile time. Some Ruby enthusiasts argue that they do not like the boilerplate associated with explicit typing and feel that the extra error checking does not outweigh the additional overhead.<br /><br />Both arguments are mistaken. Sorry about that. If Explicit and Implicit were the issues, we could add <a href="http://en.wikipedia.org/wiki/Type_inference">Type Inference</a> to Ruby and it would have the low overhead of implicit types as well as some extra error-checking (work on Soft Typing for languages like Scheme and Erlang aims to provide compile-time checking for implicitly typed languages). However, type inference is a feature of <span style="font-style: italic;">statically </span>typed languages.<br /><br />The trouble is that Ruby is <span style="font-style: italic;">dynamically </span>typed. Specifically, Ruby contains extensive <span style="font-weight: bold;">dynamic meta-programming</span> constructs. Type inference works with statically typed languages. The compiler must be able to infer the type or set of types possible for any variable.<br /><br />Consider a Ruby application that modifies classes and objects at run time. The simplest example is Ruby's built-in accessor methods: <span style="font-weight: bold;">attr_accessor :foo</span> is a class method that actually creates two instance methods at run time, <span style="font-weight: bold;">foo </span>and <span style="font-weight: bold;">foo=</span>. What happens when attr_accessor is called with a <span style="font-style: italic;">variable</span> as its argument, like <span style="font-weight: bold;">attr_accessor my_attribute</span>?<br /><br />If the type inference engine later looks at a call such as <span style="font-weight: bold;">bar.blitz = 'bash'</span>, how does it know whether attribute_accessor was ever called with 'blitz' or :blitz as an argument? Dynamic meta-programming makes the type inference problem undecidable.<br /><br />A lucid argument is that Ruby's dynamic typing makes it difficult to detect type errors statically. The <span style="font-style: italic;">correct </span>counter-argument is that Ruby's style of dynamic typing makes it possible to use dynamic meta-programming, such as <a href="http://rubyonrails.org">Ruby on Rails</a>' ActiveRecord, not that Ruby's implicit typing is more productive.<br /><br />Once you've made these arguments, you can decide for yourself whether the benefits of dynamic meta-programming do or do not outweigh the advantages of static type checking.<br /><br />(Updated to use the expression "dynamic meta-programming" to distinguish features like <span style="font-style: italic;">define_method </span>from static meta-programming features like macro systems, courtesy of the well-informed <a href="http://lambda-the-ultimate.org/node/1681">Lambda the Ultimate</a>).<br /><br /><div style="text-align: right;"><span style="font-style: italic;">fin</span><br /></div><br /><span style="font-size:85%;">p.s. <a href="http://c2.com/cgi/wiki?WelcomeVisitors"><span style="text-decoration: underline;">Ward's Wiki</span></a> seems to use the term <a href="http://c2.com/cgi/wiki?StaticTyping">static typing</a> to mean the same thing as explicit and strong typing. I prefer that the term static means that it doesn't change. The same wiki seems to use the term <a href="http://c2.com/cgi/wiki?DynamicTyping">dynamic typing</a> to mean the same thing as implicit and strong typing. It includes the possibility that a program is what I would call strongly, statically and implicitly typed: the checking is done at run time but the types of variables never change. The commentary suggests the phrase <span style="font-style: italic;">semantic dynamic typing</span> for the quality of dynamic typing that encompasses dynamic meta-programming. If you like these terms, please substitute "semantic dynamic typing" for "dynamic typing" above.</span><br /><br /><span style="font-size:85%;">p.p.s. And there's another argument that dynamic meta-programming, like macros, should be considered harmful. I'm saving my reply for a rainy day.</span><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/08/dynamic-is-opposite-of-static-not-of.html" title="permanent link">11:11 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, January 18, 2006</div>
			

			<div class="Post"><a name="113760257639104711">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/01/eq-lisp-0.html" title="permanent link">(eq? 'lisp  0)</a></span>
					<div style="clear:both;"></div>I just <a href="http://www.jimloy.com/math/zero0.htm">read</a> (via Jim Loy's <a href="http://www.jimloy.com/math/math.htm">math pages</a>) that it took Europe approximately <span style="font-style: italic;">five centuries</span> to adopt <a href="http://en.wikipedia.org/wiki/0_%28number%29">zero</a> and the Hindu-Arabic numbering system. ("from about <acronym title="1200">twelve hundred</acronym> when Fibonacci introduced Hindu-Arabic numbers to Europe, to about <acronym title="1700">seventeen hundred</acronym> when they became popular").<br /><br />So... <a href="http://planet.lisp.org/">Lisp</a> has only been around since <acronym title="1959">nineteen fifty-nine</acronym> or so, <span style="font-style: italic;">not even five decades</span>. We may have to wait another <acronym title="454">four hundred and fifty-four</acronym> years before every programming language embraces program/data equivalence, bottom-up programming, functional programming, macros, and even parentheses.<br /><br />As Jim points out, many people exposed to the new system may not have seen the advantages. Their existing zero-less numbering systems suited their existing needs just fine. This argument struck me as familiar.<br /><br /><a href="http://www.braithwaite-lee.com/weblog/2006/01/finding-signal-to-noise-ratio-in-never.html">Plus ça change... (plus c'est la même chose)</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/01/eq-lisp-0.html" title="permanent link">11:21 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, November 14, 2005</div>
			

			<div class="Post"><a name="113202013492878044">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2005/11/repost-closures-in-ruby.html" title="permanent link">Repost: Closures in Ruby</a></span>
					<div style="clear:both;"></div><p>(<span style="font-style: italic;">I wrote the original version of this page in 2002. I've made a few minor edits and added a comparison with Java's anonymous inner classes</span>)<br /></p> <p>I briefly worked with a team that used Perl to implement high availability web applications. When discussing the language with the team’s technical lead, I pointed out that I was impressed with the fact that Perl implemented <i>closures</i>. Having written a Scheme interpreter, I considered closures a fundamental component of modelling procedures.  </p>  <p>This led to a discussion of what was a closure, and what was it good for?</p>   <p></p><blockquote>A closure encapsulates the execution of a one or more operations for side effects and/or the return of a value in the environment of the function’s definition where the closure was created.</blockquote>From this definition, all functions, procedures, and methods in languages such as Java and Visual Basic are closures. When a programmer refers to a language as implementing closures, (s)he is really saying that the language permits the creation of arbitrary closures at run time. Scheme aficionados would say that languages like Perl, Lisp, and Ruby support <i>first class closures</i><span style="font-style: normal;">: closures can be arbitrarily created and assigned as values to variables or returned from functions.</span><br /><br /><p>Since contemporary programming languages are lexically scoped, the environment of the function refers to the variables in scope at the time the function is defined. This includes temporary variables, variables that are normally created on some sort of stack and discarded when they “go out of scope.” When a closure is created, variables in scope must be preserved until the closure itself ceases to exist.</p>  <p style="font-style: normal;">Here’s a Ruby closure demonstrating the fact that it ‘captures’ a variable in the scope of its definition:</p>  <pre>def makeCounter<br />var = 0<br />lambda do<br />var +=1<br />end<br />end<br /><br />c1 = makeCounter<br />c1.call<br />c1.call<br />c1.call<br /><br />c2 = makeCounter<br /><br />puts "c1 = #{c1.call}, c2 = #{c2.call}"</pre> <p> The two important things from this example are:</p>  <ol> <li><p>Although <i>var</i><span style="font-style: normal;"> is no  longer in scope once makeCounter returns, Ruby saves it for use in  the closure.</span></p>  </li><li><p style="font-style: normal;">Each invocation of makeCounter  creates a different <i>var</i>. The two counters do not interfere  with each other.</p> </li> </ol>  <p style="font-style: normal;">What can you do with closures? Here’s something a bit more useful, a call-by-need thunk factory:</p>  <pre>def delay(&procToDelay)<br />value = nil<br />return lambda do<br />if value.nil?<br />  value = procToDelay.call()<br />else<br />  value<br />end<br />end<br />end<br /><br />def force(thunk)<br />thunk.call()<br />end<br /><br />foo = delay do<br />puts "thinking about foo"<br />"fu"<br />end<br /><br />bar = delay do<br />puts "thinking about bar"<br />"british american racing"<br />end<br /><br />puts force foo<br />puts force bar<br />puts force foo<br />puts force bar</pre> <p> In this example, you have a simple facility for memoizing closures: they can be called repeatedly, but they only evaluate their operations once (provided the retun value is not nil). Obviously, this should not be combined with the previous example: call-by-need thunks are useful when there are no side effects of their evaluation.<br /></p> <p><span style="font-weight: bold;">Why Java's Anonymous Inner Classes do not implement closures</span><br /></p> <p>At first glance, an anonymous inner class in Java looks like it captures an environment. It has access to its enclosing instance's members. That looks an awful lot like the way a closure captures its environment.<br /></p> <p>But an anonymous inner class cannot access method variables or parameters. This is a crippling limitation. Consider:<br /></p> <pre>interface Transformer {<br />    int transform (int what);<br />}<br /><br />class TransformerConstructionKit {<br /><br />public static Transformer makeMultiplier (int timesWhat) {<br />   return new Transformer () {<br />      public int transform (int what) {<br />          return what * timesWhat;<br />      }<br />  };<br />}<br /><br />}<br /><br /></pre> <p>This is illegal in Java for some reason. Ok, I know what the reason is. But I don't have to like it, do I?<br /></p><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2005/11/repost-closures-in-ruby.html" title="permanent link">8:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, March 23, 2005</div>
			

			<div class="Post"><a name="111159643753670102">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2005/03/page-thirteen.html" title="permanent link">Page Thirteen</a></span>
					<div style="clear:both;"></div>In <a href="http://acmqueue.com/modules.php?name=Content&pa=printer_friendly&amp;amp;amp;amp;pid=273&page=1">a recent interview posted on ACM Queue</a>, Alan Kay described a starting revelation:<br /><p><strong></strong></p><blockquote><p><strong>Stuart Feldman</strong> If nothing else, Lisp was carefully defined in terms of    Lisp.</p>  <p> <strong>Alan Kay</strong> Yes, that was the big revelation to me when I was in graduate school when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were Maxwells Equations of Software! This is the whole world of programming in a few lines that I can put my hand over.</p></blockquote><p> </p> Here's the page in question:<br /><br /><a href="http://www.flickr.com/photos/raganwald/212588975/" title="The original metacircular evaluator"><img src="http://static.flickr.com/86/212588975_5fa840ddd2_o.png" width="540" height="729" alt="The original metacircular evaluator" /></a><br /><br />Defining Lisp in terms of Lisp is something of a tradition. One of the best books I've ever read about programming is <a href="http://print.google.com/print?id=WlfeXpW3Z8EC&amp;prev=http://print.google.com/print%3Fq%3Dlisp%2Bin%2Bsmall%2Bpieces&pg=xiii&amp;sig=61KbGD8JRRDP8PNlZjJ6q-l9BIE">Lisp in Small Pieces</a> by Christian Queinnec:<br /><br /><a href="http://images.amazon.com/images/P/0521545668.01.LZZZZZZZ.jpg"><img src="http://images.amazon.com/images/P/0521545668.01.MZZZZZZZ.jpg" /></a><br /><br />Christian explains fundamental elements of computer science by implementing each element in a series of interpreters and compilers.<br /><br />I'm tempted to try to sum this post up with a heavy conclusion, to try to derive some deep meaning from this. But you know, if you see the world the way I do, the meaning is obvious, I'd just be preaching to the choir.<br /><br />I'll take the pretentious way out and close with an ancient quote:<br /><br /><span style="font-style: italic;">Do not walk in the footsteps of the sages. Instead, seek what they sought</span>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2005/03/page-thirteen.html" title="permanent link">11:32 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://reginald.braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://weblog.raganwald.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://weblog.raganwald.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://weblog.raganwald.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://weblog.raganwald.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://weblog.raganwald.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://weblog.raganwald.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://weblog.raganwald.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://weblog.raganwald.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://weblog.raganwald.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://weblog.raganwald.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://weblog.raganwald.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://weblog.raganwald.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://weblog.raganwald.com/uploaded_images/coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://weblog.raganwald.com/uploaded_images/coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://weblog.raganwald.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://weblog.raganwald.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://weblog.raganwald.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://weblog.raganwald.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://weblog.raganwald.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://weblog.raganwald.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://weblog.raganwald.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://weblog.raganwald.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://weblog.raganwald.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://weblog.raganwald.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://weblog.raganwald.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://weblog.raganwald.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://weblog.raganwald.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://weblog.raganwald.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://weblog.raganwald.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://weblog.raganwald.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://weblog.raganwald.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://weblog.raganwald.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://weblog.raganwald.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://weblog.raganwald.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://weblog.raganwald.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://weblog.raganwald.com/welcome.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/327583163-csitaillib.js"></script>
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>