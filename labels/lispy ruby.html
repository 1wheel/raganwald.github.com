<html><head><title>Raganwald</title>

<style>
/* style modified from glish: http://www.glish.com/css/ */

body{margin:0px 0px 0px 0px;font-family:trebuchet ms, verdana, sans-serif;background-color:white;}
#Title{font-size:63px;padding-left:15px;padding-top:10px;text-transform:uppercase;font-family:trebuchet ms, verdana, sans-serif;}
#Title a {text-decoration:none;color:inherit;}
#Description{padding:0px;padding-top:10px;font-size:12px;font-weight:normal}
.DateHeader{border-bottom:none;font-size:15px;text-align:left;margin-top:20px;margin-bottom:14px;padding:1px;padding-left:17px;color:gray;font-family:trebuchet ms, verdana, sans-serif;}
.PostTitle{font-size:18px;font-weight:bold}
.Post{padding-left:20px;margin-bottom:20px;text-indent:10px;padding-right:20px;line-height:22px}
.PostFooter{margin-bottom:15px;margin-left:0px;color:black;font-size:10px}
.comment-link {margin-left:.6em;}
@media all {
  #leftcontent{background-color:whitesmoke;border-right:2px dashed #000;border-bottom:0px dashed #000;float:left;padding-bottom:20px;margin-right:15px;padding:0px;width:67%;border-top:0px dashed #000}
}
@media handheld {
  #leftcontent{border-right:0px dashed #000;float:none;margin:0 5% 0 5%;width:90%;}
}
.SideBarTitle{font-weight:bold;font-size:18px}
h1{font-size:14px;padding-top:10px}
a{text-decoration:none}
a:hover{border-bottom:dashed 1px red}
@media all {
  #rightcontent{font-size:12px;height:100%;margin-left:0px;text-transform:none;padding-right:10px;background-color:white;}
}
@media handheld {
  #rightcontent{margin:0 5% 0 5%;}
}
.blogComments{font-size:15px;text-align:left;margin-top:20px;margin-bottom:14px;padding:1px;padding-left:17px;color:gray;font-family:trebuchet ms, verdana, sans-serif;}
.blogComment{margin-top:10px;margin-bottom:10px;color:black;text-indent:10px;padding-right:20px;line-height:22px}
.deleted-comment {font-style:italic;color:gray;}
.byline{margin-bottom:20px;margin-left:0px;margin-right:10px;color:black;font-size:10px;display:inline}
#profile-container { }
.profile-datablock { }
.profile-img {display:inline;}
.profile-img img {float:left;margin:0 10px 0px 0;border:4px solid #ccc;}
#profile-container p { }
#profile-container .profile-textblock { }
.profile-data strong {display:block;}

blockquote:first-letter {
background: #f8f6f6 url(/assets/quoteleft.gif)left top no-repeat;
letter-spacing: -.06em; padding-left:30px;font-size:1.6em; }

blockquote {
background: #f8f6f6 url(/assets/quoteright.gif) right bottom no-repeat;
font-weight: normal; font-style:oblique; color: #444;
margin: 0px 50px 10px 20px; padding: 0px 25px 0px 4px;
line-height:1.5; border-top:1px solid #efefef;
border-bottom:1px solid #efefef; }

div.book {
    float: right; width: 240px; margin-left: 10px; font-style: italic; text-align: center; font-size: 80%;
}

</style>
<!-- Meta Information -->
<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="MSSmartTagsPreventParsing" content="true" />
<meta name="generator" content="Blogger" />
<link rel="alternate" type="application/atom+xml" title="Raganwald (Atom 0.3)" href="http://feeds.feedburner.com/raganwald" />
<link rel="alternate" type="application/rss+xml" title="Raganwald (RSS 2.0)" href="http://feeds.feedburner.com/raganwald" />
<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />
<style type="text/css">
@import url("http://www.blogger.com/css/blog_controls.css");
@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
</style>

<!-- /Meta Information -->
</head><body>

<div id="leftcontent">
	<div id="Title" style="background: #FFFFFF; padding-bottom: 12px;">
    
	<img src="http://raganwald.github.com/assets/raganwald.png" width="352" height="90" border="0" alt="raganwald" title="raganwald, now with Web 2.0 beta goodness"/>
	

  </div>


   
   
        <div class="DateHeader">Monday, February 26, 2007</div>
   

       <div class="Post"><a name="4134602127458276092">&nbsp;</a>
   <span class="PostTitle">

<a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">Haskell, Ruby and Infinity</a></span>
   <div style="clear:both;"></div>Languages like Haskell support <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>. In principle, you only compute what you actually need, everything else just goes away. If you usually need everything you compute, this may seem like a frill: elegant, even interesting, but having little practical importance. I find it is very much like Tail Call Optimization: if you don&rsquo;t have it, you code around it. Often it makes no difference, but from time to time there is a case where your code will be clearer and more maintainable if you express yourself succinctly and let the compiler do the work of making it efficient.<br /><br />This post is a switch from mumbling about <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y Combinators</a> and using trivial cases to explain interesting ideas: I&rsquo;m going to show some actual code I&rsquo;m writing. I apologise in advance if this adds so much background that it obscures the message about lazy evaluation: extremely simplistic examples sometimes work against the argument because it is too easy to think of other ways to accomplish the needed results.<br /><br />I don&rsquo;t apologise <em>at all</em> for the unpolished nature of the code. This isn&rsquo;t a textbook. And besides:<br /><blockquote><br />Anybody can say you can&rsquo;t write. Let no one say you don&rsquo;t.<br /></blockquote><p style="text-align: right;">&mdash;Ken Rand, courtesy of <a href="http://chalain.livejournal.com/">Chalain</a><br /><br /></p><hr /><br /><br />I&rsquo;ve been <a href="http://en.wikipedia.org/wiki/Hacker">hacking</a> some na&iuml;ve code to cluster data sets.<br /><blockquote><br />In computer programming, a hacker is a software designer and programmer who builds elegant, beautiful programs and systems… For some, &ldquo;hacker&rdquo; has a negative connotation and refers to a person who &ldquo;hacks&rdquo; or uses kludges to accomplish programming tasks that are ugly, inelegant, and inefficient.<br /></blockquote><p style="text-align: right;">&mdash;Wikipedia</p>The clustering algorithm requires a very large, fixed set of curves.<sup>1</sup> I wrote the initial curve generation by building a gigantic list of parameter tuples, and then processing the list into records. Once the &ldquo;search space&rdquo; grew beyond a trivial size, the program began to eat enormous amounts of memory. The problem was that I was trying to write the generation code as clearly as possible, and that created a massive thicket of objects that all resided in memory simultaneously.<br /><br /><div style="float: right; width: 240px; margin-left: 10px; font-style: italic; text-align: center; font-size: 80%;"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Bezier_curve.svg/800px-Bezier_curve.svg.png" height="150" width="240" />The curves being generated are paths composed of cubic beziérs. Each segment on the path requires specifications for four different control points.<br /></div>I rejected the idea of a rewrite into looping, imperative form, I wanted to separate the &ldquo;list comprehension&rdquo; code from the &ldquo;make it run in less than a gigabyte&rdquo; code. Instead, I chose to use lazy evaluation: the principle is that although the code defines a huge data structure that takes up gigabytes, we only actually evaluate things as we need them, and we discard them when we are done, so the total memory footprint for the lazy form is about the same as the memory footprint for an imperative form.<br /><br />The easiest way to perform the refactoring&mdash;besides a rewrite in Haskell&mdash;was to switch all of the arrays I used for a lazy list data structure. A lazy list is a linked list composed of head and tail tuples (known as <a href="http://en.wikipedia.org/wiki/Cons">cons cells</a>). Where a normal linked list holds an element and the rest of the list, a lazy list holds an element and a function for computing the rest of the list (<a href="http://mitpress.mit.edu/sicp/">SICP</a> calls them &ldquo;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">streams</a>.&rdquo;)<br /><br />If a modicum of care is taken not to pin objects down, you can build fantastically large lazy lists and process them at will. In fact, lazy lists can be infinitely large if you provide the appropriate function for generating the list<br /><br />For that reason, you should never append one lazy list onto another lazy list. Consider <code>odd = LazyList.unfoldr(1) { |n| n + 2 }</code> and <code>even = LazyList.unfoldr(0) { |n| n + 2 }</code>. If you append <code>odd</code> onto <code>even</code>, the resulting list in theory has both even and odd numbers. But in practice you can never reach the odd numbers because there is an infinite quantity of even numbers at the front of the list.<br /><br />Instead, <code>merge</code> them together to produce a lazy union of the two lists. Merge interleaves alternating elements from each list, so the resulting lazy list contains all the elements of each list, and if you take a finite sample, such as the first 1,000 elements, you get 500 of each. <code>even.merge(odd) => (0 1 2 3 ...)</code>. (Other interesting operations that work with infinite lists include <code>cons</code>, <code>pairwise</code> and <code>product</code>.)<br /><br /><blockquote><br />Any sufficiently complicated Lisp or Ruby program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Haskell.<br /></blockquote><br />My current version of a <code>LazyList</code> class in Ruby is <a href="http://weblog.raganwald.com/source/lazy_lists.html">here</a>. As soon as I switched from the &ldquo;eager&rdquo; code using arrays to the &ldquo;lazy&rdquo; code using lazy lists, memory use went down and performance went up. Not as much as a switch to imperative (and not even close to writing a better clustering algorithm), but enough that I can move forward.<br /><br />Here is an example of a function using arrays to enumerate choices (<code>distribute(2, 1..4) -&gt; [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</code>):<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return [] if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    return range.to_a.map { |spot| [spot] }<br />  else<br />    (range.begin..(range.end - remaining_choices)).to_a.inject([]) { |acc, first_spot| acc + (distribute(remaining_choices, (first_spot + 1)..range.end).map { |remaining_distribution| remaining_distribution.unshift(first_spot) }) }<br />  end <br />end<br /></code></pre>And rewritten with lazy lists:<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return LazyList.new() if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    LazyList.from_range(range).map { |spot| LazyList.from_element(spot) }<br />  else<br />    LazyList.from_range(range.begin..(range.end - remaining_choices)).mapr(:merge) do |first_spot|<br />      distribute(remaining_choices, (first_spot + 1)..range.end).map do |remaining_distribution| <br />        LazyList.cons(first_spot, remaining_distribution) <br />      end<br />    end<br />  end <br />end<br /></code></pre>It&rsquo;s almost identical. <code>LazyLists</code> replace arrays, <code>mapr</code> replaces accumulating a list with <code>inject</code>, and <code>cons</code> replaces <code>unshift</code>, but otherwise it&rsquo;s the same code. Mission accomplished: we&rsquo;ve changed the behaviour without having to change the way we express our algorithms. Had we wanted to, we could have supported enough array syntax that Lazy Lists look exactly like arrays, but that isn&rsquo;t necessary.<br /><br />And when running the entire generator, the memory footprint is dramatically lower. For example, this small routine quoted above no longer generates an array of arrays: it generates a structure that can generate the lists when needed. Switching the data structure changes the evaluation behaviour of the generator code: it gets us 80% of having an imperative structure without having to tie the code to the implementation.<br /><br />This is exactly what separation of concerns is all about: <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html">green code here, yellow code there</a>.<br /><br /><strong>Lazy evaluation is the red pill</strong><br /><br />It&rsquo;s great to make a change to the code&rsquo;s behaviour without changing the way we think about the solution to our problem. But you know what? It isn&rsquo;t <em>interesting</em>. In fact, if lazy optimization was something we needed on a regular basis, we ought to switch to a <a href="http://en.wikipedia.org/wiki/Miranda_%28programming_language%29">language that does it for us</a>. Implementation details ought to be left to libraries, compilers, and virtual machines. That&rsquo;s what they&rsquo;re for.<br /><blockquote><br />A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.<br /></blockquote><p style="text-align: right;">&mdash;Alan Perlis</p>Now that we hold in our hands a tool for making infinitely long lists, the question to ask is, &ldquo;how does that affect the way we think about generating sample curves?&rdquo;<br /><br />The first thing that comes to mind is to ask why the set of sample curves we generate is finite. It isn&rsquo;t really finite, there are an infinite number of curves. (And not just any infinity, it&rsquo;s Aleph One, the children&rsquo;s book <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FOne-Two-Three-Infinity-Speculations%2Fdp%2F0486256642&amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">One Two Three… Infinity</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;amp;amp;l=ur2&o=1" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> explained that forty years ago.)<br /><p></p><div class="book"><br />  <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/uploaded_images/haskell_school_of_expression.jpg" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br />I&rsquo;m not a Haskell user (yet), but <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> has received rave reviews and comes with solid recommendations. It&rsquo;s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you&rsquo;re feeling generous!<br /><br /></div>What we really want is a <em>finite sample</em> of that infinite set of curves. Now let&rsquo;s zoom in and think about a single parameter, the <code>y</code> value for one of the control points on a curve. Let&rsquo;s say it&rsquo;s a rational number between <code>0.0</code> and <code>1.0</code> inclusive. It&rsquo;s relatively easy to generate a list of rationals in that range. Say we generate <code>0.0000...00001</code> (with jillions of zeroes elided: we want the smallest number our computer can represent), followed by <code>0.0000...00002</code> (the second smallest), and so on.<br /><br />If we leave the computer running for a few months or years, we should get all of the numbers between <code>0.0</code> and <code>1.0</code> that our computer can represent. That shouldn&rsquo;t be hard. But even taking into account the finite limitations on a computer&rsquo;s representation, that list is infinitely long.<br /><br /><strong>Useful samples</strong><br /><br />We need to take a finite sample of all of the infinite possibilities in that list.<br /><br />When working with an infinite list, what we want is that the front part of the list, the part we can access before the heat death of the Universe, contains a useful sample. If we were sampling a list like <code>(0.0000...00001 0.0000...00002 0.0000...00003 0.0000...00004 ... )</code> for control points, the first values are not useful at all. We&rsquo;d just get a line along the <code>x</code> access.<br /><br />There are various strategies for generating a more useful list. We could create an infinite list of random values. I&rsquo;ll outline another method below. But the take-away idea is this: we need lists where the most useful values are first. Working with infinite lists encourage us to think of infinitely sized sets of samples, ordered by usefulness.<br /><br />Let&rsquo;s say that when we generate <code>y</code>, we devise a list like <code>(0.0 1.0 0.5 0.75 0.25 ... )</code>. We&rsquo;re successively bisecting the intervals (which is why the library method is called <code>binary_search</code>). We can stop at any time and we have decent distribution. (And we can pipe dream that in the future, we can train our generator to favour points more likely to be useful to us.) That is much more useful!<br /><br />Here&rsquo;s some Lazy List code that does just that: given two seeds and an optional bisection block, it generates an infinite list of values:<br /><br /><pre><code>def binary_search seed1, seed2, &amp;block<br />  bisection_block = block || lambda { |x, y| (x-y)/2 + y }<br />  LazyList.cons(<br />    seed1,<br />    LazyList.new(<br />      seed2,<br />      delay {<br />        bisect(seed1, seed2, &amp;bisection_block)<br />      }<br />    )<br />  )<br />end<br /><br /># infinitely bisects a space, exclusive of the seed values<br /><br />def bisect seed1, seed2, &amp;block<br />  return EMPTY if seed1 == seed2<br />  half = block.call(seed1, seed2)<br />  LazyList.new(<br />    half,<br />    delay {<br />      merge(<br />        bisect(seed1, half, &amp;block),<br />        bisect(half, seed2, &amp;block)<br />      )<br />    }<br />  )<br />end<br /></code></pre>And indeed, <code>LazyList.binary_search(0.0, 1.0) -&gt; (0.0 1.0 0.5 0.75 0.25 ... )</code>.<br /><br /><strong><a href="http://en.wikipedia.org/wiki/Hilbert%27s_hotel">The Grand Hotel</a></strong><br /><br /><div class="book"><a name="evtst|a|0974514055" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611"><img style="" src="http://raganwald.github.com/uploaded_images/satan_cantor_infinity.jpg" alt="Satan, Cantor, and Infinity" border="1" /></a><br /><br /><a href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611">Satan, Cantor, and Infinity and Other Mind-boggling Puzzles</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0192861611" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> is a five-star introduction to Cantor&rsquo;s work on infinity, including a special treat: a completely different proof that Aleph One is greater than Aleph Zero based on games, very much in the style of Conway&rsquo;s Surreal Numbers. Currently out of print, but <strong>please</strong> get yourself a used copy from a bookseller: you won&rsquo;t be disappointed!<br /><br /></div>What happens when we try to combine two infinite lists? For example, we want a list of <code>(x, y)</code> tuples, generated as the Cartesian Product of our binary search list with itself. If we use a typical breadth-first or depth-first algorithm, we&rsquo;re sunk. We get <code>( (0.0 0.0) (1.0 0.0) (0.5 0.0) (0.75 0.0) (0.25 0.0)... )</code>. That has a nice distribution along one axis but still useless. What we need is a way of combining two infinite lists such that they give us a nice useful sample when we take a finite number of elements off the front.<br /><br />Here&rsquo;s a table describing how the ‘breadth-first&rsquo; algorithm for generating the product of two lists works. Consider two lists of three elements each. In the table below, columns represent one list and rows the other. The numbers represent the order that the product of the lists is generated:<br /><br /><table><tbody><tr><th colspan="3">Breadth-first mapping from elements to integers</th><br />      </tr><tr><td>1</td><td>2</td><td>3</td></tr><br />      <tr><td>4</td><td>5</td><td>6</td></tr><br />      <tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><br />This works fine for finite lists, but as we saw above it is useless for infinite lists. But looking at it in table form is useful. The product of two lists <em>is</em> tabular, the problem with a traditional algorithm is the order that we select elements from the table, not that the elements are tabular. Just as we solved the problem of how to sample <code>y</code> magnitudes by changing the order in which we selected rationals between <code>0.0</code> and <code>1.0</code>, what we need to do with Cartesian Products, what we need to do is select the products in an order that provides useful results.<br /><br />As it happens, there&rsquo;s an order that generates useful finite samples when dealing the product of two infinite lists: Instead of generating rows and appending them to each other, it generates <em>diagonals</em> and <em>merges</em> them with each other. The first diagonal is <code>1, 5, 9</code>. The second is <code>4, 8</code>. The third is <code>2, 6</code>. And so on. The advantage of this algorithm is that if given two infinite lists, it starts in the upper left-hand corner and supplies values, working its way right and down.<sup>2</sup><br /><br />Here&rsquo;re the first four values of the product of two binary searches with each other: <code>[{:x=&gt;0.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.5}]</code>. And the next four: <code>[{:x=&gt;1.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.25}]</code>. And the next eight: <code>[{:x=&gt;0.5, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.25}, {:x=&gt;0.5, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.75}, {:x=&gt;0.25, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.75}]</code>.<br /><br />We can take as many samples as we want, and more sample give us more &ldquo;resolution.&rdquo; We now have the tools we need to get rid of all of the limits and finite combinations and focus on describing what we&rsquo;re trying to generate without intermingling a lot of generating code.<br /><blockquote><br />And I&rsquo;m thinking about eternity<br />Some kind of ecstasy got a hold on me<br /></blockquote><p style="text-align: right;">&mdash;Bruce Cockburn, <a href="http://cockburnproject.net/songs&music/wwtla.html">Wondering Where The Lions Are</a></p>Now that we can generate an infinite list of useful magnitudes, plus we can combine infinite lists in a useful way, we can define an infinite list of sample curves. Here&rsquo;s the exact definition of an infinite list of partial beziérs (there are only three control points because the origin of the beziér is always the terminus of the previous beziér in the curve we are generating):<br /><p></p><pre><code>def sample_cubic_beziers<br />  magnitudes = LazyList.binary_search(0.0, 1.0)<br />  control_points = LazyList.cartesian_product(magnitudes, magnitudes) do |x, y|<br />    { :x => x, :y => y }<br />  end<br />  LazyList.cartesian_product(control_points, control_points, control_points) do |p1, p2, p3|<br />    {<br />      :p1 => p1,<br />      :p2 => p2,<br />      :p3 => p3<br />    }<br />  end<br />end<br /></code></pre>That&rsquo;s really simple, and really easy to understand.<sup>3</sup> The domain-specific code that defines a cubic Bezi&eacute;r is concise and readable. And the infrastructure code that handles combinatorics is shunted away out of sight where it doesn&rsquo;t clutter up our thinking.<br /><br />So what have we seen?<br /><ol><br /><li>Lazy evaluation solved a performance problem without needing an extensive rewrite of our generation code;</li><br /><li>Taking the red pill, infinite lists allowed us to radically simplify the original code.</li><br /></ol>Are there some opportunities to steal an idea like lazy evaluation from other languages and use them to simplify your code?<br /><br /><hr /><br /><ol><li>The data is a set of <code>(x,y)</code> tuples where <code>x</code> is time and <code>y</code> is a magnitude. The effort remaining in a <a href="http://www.mountaingoatsoftware.com/sprint_backlog">sprint backlog</a> is an example of this kind of data set. I need a function that computes the distance between any two data sets. I already have a function that computes the distance between a curve through the <code>xy</code> space and a data set, so if I build a lot of curves and then take the distance between each curve and each data set, I can find the distance between pairs of data sets by searching for the curve with the lowest total distance.<br /><br />This operation is On<sup>2</sup>, but that&rsquo;s why we invented distributed processing. Also, this operation is done infrequently relative to operations making use of the clusters, something like Google&rsquo;s indexing being far less frequent than searching Google. And of course, when my MacBook overheats and burns its way through my desk, I can come back and replace the brute force operation with something more intelligent.<br /><br />Well, all this requires generating the sample curves. I have code that makes curves out of Beziérs, provided I supply coördinates for the control points. the curves are actually <code>ActiveRecord</code> models. So all I needed was some simple code that generates all of the possible combinations and then write them to the database. It&rsquo;s the kind of thing candidates write in job interviews where employers actually care about their stone cutting skills.</li><br /><li>This problem is congruent to the proof that the set of all points on a plane is the same size as the set of all points in a line.</li><br /><li>And it could be simpler yet: a &ldquo;list comprehensions&rdquo; DSL for lazy lists is on the wish list.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/lispy ruby.html">lispy ruby</a></p>&nbsp;
<script src="http://feeds.feedburner.com/~s/raganwald?i=http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" type="text/javascript" charset="utf-8"></script>
   <span class="PostFooter">
   &para; <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">1:49 PM</a>&nbsp;<a href="http://www2.blogger.com/comment.g?blogID=7618424&postID=4134602127458276092"location.href=http://www2.blogger.com/comment.g?blogID=7618424&postID=4134602127458276092;>2 comments</a>


<span class="item-action"><a href="http://www2.blogger.com/email-post.g?blogID=7618424&postID=4134602127458276092" title="Email Post"><span class="email-post-icon">&nbsp;</span></a></span><span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www2.blogger.com/post-edit.g?blogID=7618424&postID=4134602127458276092" title="Edit Post"><span class="quick-edit-icon">&nbsp;</span></a></span> </span> 

    </div>

 



</div>

<div id="rightcontent">

	<div id="Description">&#8220;A programming tool is like a freeway: It takes you somewhere in the universe of results. All programming tools are to some extent generalized to handle the needs of a large number of programmers. They are like freeways that take you to the most popular beaches or the most crowded resorts. He who would climb the remote peaks must forsake the freeway and make his way by foot. The exertion of a week's simple sweat can place the programmer on a mountain peak from which are visible new territories of creative opportunity invisible to those who veer away from steep grades.&#8221;&#8212;Chris Crawford</div>


	<p>


          <h2 class="sidebar-title">More...</h2>

          <a href="http://reginald.braythwayt.com">Reg Braithwaite</a> /

          <a href="http://raganwald.github.com/">Recent Posts</a>

          <br/>

          <script type="text/javascript" src="http://del.icio.us/feeds/js/networkbadge/raganwald?name;icon=s"></script>  

          <br/>


<div class="SideBarTitle">Popular</div>

    <a href="http://raganwald.github.com/2006/11/first-seven-books-i-would-buy-if-my_17.html">The first seven books I would buy if my shelves were bare</a> /

    <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I've Learned From Sales, Part I: Don't Feed the Trolls</a> and 
	<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html">Part II: Wanna Bet?</a> /

    <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a> /

    <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a> /

    <a href="http://raganwald.github.com/2006/04/why-do-we-resist-idea-that-programming.html">Why do we resist the idea that programming might be hard?</a> /

    <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html">Are we Blub programmers?</a> /

    <a href="http://raganwald.github.com/2006/08/dear-agile-metaprogrammer.html">Dear Agile Metaprogrammer</a> /

    <a href="http://raganwald.github.com/2006/03/ill-take-static-typing-for-800-alex.html">I'll take Static Typing for $800, Alex</a> /

    <a href="http://raganwald.github.com/2006/03/fair-and-balanced-look-at-static-vs.html">A
    "fair and balanced" look at the static vs. dynamic typing schism</a> /

    <a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I've learned from failure</a> /
    
    <a href="http://raganwald.github.com/2006/01/finding-signal-to-noise-ratio-in-never.html">Finding the Signal-to-Noise Ratio in the Never-Ending Language Debate</a> /
    
    <a href="http://raganwald.github.com/2005/10/im-not-young-enough-to-know-everything.html">I'm not young enough to know everything</a> /
    
    <a href="http://raganwald.github.com/2004/10/beware-of-turing-tar-pit.html">Beware of the Turing Tar-Pit</a>
    
    	<br />
    
	<br />

	<div class="SideBarTitle">Jobs and Companies</div>

    <a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

    <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a> /
    
    <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a> /
    
    <a href="http://raganwald.github.com/2005/03/are-you-thinking-of-working-for-start.html">Are you thinking of working for a start up?</a> /
    
    <a href="http://raganwald.github.com/2004/08/taking-work-personally.html">Taking Work Personally</a>

    	<br />

        <br />

<div class="SideBarTitle">History</div>


    <a href="http://raganwald.github.com/archives/2004_07_01_archive.html">July 2004</a> /

    <a href="http://raganwald.github.com/archives/2004_08_01_archive.html">August 2004</a> /

    <a href="http://raganwald.github.com/archives/2004_09_01_archive.html">September 2004</a> /

    <a href="http://raganwald.github.com/archives/2004_10_01_archive.html">October 2004</a> /

    <a href="http://raganwald.github.com/archives/2004_11_01_archive.html">November 2004</a> /

    <a href="http://raganwald.github.com/archives/2004_12_01_archive.html">December 2004</a> /

    <a href="http://raganwald.github.com/archives/2005_01_01_archive.html">January 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_02_01_archive.html">February 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_03_01_archive.html">March 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_04_01_archive.html">April 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_06_01_archive.html">June 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_07_01_archive.html">July 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_08_01_archive.html">August 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_09_01_archive.html">September 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_10_01_archive.html">October 2005</a> /

    <a href="http://raganwald.github.com/archives/2005_11_01_archive.html">November 2005</a> /

    <a href="http://raganwald.github.com/archives/2006_01_01_archive.html">January 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_02_01_archive.html">February 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_03_01_archive.html">March 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_04_01_archive.html">April 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_05_01_archive.html">May 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_06_01_archive.html">June 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_07_01_archive.html">July 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_08_01_archive.html">August 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_09_01_archive.html">September 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_10_01_archive.html">October 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_11_01_archive.html">November 2006</a> /

    <a href="http://raganwald.github.com/archives/2006_12_01_archive.html">December 2006</a> /

    <a href="http://raganwald.github.com/archives/2007_01_01_archive.html">January 2007</a> /

    <a href="http://raganwald.github.com/archives/2007_02_01_archive.html">February 2007</a> /

			<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
<br/></p>
<p></p>

<p class="profile-link"><a href="http://feeds.feedburner.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon16x16.png" alt="" style="vertical-align:middle;border:0"/></a>&nbsp;<a href="http://feeds.feedburner.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

<p class="profile-link"><a href="http://www.bloglines.com/sub/http://feeds.feedburner.com/raganwald" title="Passionate Software Development" type="application/rss+xml"><img src="http://www.bloglines.com/images/sub_modern11.gif" alt="Subscribe in Bloglines" style="border:0"/></a></p>

<p class="profile-link"><a href="http://fusion.google.com/add?feedurl=http://feeds.feedburner.com/raganwald"><img src="http://buttons.googlesyndication.com/fusion/add.gif" width="104" height="17" style="border:0" alt="Add to Google"/></a></p>

<p class="profile-link"><a href="http://add.my.yahoo.com/rss?url=http://feeds.feedburner.com/raganwald" title="Passionate Software Development"><img src="http://us.i1.yimg.com/us.yimg.com/i/us/my/addtomyyahoo4.gif" alt="" style="border:0"/></a></p>

<p class="profile-link"><a href="http://www.newsgator.com/ngs/subscriber/subext.aspx?url=http://feeds.feedburner.com/raganwald" title="Passionate Software Development"><img src="http://www.newsgator.com/images/ngsub1.gif" alt="Subscribe in NewsGator Online" style="border:0"/></a></p>

<p class="profile-link"><a href="http://www.rojo.com/add-subscription?resource=http://feeds.feedburner.com/raganwald" title="Passionate Software Development"><img src="http://www.rojo.com/corporate/images/add-to-rojo.gif" alt="Subscribe in Rojo" style="border:0"/></a></p>


</div>

<div style="visibility: hidden">
<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
</script>
<noscript>
    <img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
</noscript>
</div>

</body>
</html>