// Generated by CoffeeScript 1.6.1
(function() {
  var Five, FlockingBird, Four, NegativeOne, NegativeThree, NegativeTwo, One, Six, Three, Two, Zero, any, map, multiply, plus, subtract, _ref;

  _ref = require('underscore'), any = _ref.any, map = _ref.map;

  FlockingBird = (function() {

    function FlockingBird(_arg) {
      var _ref1;
      _ref1 = _arg != null ? _arg : {}, this.knownOutrankedBy = _ref1.knownOutrankedBy, this.knownToOutrank = _ref1.knownToOutrank;
      this.knownOutrankedBy || (this.knownOutrankedBy = []);
      this.knownToOutrank || (this.knownToOutrank = []);
    }

    FlockingBird.prototype.standsAgainst = function(rival) {
      var case1, case2, courtingBird;
      courtingBird = this;
      case1 = any(this.knownOutrankedBy, function(gb) {
        return rival.standsAgainst(gb);
      });
      case2 = any(rival.knownToOutrank, function(lb) {
        return lb.standsAgainst(courtingBird);
      });
      return (!case1) && (!case2);
    };

    FlockingBird.prototype.confused = function() {
      var case1a, case1b, case2,
        _this = this;
      case1a = any(this.knownToOutrank, function(lb) {
        return lb.confused();
      });
      case1b = any(this.knownOutrankedBy, function(gb) {
        return gb.confused();
      });
      case2 = any(this.knownToOutrank, function(lb) {
        return any(_this.knownOutrankedBy, function(gb) {
          return lb.standsAgainst(gb);
        });
      });
      return !!(case1a || case1b || case2);
    };

    FlockingBird.prototype.isOfEqualRankTo = function(otherBird) {
      var case1, case2, case3;
      case1 = this.standsAgainst(otherBird);
      case2 = otherBird.standsAgainst(this);
      case3 = !this.confused() && !otherBird.confused();
      return case1 && case2 && case3;
    };

    FlockingBird.prototype.outranks = function(otherBird) {
      var case1, case2;
      case1 = this.standsAgainst(otherBird);
      case2 = !this.isOfEqualRankTo(otherBird);
      return case1 && case2;
    };

    return FlockingBird;

  })();

  plus = function(B1, B2) {
    var PG1B2s, PG2B1s, PL1B2s, PL2B1s;
    PL1B2s = map(B1.knownToOutrank, function(L1) {
      return plus(L1, B2);
    });
    PL2B1s = map(B2.knownToOutrank, function(L2) {
      return plus(L2, B1);
    });
    PG1B2s = map(B1.knownOutrankedBy, function(G1) {
      return plus(G1, B2);
    });
    PG2B1s = map(B2.knownOutrankedBy, function(G2) {
      return plus(G2, B1);
    });
    return new FlockingBird({
      knownToOutrank: PL1B2s.concat(PL2B1s),
      knownOutrankedBy: PG1B2s.concat(PG2B1s)
    });
  };

  Zero = new FlockingBird();

  One = new FlockingBird({
    knownToOutrank: [Zero]
  });

  Two = new FlockingBird({
    knownToOutrank: [One]
  });

  Three = new FlockingBird({
    knownToOutrank: [Two]
  });

  Four = new FlockingBird({
    knownToOutrank: [Three]
  });

  Five = new FlockingBird({
    knownToOutrank: [Four]
  });

  Six = new FlockingBird({
    knownToOutrank: [Five]
  });

  NegativeOne = new FlockingBird({
    knownOutrankedBy: [Zero]
  });

  NegativeTwo = new FlockingBird({
    knownOutrankedBy: [NegativeOne]
  });

  NegativeThree = new FlockingBird({
    knownOutrankedBy: [NegativeTwo]
  });

  describe("negative one plus zero", function() {
    return it("should equal negative one", function() {
      expect(plus(NegativeOne, Zero).isOfEqualRankTo(NegativeOne)).toEqual(true);
      return expect(plus(Zero, NegativeOne).isOfEqualRankTo(NegativeOne)).toEqual(true);
    });
  });

  describe("negative one plus negative one", function() {
    return it("should equal negative one", function() {
      return expect(plus(NegativeOne, NegativeOne).isOfEqualRankTo(NegativeTwo)).toEqual(true);
    });
  });

  describe("negative one plus positive one", function() {
    return it("should equal negative one", function() {
      expect(plus(NegativeOne, One).isOfEqualRankTo(Zero)).toEqual(true);
      return expect(plus(One, NegativeOne).isOfEqualRankTo(Zero)).toEqual(true);
    });
  });

  FlockingBird.prototype.doppleganger = function() {
    return new FlockingBird({
      knownOutrankedBy: map(this.knownToOutrank, function(its) {
        return its.doppleganger();
      }),
      knownToOutrank: map(this.knownOutrankedBy, function(its) {
        return its.doppleganger();
      })
    });
  };

  describe("One's döppleganger", function() {
    return it("should be of equal rank as NegativeOne", function() {
      return expect(One.doppleganger().isOfEqualRankTo(NegativeOne)).toEqual(true);
    });
  });

  describe("NegativeOne's döppleganger", function() {
    return it("should be of equal rank as One", function() {
      return expect(NegativeOne.doppleganger().isOfEqualRankTo(One)).toEqual(true);
    });
  });

  describe("Three's döppleganger", function() {
    return it("should be of equal rank as NegativeThree", function() {
      return expect(Three.doppleganger().isOfEqualRankTo(NegativeThree)).toEqual(true);
    });
  });

  describe("NegativeThree's döppleganger", function() {
    return it("should be of equal rank as Three", function() {
      return expect(NegativeThree.doppleganger().isOfEqualRankTo(Three)).toEqual(true);
    });
  });

  subtract = function(bird, squabbler) {
    return plus(bird, squabbler.doppleganger());
  };

  expect(subtract(Three, One).isOfEqualRankTo(Two)).toEqual(true);

  expect(subtract(Zero, NegativeOne).isOfEqualRankTo(One)).toEqual(true);

  multiply = function(x, y) {
    var XL, XLYL, XLYR, XR, XRYL, XRYR, _fn, _fn1, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
    _ref1 = [[], [], [], []], XLYL = _ref1[0], XLYR = _ref1[1], XRYL = _ref1[2], XRYR = _ref1[3];
    _ref2 = x.knownToOutrank;
    _fn = function() {
      var XLy, YL, YR, _fn1, _j, _k, _len1, _len2, _ref3, _ref4, _results;
      XLy = multiply(XL, y);
      _ref3 = y.knownToOutrank;
      _fn1 = function() {
        var xYL;
        xYL = multiply(x, YL);
        return XLYL.push(plus(plus(XLy, xYL), multiply(XL, YL).doppleganger()));
      };
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        YL = _ref3[_j];
        _fn1();
      }
      _ref4 = y.knownOutrankedBy;
      _results = [];
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        YR = _ref4[_k];
        _results.push((function() {
          var xYR;
          xYR = multiply(x, YR);
          return XLYR.push(plus(plus(XLy, xYR), multiply(XL, YR).doppleganger()));
        })());
      }
      return _results;
    };
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      XL = _ref2[_i];
      _fn();
    }
    _ref3 = x.knownOutrankedBy;
    _fn1 = function() {
      var XRy, YL, YR, _fn2, _k, _l, _len2, _len3, _ref4, _ref5, _results;
      XRy = multiply(XR, y);
      _ref4 = y.knownToOutrank;
      _fn2 = function() {
        var xYL;
        xYL = multiply(x, YL);
        return XRYL.push(plus(plus(XRy, xYL), multiply(XR, YL).doppleganger()));
      };
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        YL = _ref4[_k];
        _fn2();
      }
      _ref5 = y.knownOutrankedBy;
      _results = [];
      for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
        YR = _ref5[_l];
        _results.push((function() {
          var xYR;
          xYR = multiply(x, YR);
          return XRYR.push(plus(plus(XRy, xYR), multiply(XR, YR).doppleganger()));
        })());
      }
      return _results;
    };
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      XR = _ref3[_j];
      _fn1();
    }
    return new FlockingBird({
      knownToOutrank: XLYL.concat(XRYR),
      knownOutrankedBy: XLYR.concat(XRYL)
    });
  };

  describe("multiplication by zero", function() {
    return it("should turn any number into zero", function() {
      expect(multiply(Zero, Zero).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(Zero, One).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(One, Zero).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(Zero, Two).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(Two, Zero).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(Zero, Zero).isOfEqualRankTo(One)).toEqual(false);
      expect(multiply(Zero, One).isOfEqualRankTo(Two)).toEqual(false);
      expect(multiply(One, Zero).isOfEqualRankTo(Three)).toEqual(false);
      expect(multiply(Zero, Two).isOfEqualRankTo(Two)).toEqual(false);
      return expect(multiply(Two, Zero).isOfEqualRankTo(One)).toEqual(false);
    });
  });

  describe("multiplication by one", function() {
    return it("should turn any number into itself", function() {
      expect(multiply(Zero, One).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(One, Zero).isOfEqualRankTo(Zero)).toEqual(true);
      expect(multiply(One, One).isOfEqualRankTo(One)).toEqual(true);
      expect(multiply(One, Two).isOfEqualRankTo(Two)).toEqual(true);
      expect(multiply(Two, One).isOfEqualRankTo(Two)).toEqual(true);
      expect(multiply(Zero, One).isOfEqualRankTo(One)).toEqual(false);
      expect(multiply(One, Zero).isOfEqualRankTo(Two)).toEqual(false);
      expect(multiply(One, One).isOfEqualRankTo(Zero)).toEqual(false);
      expect(multiply(One, Two).isOfEqualRankTo(Three)).toEqual(false);
      return expect(multiply(Two, One).isOfEqualRankTo(One)).toEqual(false);
    });
  });

  describe("multiplication by two", function() {
    return it("should double any number", function() {
      expect(multiply(Two, Two).isOfEqualRankTo(Four)).toEqual(true);
      expect(multiply(Two, Three).isOfEqualRankTo(Six)).toEqual(true);
      return expect(multiply(Three, Two).isOfEqualRankTo(Six)).toEqual(true);
    });
  });

}).call(this);
