// Generated by CoffeeScript 1.6.1
(function() {
  var FlockingBird, NegativeOne, NegativeThree, NegativeTwo, One, Three, Two, Zero, any, map, plus, _ref;

  _ref = require('underscore'), any = _ref.any, map = _ref.map;

  FlockingBird = (function() {

    function FlockingBird(_arg) {
      var _ref1;
      _ref1 = _arg != null ? _arg : {}, this.knownOutrankedBy = _ref1.knownOutrankedBy, this.knownToOutrank = _ref1.knownToOutrank;
      this.knownOutrankedBy || (this.knownOutrankedBy = []);
      this.knownToOutrank || (this.knownToOutrank = []);
    }

    FlockingBird.prototype.standsAgainst = function(rival) {
      var case1, case2, courtingBird;
      courtingBird = this;
      case1 = any(this.knownOutrankedBy, function(gb) {
        return rival.standsAgainst(gb);
      });
      case2 = any(rival.knownToOutrank, function(lb) {
        return lb.standsAgainst(courtingBird);
      });
      return (!case1) && (!case2);
    };

    FlockingBird.prototype.confused = function() {
      var case1a, case1b, case2,
        _this = this;
      case1a = any(this.knownToOutrank, function(lb) {
        return lb.confused();
      });
      case1b = any(this.knownOutrankedBy, function(gb) {
        return gb.confused();
      });
      case2 = any(this.knownToOutrank, function(lb) {
        return any(_this.knownOutrankedBy, function(gb) {
          return lb.standsAgainst(gb);
        });
      });
      return !!(case1a || case1b || case2);
    };

    FlockingBird.prototype.isOfEqualRankTo = function(otherBird) {
      var case1, case2, case3;
      case1 = this.standsAgainst(otherBird);
      case2 = otherBird.standsAgainst(this);
      case3 = !this.confused() && !otherBird.confused();
      return case1 && case2 && case3;
    };

    FlockingBird.prototype.outranks = function(otherBird) {
      var case1, case2;
      case1 = this.standsAgainst(otherBird);
      case2 = !this.isOfEqualRankTo(otherBird);
      return case1 && case2;
    };

    return FlockingBird;

  })();

  plus = function(B1, B2) {
    var PG1B2s, PG2B1s, PL1B2s, PL2B1s;
    PL1B2s = map(B1.knownToOutrank, function(L1) {
      return plus(L1, B2);
    });
    PL2B1s = map(B2.knownToOutrank, function(L2) {
      return plus(L2, B1);
    });
    PG1B2s = map(B1.knownOutrankedBy, function(G1) {
      return plus(G1, B2);
    });
    PG2B1s = map(B2.knownOutrankedBy, function(G2) {
      return plus(G2, B1);
    });
    return new FlockingBird({
      knownToOutrank: PL1B2s.concat(PL2B1s),
      knownOutrankedBy: PG1B2s.concat(PG2B1s)
    });
  };

  Zero = new FlockingBird();

  One = new FlockingBird({
    knownToOutrank: [Zero]
  });

  Two = new FlockingBird({
    knownToOutrank: [One]
  });

  Three = new FlockingBird({
    knownToOutrank: [Two]
  });

  NegativeOne = new FlockingBird({
    knownOutrankedBy: [Zero]
  });

  NegativeTwo = new FlockingBird({
    knownOutrankedBy: [NegativeOne]
  });

  NegativeThree = new FlockingBird({
    knownOutrankedBy: [NegativeTwo]
  });

  describe("negative one plus zero", function() {
    return it("should equal negative one", function() {
      expect(plus(NegativeOne, Zero).isOfEqualRankTo(NegativeOne)).toEqual(true);
      return expect(plus(Zero, NegativeOne).isOfEqualRankTo(NegativeOne)).toEqual(true);
    });
  });

  describe("negative one plus negative one", function() {
    return it("should equal negative one", function() {
      return expect(plus(NegativeOne, NegativeOne).isOfEqualRankTo(NegativeTwo)).toEqual(true);
    });
  });

  describe("negative one plus positive one", function() {
    return it("should equal negative one", function() {
      expect(plus(NegativeOne, One).isOfEqualRankTo(Zero)).toEqual(true);
      return expect(plus(One, NegativeOne).isOfEqualRankTo(Zero)).toEqual(true);
    });
  });

}).call(this);
