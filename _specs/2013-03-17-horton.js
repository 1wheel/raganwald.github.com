// Generated by CoffeeScript 1.6.1
(function() {
  var FlockingBird, Mayzie, OneRight, P, TwoRight, any, map;

  any = require('underscore').any;

  FlockingBird = (function() {

    function FlockingBird(_arg) {
      var _ref;
      _ref = _arg != null ? _arg : {}, this.knownOutrankedBy = _ref.knownOutrankedBy, this.knownToOutrank = _ref.knownToOutrank;
      this.knownOutrankedBy || (this.knownOutrankedBy = []);
      this.knownToOutrank || (this.knownToOutrank = []);
    }

    FlockingBird.prototype.standsAgainst = function(rival) {
      var case1, case2, courtingBird;
      courtingBird = this;
      case1 = any(this.knownOutrankedBy, function(gb) {
        return rival.standsAgainst(gb);
      });
      case2 = any(rival.knownToOutrank, function(lb) {
        return lb.standsAgainst(courtingBird);
      });
      return (!case1) && (!case2);
    };

    FlockingBird.prototype.confused = function() {
      var case1a, case1b, case2,
        _this = this;
      case1a = any(this.knownToOutrank, function(lb) {
        return lb.confused();
      });
      case1b = any(this.knownOutrankedBy, function(gb) {
        return gb.confused();
      });
      case2 = any(this.knownToOutrank, function(lb) {
        return any(_this.knownOutrankedBy, function(gb) {
          return lb.standsAgainst(gb);
        });
      });
      return !!(case1a || case1b || case2);
    };

    return FlockingBird;

  })();

  describe("Lazy Mayzie", function() {
    var Mayzie;
    Mayzie = new FlockingBird();
    return it("should not be confused", function() {
      return expect(Mayzie.confused()).toEqual(false);
    });
  });

  Mayzie = new FlockingBird();

  OneRight = new FlockingBird({
    knownToOutrank: [Mayzie]
  });

  describe("a flock with two birds", function() {
    it("should not contain confused birds", function() {
      expect(Mayzie.confused()).toEqual(false);
      return expect(OneRight.confused()).toEqual(false);
    });
    return it("should have a linear pecking order", function() {
      expect(OneRight.standsAgainst(Mayzie)).toEqual(true);
      return expect(Mayzie.standsAgainst(OneRight)).toEqual(false);
    });
  });

  TwoRight = new FlockingBird({
    knownToOutrank: [OneRight]
  });

  describe("a flock with three birds", function() {
    it("should not contain confused birds", function() {
      expect(Mayzie.confused()).toEqual(false);
      expect(OneRight.confused()).toEqual(false);
      return expect(TwoRight.confused()).toEqual(false);
    });
    return it("should have a linear pecking order", function() {
      expect(Mayzie.standsAgainst(OneRight)).toEqual(false);
      expect(Mayzie.standsAgainst(TwoRight)).toEqual(false);
      expect(OneRight.standsAgainst(Mayzie)).toEqual(true);
      expect(OneRight.standsAgainst(TwoRight)).toEqual(false);
      expect(TwoRight.standsAgainst(Mayzie)).toEqual(true);
      return expect(TwoRight.standsAgainst(TwoRight)).toEqual(true);
    });
  });

  FlockingBird.prototype.isOfEqualRankTo = function(otherBird) {
    var case1, case2, case3;
    case1 = this.standsAgainst(otherBird);
    case2 = otherBird.standsAgainst(this);
    case3 = !this.confused() && !otherBird.confused();
    return case1 && case2 && case3;
  };

  describe("equality", function() {
    it("should be true for Mayzie vs Mayzie", function() {
      return expect(Mayzie.isOfEqualRankTo(Mayzie)).toEqual(true);
    });
    it("should be true for OneRight vs OneRight", function() {
      return expect(OneRight.isOfEqualRankTo(OneRight)).toEqual(true);
    });
    return it("should be false for Mayzie vs OneRight", function() {
      expect(Mayzie.isOfEqualRankTo(OneRight)).toEqual(false);
      return expect(OneRight.isOfEqualRankTo(Mayzie)).toEqual(false);
    });
  });

  FlockingBird.prototype.outranks = function(otherBird) {
    var case1, case2;
    case1 = this.standsAgainst(otherBird);
    case2 = !this.isOfEqualRankTo(otherBird);
    return case1 && case2;
  };

  describe("outranking", function() {
    it("should work for Mayzie vs. Mayzie", function() {
      return expect(Mayzie.outranks(Mayzie)).toEqual(false);
    });
    it("should work for Mayzie vs. OneRight", function() {
      expect(Mayzie.outranks(OneRight)).toEqual(false);
      return expect(OneRight.outranks(Mayzie)).toEqual(true);
    });
    return it("should work for Mayzie vs. TwoRight", function() {
      expect(Mayzie.outranks(TwoRight)).toEqual(false);
      return expect(TwoRight.outranks(Mayzie)).toEqual(true);
    });
  });

  map = require('underscore').map;

  P = function(B1, B2) {
    var PG1B2s, PG2B1s, PL1B2s, PL2B1s;
    PL1B2s = map(B1.knownToOutrank, function(L1) {
      return P(L1, B2);
    });
    PL2B1s = map(B2.knownToOutrank, function(L2) {
      return P(L2, B1);
    });
    PG1B2s = map(B1.knownOutrankedBy, function(G1) {
      return P(G1, B2);
    });
    PG2B1s = map(B2.knownOutrankedBy, function(G2) {
      return P(G2, B1);
    });
    return new FlockingBird({
      knownToOutrank: PL1B2s.concat(PL2B1s),
      knownOutrankedBy: PG1B2s.concat(PG2B1s)
    });
  };

  describe("paired birds", function() {
    it("should be the case that Mayzie paired with any bird is the same rank as that bird", function() {
      expect(P(Mayzie, Mayzie).isOfEqualRankTo(Mayzie)).toEqual(true);
      expect(P(Mayzie, OneRight).isOfEqualRankTo(OneRight)).toEqual(true);
      expect(P(OneRight, Mayzie).isOfEqualRankTo(OneRight)).toEqual(true);
      expect(P(Mayzie, TwoRight).isOfEqualRankTo(TwoRight)).toEqual(true);
      return expect(P(TwoRight, Mayzie).isOfEqualRankTo(TwoRight)).toEqual(true);
    });
    return it("should be the case that OneRight paired with itself is teh same rank as TwoRight", function() {
      return expect(P(OneRight, OneRight).isOfEqualRankTo(TwoRight)).toEqual(true);
    });
  });

}).call(this);
