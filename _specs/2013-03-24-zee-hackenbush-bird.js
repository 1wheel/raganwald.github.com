// Generated by CoffeeScript 1.6.1
(function() {
  var Dyadic, MixedHackenstringGame, SimpleHackenstringGame, applyLeft, black, every, isArray, isEmpty, reduce, twoToPowerOf, white, zero, _ref, _ref1;

  _ref = require('underscore'), isArray = _ref.isArray, every = _ref.every, reduce = _ref.reduce, isEmpty = _ref.isEmpty;

  white = {};

  black = {};

  SimpleHackenstringGame = (function() {
    var invert, stoneValue, validRow;

    invert = function(colour) {
      if (colour === white) {
        return black;
      } else if (colour === black) {
        return white;
      }
    };

    stoneValue = function(colour) {
      if (colour === white) {
        return 1;
      } else if (colour === black) {
        return -1;
      }
    };

    validRow = function(row) {
      return isArray(row) && every(row, function(stone) {
        return stone === white || stone === black;
      });
    };

    function SimpleHackenstringGame(rows) {
      this.rows = rows;
      if (!(isArray(this.rows) && every(this.rows, validRow))) {
        throw 'invalid';
      }
    }

    SimpleHackenstringGame.prototype.evaluation = function() {
      return reduce(this.rows, function(acc, row) {
        var firstOther, startColour;
        startColour = row[0];
        firstOther = row.indexOf(invert(startColour));
        if (row.length === 0) {
          return acc;
        } else if (firstOther < 1) {
          return row.length * stoneValue(startColour) + acc;
        } else {
          throw "TODO: Implement Me";
        }
      }, 0);
    };

    return SimpleHackenstringGame;

  })();

  describe("SimpleHackenstringGame", function() {
    var noRows, oneEmptyRow, twoEmptyRows;
    noRows = new SimpleHackenstringGame([]);
    oneEmptyRow = new SimpleHackenstringGame([[]]);
    twoEmptyRows = new SimpleHackenstringGame([[]]);
    describe("construction", function() {
      it("shouldn't throw an error for no rows or empty rows", function() {
        expect(function() {
          return noRows;
        }).not.toThrow();
        expect(function() {
          return oneEmptyRow;
        }).not.toThrow();
        return expect(function() {
          return twoEmptyRows;
        }).not.toThrow();
      });
      it("shouldn't throw an error for rows with stones", function() {
        expect(function() {
          return new SimpleHackenstringGame([[white]]);
        }).not.toThrow();
        expect(function() {
          return new SimpleHackenstringGame([[white, white]]);
        }).not.toThrow();
        expect(function() {
          return new SimpleHackenstringGame([[black]]);
        }).not.toThrow();
        return expect(function() {
          return new SimpleHackenstringGame([[white, black]]);
        }).not.toThrow();
      });
      return it("should throw an error for a row with a non-stone", function() {
        return expect(function() {
          return new SimpleHackenstringGame([[{}]]);
        }).toThrow();
      });
    });
    return describe("evaluation", function() {
      it("should be zero for empty games", function() {
        expect(noRows.evaluation()).toEqual(0);
        return expect(twoEmptyRows.evaluation()).toEqual(0);
      });
      it("shoudl be zero for equal games", function() {
        return expect(new SimpleHackenstringGame([[white], [black]]).evaluation()).toEqual(0);
      });
      return it("should be positive for games where white has more stones", function() {
        var whiteWins;
        whiteWins = new SimpleHackenstringGame([[white], [black, black, black], [white, white, white, white]]);
        return expect(whiteWins.evaluation()).toEqual(2);
      });
    });
  });

  applyLeft = require('allong.es').applyLeft;

  twoToPowerOf = applyLeft(Math.pow, 2);

  Dyadic = (function() {

    function Dyadic(a, b) {
      var _ref1;
      this.a = a;
      this.b = b;
      while (!(this.a % 2 || this.b === 0)) {
        _ref1 = [this.a / 2, this.b - 1], this.a = _ref1[0], this.b = _ref1[1];
      }
    }

    Dyadic.prototype.toString = function() {
      var a, denominator, units, _ref1;
      denominator = twoToPowerOf(this.b);
      if (denominator === 1) {
        return "" + this.a;
      } else if (this.a > denominator) {
        _ref1 = [Math.floor(this.a / denominator), this.a % denominator], units = _ref1[0], a = _ref1[1];
        return "" + units + " " + a + "/" + denominator;
      } else {
        return "" + this.a + "/" + denominator;
      }
    };

    Dyadic.prototype.plus = function(that) {
      var a1, a2, b;
      b = Math.max(this.b, that.b);
      a1 = this.a * twoToPowerOf(b - this.b);
      a2 = that.a * twoToPowerOf(b - that.b);
      return new Dyadic(a1 + a2, b);
    };

    return Dyadic;

  })();

  describe("dyadic", function() {
    it("should have readable output", function() {
      expect(new Dyadic(5, 0).toString()).toEqual('5');
      expect(new Dyadic(5, 1).toString()).toEqual('2 1/2');
      expect(new Dyadic(5, 2).toString()).toEqual('1 1/4');
      return expect(new Dyadic(5, 3).toString()).toEqual('5/8');
    });
    it("should handle overflow", function() {
      return expect(new Dyadic(10, 3).toString()).toEqual('1 1/4');
    });
    return it("should handle plus", function() {
      return expect(new Dyadic(5, 3).plus(new Dyadic(5, 3)).toString()).toEqual('1 1/4');
    });
  });

  _ref1 = require('underscore'), isArray = _ref1.isArray, every = _ref1.every, reduce = _ref1.reduce, isEmpty = _ref1.isEmpty;

  white = {};

  black = {};

  zero = new Dyadic(0, 0);

  MixedHackenstringGame = (function() {
    var invert, stoneValue, validRow;

    invert = function(colour) {
      if (colour === white) {
        return black;
      } else if (colour === black) {
        return white;
      }
    };

    stoneValue = function(colour) {
      if (colour === white) {
        return 1;
      } else if (colour === black) {
        return -1;
      }
    };

    validRow = function(row) {
      return isArray(row) && every(row, function(stone) {
        return stone === white || stone === black;
      });
    };

    function MixedHackenstringGame(rows) {
      this.rows = rows;
      if (!(isArray(this.rows) && every(this.rows, validRow))) {
        throw 'invalid';
      }
    }

    MixedHackenstringGame.prototype.evaluation = function() {
      return reduce(this.rows, function(acc, row) {
        var firstOther, startColour;
        startColour = row[0];
        if (row.length === 0) {
          return acc;
        } else {
          firstOther = row.indexOf(invert(startColour));
          if (firstOther === -1) {
            return acc.plus(new Dyadic(row.length * stoneValue(startColour), 0));
          } else {
            acc = acc.plus(new Dyadic(firstOther * stoneValue(startColour), 0));
            row.slice(firstOther).forEach(function(stone, index) {
              return acc = acc.plus(new Dyadic(stoneValue(stone), index + 1));
            });
            return acc;
          }
        }
      }, zero);
    };

    return MixedHackenstringGame;

  })();

  describe("MixedHackenstringGame", function() {
    var noRows, oneEmptyRow, twoEmptyRows;
    noRows = new MixedHackenstringGame([]);
    oneEmptyRow = new MixedHackenstringGame([[]]);
    twoEmptyRows = new MixedHackenstringGame([[]]);
    describe("regression-free evaluation", function() {
      it("should be zero for empty games", function() {
        expect(noRows.evaluation().toString()).toEqual('0');
        return expect(twoEmptyRows.evaluation().toString()).toEqual('0');
      });
      it("should be zero for equal games", function() {
        var wb;
        wb = new MixedHackenstringGame([[white], [black]]);
        return expect(wb.evaluation().toString()).toEqual('0');
      });
      return it("should be positive for games where white has more stones", function() {
        var whiteWins;
        whiteWins = new MixedHackenstringGame([[white], [black, black, black], [white, white, white, white]]);
        return expect(whiteWins.evaluation().toString()).toEqual('2');
      });
    });
    return describe("with mixed stones", function() {
      return it("should be -1/2 for b-w", function() {
        var bw;
        bw = new MixedHackenstringGame([[black, white]]);
        return expect(bw.evaluation().toString()).toEqual('-1/2');
      });
    });
  });

}).call(this);
