// Generated by CoffeeScript 1.6.1
(function() {
  var HackenstringGame, black, every, isArray, isEmpty, reduce, white, _ref;

  _ref = require('underscore'), isArray = _ref.isArray, every = _ref.every, reduce = _ref.reduce, isEmpty = _ref.isEmpty;

  white = {};

  black = {};

  HackenstringGame = (function() {
    var invert, stoneValue, validRow;

    invert = function(colour) {
      if (colour === white) {
        return black;
      } else if (colour === black) {
        return white;
      }
    };

    stoneValue = function(colour) {
      if (colour === white) {
        return 1;
      } else if (colour === black) {
        return -1;
      }
    };

    validRow = function(row) {
      return isArray(row) && every(row, function(stone) {
        return stone === white || stone === black;
      });
    };

    function HackenstringGame(rows) {
      this.rows = rows;
      if (!(isArray(this.rows) && every(this.rows, validRow))) {
        throw 'invalid';
      }
    }

    HackenstringGame.prototype.evaluation = function() {
      return reduce(this.rows, function(acc, row) {
        var firstOther, startColour;
        startColour = row[0];
        firstOther = row.indexOf(invert(startColour));
        if (row.length === 0) {
          return acc;
        } else if (firstOther < 1) {
          return row.length * stoneValue(startColour) + acc;
        } else {
          throw "TODO: Implement Me";
        }
      }, 0);
    };

    return HackenstringGame;

  })();

  describe("HackenstringGame", function() {
    var noRows, oneEmptyRow, twoEmptyRows;
    noRows = new HackenstringGame([]);
    oneEmptyRow = new HackenstringGame([[]]);
    twoEmptyRows = new HackenstringGame([[]]);
    describe("construction", function() {
      it("shouldn't throw an error for no rows or empty rows", function() {
        expect(function() {
          return noRows;
        }).not.toThrow();
        expect(function() {
          return oneEmptyRow;
        }).not.toThrow();
        return expect(function() {
          return twoEmptyRows;
        }).not.toThrow();
      });
      it("shouldn't throw an error for rows with stones", function() {
        expect(function() {
          return new HackenstringGame([[white]]);
        }).not.toThrow();
        expect(function() {
          return new HackenstringGame([[white, white]]);
        }).not.toThrow();
        expect(function() {
          return new HackenstringGame([[black]]);
        }).not.toThrow();
        return expect(function() {
          return new HackenstringGame([[white, black]]);
        }).not.toThrow();
      });
      return it("should throw an error for a row with a non-stone", function() {
        return expect(function() {
          return new HackenstringGame([[{}]]);
        }).toThrow();
      });
    });
    return describe("evaluation", function() {
      it("should be zero for empty games", function() {
        expect(noRows.evaluation()).toEqual(0);
        return expect(twoEmptyRows.evaluation()).toEqual(0);
      });
      it("shoudl be zero for equal games", function() {
        return expect(new HackenstringGame([[white], [black]]).evaluation()).toEqual(0);
      });
      return it("should be positive for games where white has more stones", function() {
        var whiteWins;
        whiteWins = new HackenstringGame([[white], [black, black, black], [white, white, white, white]]);
        return expect(whiteWins.evaluation()).toEqual(2);
      });
    });
  });

}).call(this);
